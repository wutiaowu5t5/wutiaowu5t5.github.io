<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nanami Kento</title>
  
  
  <link href="https://wutiaowu5t5.github.io/atom.xml" rel="self"/>
  
  <link href="https://wutiaowu5t5.github.io/"/>
  <updated>2024-04-09T07:24:24.000Z</updated>
  <id>https://wutiaowu5t5.github.io/</id>
  
  <author>
    <name>Nanami Kento</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript设计模式汇总</title>
    <link href="https://wutiaowu5t5.github.io/posts/d342d2ec/"/>
    <id>https://wutiaowu5t5.github.io/posts/d342d2ec/</id>
    <published>2024-04-09T07:24:24.000Z</published>
    <updated>2024-04-09T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式是在软件工程中被反复使用的、经过验证的解决方案，用于解决特定问题或设计软件架构</p><p>它们提供了一种在设计和开发过程中重用的可靠方式，有助于解决常见的设计问题并促进代码的可维护性、可扩展性和可重用性</p><p><br/>设计模式并不是一种具体的编程语言特性或库，而是一种通用的解决方案</p><p>它们是从实际开发经验中总结出来的，并被广泛接受和使用</p><p>设计模式通常包括了面向对象设计的一些基本原则和惯例，通过它们可以更好地组织代码结构、降低耦合度、提高代码的灵活性和可维护性</p><p><br/>设计模式之所以出现，是因为在软件开发中经常会遇到一些常见的问题，比如对象创建、对象之间的关系、算法的选择等等</p><p>这些问题在不同的项目和场景中可能会多次出现，因此工程师们开始寻找并提炼出一些通用的解决方案，这就是设计模式产生的原因</p><p>设计模式有助于开发人员更快速地理解和解决问题，提高了开发效率</p><p>此外，它们还有助于提高代码的可读性和可维护性，因为它们是经过验证的、被广泛认可的解决方案，可以减少因为设计上的错误而造成的后续问题</p><p><br/></p><h2 id="设计模式遵循原则"><a href="#设计模式遵循原则" class="headerlink" title="设计模式遵循原则"></a>设计模式遵循原则</h2><p>设计模式的原则通常指的是一些基本的设计理念和规范，它们指导着设计模式的实现和应用。以下是一些常见的设计模式原则：</p><ol><li><p><strong>单一责任原则（Single Responsibility Principle, SRP）</strong>：</p><p>一个类应该只有一个引起变化的原因</p><p>换句话说，一个类应该只负责一项职责</p></li><li><p><strong>开放-封闭原则（Open-Closed Principle, OCP）</strong>：</p><p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭</p><p>即应该通过扩展现有代码来实现新功能，而不是直接修改已有代码</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p><p>所有能够使用父类对象的地方都应该能够使用子类对象</p><p>即子类应该能够替换父类并且不影响程序的正确性</p></li><li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p><p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</p><p>抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p><p>客户端不应该被迫依赖于它们不使用的接口</p><p>即应该将大接口拆分成更小、更具体的接口，以便客户端只需要知道它们需要使用的接口</p></li><li><p><strong>合成/聚合复用原则（Composition/Aggregation Reuse Principle, CARP）</strong>：</p><p>优先使用对象组合/聚合，而不是继承来达到代码复用的目的</p><p>通过将对象组合到新的对象中，而不是通过继承来实现代码复用，可以更灵活地实现代码的复用</p></li></ol><p>这些原则是面向对象设计的基础，设计模式通常都遵循这些原则，以提高代码的可维护性、可扩展性和可重用性</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol><li><p>创建型</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/4fda2d18/">单例模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/14ddad5d/">原型模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/7e9872a1/">工厂模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/7aab53ba/">抽象工厂模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/7e3e0f32/">建造者模式</a></p>            </div></li><li><p>结构型</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/edf2252f/">适配器模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/f51f74c/">装饰器模式</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/54233691/">代理模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/bd865a4b/">外观模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/2b8aa55b/">桥接模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/79a1bf69/">组合模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/469c39d8/">享元模式</a></p>            </div></li><li><p>行为型</p><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/73dbb689/">观察者模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/b1de33a6/">迭代器模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/1445619f/">策略模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/8472c90e/">模板方法模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/ae2b73e3/">职责链模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/25e1ecde/">命令模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/e88d43d9/">备忘录模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/d207f3e/">状态模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/edaaf222/">访问者模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/957fddbf/">中介者模式</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p><a href="https://wutiaowu5t5.github.io/posts/29dbf566/">解释器模式</a></p>            </div></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式是什么&quot;&gt;&lt;a href=&quot;#设计模式是什么&quot; class=&quot;headerlink&quot; title=&quot;设计模式是什么&quot;&gt;&lt;/a&gt;设计模式是什么&lt;/h2&gt;&lt;p&gt;设计模式是在软件工程中被反复使用的、经过验证的解决方案，用于解决特定问题或设计软件架构&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经汇总</title>
    <link href="https://wutiaowu5t5.github.io/posts/ed392c85/"/>
    <id>https://wutiaowu5t5.github.io/posts/ed392c85/</id>
    <published>2024-04-09T03:10:24.000Z</published>
    <updated>2024-04-09T03:19:35.989Z</updated>
    
    <content type="html"><![CDATA[<div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/556519a1/">Html</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/179be34f/">Css</a></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><a href="https://wutiaowu5t5.github.io/posts/e82d9764/">Javascript</a></p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>手写Javascript</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>Vue</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>React</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>工程化</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>Http</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>浏览器</p>            </div><div class='checkbox gray'><input type="checkbox" />            <p>Node</p>            </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&#39;checkbox green checked&#39;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;
            &lt;p&gt;&lt;a href=&quot;https://wutiaowu5t5.github.io/posts/5</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="面试" scheme="https://wutiaowu5t5.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Git提交规范记录</title>
    <link href="https://wutiaowu5t5.github.io/posts/a70ec0c6/"/>
    <id>https://wutiaowu5t5.github.io/posts/a70ec0c6/</id>
    <published>2024-04-07T07:24:24.000Z</published>
    <updated>2024-04-08T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Commit-Message作用"><a href="#Commit-Message作用" class="headerlink" title="Commit Message作用"></a>Commit Message作用</h2><ol><li><p>提供更多的历史信息，方便快速浏览</p><p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure></li><li><p>可以过滤某些commit（比如文档改动），便于快速查找信息</p><p>比如，下面的命令仅仅显示本次发布新增加的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure></li><li><p>可以直接从commit生成Change log</p><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档</p></li></ol><p><br/></p><h2 id="Commit-Message-的格式"><a href="#Commit-Message-的格式" class="headerlink" title="Commit Message 的格式"></a>Commit Message 的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观</p><ol><li><p>Header</p><p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</p><ul><li><p>type</p><p>type用于说明 commit 的类别，只允许使用下面7个标识</p><p>feat：新功能（feature）</p><p>fix：修补bug</p><p>docs：文档（documentation）</p><p>style： 格式（不影响代码运行的变动）</p><p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p><p>test：增加测试</p><p>chore：构建过程或辅助工具的变动</p></li><li><p>scope</p><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</p></li><li><p>subject</p><p>subject是 commit 目的的简短描述，不超过50个字符</p><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p><p>第一个字母小写</p><p>结尾不加句号（.）</p></li></ul></li><li><p>Body</p><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent</span><br></pre></td></tr></table></figure><p>说明代码变动的动机，以及与以前行为的对比</p></li><li><p>Footer</p><ol><li><p>Footer 部分只用于两种情况</p><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">&#x27;attribute&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn<span class="string">&#x27;t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure></li><li><p>关闭 Issue</p><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure><p>也可以一次关闭多个 issue </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Revert</p><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">&#x27;graphiteWidth&#x27;</span> option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成This reverts commit <hash>.，其中的hash是被撤销 commit 的 SHA 标识符</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面</p></li></ol><p><br/></p><h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><p>Commitizen是一个撰写合格 Commit message 的工具。</p><p>安装命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure><p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。</p><p><img src="https://s2.loli.net/2024/04/23/fuyUO5tDjYRo3Pv.png" alt="429b439c9f9f422039f8c2afbb4886bd034e5b3f.png"></p><p><br/></p><h2 id="validate-commit-msg"><a href="#validate-commit-msg" class="headerlink" title="validate-commit-msg"></a>validate-commit-msg</h2><p>validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式</p><p>它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js</p><p>接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;ghooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;./validate-commit-msg.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A </span><br><span class="line">$ git commit -m <span class="string">&quot;edit markdown&quot;</span> INVALID COMMIT MSG: does not match <span class="string">&quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</span> ! was: edit markdown</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="生成-Change-log"><a href="#生成-Change-log" class="headerlink" title="生成 Change log"></a>生成 Change log</h2><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2，例3）</p><p>生成的文档包括以下三个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">New features</span><br><span class="line"></span><br><span class="line">Bug fixes</span><br><span class="line"></span><br><span class="line">Breaking changes.</span><br></pre></td></tr></table></figure><p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容</p><p>conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g conventional-changelog</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动</p><p>如果你想生成所有发布的 Change log，要改为运行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入package.json的scripts字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run changelog</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Commit-Message作用&quot;&gt;&lt;a href=&quot;#Commit-Message作用&quot; class=&quot;headerlink&quot; title=&quot;Commit Message作用&quot;&gt;&lt;/a&gt;Commit Message作用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提供更多的</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="git" scheme="https://wutiaowu5t5.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《解释器模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/29dbf566/"/>
    <id>https://wutiaowu5t5.github.io/posts/29dbf566/</id>
    <published>2024-04-07T07:24:24.000Z</published>
    <updated>2024-04-07T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一种语言的文法，并提供了一种解释器来解释该语言中的句子</p><p><br/></p><p>解释器模式通常涉及两个核心角色：解释器（Interpreter）和上下文（Context）</p><ul><li><p><strong>解释器（Interpreter）</strong></p><p>定义了一个抽象的解释操作接口，用于解释文法中的各种句子</p><p>解释器通常会包含多个解释方法，每个方法对应文法中的一个语法规则</p></li><li><p><strong>上下文（Context）</strong></p><p>包含了需要解释的文法内容</p><p>上下文对象通常会包含一些全局信息或者状态，供解释器对象使用</p></li></ul><p><br/></p><p>解释器模式的核心思想是将语言的文法抽象成一个解释器对象，并通过解释器对象来解释文法中的句子</p><p>这种模式的优点在于，可以将语言的解释和实现分离，使得解释过程更加灵活和可扩展</p><p>解释器模式适用于以下情况：</p><ul><li>当需要解释一种语言的文法，并且希望解释过程与实现解释的对象解耦时，可以使用解释器模式</li><li>当希望将解释过程封装到一个对象中，并提供一种统一的接口来解释不同类型的句子时，解释器模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个简单的数学表达式解析器</p><p>解释器模式可以将数学表达式的文法抽象成一个解释器对象，并通过解释器对象来解释和计算表达式的值</p><p>例如，给定一个表达式 “3 + 5 * 2”，解释器模式可以通过解释器对象来解析该表达式，并计算出其结果为 13</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在一种语言</strong></p><p>解释器模式适用于存在一种自定义语言或者规则的情况，需要解释和执行这种语言或者规则</p></li><li><p><strong>需要对语言进行解释和执行</strong></p><p>解释器模式适用于需要对一种自定义语言或者规则进行解释和执行的情况，例如编译器、解析器等</p></li><li><p><strong>语言的规则相对固定</strong></p><p>解释器模式适用于语言的规则相对固定，并且不太容易发生变化的情况</p><p>因为解释器模式需要定义一组解释器对象，并且需要根据语言的规则来实现这些解释器对象</p></li><li><p><strong>需要对语言进行扩展</strong></p><p>解释器模式适用于需要对语言进行扩展的情况，因为解释器模式可以通过定义新的解释器对象来扩展语言的功能</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>性能问题</strong></p><p>解释器模式通常需要解释和执行语言的语法规则，因此可能会导致性能问题，特别是在处理大规模和复杂的语法规则时</p></li><li><p><strong>复杂度高</strong></p><p>解释器模式通常需要定义大量的解释器对象，并且需要正确地组合这些解释器对象来实现语言的语法规则，可能会导致系统的复杂度增加</p></li><li><p><strong>不适用于所有情况</strong></p><p>解释器模式适用于对语言进行解释和执行的情况，但并不适用于所有情况，特别是对性能要求较高或者语言规则变化频繁的情况</p></li><li><p><strong>难以维护</strong></p><p>解释器模式通常会涉及到大量的解释器对象和语法规则，可能会导致代码的维护成本增加</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>性能问题</strong></p><p>解释器模式通常需要解释和执行语言的语法规则，因此可能会导致性能问题，特别是在处理大规模和复杂的语法规则时</p></li><li><p><strong>复杂度高</strong></p><p>解释器模式通常需要定义大量的解释器对象，并且需要正确地组合这些解释器对象来实现语言的语法规则，可能会导致系统的复杂度增加</p></li><li><p><strong>不适用于所有情况</strong></p><p>解释器模式适用于对语言进行解释和执行的情况，但并不适用于所有情况，特别是对性能要求较高或者语言规则变化频繁的情况</p></li><li><p><strong>难以维护</strong></p><p>解释器模式通常会涉及到大量的解释器对象和语法规则，可能会导致代码的维护成本增加</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一种语言的文法，并提供了一种解释器来解释该语言中的句子&lt;/</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《中介者模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/957fddbf/"/>
    <id>https://wutiaowu5t5.github.io/posts/957fddbf/</id>
    <published>2024-04-06T07:24:24.000Z</published>
    <updated>2024-04-06T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列对象之间的交互，从而降低对象之间的耦合度</p><p><br/></p><p>中介者模式通常涉及三个核心角色：中介者（Mediator）、同事对象（Colleague）和具体中介者（Concrete Mediator）</p><ul><li><p><strong>中介者（Mediator）</strong></p><p>定义了一个接口用于与各个同事对象通信，并负责协调各个同事对象之间的交互</p><p>中介者对象通常包含一个或多个方法，用于处理不同类型的交互事件</p></li><li><p><strong>同事对象（Colleague）</strong></p><p>各个参与交互的对象。同事对象可以向中介者发送消息，也可以接收来自中介者的消息</p></li><li><p><strong>具体中介者（Concrete Mediator）</strong></p><p>实现了中介者接口，负责实际的协调和控制各个同事对象之间的交互</p><p>具体中介者对象通常包含了各个同事对象的引用，并根据收到的消息来进行相应的处理</p></li></ul><p><br/></p><p>中介者模式的核心思想是将系统中各个对象之间的交互行为集中到一个中介者对象中，从而降低对象之间的耦合度</p><p>这种模式的优点在于，可以减少对象之间的直接依赖关系，提高系统的灵活性和可维护性</p><p>中介者模式适用于以下情况：</p><ul><li>当系统中各个对象之间存在复杂的交互关系，并且希望将这些交互关系集中到一个对象中进行管理时，可以使用中介者模式</li><li>当系统中的对象之间的交互关系随着系统的演化而变得复杂时，中介者模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个聊天室系统</p><p>聊天室中的用户可以发送消息给其他用户，而消息发送过程中需要对消息进行广播和接收等操作</p><p>中介者模式可以将聊天室对象视为一个中介者对象，负责管理用户之间的消息发送和接收</p><p>当用户发送消息时，可以将消息发送给聊天室对象，由聊天室对象负责将消息广播给所有在线用户</p><p>这样，可以实现用户之间的交互行为集中到一个中介者对象中进行管理，从而降低系统的复杂度</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在多个对象之间的复杂交互</strong></p><p>中介者模式适用于存在多个对象之间的复杂交互，并且这些对象之间存在相互依赖的情况</p></li><li><p><strong>需要解耦对象之间的关系</strong></p><p>中介者模式适用于需要解耦对象之间的关系，避免对象之间的直接通信，从而降低对象之间的耦合度</p></li><li><p><strong>对象之间存在多对多的关系</strong></p><p>中介者模式适用于对象之间存在多对多的关系，并且对象之间的交互比较复杂的情况，通过引入中介者来统一管理对象之间的交互</p></li><li><p><strong>需要集中化控制对象之间的交互</strong></p><p>中介者模式适用于需要集中化控制对象之间的交互，通过引入中介者来协调对象之间的交互，避免交互逻辑分散在多个对象中</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>减少类之间的依赖关系</strong></p><p>中介者模式可以减少类之间的直接依赖关系，将对象之间的交互逻辑集中到中介者对象中，从而降低了类之间的耦合度</p></li><li><p><strong>简化对象的交互</strong></p><p>中介者模式可以简化对象之间的交互逻辑，将复杂的交互逻辑封装到中介者对象中，使得对象之间只需要与中介者进行通信，而无需直接相互交互</p></li><li><p><strong>提高系统的可维护性</strong></p><p>中介者模式将对象之间的交互逻辑集中到中介者对象中，使得系统的交互逻辑更加清晰和易于理解，从而提高了系统的可维护性</p></li><li><p><strong>提高系统的灵活性</strong></p><p>中介者模式可以通过引入新的中介者对象来扩展系统的功能，而无需修改已有的对象，从而提高了系统的灵活性</p></li><li><p><strong>降低了对象之间的直接耦合</strong></p><p>中介者模式可以避免对象之间的直接相互引用，降低了对象之间的耦合度，使得系统更加灵活和易于扩展</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>中介者对象可能变得复杂</strong></p><p>随着系统的演化，中介者对象可能会变得复杂，包含大量的交互逻辑，导致中介者对象变得难以维护和理解</p></li><li><p><strong>可能导致单点故障</strong></p><p>如果中介者对象出现故障，可能会导致系统的其他部分无法正常工作，特别是系统的依赖性较高时</p></li><li><p><strong>可能导致性能问题</strong></p><p>由于中介者对象负责管理对象之间的交互逻辑，可能会导致中介者对象成为系统的瓶颈，特别是在处理大量请求时可能会出现性能问题</p></li><li><p><strong>增加了系统的复杂度</strong></p><p>中介者模式引入了一个额外的中介者对象，可能会增加系统的复杂度，特别是当系统中存在多个中介者对象时</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列对象之间的交互，从而降低对象之间的耦</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《访问者模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/edaaf222/"/>
    <id>https://wutiaowu5t5.github.io/posts/edaaf222/</id>
    <published>2024-04-05T07:24:24.000Z</published>
    <updated>2024-04-05T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不改变被访问对象的类的前提下定义对其进行操作的新操作</p><p><br/></p><p>访问者模式通常涉及两个核心角色：访问者（Visitor）和被访问元素（Element）</p><ul><li><p><strong>访问者（Visitor）</strong></p><p>定义了对每个被访问元素的操作方法</p><p>每个操作方法都对应着被访问元素的不同类型，可以通过访问者来实现对被访问元素的不同操作</p></li><li><p><strong>被访问元素（Element）</strong></p><p>定义了一个接受访问者对象的方法，并将自身作为参数传递给访问者对象</p><p>被访问元素可以是单个对象或者对象的集合</p></li></ul><p><br/></p><p>访问者模式的核心思想是将对对象的操作（算法）从对象本身中提取出来，并将其封装到不同的访问者对象中，从而实现对对象操作的解耦</p><p>这种模式的优点在于，可以在不修改被访问对象的类的情况下定义新的操作，同时也使得新增操作的扩展更加灵活和可控</p><p>访问者模式适用于以下情况：</p><ul><li>当需要对一个对象结构中的元素进行不同类型的操作，并且希望将操作与对象的数据结构解耦时，可以使用访问者模式</li><li>当希望在不修改对象类的情况下定义新的操作，并且希望新增操作的扩展更加灵活和可控时，访问者模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个文件系统中的不同类型的文件对象（如文本文件、图像文件、音频文件等）</p><p>访问者模式可以将对文件对象的操作（如打印文件内容、压缩文件、加密文件等）抽象成访问者对象，并在不修改文件对象类的情况下定义新的操作，从而实现对文件对象的不同操作的解耦</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在一组不同类型的对象</strong></p><p>访问者模式适用于存在一组不同类型的对象，并且这些对象之间存在一定的复杂关系，例如对象之间存在继承关系或者对象之间存在组合关系等</p></li><li><p><strong>需要对对象进行不同的操作</strong></p><p>访问者模式适用于需要对一组不同类型的对象进行不同的操作，并且这些操作可能会随着对象的类型而变化的情况</p></li><li><p><strong>对象的结构相对稳定</strong></p><p>访问者模式适用于对象的结构相对稳定，并且不太容易发生变化的情况</p><p>因为访问者模式需要将不同类型的对象和操作进行解耦，如果对象的结构经常发生变化，可能会导致访问者对象的变化较大</p></li><li><p><strong>需要对对象进行多种操作</strong></p><p>访问者模式适用于需要对一组对象进行多种不同操作的情况，并且这些操作之间可能没有直接关联</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>增加新的操作很容易</strong></p><p>访问者模式使得增加新的操作很容易，只需要定义一个新的访问者对象即可，无需修改现有的对象结构</p></li><li><p><strong>符合开闭原则</strong></p><p>访问者模式通过将操作封装在访问者对象中，并将访问者对象与对象结构分离，使得可以在不修改现有对象结构的情况下增加新的操作，符合开闭原则</p></li><li><p><strong>解耦了对象结构和操作</strong></p><p>访问者模式将对象结构和操作进行了解耦，使得可以独立地改变对象结构或者操作，并且可以相互独立地进行扩展</p></li><li><p><strong>支持不同类型的访问者</strong></p><p>访问者模式支持定义不同类型的访问者对象，并且可以在不同的情况下选择合适的访问者对象进行操作，从而提高了系统的灵活性和可扩展性</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>增加新的元素类很困难</strong></p><p>访问者模式使得增加新的元素类变得很困难，因为需要在每个访问者对象中添加对应的操作，可能会导致访问者对象的数量和复杂度增加</p></li><li><p><strong>破坏封装性</strong></p><p>访问者模式将操作封装在访问者对象中，可能会破坏对象的封装性，因为访问者对象需要访问对象的内部状态和结构</p></li><li><p><strong>可能导致性能问题</strong></p><p>访问者模式需要在访问者对象和元素对象之间建立关联，可能会导致访问者对象过多或者访问者对象过于庞大，从而可能会导致性能问题</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不改变被访问对象的类的前提下定义对其进行操作的新操作&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《状态模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/d207f3e/"/>
    <id>https://wutiaowu5t5.github.io/posts/d207f3e/</id>
    <published>2024-04-04T07:24:24.000Z</published>
    <updated>2024-04-04T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状态模式（State Pattern）是一种行为型设计模式，它允许对象在内部状态发生变化时改变其行为，使得对象看起来好像修改了其类</p><p><br/></p><p>状态模式通常涉及三个核心角色：上下文（Context）、状态（State）和具体状态（Concrete State）</p><ul><li><p><strong>上下文（Context）</strong></p><p>维护一个当前状态对象，并将状态相关的操作委托给当前状态对象处理</p><p>上下文对象通常会包含一个状态对象的引用，并提供方法来切换当前状态和执行状态相关的操作</p></li><li><p><strong>状态（State）</strong></p><p>定义了一个接口用于封装与上下文相关的行为</p><p>状态对象通常会包含多个方法，用于处理上下文对象的请求，并可能会改变上下文对象的状态</p></li><li><p><strong>具体状态（Concrete State）</strong></p><p>实现了状态接口，并负责实现具体的状态行为</p><p>具体状态对象通常会包含状态相关的业务逻辑，并根据需要改变上下文对象的状态</p></li></ul><p><br/></p><p>状态模式的核心思想是将对象的状态和行为进行分离，使得状态的改变不会影响对象的行为，从而实现对象的灵活性和可扩展性</p><p>这种模式的优点在于，可以将状态的转换和状态的行为封装到不同的状态对象中，使得状态之间的转换更加灵活和可扩展</p><p>状态模式适用于以下情况：</p><ul><li>当对象的行为取决于其状态，并且状态可能在运行时发生变化时，可以使用状态模式</li><li>当希望将状态的转换和状态的行为封装到不同的状态对象中，并且希望通过配置来动态地改变对象的行为时，状态模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个自动售货机系统</p><p>自动售货机的行为可能会根据不同的状态（如有货、缺货、正在出货等）而发生变化，而状态模式可以将每种状态抽象成一个状态对象，并根据当前状态来执行相应的行为</p><p>例如，当自动售货机处于有货状态时，可以执行出售商品的行为；当自动售货机处于缺货状态时，可以执行补货的行为</p><p>这样，可以通过改变状态对象来动态地改变自动售货机的行为，而不需要修改自动售货机的代码</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在多个状态</strong></p><p>状态模式适用于存在多个状态，并且对象在不同状态下会有不同的行为的情况</p></li><li><p><strong>状态之间存在转换关系</strong></p><p>状态模式适用于状态之间存在转换关系，并且状态转换是由一定的条件触发的情况</p></li><li><p><strong>需要封装对象的状态</strong></p><p>状态模式适用于需要封装对象的状态，并且根据对象的状态来决定对象的行为的情况</p></li><li><p><strong>行为随状态的改变而改变</strong></p><p>状态模式适用于对象的行为随状态的改变而改变的情况，状态模式将对象的行为分离成多个状态类，每个状态类负责管理对象在特定状态下的行为</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>封装了状态相关行为</strong></p><p>状态模式将每个状态封装成一个类，使得每个状态都有独立的类实现，从而简化了状态之间的转换和管理</p></li><li><p><strong>消除了大量的条件判断语句</strong></p><p>状态模式将对象的行为随状态的改变而改变，避免了大量的条件判断语句，使得代码更加清晰和易于维护</p></li><li><p><strong>符合开闭原则</strong></p><p>状态模式符合开闭原则，可以通过增加新的状态类来扩展系统的功能，而无需修改已有的代码</p></li><li><p><strong>增强了对象的封装性</strong></p><p>状态模式将对象的状态封装到不同的状态类中，使得对象的状态对外部是透明的，增强了对象的封装性</p></li><li><p><strong>简化了对象的行为切换</strong></p><p>状态模式将对象的行为切换和状态转换都交由状态类来管理，使得对象的行为切换更加简单和灵活</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能会增加类的数量</strong></p><p>状态模式会将每个状态都封装成一个类，可能会导致系统中类的数量增加，从而增加系统的复杂度</p></li><li><p><strong>状态之间的转换可能复杂</strong></p><p>状态模式要求状态之间存在转换关系，如果状态之间的转换关系比较复杂，可能会导致状态模式的实现变得复杂</p></li><li><p><strong>可能导致逻辑分散</strong></p><p>状态模式将对象的行为切换和状态转换都交由状态类来管理，可能会导致对象的行为和状态分散到多个状态类中，增加了代码的理解和维护难度</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;状态模式（State Pattern）是一种行为型设计模式，它允许对象在内部状态发生变化时改变其行为，使得对象看起来好像修改了其类&lt;/p&gt;
</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《备忘录模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/e88d43d9/"/>
    <id>https://wutiaowu5t5.github.io/posts/e88d43d9/</id>
    <published>2024-04-03T07:24:24.000Z</published>
    <updated>2024-04-03T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现细节的情况下，捕获并存储对象的内部状态，并在需要时恢复到先前的状态</p><p><br/></p><p>备忘录模式通过引入三个核心角色来实现这一点：发起人（Originator）、备忘录（Memento）和管理者（Caretaker）</p><ul><li><p><strong>发起人（Originator）</strong></p><p>负责创建备忘录对象，并在需要时使用备忘录对象恢复其状态</p><p>发起人可以访问其内部状态，并在需要时将其保存到备忘录中或从备忘录中恢复状态</p></li><li><p><strong>备忘录（Memento）</strong></p><p>用于存储发起人对象的内部状态</p><p>备忘录对象可以是不可变的，以确保其状态不会被外部修改</p></li><li><p><strong>管理者（Caretaker）</strong></p><p>负责存储和管理备忘录对象</p><p>管理者通常不直接操作备忘录的内容，而是将备忘录对象传递给发起人，以便发起人可以恢复其状态</p></li></ul><p><br/></p><p>备忘录模式的核心思想是将对象的状态保存到备忘录对象中，并在需要时将状态恢复到先前的状态，从而实现对象状态的回溯</p><p>这种模式的优点在于，可以避免在对象内部暴露其状态的细节，同时也使得状态的存储和恢复变得更加灵活和可控</p><p>备忘录模式适用于以下情况：</p><ul><li>当需要保存和恢复对象的状态，并且不希望暴露对象内部状态细节时，可以使用备忘录模式</li><li>当需要实现撤销/重做功能或者历史记录功能时，备忘录模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个文本编辑器</p><p>用户在编辑文本时可以进行多次修改，而备忘录模式可以用来保存每次修改前的文本状态，以便用户可以撤销到先前的状态或者查看编辑历史记录</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>需要保存和恢复对象的状态</strong></p><p>备忘录模式适用于需要保存对象状态，并在需要时将其恢复到先前状态的情况</p><p>这通常涉及到对象的状态频繁变化，需要在某个时间点保存状态以便后续恢复</p></li><li><p><strong>需要实现状态保存和恢复的封装</strong></p><p>备忘录模式将状态的保存和恢复封装到备忘录对象中，因此需要定义备忘录对象和相应的接口来实现状态的保存和恢复</p></li><li><p><strong>需要保持备忘录对象与原发器对象之间的隔离</strong></p><p>备忘录模式通过备忘录对象来保存原发器对象的状态，因此需要保持备忘录对象与原发器对象之间的隔离，以防止原发器对象直接访问备忘录对象的内部状态</p></li><li><p><strong>需要提供恢复状态的接口</strong></p><p>备忘录模式通常需要提供一个接口或方法来将对象恢复到之前保存的状态</p><p>这样，在需要恢复状态时，可以通过调用该接口或方法来实现状态的恢复</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>状态保存和恢复的封装</strong></p><p>备忘录模式将对象状态的保存和恢复封装到备忘录对象中，使得原发器对象可以专注于自身的业务逻辑，而不需要关心状态的保存和恢复</p></li><li><p><strong>状态的可控性</strong></p><p>备忘录模式允许在任意时间点保存对象的状态，并在需要时将其恢复到先前的状态，从而提供了一种灵活的方式来管理对象的状态</p></li><li><p><strong>隔离备忘录对象与原发器对象</strong></p><p>备忘录模式通过备忘录对象来保存原发器对象的状态，从而实现了备忘录对象与原发器对象之间的隔离，使得原发器对象无法直接访问备忘录对象的内部状态，保证了对象状态的封装性和安全性</p></li><li><p><strong>支持多次撤销和重做操作</strong></p><p>备忘录模式允许保存多个状态快照，并支持多次撤销和重做操作，从而提供了一种有效的方式来管理对象状态的变化历史</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能导致内存消耗过大</strong></p><p>备忘录模式需要在备忘录对象中保存对象的状态信息，如果对象的状态信息较大或者状态信息保存的备忘录对象过多，可能会导致内存消耗过大</p></li><li><p><strong>可能导致性能下降</strong></p><p>备忘录模式需要在备忘录对象中保存对象的状态信息，如果频繁保存状态或者频繁恢复状态，可能会导致性能下降</p></li><li><p><strong>可能增加代码复杂度</strong></p><p>备忘录模式需要定义备忘录对象、原发器对象和负责人对象等多个角色，并且需要正确管理这些对象之间的关系，可能会增加代码的复杂度</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现细节的情况下，捕获并存储对象的内部状态，并在需要时恢</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《命令模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/25e1ecde/"/>
    <id>https://wutiaowu5t5.github.io/posts/25e1ecde/</id>
    <published>2024-04-02T07:24:24.000Z</published>
    <updated>2024-04-02T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而允许用不同的请求对客户进行参数化，队列或记录请求日志，并支持可撤销的操作</p><p><br/></p><p>命令模式通常涉及四个核心角色：命令（Command）、接收者（Receiver）、调用者（Invoker）和客户端（Client）</p><ul><li><p><strong>命令（Command）</strong></p><p>定义了执行操作的接口</p><p>通常包含一个执行操作的方法，以及可能包含一些其他方法用于支持命令的撤销、重做等操作</p></li><li><p><strong>接收者（Receiver）</strong></p><p>实际执行命令操作的对象</p><p>接收者包含了具体的业务逻辑，负责实现命令接口定义的操作</p></li><li><p><strong>调用者（Invoker）</strong></p><p>负责调用命令对象来执行请求</p><p>调用者通常不直接与接收者交互，而是通过调用命令对象的方法来执行具体的操作</p></li><li><p><strong>客户端（Client）</strong></p><p>创建命令对象，并将命令对象传递给调用者来执行请求</p><p>客户端通常不需要知道命令对象的具体实现，只需要知道如何创建命令对象，并将其传递给调用者即可</p></li></ul><p><br/></p><p>命令模式的核心思想是将请求封装成一个对象，使得请求的发送者和接收者之间解耦，从而可以灵活地添加、修改和重用命令对象，同时也提供了一种统一的方式来处理请求的执行、撤销和重做等操作</p><p>命令模式适用于以下情况：</p><ul><li>当需要将请求的发送者和接收者之间解耦，并且希望在不同的请求之间进行参数化时，可以使用命令模式</li><li>当希望支持命令的撤销、重做等操作，并且希望将这些操作封装到命令对象中时，命令模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个遥控器系统</p><p>遥控器可以控制不同的家电设备（如电视、音响等），而命令模式可以将每个控制命令（如打开、关闭、调高音量等）封装成一个命令对象，并将命令对象传递给遥控器来执行具体的控制操作</p><p>这样，可以实现遥控器与家电设备之间的解耦，同时也提供了一种统一的方式来处理控制命令的执行、撤销和重做等操作</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在命令对象</strong></p><p>命令模式适用于存在一组需要被执行的命令，并且希望将这些命令封装成独立的对象的情况</p></li><li><p><strong>需要将请求者和接收者解耦</strong></p><p>命令模式适用于需要将请求者和接收者解耦的情况，即请求者不需要知道接收者的具体实现细节，而是通过命令对象来与接收者进行通信</p></li><li><p><strong>需要支持撤销和重做操作</strong></p><p>命令模式适用于需要支持撤销和重做操作的情况，因为命令对象可以保存执行命令的历史记录，并且可以根据需要进行撤销和重做操作</p></li><li><p><strong>需要支持命令队列或者日志</strong></p><p>命令模式适用于需要支持命令队列或者日志的情况，因为命令对象可以将所有的命令保存在一个队列中，并且可以将执行命令的日志保存下来</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>解耦请求者和接收者</strong></p><p>命令模式将请求封装成命令对象，使得请求者和接收者之间解耦，请求者不需要知道接收者的具体实现细节</p></li><li><p><strong>容易扩展新的命令</strong></p><p>由于命令模式将每个命令封装成独立的对象，因此容易扩展新的命令，只需要创建新的命令对象并实现对应的执行逻辑即可</p></li><li><p><strong>支持撤销和重做操作</strong></p><p>命令模式可以轻松地支持撤销和重做操作，因为每个命令对象都可以保存执行命令的历史记录，并且可以根据需要进行撤销和重做操作</p></li><li><p><strong>支持命令队列和日志</strong></p><p>命令模式可以支持命令队列和日志功能，因为命令对象可以将所有的命令保存在一个队列中，并且可以将执行命令的日志保存下来</p></li><li><p><strong>降低系统的耦合度</strong></p><p>命令模式降低了系统的耦合度，使得请求者和接收者之间的关系更加灵活，易于维护和扩展</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能导致类爆炸</strong></p><p>命令模式可能会导致类爆炸，因为每个命令都需要定义一个独立的命令类，如果命令较多，可能会导致类的数量增加</p></li><li><p><strong>增加代码复杂度</strong></p><p>命令模式可能会增加代码的复杂度，因为需要定义大量的命令类，并且需要正确地组织和管理这些命令类</p></li><li><p><strong>可能降低性能</strong></p><p>命令模式可能会降低系统的性能，因为需要创建和管理大量的命令对象，并且需要保存命令的历史记录，可能会导致内存占用和执行时间增加</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而允许用不同的请求对客户进行参数化，队列或记录请求</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《职责链模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/ae2b73e3/"/>
    <id>https://wutiaowu5t5.github.io/posts/ae2b73e3/</id>
    <published>2024-04-01T07:24:24.000Z</published>
    <updated>2024-04-01T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p><p><br/></p><p>职责链模式通常涉及两个核心角色：处理者（Handler）和客户端（Client）</p><ul><li><p><strong>处理者（Handler）</strong></p><p>定义了一个处理请求的接口，并维护了一个后继处理者的引用</p><p>处理者可以决定是否处理请求，或者将请求传递给后继处理者</p></li><li><p><strong>客户端（Client）</strong></p><p>创建处理者对象，并将请求发送给处理者链的第一个处理者</p><p>客户端通常不需要知道处理者链的具体结构，只需要将请求发送给第一个处理者即可</p></li></ul><p><br/></p><p>职责链模式的核心思想是将请求发送者和接收者解耦，使得多个对象都有机会处理请求，并且可以灵活地调整处理者链的结构</p><p>这种模式的优点在于，可以降低请求发送者和接收者之间的耦合度，提高系统的灵活性和可扩展性</p><p>职责链模式适用于以下情况：</p><ul><li>当有多个对象可以处理同一个请求，并且希望将请求发送者和接收者解耦时，可以使用职责链模式</li><li>当希望动态地调整处理者链的结构，并且希望在运行时决定请求的处理者时，职责链模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个请假审批系统</p><p>请假申请可以被多个领导依次审批，而每个领导都有不同的审批权限</p><p>职责链模式可以将每个领导视为一个处理者对象，并将请假申请发送给处理者链的第一个处理者</p><p>如果第一个处理者无法处理请求，则将请求传递给下一个处理者，直到找到能够处理请求的处理者为止</p><p>这样，可以实现请求发送者和接收者的解耦，同时也提供了一种灵活的方式来处理请求</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>多个对象处理同一请求</strong></p><p>职责链模式适用于多个对象处理同一请求的情况，请求会按照一定的顺序经过一系列的处理者，直到找到合适的处理者处理请求为止</p></li><li><p><strong>请求发送者不需要明确知道接收</strong></p></li><li><p>职责链模式适用于请求发送者不需要明确知道接收者是谁的情况，请求发送者只需要将请求发送给第一个处理者，由处理者之间相互传递请求，直到找到合适的处理者</p></li><li><p><strong>请求可以被任意处理者处理</strong></p><p>职责链模式适用于请求可以被任意处理者处理的情况，处理者之间没有严格的顺序要求，可以根据具体情况自由选择处理请求的方式</p></li><li><p><strong>需要动态添加或者删除处理者</strong></p><p>职责链模式适用于需要动态添加或者删除处理者的情况，处理者之间的关系是动态变化的，可以根据需要灵活地调整处理者的顺序和数量</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>降低耦合度</strong></p><p>职责链模式将请求发送者和接收者解耦，请求发送者不需要知道具体的接收者是谁，接收者也不需要知道请求的发送者是谁，从而降低了对象之间的耦合度</p></li><li><p><strong>增强灵活性</strong></p><p>职责链模式允许请求沿着一条链传递，每个处理者都有机会处理请求或者将请求传递给下一个处理者，从而增强了系统的灵活性和可扩展性</p></li><li><p><strong>简化对象的相互连接</strong></p><p>职责链模式可以简化对象之间的相互连接，每个处理者只需要保存对下一个处理者的引用即可，无需了解整个处理链的结构，降低了系统的复杂度</p></li><li><p><strong>增强了请求的处理过程</strong></p><p>职责链模式将请求的处理过程分解成多个处理者来共同完成，每个处理者只负责自己能够处理的部分，使得请求的处理过程更加清晰和可控</p></li><li><p><strong>动态添加或者删除处理者</strong>职</p><p>责链模式允许动态地添加或者删除处理者，处理者之间的关系是动态变化的，可以根据需要灵活地调整处理者的顺序和数量</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>请求可能未被处理</strong></p><p>如果请求没有合适的处理者来处理，可能会导致请求未被处理，需要额外的机制来处理这种情况，例如设置一个默认处理者</p></li><li><p><strong>性能问题</strong></p><p>职责链模式可能会导致性能问题，特别是处理链比较长或者请求频繁的情况下，可能会造成请求的传递和处理延迟</p></li><li><p><strong>调试困难</strong></p><p>由于请求的处理过程被分解到多个处理者中，可能会导致调试困难，难以确定请求的处理流程和具体是哪个处理者处理了请求</p></li><li><p><strong>可能导致循环引用</strong></p><p>如果处理链中存在循环引用的情况，可能会导致请求无法正常处理，甚至造成系统崩溃，需要谨慎设计处理链的结构</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象都有机会处理请求，从而避免请</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《模版方法模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/8472c90e/"/>
    <id>https://wutiaowu5t5.github.io/posts/8472c90e/</id>
    <published>2024-03-30T07:24:24.000Z</published>
    <updated>2024-03-30T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现</p><p><br/></p><p>模板方法模式通常涉及两个核心角色：模板类（Abstract Class）和具体实现类（Concrete Class）</p><ul><li><p><strong>模板类（Abstract Class）</strong></p><p>定义了一个算法的骨架，其中包含了算法的各个步骤，其中某些步骤可能由子类实现</p></li><li><p><strong>具体实现类（Concrete Class）</strong></p><p>实现了模板类中定义的具体步骤。具体实现类负责实现模板类中定义的抽象方法，从而提供算法的具体实现</p></li></ul><p><br/></p><p>模板方法模式的核心思想是将算法的不变部分封装到模板类中，而将可变部分留给子类来实现</p><p>这种模式的优点在于，可以避免代码的重复，提高代码的复用性，并且可以在不修改模板类的情况下改变算法的某些部分</p><p>模板方法模式适用于以下情况：</p><ul><li>当希望定义一个算法的骨架，并允许子类为其中的某些步骤提供具体实现时，可以使用模板方法模式</li><li>当希望在不修改模板类的情况下改变算法的某些部分时，模板方法模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个制作咖啡和茶的过程</p><p>制作咖啡和茶的过程中都有一些共同的步骤（如煮水、冲泡、加调味品等），而某些步骤可能因为制作的饮料不同而有所不同</p><p>模板方法模式可以将制作饮料的算法抽象成一个模板类，并将其中的共同步骤封装到模板类中，而将可变步骤留给具体的实现类来实现</p><p>这样，就可以通过继承模板类并重写其中的部分方法来实现不同种类饮料的制作过程，而不需要重复编写相同的代码</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在多个子类</strong></p><p>模板方法模式适用于存在多个子类，并且这些子类之间存在一定的共同行为或者流程的情况</p></li><li><p><strong>需要定义一个算法的框架</strong></p><p>模板方法模式适用于需要定义一个算法的框架，并且允许子类根据需要重写其中的某些步骤的情况</p></li><li><p><strong>需要避免代码重复</strong></p><p>模板方法模式适用于需要避免代码重复的情况，通过将共同行为或者流程抽象到父类中，可以避免在每个子类中重复编写相同的代码</p></li><li><p><strong>需要在运行时动态确定算法的具体实现</strong></p><p>模板方法模式适用于需要在运行时动态确定算法的具体实现的情况，因为模板方法模式允许子类根据需要重写父类中的某些步骤，从而实现不同的算法</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>提高代码复用性</strong></p><p>模板方法模式将共同的行为封装到父类中，子类只需要实现特定的步骤即可，从而提高了代码的复用性</p></li><li><p><strong>提高扩展性</strong></p><p>模板方法模式通过将算法的框架定义在父类中，并且允许子类重写特定的步骤，提高了系统的扩展性，可以灵活地增加或者修改算法的具体实现</p></li><li><p><strong>符合开闭原则</strong></p><p>模板方法模式符合开闭原则，父类中定义的算法框架是稳定的，而具体步骤的实现可以在子类中灵活扩展或者修改，因此对于扩展是开放的，对于修改是关闭的</p></li><li><p><strong>提高了系统的适应性</strong></p><p>模板方法模式可以定义一个算法的框架，并且允许子类根据具体情况来实现算法的特定步骤，从而提高了系统的适应性和灵活性</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能导致代码的阅读和理解难度增加</strong></p><p>模板方法模式将算法的框架定义在父类中，而具体步骤的实现分散在不同的子类中，可能会导致代码的阅读和理解难度增加</p></li><li><p><strong>可能限制子类的灵活性</strong></p><p>模板方法模式将算法的框架固定在父类中，可能会限制子类的灵活性，如果算法的框架需要在运行时动态确定，可能会导致子类的扩展受到限制</p></li><li><p><strong>可能增加系统的复杂度</strong></p><p>模板方法模式将算法的具体实现分散在不同的子类中，可能会增加系统的复杂度，特别是当算法的具体实现比较复杂时</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，并允许子类为一个或多个步骤提供实</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《策略模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/1445619f/"/>
    <id>https://wutiaowu5t5.github.io/posts/1445619f/</id>
    <published>2024-03-29T07:24:24.000Z</published>
    <updated>2024-03-29T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装成单独的对象，使它们可以相互替换。策略模式允许算法的变化独立于使用算法的客户端</p><p><br/></p><p>策略模式通常涉及三个核心角色：上下文（Context）、策略接口（Strategy Interface）和具体策略类（Concrete Strategies）</p><ul><li><p><strong>上下文（Context）</strong></p><p>负责维护对策略对象的引用，并在需要时调用策略对象的算法</p><p>上下文通常会将请求委派给策略对象来执行特定的算法。</p></li><li><p><strong>策略接口（Strategy Interface）</strong></p><p>定义了所有具体策略类必须实现的算法接口</p><p>这个接口通常只有一个方法，用于执行具体的算法。</p></li><li><p><strong>具体策略类（Concrete Strategies）</strong></p><p>实现了策略接口，包含了具体的算法实现</p><p>每个具体策略类代表了一个具体的算法，可以根据需求增加或修改</p></li></ul><p><br/></p><p>策略模式的核心思想是将算法封装成独立的对象，并使这些对象可以相互替换，从而使得算法的变化不会影响到使用算法的客户端</p><p>这种模式的优点在于，提高了代码的灵活性和可维护性，使得算法可以在不修改客户端代码的情况下进行替换或者扩展</p><p>策略模式适用于以下情况：</p><ul><li>当一个系统需要支持多种算法，并且这些算法可以相互替换时，可以使用策略模式</li><li>当一个类的行为取决于一些动态变化的条件时，可以考虑使用策略模式</li></ul><p><br/></p><p>举个简单的例子，考虑一个电商系统中的支付功能</p><p>系统可以支持多种支付方式，如支付宝、微信支付、信用卡支付等</p><p>策略模式可以将每种支付方式封装成一个具体的策略类，然后根据用户选择的支付方式来动态地选择并使用相应的支付策略，从而实现支付功能的灵活性和可扩展性</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在一组相关的算法</strong></p><p>策略模式适用于存在一组相关的算法，并且客户端需要在运行时选择其中一个算法来使用的情况</p></li><li><p><strong>算法之间可以相互替换</strong></p><p>策略模式的核心思想是将算法封装成策略对象，并且允许客户端在不修改客户端代码的情况下替换算法</p></li><li><p><strong>需要避免使用条件语句来选择算法</strong></p><p>如果存在多个条件语句来选择不同的算法，可能会导致代码的可读性和可维护性下降</p><p>策略模式可以将条件语句替换为对象之间的关系，从而提高代码的可读性和可维护性</p></li><li><p><strong>需要将算法的实现和使用分离</strong></p><p>策略模式将算法的实现和使用分离，使得客户端可以独立于具体算法进行变化，从而提高系统的灵活性和可扩展性</p></li><li><p><strong>需要将变化的部分封装成独立的对象</strong></p><p>策略模式将算法封装成策略对象，并将策略对象作为客户端和上下文对象的一部分，从而将变化的部分封装成独立的对象，方便扩展和修改</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>灵活性高</strong></p><p>策略模式允许客户端在运行时动态地选择算法，从而提高系统的灵活性和可扩展性</p></li><li><p><strong>可维护性好</strong></p><p>策略模式将算法封装成独立的策略对象，使得算法的实现和使用分离，从而提高了代码的可维护性</p></li><li><p><strong>避免使用条件语句</strong></p><p>策略模式避免了使用过多的条件语句来选择不同的算法，从而提高了代码的可读性和可维护性</p></li><li><p><strong>增加代码复用性</strong></p><p>策略模式将算法封装成独立的策略对象，可以在不同的上下文中重复使用相同的算法，从而提高了代码的复用性</p></li><li><p><strong>符合开闭原则</strong></p><p>策略模式通过定义一组算法族，并通过策略对象进行封装和使用，可以方便地添加新的算法或修改现有算法，从而符合开闭原则</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>增加对象数量</strong></p><p>策略模式将每个算法都封装成独立的策略对象，可能会增加对象数量，从而增加了系统的复杂度</p></li><li><p><strong>客户端需要了解所有策略</strong></p><p>客户端需要了解所有可用的策略，并在运行时选择合适的策略，可能会增加客户端的复杂度</p></li><li><p><strong>可能增加系统的运行开销</strong></p><p>策略模式需要在运行时动态地选择算法，可能会增加系统的运行开销</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装成单独的对象，使它们可以相互替换。策略</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《迭代器模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/b1de33a6/"/>
    <id>https://wutiaowu5t5.github.io/posts/b1de33a6/</id>
    <published>2024-03-28T07:24:24.000Z</published>
    <updated>2024-03-28T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</p><p><br/></p><p>迭代器模式通常涉及两个核心角色：迭代器（Iterator）和可迭代对象（Iterable）</p><ul><li><p><strong>迭代器（Iterator）</strong></p><p>负责定义访问和遍历聚合对象元素的接口</p><p>迭代器对象通常会追踪当前位置，并提供方法来获取下一个元素、检查是否还有下一个元素等</p></li><li><p><strong>可迭代对象（Iterable）</strong></p><p>表示包含一组元素的聚合对象，并提供一个方法来获取对应的迭代器</p><p>可迭代对象可以是集合类、数组、列表等</p></li></ul><p><br/></p><p>迭代器模式的核心思想是将遍历聚合对象的行为抽象出来，并将其封装到迭代器对象中，从而实现聚合对象与遍历算法的解耦</p><p>这种模式的优点在于，可以统一遍历接口，使得客户端代码与聚合对象的内部结构解耦，同时也提供了一种通用的遍历方法，适用于各种不同类型的聚合对象</p><p>迭代器模式适用于以下情况：</p><ul><li>当需要对聚合对象进行遍历，并且希望遍历算法与聚合对象的内部结构解耦时，可以使用迭代器模式</li><li>当希望提供一种统一的遍历接口，使得客户端代码可以统一处理不同类型的聚合对象时，迭代器模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个集合类（如列表、数组）中包含一组元素</p><p>而迭代器模式可以将遍历集合元素的算法抽象成一个迭代器对象，从而使得客户端代码可以通过迭代器对象来访问和遍历集合元素，而不需要了解集合对象的内部结构</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在一个聚合对象</strong></p><p>迭代器模式适用于需要遍历一组元素的情况，因此需要存在一个聚合对象来存储这组元素</p></li><li><p><strong>需要对元素进行遍历操作</strong></p><p>迭代器模式适用于需要对聚合对象中的元素进行遍历操作的情况</p></li><li><p><strong>需要对遍历方式进行抽象</strong></p><p>迭代器模式将遍历方式抽象成迭代器对象，并提供一组统一的接口来对元素进行遍历，从而使得客户端可以统一地处理不同类型的聚合对象</p></li><li><p><strong>需要支持多种遍历方式</strong></p><p>迭代器模式允许定义多种不同的迭代器对象，从而支持多种不同的遍历方式，例如正向遍历、逆向遍历、按照某种顺序遍历等</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>简化聚合对象的接口</strong></p><p>迭代器模式将遍历操作封装在迭代器对象中，使得客户端可以统一地对聚合对象进行遍历操作，简化了聚合对象的接口</p></li><li><p><strong>解耦迭代算法和聚合对象</strong></p><p>迭代器模式将遍历算法与聚合对象进行了解耦，使得聚合对象的内部结构可以独立于其遍历算法的变化</p></li><li><p><strong>支持多种遍历方式</strong></p><p>迭代器模式允许定义多种不同的迭代器对象，从而支持多种不同的遍历方式，例如正向遍历、逆向遍历、按照某种顺序遍历等</p></li><li><p><strong>增加代码复用性</strong></p><p>迭代器模式将遍历操作封装在迭代器对象中，可以在不同的聚合对象之间重复使用相同的迭代器对象，从而提高了代码的复用性</p></li><li><p><strong>简化客户端代码</strong></p><p>迭代器模式使得客户端可以统一地对聚合对象进行遍历操作，不需要关心聚合对象的内部结构和遍历方式，从而简化了客户端的代码</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>增加对象数量</strong></p><p>迭代器模式需要定义迭代器对象和聚合对象之间的关系，可能会增加对象数量，从而增加了系统的复杂度</p></li><li><p><strong>可能降低性能</strong></p><p>迭代器模式需要在迭代器对象中保存迭代状态，并且可能需要频繁地进行状态转换，可能会降低系统的性能</p></li><li><p><strong>可能增加代码复杂度</strong></p><p>迭代器模式需要定义迭代器对象和聚合对象之间的关系，并且可能需要在迭代器对象中保存迭代状态，可能会增加代码的复杂度</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《观察者模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/73dbb689/"/>
    <id>https://wutiaowu5t5.github.io/posts/73dbb689/</id>
    <published>2024-03-27T07:24:24.000Z</published>
    <updated>2024-03-27T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听并收到目标对象的状态变化</p><p><br/></p><p>观察者模式通常涉及两个核心角色：目标（Subject）和观察者（Observer）</p><ul><li><p><strong>目标（Subject）</strong></p><p>也称为主题或者可观察对象，它是被观察的对象</p><p>目标对象会维护一个观察者列表，并提供方法来添加、移除和通知观察者</p></li><li><p><strong>观察者（Observer）</strong></p><p>也称为订阅者或者监听者，它是接收目标对象状态变化通知的对象</p><p>观察者对象通常会实现一个更新方法，用于接收目标对象状态变化的通知</p></li></ul><p><br/></p><p>观察者模式的核心思想是通过定义目标对象和观察者对象之间的一对多依赖关系，使得目标对象状态变化时能够通知所有的观察者对象</p><p>这种模式的优点在于，实现了目标对象和观察者对象的解耦，使得它们可以独立变化，同时也提供了一种灵活的机制来实现发布-订阅模式</p><p>观察者模式适用于以下情况：</p><ul><li>当一个对象的状态变化需要通知其他对象，并且这些对象的数量和类型在运行时可以动态变化时，可以使用观察者模式</li><li>当一个对象的状态变化可能引起其他对象的状态变化，并且希望避免对象之间的紧耦合关系时，观察者模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个新闻发布系统</p><p>新闻发布者是目标对象，而订阅者是观察者对象。当新闻发布者发布了新的新闻时，所有订阅者都会收到新闻通知，并更新自己的状态</p><p>观察者模式可以很好地实现这种发布-订阅的机制，同时也保持了发布者和订阅者之间的解耦</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在一个一对多的依赖关系</strong></p><p>观察者模式适用于存在一个主题（Subject）对象和多个观察者（Observer）对象之间的一对多的依赖关系的情况，当主题对象的状态发生变化时，所有依赖于该主题对象的观察者对象都会得到通知</p></li><li><p><strong>主题对象的状态发生变化需要通知观察者对象</strong></p><p>观察者模式适用于主题对象的状态发生变化时需要通知所有观察者对象的情况，观察者对象根据主题对象的状态变化来更新自己的状态或者执行相应的操作</p></li><li><p><strong>观察者对象的数量相对固定</strong></p><p>观察者模式适用于观察者对象的数量相对固定的情况，因为主题对象需要维护观察者对象的引用，并且在状态发生变化时通知所有观察者对象</p></li><li><p><strong>观察者对象与主题对象之间的解耦</strong></p><p>观察者模式将主题对象和观察者对象之间的关系进行了解耦，使得主题对象和观察者对象可以相互独立地变化，而不需要相互了解具体的实现细节</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>简化事件管理</strong></p><p>在前端开发中，观察者模式可以用于简化事件管理。主题对象就是事件源，而观察者对象就是事件处理函数</p><p>当事件源状态变化时，观察者（事件处理函数）会得到通知并执行相应的操作，从而使得事件管理更加简单清晰</p></li><li><p><strong>模块解耦</strong></p><p>观察者模式可以帮助将模块解耦，使得代码更具灵活性和可维护性</p><p>通过观察者模式，主题对象（被观察者）和观察者对象之间的依赖关系被解耦，它们可以独立地变化和扩展</p></li><li><p><strong>数据驱动界面更新</strong></p><p>在前端应用中，观察者模式常用于数据驱动界面更新</p><p>当数据发生变化时，主题对象会通知所有的观察者对象，而这些观察者对象可以负责更新相应的界面元素，实现了数据和界面的分离</p></li><li><p><strong>事件监听</strong></p><p>在前端开发中，观察者模式常用于事件监听。通过注册事件监听器（观察者），可以在事件发生时执行相应的操作，从而实现事件驱动的编程模型</p></li><li><p><strong>组件通信</strong></p><p>观察者模式也常被用于组件间的通信。当一个组件的状态发生变化时，可以通过观察者模式通知其他组件进行相应的更新或者操作，从而实现组件间的解耦和通信</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能引起内存泄漏</strong></p><p>如果观察者对象没有被正确地释放或者没有及时地取消注册，可能会导致主题对象保持对观察者对象的引用，从而导致内存泄漏</p></li><li><p><strong>可能引起循环引用</strong></p><p>如果观察者对象之间存在循环引用，可能会导致系统出现死锁或者其他不可预期的问题</p></li><li><p><strong>可能导致性能问题</strong></p><p>当观察者对象过多或者观察者对象的通知频率过高时，可能会导致系统的性能下降</p></li><li><p><strong>可能导致事件顺序问题</strong></p><p>观察者模式通常是异步通知观察者对象的，因此可能会导致观察者对象接收到通知的顺序与注册的顺序不一致的问题</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>创建基础的观察者类，并冻结它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者类，提供订阅、取消订阅和通知功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化观察者对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 使用Set存储订阅的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅功能，添加一个观察者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span> - 需要订阅的函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果传入的参数不是函数类型，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Observer.subscribe: Expected function&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅功能，移除一个观察者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span> - 需要取消订阅的函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果传入的参数不是函数类型，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Observer.unsubscribe: Expected function&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">delete</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有订阅者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">data</span> - 传递给订阅者函数的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>(data)) <span class="comment">// 循环调用所有订阅者函数，传入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个全局不变的观察者实例</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Watcher</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(<span class="keyword">new</span> <span class="title class_">Observer</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Watcher</span></span><br></pre></td></tr></table></figure><p><br/></p><p>导入使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入Watcher对象，该对象来自于ObserverPattern模块，用于实现观察者模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Watcher</span> <span class="keyword">from</span> <span class="string">&#x27;../ObserverPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义第一个观察者函数，当接收到数据时，打印出数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">data</span> - 接收到的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observer1</span> = data =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Observer 1 received: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义第二个观察者函数，当接收到数据时，打印出数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">data</span> - 接收到的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observer2</span> = data =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Observer 2 received: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅observer1和observer2，使其成为Watcher的观察者。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">subscribe</span>(observer1)</span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">subscribe</span>(observer2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有观察者，发送消息&#x27;Hello World&#x27;。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">notify</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消observer1的订阅。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">unsubscribe</span>(observer1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次通知所有观察者，发送消息&#x27;How are you?&#x27;，此时observer1不会收到该消息。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">notify</span>(<span class="string">&#x27;How are you?&#x27;</span>)</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>表单字段的验证与提示</strong></p><p> 当用户在表单中输入内容时，需要实时验证输入的有效性，并及时提示用户</p><p>这里可以将表单字段作为观察者，输入事件作为主题，当字段的值发生变化时，触发相应的验证函数来更新提示信息</p></li><li><p><strong>组件间通信</strong>：</p><p>在复杂的前端应用中，不同的组件之间可能需要进行通信和数据传递</p><p>观察者模式可以被用来实现组件间的解耦，一个组件可以作为主题，而其他组件则可以订阅主题来获取相关的数据或状态更新</p></li><li><p><strong>全局状态管理</strong></p><p> 在大型前端应用中，可能会存在一些全局的状态需要在不同的组件中共享和管理</p><p>观察者模式可以被用来实现全局状态的管理，一个状态对象可以作为主题，而其他组件则可以订阅该主题来获取状态的更新</p></li><li><p><strong>路由管理</strong></p><p>在单页面应用（SPA）中，路由管理是一个重要的功能</p><p>当路由发生变化时，不同的页面或组件需要做出相应的响应</p><p>观察者模式可以被用来实现路由管理，路由对象可以作为主题，而页面或组件则可以订阅该主题来获取路由的变化</p></li><li><p><strong>事件总线</strong></p><p>在前端开发中，可能会遇到需要在不同组件之间进行事件通信的情况</p><p>观察者模式可以被用来实现事件总线，一个事件总线对象可以作为主题，而其他组件则可以订阅事件总线来接收和处理事件</p></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/ObserverPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听并收到目标对象的状</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《享元模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/469c39d8/"/>
    <id>https://wutiaowu5t5.github.io/posts/469c39d8/</id>
    <published>2024-03-26T07:24:24.000Z</published>
    <updated>2024-03-26T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最小化内存使用和提高性能</p><p><br/></p><p>享元模式通常涉及两个核心角色：享元（Flyweight）和享元工厂（Flyweight Factory）</p><ul><li><p><strong>享元（Flyweight）</strong></p><p>表示一个可共享的对象，包含了内部状态和外部状态</p><p>内部状态是对象共享的部分，它存储在享元对象内部，而外部状态是对象特有的部分，它存储在享元对象外部，并在需要时通过参数传递给享元对象</p></li><li><p><strong>享元工厂（Flyweight Factory）</strong></p><p>用于创建和管理享元对象</p><p>享元工厂通常包含一个享元对象的池子（或者缓存），用于存储和复用已创建的享元对象，并在需要时返回给客户端</p></li></ul><p><br/></p><p>享元模式的核心思想是通过共享对象来最小化内存使用和提高性能</p><p>当有多个相似的对象需要创建时，享元模式可以将其中的一部分共享出来，从而节省内存空间</p><p>这种模式的优点在于，可以减少对象的创建数量，提高系统的性能和可扩展性</p><p>享元模式适用于以下情况：</p><ul><li>当需要创建大量相似对象，并且这些对象之间有一些共同的部分时，可以使用享元模式</li><li>当希望减少对象的创建数量，提高系统性能和可扩展性时，享元模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个文本编辑器中的字符对象</p><p>文本编辑器可能需要创建大量的字符对象来表示文本内容，而很多字符对象可能是相同的（如空格、换行符等）</p><p>享元模式可以将其中的一些字符对象共享出来，从而节省内存空间，提高系统性能</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>存在大量相似对象</strong></p><p>享元模式适用于存在大量相似对象，并且这些对象之间有一些共享的状态或者行为的情况</p></li><li><p><strong>需要节省内存空间</strong></p><p>享元模式适用于需要节省内存空间的情况，因为享元模式可以将对象的内部状态和外部状态分离，从而避免了创建大量相似对象所带来的内存浪费</p></li><li><p><strong>外部状态相对固定</strong></p><p>享元模式适用于外部状态相对固定的情况，因为享元模式将对象的内部状态和外部状态分离，因此外部状态需要相对稳定</p></li><li><p><strong>需要对对象进行复用</strong></p><p>享元模式适用于需要对对象进行复用的情况，因为享元模式通过共享已有的对象来避免创建新的对象，从而提高了对象的复用性</p></li><li><p><strong>需要降低系统的复杂度</strong></p><p>享元模式适用于需要降低系统的复杂度的情况，因为享元模式可以将对象的内部状态和外部状态分离，从而降低了对象的复杂度</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>减少内存使用</strong></p><p>享元模式可以有效减少相似对象的内存使用，通过共享相同的对象实例来节省内存空间</p></li><li><p><strong>提高性能</strong></p><p>由于减少了对象的数量，享元模式可以提高系统的性能，减少了对象的创建和销毁次数，从而提高了系统的响应速度。</p></li><li><p><strong>对象复用</strong></p><p>享元模式可以实现对象的复用，通过共享已有的对象实例来避免创建新的对象，从而提高了对象的复用性</p></li><li><p><strong>简化对象管理</strong></p><p>享元模式可以简化对象的管理，因为所有共享的对象实例都由工厂类来管理，减少了对象的创建和销毁的逻辑</p></li><li><p><strong>分离内部状态和外部状态</strong></p><p>享元模式将对象的内部状态和外部状态分离，使得可以共享内部状态，而外部状态可以独立变化，提高了系统的灵活性</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>可能引起线程安全问题</strong></p><p>如果多个线程同时访问享元对象，并且对外部状态进行修改，可能会引起线程安全问题，需要额外的同步措施来保证线程安全</p></li><li><p><strong>增加系统复杂度</strong></p><p>享元模式需要对对象的内部状态和外部状态进行分离，并且需要维护一个共享池，可能会增加系统的复杂度</p></li><li><p><strong>可能导致代码混乱</strong></p><p>如果对象的内部状态和外部状态没有良好地分离，可能会导致代码混乱，降低了系统的可维护性</p></li><li><p><strong>不适用于所有情况</strong></p><p>享元模式适用于存在大量相似对象，并且需要节省内存空间的情况，但并不适用于所有情况，特别是对象的外部状态变化频繁的情况</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>创建基础的类跟工厂类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个字符及其相关操作的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个字符对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; char 一个长度为1的字符串。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果输入不是一个长度为1的字符串，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> char !== <span class="string">&#x27;string&#x27;</span> || char.<span class="property">length</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Character must be a single character string.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">char</span> = char</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定位置显示字符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; position 一个包含两个数字的数组，表示位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果位置不是一个包含两个数字的数组，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">display</span>(<span class="params">position</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(position) || position.<span class="property">length</span> !== <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Position must be an array of two numbers.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Character &#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.char&#125;</span>&#x27; displayed at position (<span class="subst">$&#123;position[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;position[<span class="number">1</span>]&#125;</span>)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建和管理字符对象的工厂类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    #characters = &#123;&#125; <span class="comment">// 用于存储已创建的字符对象的私有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个字符对象，如果不存在则创建。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; char 一个长度为1的字符串，表示要获取的字符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Character</span>&#125; 返回对应的字符对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果输入不是一个长度为1的字符串，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getCharacter</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> char !== <span class="string">&#x27;string&#x27;</span> || char.<span class="property">length</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Character must be a single character string.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(char <span class="keyword">in</span> <span class="variable language_">this</span>.#characters)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#characters[char] = <span class="keyword">new</span> <span class="title class_">Character</span>(char)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#characters[char]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个CharacterFactory的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">CharacterFactory</span>()</span><br></pre></td></tr></table></figure><p><br/></p><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">CharacterFactory</span> <span class="keyword">from</span> <span class="string">&#x27;../FlyweightPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试创建并显示字符对象</span></span><br><span class="line">    <span class="comment">// 首次请求字符&#x27;A&#x27;的实例</span></span><br><span class="line">    <span class="keyword">const</span> charA = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    charA.<span class="title function_">display</span>([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次请求字符&#x27;B&#x27;的实例</span></span><br><span class="line">    <span class="keyword">const</span> charB = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    charB.<span class="title function_">display</span>([<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次请求字符&#x27;A&#x27;的实例，预期将复用之前的实例而不是创建新实例</span></span><br><span class="line">    <span class="keyword">const</span> anotherCharA = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    anotherCharA.<span class="title function_">display</span>([<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证两个字符&#x27;A&#x27;的实例是否相同</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(charA === anotherCharA) <span class="comment">// 预期输出 true，表明两个&#x27;A&#x27;字符引用了同一实例</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 捕获并输出可能发生的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>游戏开发</strong></p><p>在游戏中，可能存在大量相同类型的对象，比如敌人、子弹、粒子等。这些对象的外部状态（位置、速度等）可能不同，但内部状态（外观、行为等）是相同的</p><p>通过使用享元模式，游戏可以共享相同类型的对象，从而提高性能和降低内存占用</p></li><li><p>Web 开发</p><p>在 Web 应用程序中，可能存在大量重复的数据，比如页面元素、样式、图标等。通过使用享元模式，可以共享这些数据，并减少加载时间和网络带宽的消耗</p></li><li><p><strong>图形编辑器</strong></p><p>在图形编辑器中，用户可以创建和编辑大量的图形对象，比如线条、圆形、矩形等</p><p>通过使用享元模式，可以共享相同类型的图形对象，从而减少内存消耗，并提高绘图性能</p></li><li><p><strong>操作系统</strong></p><p>在操作系统中，可能存在大量相同类型的资源，比如文件、进程、线程等</p><p>通过使用享元模式，可以共享这些资源，并提高系统的整体性能和响应速度</p></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/FlyweightPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最小化内存使用和提高性能&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《组合模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/79a1bf69/"/>
    <id>https://wutiaowu5t5.github.io/posts/79a1bf69/</id>
    <published>2024-03-25T07:24:24.000Z</published>
    <updated>2024-03-25T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示部分-整体的层次结构</p><p>组合模式使得客户端可以统一地处理单个对象和对象集合</p><p><br/></p><p>组合模式通常涉及两个核心角色：组件（Component）和叶子节点（Leaf）</p><ul><li><p><strong>组件（Component）</strong></p><p>定义了组合中所有对象共有的接口和行为，并提供了管理子组件的方法</p><p>组件可以是抽象类或接口，它可以是叶子节点或容器节点</p></li><li><p><strong>叶子节点（Leaf）</strong></p><p>表示组合中的叶子对象，它没有子组件</p><p>叶子节点通常是组合的最小单元，它实现了组件接口的具体行为</p></li></ul><p><br/></p><p>组合模式的核心思想是将对象组合成树形结构，并且统一对待单个对象和对象集合</p><p>这种模式的优点在于，可以简化客户端和对象之间的交互，客户端不需要区分单个对象和对象集合，而是统一地对待它们</p><p>同时，组合模式也提供了一种灵活的方式来组织和管理对象的层次结构</p><p>组合模式适用于以下情况：</p><ul><li>当希望将对象组合成树形结构，并且统一对待单个对象和对象集合时，可以使用组合模式</li><li>当希望客户端可以统一地处理单个对象和对象集合时，组合模式也是一个很好的选择</li></ul><p><br/></p><p>举个简单的例子，考虑一个文件系统中的目录和文件对象</p><p>目录可以包含其他目录和文件对象，而文件是组合中的叶子节点</p><p>组合模式可以将目录和文件抽象成组件对象，并将它们组合成树形结构</p><p>这样，可以通过统一的方式来处理目录和文件对象，而不需要区分它们的类型</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>对象具有层次结构</strong></p><p>组合模式适用于对象具有层次结构的情况，对象可以按照树形结构组织，并且对象之间存在整体-部分关系</p></li><li><p><strong>客户端统一处理叶子对象和容器对象</strong></p><p>组合模式适用于客户端需要统一处理叶子对象和容器对象的情况，客户端无需区分对象是叶子对象还是容器对象，可以统一对待</p></li><li><p><strong>对整体和部分具有一致性要求</strong></p><p>组合模式适用于对整体和部分具有一致性要求的情况，客户端可以通过统一的接口对整体对象和部分对象进行操作，无需关心具体是哪种对象</p></li><li><p><strong>需要简化客户端代码</strong></p><p>组合模式适用于需要简化客户端代码的情况，客户端无需关心对象的层次结构和具体实现细节，只需要使用统一的接口来操作对象</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>统一接口</strong></p><p>组合模式统一了叶子对象和容器对象的接口，使得客户端可以统一对待叶子对象和容器对象，无需区分</p></li><li><p><strong>灵活性</strong></p><p>组合模式使得客户端可以像处理单个对象一样处理对象的组合，从而增加了系统的灵活性</p></li><li><p><strong>可扩展性</strong></p><p>组合模式通过递归结构实现了对象的树形结构，可以方便地扩展和修改树形结构，从而提高了系统的可扩展性</p></li><li><p><strong>简化客户端代码</strong></p><p>组合模式使得客户端无需关心对象的层次结构和具体实现细节，只需要使用统一的接口来操作对象，从而简化了客户端代码</p></li><li><p><strong>增加了安全性</strong></p><p>组合模式可以通过类型检查来保证容器对象只能包含叶子对象或者其他容器对象，从而增加了系统的安全性</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>限制子对象的类型</strong></p><p>组合模式将叶子对象和容器对象统一成了一种类型，可能会限制子对象的类型，使得子对象的类型不能发生变化</p></li><li><p><strong>增加了系统复杂度</strong></p><p>组合模式通过递归结构实现了对象的树形结构，可能会增加系统的复杂度，特别是在处理复杂的树形结构时</p></li><li><p><strong>不适用于需求变化频繁的场景</strong></p><p>如果对象的结构和层次经常发生变化，可能会导致组合模式的实现变得复杂和不稳定，不适用于需求变化频繁的场景</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基础类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示文件系统的一个组件，是一个抽象基类，不能直接实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，创建一个文件系统组件实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 组件的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当尝试直接实例化FileSystemComponent时抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">FileSystemComponent</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;FileSystemComponent is an abstract class and cannot be instantiated directly.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行文件系统组件的操作，此方法在子类中被重写。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当调用此方法时抛出错误，因为这是一个抽象方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This method should be overridden&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><p>子类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个目录，继承自FileSystemComponent。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，创建一个目录实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 目录的名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span> = [] <span class="comment">// 存储子组件的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向目录中添加一个组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">FileSystemComponent</span>&#125; component 要添加的文件系统组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当添加的对象不是FileSystemComponent的实例时抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">component</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(component <span class="keyword">instanceof</span> <span class="title class_">FileSystemComponent</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Component must be an instance of FileSystemComponent&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(component)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从目录中移除一个组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">FileSystemComponent</span>&#125; component 要移除的文件系统组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">boolean</span>&#125; 成功移除返回true，否则返回false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">component</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">indexOf</span>(component)</span><br><span class="line">        <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行目录的操作，包括打印目录名称和所有子组件的信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="string">&#x27; &#x27;</span>.repeat(indent)&#125;</span>Directory: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="title function_">operation</span>(indent + <span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个文件，继承自FileSystemComponent。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行文件的操作，即打印文件的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="string">&#x27; &#x27;</span>.repeat(indent)&#125;</span>File: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><p>怎么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段代码展示了使用组合模式来管理文件系统对象的例子。</span></span><br><span class="line"><span class="comment"> * 首先，导入了组合模式中的 Directory 和 File 类。</span></span><br><span class="line"><span class="comment"> * 然后，创建了一个根目录 root，两个子目录 dir1 和 dir2，以及两个文件 file1 和 file2。</span></span><br><span class="line"><span class="comment"> * 接着，将 dir1 和 file1 添加到 root 目录中，将 file2 添加到 dir1 目录中。</span></span><br><span class="line"><span class="comment"> * 最后，对 root 目录执行 operation 操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directory</span>, <span class="title class_">File</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../CombinationPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根目录和一系列子目录及文件</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dir1 = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;dir1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dir2 = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;dir2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;file1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;file2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子目录和文件添加到根目录中</span></span><br><span class="line">root.<span class="title function_">add</span>(dir1)</span><br><span class="line">root.<span class="title function_">add</span>(file1)</span><br><span class="line">root.<span class="title function_">add</span>(dir2)</span><br><span class="line"><span class="comment">// 将文件添加到子目录中</span></span><br><span class="line">dir1.<span class="title function_">add</span>(file2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对根目录执行操作（如打印文件结构等）</span></span><br><span class="line">root.<span class="title function_">operation</span>()</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>文件系统</strong></p><p>文件系统是组合模式的经典应用，其中目录可以包含其他目录和文件，而文件是组合中的叶子节点</p></li><li><p><strong>图形用户界面(GUI)</strong></p><p>GUI中的UI元素通常也可以使用组合模式来实现，比如窗口可以包含其他窗口、面板、按钮等UI组件</p></li><li><p><strong>组织结构</strong></p><p>企业组织结构可以使用组合模式来表示，部门可以包含其他部门和员工，而员工是叶子节点</p></li><li><p><strong>菜单系统</strong></p><p>菜单系统通常也可以使用组合模式来实现，菜单可以包含子菜单和菜单项，从而形成多级菜单结构</p></li><li><p><strong>电子商务平台</strong></p><p>电子商务平台的商品分类系统通常也可以使用组合模式来实现，分类可以包含子分类和商品，从而形成多级分类结构</p></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/CombinationPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示部分-整体的层次结构&lt;/p&gt;
&lt;p&gt;组合</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《桥接模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/2b8aa55b/"/>
    <id>https://wutiaowu5t5.github.io/posts/2b8aa55b/</id>
    <published>2024-03-24T07:24:24.000Z</published>
    <updated>2024-03-24T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它用于将抽象部分与它的实现部分分离，使它们可以独立变化</p><p>桥接模式通过将继承关系转化为组合关系来实现这一点</p><p><br/>在桥接模式中，存在两个独立的继承层次结构：抽象部分（Abstraction）和实现部分（Implementation）</p><p>抽象部分定义了高层次的抽象接口，而实现部分则提供了这些接口的具体实现。通过将抽象部分和实现部分分离，可以使它们可以独立地扩展和变化，而不会相互影响</p><p><br/>这种模式的核心思想是通过抽象与实现之间的桥梁来连接它们，使得它们可以独立变化</p><p>这种分离使得系统更加灵活，能够更好地应对需求变化。</p><p><br/></p><p>举个简单的例子，考虑一个绘制图形的程序</p><p>可以有不同类型的图形（如圆形、矩形等），也可以有不同的绘制方式（如在屏幕上绘制、在打印机上绘制等）</p><p>使用桥接模式，可以将图形的类型和绘制方式分离开来，使得可以很容易地添加新的图形类型或绘制方式，而不需要修改已有的代码</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p>存在多个维度的变化</p><p>桥接模式适用于有多个维度的变化，并且这些变化需要独立地进行扩展</p><p>例如，一个类有两个或更多的维度，每个维度都可能变化，而且这些变化不应该相互影响</p></li><li><p>需要在抽象部分和实现部分之间建立关联</p><p>桥接模式的核心是将抽象部分和实现部分分离，但又需要在它们之间建立关联</p><p>因此，在桥接模式中，需要有一种方式将抽象部分和实现部分连接起来，使它们可以协同工作</p></li><li><p>需要在运行时选择具体实现</p><p>桥接模式适用于需要在运行时选择具体实现的情况</p><p>通过桥接模式，可以将抽象部分和实现部分分离开来，并且可以在运行时动态地选择具体的实现</p></li><li><p>可以通过组合而不是继承来实现</p><p>在桥接模式中，通常是通过组合而不是继承来实现抽象部分和实现部分之间的关联</p><p>因此，需要考虑如何将抽象部分和实现部分通过组合关系来连接起来</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>分离抽象和实现</strong></p><p>桥接模式通过将抽象部分和实现部分分离，使它们可以独立变化</p><p>这样一来，可以更容易地扩展和修改系统的功能。</p></li><li><p><strong>可扩展性</strong></p><p>由于桥接模式分离了抽象部分和实现部分，因此可以很容易地添加新的抽象部分或实现部分，而不会影响到已有的代码。</p></li><li><p><strong>透明性</strong></p><p>客户端不需要了解抽象部分和实现部分的具体实现细节，只需要通过抽象接口与抽象部分交互即可，这提高了系统的透明性。</p></li><li><p><strong>高内聚低耦合</strong></p><p>桥接模式使得系统中的不同部分之间的耦合度降低，同时提高了内聚性，使得系统更易于理解和维护。</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>增加复杂性</strong></p><p>引入桥接模式会增加一定的复杂性，因为需要定义抽象部分、实现部分以及它们之间的桥梁，这可能会增加代码量和理解难度</p></li><li><p><strong>可能导致过度设计</strong></p><p>如果系统中的抽象部分和实现部分之间的关系并不复杂，使用桥接模式可能会显得过度设计，增加不必要的开销</p></li><li><p><strong>抽象和实现分离的代价</strong></p><p>虽然将抽象部分和实现部分分离可以提高系统的灵活性和可扩展性，但同时也会增加系统的理解难度，特别是在复杂的系统中可能会增加维护的成本</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基础的Shape类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shape 类定义了基本的形状对象，包括颜色和位置属性，并提供了一系列方法来操作这些属性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">color</span> - 形状的颜色，默认为&quot;black&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color = <span class="string">&quot;black&quot;</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color  <span class="comment">// 设置形状颜色</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;  <span class="comment">// 初始化形状位置为原点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置形状的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">color</span> - 新的颜色值，默认为&quot;black&quot;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setColor</span>(<span class="params">color = <span class="string">&quot;black&quot;</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取形状的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 返回当前形状的颜色。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置形状的位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span> - x轴坐标。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">y</span> - y轴坐标。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setPosition</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">x</span> = x</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">y</span> = y</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取形状的位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125; 返回一个包含x和y属性的对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getPosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...<span class="variable language_">this</span>.<span class="property">position</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，用于绘制形状。子类需要重写此方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;draw&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Shape</span>  <span class="comment">// 导出默认的 Shape 类</span></span><br></pre></td></tr></table></figure><p><br/></p><p>使用方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Square 类继承自 Shape 类，代表一个正方形形状。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> <span class="variable">Shape</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个新的 Square 实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; color 正方形的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; sideLength 正方形的边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color, sideLength</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(color) <span class="comment">// 调用父类的构造函数设置颜色</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setSideLength</span>(sideLength) <span class="comment">// 设置正方形的边长</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置正方形的边长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; sideLength 想要设置的边长值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果边长小于等于零，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setSideLength</span>(<span class="params">sideLength</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sideLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Side length must be greater than zero.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sideLength</span> = sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取正方形的边长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 返回当前正方形的边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getSideLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sideLength</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制正方形。</span></span><br><span class="line"><span class="comment">     * 在控制台输出绘制的信息，包括颜色和边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Drawing Square with color <span class="subst">$&#123;<span class="variable language_">this</span>.getColor()&#125;</span> and side length <span class="subst">$&#123;<span class="variable language_">this</span>.getSideLength()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个蓝色的正方形实例，边长为20</span></span><br><span class="line"><span class="keyword">const</span> blueSquare = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="string">&quot;blue&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置正方形的位置为 (200, 200)</span></span><br><span class="line">blueSquare.<span class="title function_">setPosition</span>(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并输出正方形的位置信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Square position:&quot;</span>, blueSquare.<span class="title function_">getPosition</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出正方形的边长</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Square side length:&quot;</span>, blueSquare.<span class="title function_">getSideLength</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制正方形</span></span><br><span class="line">blueSquare.<span class="title function_">draw</span>() <span class="comment">// 输出：Drawing Square with color blue and side length 20</span></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><strong>UI 组件库</strong>：<ul><li>UI 组件库通常需要支持多种不同的主题样式和外观，例如不同的色彩、字体、布局等。桥接模式可以用来将 UI 组件的核心功能与不同的主题样式进行解耦，从而实现灵活的主题切换。</li></ul></li><li><strong>跨浏览器兼容性库</strong>：<ul><li>在前端开发中，需要考虑不同浏览器之间的兼容性问题，例如不同的 CSS 属性、JavaScript API 等。桥接模式可以用来将前端代码的核心功能与不同的浏览器兼容性进行解耦，从而实现跨浏览器兼容性。</li></ul></li><li><strong>数据可视化库</strong>：<ul><li>数据可视化库通常需要支持多种不同的图表类型和图形样式，例如折线图、柱状图、饼图等。桥接模式可以用来将数据可视化库的核心功能与不同的图表类型和图形样式进行解耦，从而实现灵活的数据可视化。</li></ul></li><li><strong>前端框架</strong>：<ul><li>前端框架（如 React、Vue、Angular 等）通常需要支持多种不同的 UI 组件、路由、状态管理等功能。桥接模式可以用来将前端框架的核心功能与不同的 UI 组件库、路由库、状态管理库进行解耦，从而实现灵活的前端开发。</li></ul></li><li><strong>HTTP 请求库</strong>：<ul><li>前端应用通常需要与后端进行数据交互，例如发送 HTTP 请求获取数据。桥接模式可以用来将前端应用的核心功能与不同的 HTTP 请求库进行解耦，从而实现灵活的数据交互。</li></ul></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/BridgePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;桥接模式（Bridge Pattern）是一种结构型设计模式，它用于将抽象部分与它的实现部分分离，使它们可以独立变化&lt;/p&gt;
&lt;p&gt;桥接模式</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《外观模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/bd865a4b/"/>
    <id>https://wutiaowu5t5.github.io/posts/bd865a4b/</id>
    <published>2024-03-23T07:24:24.000Z</published>
    <updated>2024-03-23T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外观模式（Facade Pattern）是一种结构型设计模式，旨在为复杂系统提供一个简单的接口</p><p>它通过隐藏系统的复杂性，为客户端提供一个简单的接口，使得客户端与系统的子系统之间的通信和交互更加简单</p><p><br/>在外观模式中，一个单一的外观类提供了一个高级接口，它将系统中的一组接口进行了封装，对外只暴露少量的接口，客户端通过这些接口与系统进行交互，而不需要了解系统中具体的子系统之间的关联和细节</p><p><br/></p><p>举个例子，考虑一个电脑系统，它包含了各种硬件和软件组件，如CPU、内存、硬盘、操作系统等</p><p>客户端如果要使用这些组件，可能需要直接与这些组件进行交互，这样会使得客户端代码变得复杂且不易维护</p><p>使用外观模式，可以定义一个电脑外观类，封装各个组件的初始化、启动和关闭等操作，客户端只需要与电脑外观类交互，而不需要了解具体的硬件和软件组件</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>系统包含多个子系统</strong></p><p>系统由多个复杂的子系统组成，这些子系统可能相互关联，但客户端不需要知道这些细节</p></li><li><p><strong>需要简化客户端与子系统之间的交互</strong></p><p>客户端需要与系统交互，但由于系统复杂性的原因，直接与子系统交互可能会导致代码复杂性增加</p></li><li><p><strong>需要实现系统的解耦</strong></p><p>客户端与系统之间的耦合度过高，需要通过一个统一的接口来降低耦合度，从而实现系统的解耦</p></li><li><p><strong>需要提供统一的接口</strong></p><p>系统中的一组接口需要被封装在一个统一的接口后面，以简化客户端的操作</p></li><li><p><strong>需要提高系统的安全性和稳定性</strong></p><p>通过外观模式，可以对系统进行更好的封装和隔离，提高系统的安全性和稳定性</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>简化接口</strong></p><p>外观模式提供了一个简单的接口，隐藏了系统的复杂性，使得客户端只需与外观类交互，而不需要了解系统的内部结构和细节</p></li><li><p><strong>降低耦合度</strong></p><p>外观模式降低了客户端与系统之间的耦合度，客户端只与外观类进行交互，而不需要直接与系统中的各个子系统交互，从而降低了代码的复杂度</p></li><li><p><strong>提高可维护性</strong></p><p>外观模式将系统中的复杂性封装在一个外观类中，使得系统更易于理解、维护和修改</p></li><li><p><strong>提高安全性和稳定性</strong></p><p>通过外观模式，可以对系统进行更好的封装和隔离，提高了系统的安全性和稳定性</p></li><li><p><strong>遵循单一职责原则</strong></p><p>外观模式将系统中的各个子系统功能进行了分离，每个子系统只负责自己的功能，遵循了单一职责原则</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>不符合开闭原则</strong></p><p>如果需要新增或修改系统的功能，可能需要修改外观类，这违反了开闭原则</p></li><li><p><strong>可能隐藏系统的复杂性过多</strong></p><p>外观模式可能会导致系统的某些复杂性被过度隐藏，使得一些高级功能无法实现，或者导致性能问题</p></li><li><p><strong>可能引入性能损耗</strong></p><p>在某些情况下，外观模式可能会引入额外的性能损耗，因为客户端通过外观类来访问子系统，而不是直接访问，可能会增加额外的调用开销</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>定义子系统，跟外观系统</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频解码器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责解码音频文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioDecoder</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码指定的音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; audioFile 需要解码的音频文件路径或名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">decode</span>(<span class="params">audioFile</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`解码音频文件: <span class="subst">$&#123;audioFile&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频控制器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责管理音频的播放控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;播放音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pause</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;暂停音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止音频播放。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;停止音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音量控制器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责管理音量的设置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VolumeController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置音量级别。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; volumeLevel 需要设置的音量级别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setVolume</span>(<span class="params">volumeLevel</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置音量为: <span class="subst">$&#123;volumeLevel&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频播放器外观类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供一个简单统一的接口来控制音频的播放、暂停、停止以及音量设置，隐藏了子系统的复杂性。</span></span><br><span class="line"><span class="comment"> * 通过封装`AudioDecoder`、`AudioController`和`VolumeController`等子系统，简化了对外部使用者的交互逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayerFacade</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化音频解码器、音频控制器和音量控制器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioDecoder</span> = <span class="keyword">new</span> <span class="title class_">AudioDecoder</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span> = <span class="keyword">new</span> <span class="title class_">AudioController</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">volumeController</span> = <span class="keyword">new</span> <span class="title class_">VolumeController</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放指定的音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; audioFile 需要播放的音频文件路径或名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">playAudio</span>(<span class="params">audioFile</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioDecoder</span>.<span class="title function_">decode</span>(audioFile)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">play</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前正在播放的音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pauseAudio</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">pause</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止当前正在播放的音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">stopAudio</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">stop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置播放音量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; volumeLevel 需要设置的音量级别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setVolume</span>(<span class="params">volumeLevel</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">volumeController</span>.<span class="title function_">setVolume</span>(volumeLevel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AudioPlayerFacade</span></span><br></pre></td></tr></table></figure><p>怎么使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用外观模式控制音频播放</span></span><br><span class="line"><span class="comment">// 导入AudioPlayerFacade类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AudioPlayerFacade</span> <span class="keyword">from</span> <span class="string">&#x27;../AppearancePattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个AudioPlayerFacade的实例</span></span><br><span class="line"><span class="keyword">const</span> audioPlayerFacade = <span class="keyword">new</span> <span class="title class_">AudioPlayerFacade</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放音频文件&quot;music.mp3&quot;</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">playAudio</span>(<span class="string">&quot;music.mp3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停当前正在播放的音频</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">pauseAudio</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置音量为80%</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">setVolume</span>(<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止当前正在播放的音频</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">stopAudio</span>()</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>jQuery</strong></p><p> jQuery 是一个流行的 JavaScript 库，它简化了 DOM 操作和事件处理</p><p>通过使用 jQuery，开发人员可以使用简洁的语法来访问和操作 DOM 元素，从而隐藏了底层浏览器的差异性，这可以看作是一种外观模式的应用</p></li><li><p><strong>React</strong></p><p> React 是一个用于构建用户界面的 JavaScript 库，它采用了组件化的开发模式</p><p>在 React 中，每个组件都可以看作是一个外观，它封装了一部分 UI 和逻辑，并提供了一个简单的接口供其他组件使用</p></li><li><p><strong>Vue.js</strong></p><p> Vue.js 是另一个流行的 JavaScript 框架，也是基于组件化开发的</p><p>在 Vue.js 中，组件提供了一个简单的接口来封装复杂的 UI 和逻辑，从而降低了组件之间的耦合度，这也可以看作是一种外观模式的应用</p></li><li><p><strong>Bootstrap</strong>:</p><p>Bootstrap 是一个流行的前端框架，它提供了许多预定义的 UI 组件和样式，可以帮助开发人员快速构建具有统一外观和响应式设计的网站和应用程序</p></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/AppearancePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;外观模式（Facade Pattern）是一种结构型设计模式，旨在为复杂系统提供一个简单的接口&lt;/p&gt;
&lt;p&gt;它通过隐藏系统的复杂性，为客户</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《代理模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/54233691/"/>
    <id>https://wutiaowu5t5.github.io/posts/54233691/</id>
    <published>2024-03-22T07:24:24.000Z</published>
    <updated>2024-03-22T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>代理模式（Proxy Pattern）是一种结构型设计模式，它允许你创建一个代理对象，用来控制对另一个对象的访问</p><p><br/></p><p>代理模式通过引入一个代理对象来代替原始对象，实现了对原始对象的间接访问、控制或者增强</p><p>代理对象拥有与原始对象相同的接口，使得客户端无需知道代理对象的存在</p><p><br/></p><p>在代理模式中，存在两个关键角色：真实主题（Real Subject）和代理主题（Proxy Subject）</p><p>真实主题是客户端直接访问的对象，而代理主题是客户端通过代理间接访问真实主题的对象</p><p>通过代理模式，可以实现多种功能，比如：</p><ul><li><p><strong>远程代理（Remote Proxy）</strong></p><p>代理对象可以代表远程的对象，允许客户端通过代理对象访问远程的资源或服务，而无需了解远程对象的具体细节</p></li><li><p><strong>虚拟代理（Virtual Proxy）</strong></p><p>代理对象可以延迟加载真实对象，只有当客户端需要访问真实对象时才进行加载，从而提高系统的性能和资源利用率</p></li><li><p><strong>保护代理（Protective Proxy）</strong></p><p>代理对象可以控制对真实对象的访问权限，限制客户端对真实对象的直接访问，增强系统的安全性</p></li><li><p><strong>缓存代理（Cache Proxy）</strong></p><p>代理对象可以缓存真实对象的结果，当客户端再次请求相同的操作时，可以直接返回缓存的结果，减少重复计算，提高系统的性能</p></li></ul><p><br/></p><p>代理模式的核心思想是通过引入代理对象来控制对真实对象的访问，从而实现对真实对象的间接访问、控制或者增强</p><p>这种分离使得系统更加灵活，能够更好地应对需求变化，同时也提高了系统的安全性和性能</p><p><br/></p><p>举个简单的例子，考虑一个网络请求的程序</p><p>可以有不同类型的网络请求（如GET请求、POST请求等），也可以有不同的处理方式（如异步处理、同步处理等）</p><p>使用代理模式，可以将网络请求的类型和处理方式分离开来，使得可以很容易地添加新的网络请求类型或处理方式，而不需要修改已有的代码</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol><li><p><strong>目标对象</strong></p><p>代理模式需要有一个目标对象，它是需要被代理的对象</p><p>目标对象定义了要被代理的功能和行为</p></li><li><p><strong>代理对象</strong></p><p>代理对象是一个与目标对象具有相同接口的对象</p><p>代理对象在客户端和目标对象之间起到中间人的作用，通过拦截对目标对象的访问，可以对目标对象的行为进行控制、调整或增强</p></li><li><p><strong>一致的接口</strong></p><p>代理对象和目标对象通常应具有相同的接口</p><p>这意味着代理对象可以接受和处理客户端对目标对象的所有请求</p><p>客户端通过使用代理对象而不是直接使用目标对象，可以完全透明地调用目标对象的功能</p></li><li><p><strong>处理程序</strong></p><p>代理对象通常包含一个处理程序（handler），它定义了如何拦截并处理客户端对目标对象的请求</p><p>这可能包括操作前后的额外逻辑、权限控制、日志记录、数据验证等</p></li><li><p><strong>拦截机制</strong></p><p>代理对象需要能够拦截对目标对象的操作</p><p>这可以通过 JavaScript 中的 <code>Proxy</code> 对象来实现，<code>Proxy</code> 对象提供了一系列拦截器（如 <code>get</code>、<code>set</code>、<code>apply</code> 等）来处理属性访问和函数调用等操作</p></li><li><p><strong>透明性</strong></p><p>代理模式应保持对客户端的透明性，这意味着客户端不需要知道它正在与代理对象交互而不是目标对象</p><p>这使得客户端可以专注于业务逻辑而不必关心代理的细节</p></li><li><p><strong>控制访问和增强</strong></p><p>代理模式的核心是通过代理对象控制和增强对目标对象的访问</p><p>代理对象可以选择性地允许或拒绝客户端对目标对象的请求，或者在请求前后添加额外的逻辑</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>分离关注点</strong></p><p>代理模式使目标对象和客户端之间的逻辑分离</p><p>这可以使目标对象的实现更加专注于其核心功能，而代理负责其他方面的逻辑（例如，验证、权限控制、缓存、日志记录等）</p></li><li><p><strong>增强对象功能</strong></p><p>通过代理对象，可以在不修改目标对象的情况下增强其功能</p><p>例如，可以在目标对象的操作前后添加额外的行为</p></li><li><p><strong>控制访问</strong></p><p>代理模式可以控制对目标对象的访问</p><p>代理可以决定是否允许访问目标对象的特定功能，并在必要时进行权限验证或日志记录</p></li><li><p><strong>延迟初始化</strong></p><p>通过代理模式，可以将目标对象的初始化延迟到实际需要的时候</p><p>这有助于优化性能，避免不必要的资源消耗</p></li><li><p><strong>安全性</strong></p><p>代理模式可以用于提高系统的安全性</p><p>例如，通过代理对象，可以在调用目标对象的方法之前进行权限验证，确保只有授权的用户才能访问目标对象的功能</p></li><li><p><strong>透明性</strong></p><p>代理对象通常提供与目标对象相同的接口，因此客户端不需要了解目标对象是否被代理</p><p>这样，客户端的代码可以保持简单和一致</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>额外的复杂性</strong></p><p>引入代理对象可能会增加代码的复杂性，因为需要管理额外的对象和逻辑</p><p>特别是当代理对象和目标对象之间的逻辑较复杂时，这种复杂性会更明显</p></li><li><p><strong>性能开销</strong></p><p>代理模式可能引入一定的性能开销</p><p>例如，代理对象在执行操作时需要额外的拦截和逻辑处理，这可能会影响系统的性能</p></li><li><p><strong>调试难度</strong></p><p>由于代理对象在目标对象和客户端之间起到中间层的作用，这可能使调试变得更复杂，因为问题可能出现在代理对象、目标对象或二者之间的交互中</p></li><li><p><strong>维护难度</strong></p><p>代理模式可能导致代码维护难度增加，尤其是当代理对象和目标对象之间的逻辑复杂时</p><p>在设计代理对象时需要特别注意清晰的接口定义和职责划分</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>ES6 Proxy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义目标对象</span></span><br><span class="line"><span class="comment">// 目标对象是需要被代理的对象，包括属性和方法</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// greet 方法用于打印一个问候语</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处理程序对象</span></span><br><span class="line"><span class="comment">// 处理程序对象包含了代理对象的行为拦截逻辑</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 拦截对目标对象属性的读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27;`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.get 方法获取目标对象的属性值</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如权限控制、日志记录等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截对目标对象属性的设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; to &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.set 方法设置目标对象的属性值</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如数据验证、权限控制等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截对目标对象方法的调用操作</span></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling function with arguments: <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.apply 方法调用目标对象的方法</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如日志记录、权限控制等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Proxy 构造函数创建代理对象</span></span><br><span class="line"><span class="comment">// 参数为目标对象和处理程序对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问代理对象的 name 属性</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.get 拦截器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// 获取 name 属性，拦截器将打印日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理对象的 age 属性</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.set 拦截器</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 设置 age 属性，拦截器将打印日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理对象的 greet 方法</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.apply 拦截器</span></span><br><span class="line">proxy.<span class="title function_">greet</span>(); <span class="comment">// 调用 greet 方法，拦截器将打印日志</span></span><br></pre></td></tr></table></figure></li><li><p>Class</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target</span> = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截对目标对象的属性读取</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27;`</span>);</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">target</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">target</span>[property];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截对目标对象的属性设置</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; to &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;`</span>);</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">target</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">target</span>[property] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">methodName, ...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27; with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">const</span> method = <span class="variable language_">this</span>.<span class="property">target</span>[methodName];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> method === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理类来创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// 获取 name 属性，拦截器将打印日志</span></span><br><span class="line">handler.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>); <span class="comment">// 设置 age 属性，拦截器将打印日志</span></span><br><span class="line">handler.<span class="title function_">apply</span>(<span class="string">&#x27;greet&#x27;</span>); <span class="comment">// 调用 greet 方法，拦截器将打印日志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p></li></ol><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>Vue.js</strong></p><p>Vue 使用代理模式来实现数据绑定和响应式编程</p><p>Vue 创建了一个代理对象，通过代理对象监视数据的变化，然后根据变化自动更新 UI</p></li><li><p><strong>Redux 中的 Middleware</strong></p><p>虽然 Redux 本身是一个状态管理库，但在中间件（middleware）的设计中有使用代理模式</p><p>中间件可以拦截并调整 Redux 的动作，这样可以在动作被派发和状态更新之间添加额外的逻辑，如日志记录、异步请求等</p></li><li><p><strong>Node.js 的 HTTP 代理</strong></p><p>在 Node.js 中，开发人员可以使用库如 <code>http-proxy</code> 来创建 HTTP 代理</p><p>这个代理模式允许开发人员在客户端和服务器之间创建一个中间层，通过该层可以调整 HTTP 请求和响应</p><p>例如，可以修改请求头、缓存请求或将请求重定向到其他服务器</p></li><li><p><strong>GraphQL 中的 Resolvers</strong></p><p>在 GraphQL 中，Resolvers 是用于处理 GraphQL 查询的函数</p><p>通过代理模式，可以在查询结果返回客户端之前，对结果进行拦截和调整</p><p>例如，添加额外的数据处理、权限控制等</p></li><li><p><strong>Angular</strong></p><p>Angular 框架中的依赖注入系统使用了代理模式</p><p>通过拦截服务的创建和调用，Angular 可以实现服务的生命周期管理、配置和注入依赖等</p></li><li><p><strong>jQuery</strong></p><p>虽然 jQuery 不直接使用原生的 JavaScript <code>Proxy</code> 对象，但 jQuery 中的一些功能，例如事件代理（event delegation），与代理模式的理念相似</p><p>通过事件代理，jQuery 可以在父元素上监听事件，然后根据事件的目标元素来执行特定的处理</p></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/ProxyPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;代理模式（Proxy Pattern）是一种结构型设计模式，它允许你创建一个代理对象，用来控制对另一个对象的访问&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式 - 《装饰器模式》</title>
    <link href="https://wutiaowu5t5.github.io/posts/f51f74c/"/>
    <id>https://wutiaowu5t5.github.io/posts/f51f74c/</id>
    <published>2024-03-21T07:24:24.000Z</published>
    <updated>2024-03-21T07:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许动态地给一个对象添加一些额外的职责，而不需要通过继承来实现</p><p>装饰器模式通过引入一个装饰器类和具体组件类来实现这一点</p><p><br/></p><p>在装饰器模式中，通常存在四个核心角色：抽象组件（Component）、具体组件（Concrete Component）、抽象装饰器（Decorator）和具体装饰器（Concrete Decorator）</p><p>抽象组件定义了对象的基本行为，具体组件实现了抽象组件的行为，抽象装饰器继承了抽象组件，并持有一个抽象组件的引用，具体装饰器继承了抽象装饰器，并通过调用抽象组件的方法来增加额外的职责</p><p><br/></p><p>装饰器模式的核心思想是通过组合的方式来动态地给一个对象添加一些额外的职责，而不需要通过继承来修改原有的类结构</p><p>这种模式的优点在于，可以在不改变原有对象的情况下，动态地增加新的功能，从而提高了系统的灵活性和可维护性</p><p>装饰器模式适用于以下情况：</p><ol><li>需要动态地给一个对象添加一些额外的职责，而不希望通过继承来实现</li><li>需要在不影响其他对象的情况下，给一个对象添加一些额外的功能</li></ol><p><br/></p><p>举个简单的例子，考虑一个咖啡店</p><p>咖啡店提供基本的咖啡（具体组件），但是顾客可能需要在咖啡中加入额外的调料，比如牛奶、糖等</p><p>使用装饰器模式，可以通过装饰器来动态地给咖啡对象添加额外的调料功能，而不需要修改原有的咖啡类结构，从而实现了对咖啡对象的灵活扩展</p><p><br/></p><h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><p>要实现装饰器模式，通常需要以下条件：</p><ol><li><p>组件接口</p><p>一个定义了对象的基本功能的接口</p></li><li><p>具体组件</p><p>实现或继承自组件接口的类，它定义了基本功能</p></li><li><p>装饰器类</p><p>实现或继承自组件接口的类，它包含具体组件的实例，并添加新的功能</p></li></ol><p><br/></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p><strong>增加职责</strong></p><p>可以在不修改原始代码的情况下，向对象添加新的功能</p></li><li><p><strong>灵活性</strong></p><p>可以动态地添加或删除功能</p></li><li><p><strong>功能组合</strong></p><p>可以组合多个装饰器，创造出复杂的功能</p></li></ol><p><br/></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p><strong>复杂性</strong></p><p>使用大量装饰器会增加系统的复杂性</p></li><li><p><strong>维护难度</strong></p><p>过多的层次和装饰可能会使系统变得难以维护</p></li><li><p><strong>性能问题</strong></p><p>在某些情况下，过多的包装层可能会影响性能</p></li></ol><p><br/></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基本对象定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口（或者抽象类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;getCost()&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;getDescription()&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本咖啡类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰器类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="keyword">if</span> (!(coffee <span class="keyword">instanceof</span> <span class="title class_">CoffeeInterface</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Decorator requires a CoffeeInterface instance.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">coffee</span> = coffee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在基本对象上增加新东西的装饰器类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛奶装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">getCost</span>() + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.coffee.getDescription()&#125;</span>, Milk`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糖装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">getCost</span>() + <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.coffee.getDescription()&#125;</span>, Sugar`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用装饰器</span></span><br><span class="line"><span class="keyword">let</span> myCoffee = <span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>() <span class="comment">// 创建一个基本的咖啡对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line">myCoffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(myCoffee) <span class="comment">// 向咖啡中添加牛奶</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee, Milk</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：6</span></span><br><span class="line"></span><br><span class="line">myCoffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(myCoffee) <span class="comment">// 向咖啡中添加糖</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee, Milk, Sugar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：6.5</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>接口定义</strong></p><p><code>CoffeeInterface</code> 是一个抽象接口或类，定义了 <code>getCost()</code> 和 <code>getDescription()</code> 两个方法</p><p>这些方法代表了咖啡对象的基本功能，装饰器和基本对象都应该实现这个接口</p></li><li><p><strong>基本对象</strong></p><p><code>SimpleCoffee</code> 类是一个基本的咖啡对象，继承自 <code>CoffeeInterface</code>，并实现了 <code>getCost()</code> 和 <code>getDescription()</code> 方法</p><p>这个类代表了最基本的咖啡，没有任何额外的添加</p></li><li><p><strong>抽象装饰器类</strong></p><p><code>CoffeeDecorator</code> 是一个抽象装饰器类，继承自 <code>CoffeeInterface</code></p><p>它的构造函数接受一个 <code>CoffeeInterface</code> 类型的对象，并确保传入的对象符合该接口</p></li><li><p><strong>具体装饰器类</strong></p><p><code>MilkDecorator</code> 和 <code>SugarDecorator</code> 类继承自 <code>CoffeeDecorator</code>，分别代表牛奶和糖装饰器</p><p>它们在原始对象的基础上扩展了 <code>getCost()</code> 和 <code>getDescription()</code> 方法，添加了相应的功能</p></li><li><p><strong>组合装饰器</strong></p><p>装饰器模式允许将不同的装饰器组合在一起</p><p>通过在装饰器链中逐一应用装饰器，<code>myCoffee</code> 对象依次被 <code>MilkDecorator</code> 和 <code>SugarDecorator</code> 装饰，从而在原始 <code>SimpleCoffee</code> 对象上添加了牛奶和糖的功能</p></li></ol><p><br/></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><p><strong>React 高阶组件</strong></p><ul><li><strong>高阶组件</strong>（HOC，Higher-Order Component）是 React 中的一种模式，它类似于装饰器模式。高阶组件接受一个组件作为参数，并返回一个新的组件。这种方式可以用来增强组件的功能</li><li>例如，<code>react-redux</code> 中的 <code>connect</code> 函数就是一个高阶组件，它将组件与 Redux 的状态和派发函数相连接</li></ul></li><li><p><strong>Node.js 中的中间件</strong></p><ul><li>在 Node.js 中，特别是在 Web 框架（如 Express 和 Koa）中，中间件模式类似于装饰器模式。中间件通过将请求和响应对象传递给一系列函数，从而动态地添加或修改功能。</li><li>例如，在 Express 中，你可以使用中间件来对请求进行身份验证、解析数据、添加日志记录等</li></ul></li><li><p><strong>Python 装饰器</strong></p><ul><li><p>虽然 Python 不是 JavaScript，但其装饰器特性可以提供一个参考</p><p>Python 中的装饰器用于为函数或方法添加额外的行为</p><p>在 JavaScript 中，你可以通过闭包和高阶函数来模拟类似的效果</p></li></ul></li><li><p><strong>Angular 装饰器</strong></p><ul><li><p>Angular 框架使用装饰器</p><p>（如 <code>@Component</code>、<code>@Injectable</code> 等）来定义组件、服务、模块等</p><p>这些装饰器本质上是函数，用于为类添加元数据和功能</p></li></ul></li><li><p><strong>JavaScript 中的工具和库</strong></p><ul><li><p><strong>Lodash</strong> 和 <strong>underscore</strong> 等工具库提供了一些高阶函数</p><p>可以用于以装饰器的形式对函数进行封装，如 <code>_.debounce</code> 和 <code>_.throttle</code></p></li><li><p><strong>TypeScript 装饰器</strong></p><p>TypeScript 支持类和方法装饰器</p><p>它们可以用来为类或方法添加元数据或功能</p><p>虽然这在语法上不同于传统的装饰器模式，但它提供了类似的功能</p></li></ul></li></ol><p><br/></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/DecoratorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许动态地给一个对象添加一些额外的职责，而不需要通过继承来实现&lt;/p</summary>
      
    
    
    
    <category term="web" scheme="https://wutiaowu5t5.github.io/categories/web/"/>
    
    
    <category term="javascript" scheme="https://wutiaowu5t5.github.io/tags/javascript/"/>
    
    <category term="设计模式" scheme="https://wutiaowu5t5.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
