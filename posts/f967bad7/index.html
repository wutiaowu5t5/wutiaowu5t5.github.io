<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《React 面试题》 | Nanami Kento</title><meta name="author" content="Nanami Kento"><meta name="copyright" content="Nanami Kento"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念Q1：React Portals 有什么用难度：⭐  答案                               React Portals 是 React 提供的一种机制，用于将子组件渲染到父组件 DOM 层次结构之外的位置它在处理一些特殊情况下的 UI 布局或交互时非常有用以下是一些使用 React Portals 的常见情况：在模态框中使用 当你需要在应用的根 DOM 结构之外显示">
<meta property="og:type" content="article">
<meta property="og:title" content="《React 面试题》">
<meta property="og:url" content="https://wutiaowu5t5.github.io/posts/f967bad7/index.html">
<meta property="og:site_name" content="Nanami Kento">
<meta property="og:description" content="概念Q1：React Portals 有什么用难度：⭐  答案                               React Portals 是 React 提供的一种机制，用于将子组件渲染到父组件 DOM 层次结构之外的位置它在处理一些特殊情况下的 UI 布局或交互时非常有用以下是一些使用 React Portals 的常见情况：在模态框中使用 当你需要在应用的根 DOM 结构之外显示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg">
<meta property="article:published_time" content="2024-01-15T07:24:24.000Z">
<meta property="article:modified_time" content="2024-01-15T07:24:24.000Z">
<meta property="article:author" content="Nanami Kento">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg"><link rel="shortcut icon" href="/img/header.jpg"><link rel="canonical" href="https://wutiaowu5t5.github.io/posts/f967bad7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Nanami Kento","link":"链接: ","source":"来源: Nanami Kento","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《React 面试题》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 15:24:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 17
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/all.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Nanami Kento" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div id="loading-box-me"><div id="wrapper"><div id="mouse"></div><div class="loader"></div><div class="loading-bar-me"><div class="progress-bar"></div></div><div class="status"><div class="state"></div><div class="percentage"></div></div></div></div></div><script>const preloader = {
  endLoading: () => {
    var loadingBox = document.getElementById('loading-box');
    var loadingBoxme = document.getElementById('loading-box-me');
    loadingBoxme.addEventListener('animationend', () => {setTimeout(function() {loadingBox.classList.add("loaded");}, 2000) })
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  },
  otherendLoading: () => {
    document.getElementById('loading-box').classList.add("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.otherendLoading();},10000)

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.otherendLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Nanami Kento"><span class="site-name">Nanami Kento</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《React 面试题》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-15T07:24:24.000Z" title="发表于 2024-01-15 15:24:24">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T07:24:24.000Z" title="更新于 2024-01-15 15:24:24">2024-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>119分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《React 面试题》"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：React-Portals-有什么用"><a href="#Q1：React-Portals-有什么用" class="headerlink" title="Q1：React Portals 有什么用"></a>Q1：React Portals 有什么用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Portals 是 React 提供的一种机制，用于将子组件渲染到父组件 DOM 层次结构之外的位置</p><p>它在处理一些特殊情况下的 UI 布局或交互时非常有用</p><p>以下是一些使用 React Portals 的常见情况：</p><ol><li><p><strong>在模态框中使用</strong></p><p> 当你需要在应用的根 DOM 结构之外显示模态框（对话框）时，React Portals 可以帮助你将模态框的内容渲染到根 DOM 之外的地方，而不影响布局</p></li><li><p><strong>处理 z-index 问题</strong></p><p> 在一些复杂的布局中，可能存在 z-index 的层级关系导致组件无法按照预期的方式叠加显示</p><p>使用 React Portals 可以将组件渲染到具有更高 z-index 的容器中，以解决这些问题</p></li><li><p><strong>在全局位置显示组件</strong></p><p> 如果你希望某个组件在页面的固定位置显示，而不受父组件的定位影响，React Portals 可以将该组件渲染到 body 或其他容器中</p></li><li><p><strong>在动画中使用</strong> </p><p>当你需要在页面中的某个位置执行动画时，React Portals 可以帮助你将动画的内容渲染到离该位置更近的 DOM 结构中，以提高动画性能</p></li></ol><p><strong>基本使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">function MyPortalComponent() &#123;</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    // 子组件的内容</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      This is rendered using a portal!</span><br><span class="line">    &lt;/div&gt;,</span><br><span class="line">    // 渲染目标的 DOM 元素</span><br><span class="line">    document.getElementById(&#x27;portal-root&#x27;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在应用的根组件中渲染 MyPortalComponent</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;/* 此处的内容在正常的 DOM 结构中 */&#125;</span><br><span class="line">      &lt;p&gt;This is a normal component.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &#123;/* 使用 React Portals 渲染到 &#x27;portal-root&#x27; 元素外 */&#125;</span><br><span class="line">      &lt;MyPortalComponent /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：React18有哪些更新"><a href="#Q2：React18有哪些更新" class="headerlink" title="Q2：React18有哪些更新"></a>Q2：React18有哪些更新</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>并发模式（Concurrent Mode）</strong>:<br>并发模式是 React 的一个大型功能更新，它允许 React 在渲染时更好地管理优先级和资源</p><p>并发模式可以让 React 在长时间渲染的过程中保持应用的响应性，通过中断渲染工作和重新开始的能力，可以优化性能并减少延迟</p></li><li><p><strong>更新 render API</strong>:<br>React 18 中的新<code>render</code> AI 被设计来支持并发功能</p><p>换句话说，通过使用新的 <code>createRoot</code> API 替代 <code>ReactDOM.render</code>, 可以开启 React 应用的并发特性</p></li><li><p><strong>自动批处理（Automatic Batching）</strong>:<br>批处理是一种合并多个状态更新，以减少多余渲染次数的优化技术</p><p>在 React 18 中，所有的状态更新（无论它们源自事件处理、Promises、setTimeout等）都会自动批处理，而在以前，React 只会在合成事件和生命周期函数中自动批处理更新</p></li><li><p><strong>Suspense 支持 SSR（Suspense for Server Side Rendering）</strong>:<br>在 React 18 中，<code>Suspense</code> 组件得到了 SSR 的官方支持</p><p>这意味着你现在可以使用 <code>Suspense</code> 来延迟渲染组件的一部分，直到必要的数据加载完成，即便这个组件是在服务器端渲染的</p></li><li><p><strong>startTransition</strong>:<br><code>startTransition</code> 是一个调度一个不紧急更新的新方法</p><p>这可以告诉 React 某些更新可以延后执行，让用户不会感受到卡顿，并且保证更重要的更新（如输入）可以优先处理</p></li><li><p><strong>useTransition</strong>:<br><code>useTransition</code> 钩子允许你在组件中标记状态更新和组件转换</p><p>你可以使用它来通知 React，某些更新具有较低的优先级。它返回一个数组，其中第一个值是一个布尔值，指示低优先级更新是否正在发生，第二个值是 <code>startTransition</code> 的包装函数</p></li><li><p><strong>useDeferredValue</strong>:<br>这个钩子接受一个值，并返回一个延迟版本的该值</p><p>这对于保持大型列表或表格的响应性非常有用，即使在我们等待这些渲染数据时，用户仍然能够继续做其他操作，如输入</p></li><li><p><strong>useId</strong>:<br><code>useId</code> 是一个钩子，用来生成稳定、服务端和客户端都能保持同步的唯一标识符，这个功能主要解决在服务端渲染的应用中处理 ID 生成的问题</p></li><li><p><strong>提供给第三方库的 Hook</strong>:<br>React 18 引入了一些新的钩子，如 <code>useSyncExternalStore</code> 和 <code>useInsertionEffect</code> 等，专为第三方库设计，以便更好地集成并发模式和新特性</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li>并发模式</li><li>更新 render API</li><li>自动批处理</li><li>Suspense 支持 SSR</li><li>startTransition</li><li>useTransition</li><li>useDeferredValue</li><li>useId</li><li>提供给第三方库的 Hook</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：react-和-react-dom-是什么关系"><a href="#Q3：react-和-react-dom-是什么关系" class="headerlink" title="Q3：react 和 react-dom 是什么关系"></a>Q3：react 和 react-dom 是什么关系</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>react</code> 和 <code>react-dom</code> 是 React 库的两个主要部分，它们分别负责处理不同的事务</p><p>它们之间的关系可以理解为：</p><ol><li><p><strong><code>react</code></strong></p><p>这是 React 库的核心部分，包含了 React 的核心功能，如组件、状态、生命周期等</p><p>它提供了构建用户界面所需的基本构建块</p><p>当你编写 React 组件时，你实际上是在使用 <code>react</code> 包</p></li><li><p><strong><code>react-dom</code></strong> </p><p>这是 React 专门为 DOM 环境提供的包，它包含了与浏览器 DOM 相关的功能</p><p>react-dom<code>提供了用于在浏览器中渲染 React 组件的方法，包括</code>ReactDOM.render</p><p><code>在 Web 开发中，</code>react-dom` 被用于将 React 应用渲染到浏览器的 DOM 中</p></li></ol><p>基本上，<code>react</code> 和 <code>react-dom</code> 是为了分离 React 的核心功能，以便更好地处理不同的环境和平台</p><p>这种分离使得 React 更加灵活，可以适应不同的渲染目标，而不仅仅局限于浏览器环境。</p><p>在使用 React 开发 Web 应用时，通常会同时安装和引入这两个包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react react-dom</span><br></pre></td></tr></table></figure><p>然后在代码中引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>react</code> 库提供了 <code>App</code> 组件的定义，而 <code>react-dom</code> 库提供了 <code>ReactDOM.render</code> 方法，用于将组件渲染到 HTML 页面中</p><p>这种分工让 React 在不同平台上能够更灵活地适应各种渲染目标</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：为什么-react-需要-fiber-架构，而-Vue-却不需要"><a href="#Q4：为什么-react-需要-fiber-架构，而-Vue-却不需要" class="headerlink" title="Q4：为什么 react 需要 fiber 架构，而 Vue 却不需要"></a>Q4：为什么 react 需要 fiber 架构，而 Vue 却不需要</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 和 Vue 都是现代前端开发中非常流行的库/框架，它们以不同的方式实现更新和渲染机制，以提供高效且响应式的用户界面</p><p>React 的 Fiber 架构和 Vue 的响应式系统设计理念在解决特定问题和优化渲染机制上有着各自的目标和策略</p><p>下面，我们来探讨为什么 React 需要引入 Fiber 架构，而 Vue 没有采用类似的方案。</p><ol><li><p>React 的 Fiber 架构</p><p>Fiber 架构是 React 16 中引入的一个重大更新，旨在解决大型应用的性能问题以及一些与异步渲染相关的挑战</p><p>Fiber 架构的关键目标包括：</p><ul><li><p><strong>增强组件的渲染和更新性能：</strong></p><p>通过实现任务的分割和优先级调度，Fiber 架构使得 React 能够暂停、中断、恢复和重用渲染工作</p><p>这对于提高复杂应用的性能，特别是在动画、布局和手势等需要快速响应的场景中，非常关键</p></li><li><p><strong>提升应用的响应性：</strong></p><p>通过引入异步渲染能力，React 可以在长时间的渲染任务中更好地控制主线程，避免界面卡顿，从而保持应用流畅并快速响应用户输入</p></li><li><p><strong>更灵活的架构：</strong></p><p>Fiber 架构给 React 带来了更多的可能性，如并发模式、Suspense 等，这些特性进一步提升了开发体验和用户体验</p></li></ul></li><li><p>Vue 的响应式系统</p><p>与此同时，Vue 采用的是响应式系统，Vue 3 中的响应式系统通过 Proxy 对象重写，该机制允许 Vue 检测到任何嵌套属性的变化，从而实现更为精准和高效的更新</p><p>Vue 的核心目标包括：</p><ul><li><p><strong>简洁的 API 和易于上手：</strong></p><p>Vue 重视开发体验，并致力于提供简单且强大的模板语法和计算属性，让开发者快速构建高效的应用</p></li><li><p><strong>细粒度的更新机制：</strong></p><p>Vue 的响应式系统能够精确地追踪依赖变化，保证只有相关的组件会重新渲染，从而提高性能</p></li><li><p><strong>优化的打包大小和运行性能：</strong></p><p>Vue 3 引入 Composition API，促进了代码的组织性，同时也使得 Vue 的核心更轻量，提升了运行时性能</p></li></ul></li></ol><p><strong>为什么 React 需要 Fiber，而 Vue 不需要？</strong></p><ul><li><p><strong>不同的更新策略和焦点：</strong></p><p>React 的 Fiber 架构主要解决的是长时间的、阻塞式更新所带来的性能问题，以及实现异步渲染的能力</p><p>而 Vue 通过其响应式系统和细粒度的更新机制，关注的是依赖追踪和高效的组件更新</p></li><li><p><strong>核心设计理念的差异：</strong></p><p>React 通过 JSX 和组件树构建应用，强调组件的状态管理和更新</p><p>Vue 则侧重于模板和响应式数据绑定，提供一种更直观的开发方式</p><p>这些核心的设计理念导致了它们在技术实现和优化方向上的不同选择</p></li></ul><p>总的来说，React 的 Fiber 架构和 Vue 的响应式系统分别体现了这两个框架针对性能优化和开发体验的不同策略和重点。每种方式都有其适用的场景和优点，而选择使用哪一个往往取决于项目的需求、团队的熟悉度以及个人偏好。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：JSX是什么，它和JS有什么区别"><a href="#Q5：JSX是什么，它和JS有什么区别" class="headerlink" title="Q5：JSX是什么，它和JS有什么区别"></a>Q5：JSX是什么，它和JS有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JSX（JavaScript XML）是 JavaScript 的一个语法扩展，最常用于 React 组件中描述 UI 结构</p><p>JSX 使得你可以在 JavaScript 代码中写类似于 HTML 的标记，从而创建 React 元素</p><p>虽然 JSX 在视觉上看起来与 HTML 相似，但它在底层完全是 JavaScript</p><p>当编译这些 JSX 代码时（通常是使用 Babel 这样的转译器），它们会被转换成 <code>React.createElement</code> 调用</p><p>以下是一些主要的区别：</p><ol><li><p><strong>语法形式</strong></p><p>JSX 是一种混合的语法，允许 HTML 和 JavaScript 混合编写</p><p>而在纯 JavaScript 中，你需要显式地通过 JavaScript 方法来创建和操作 DOM</p></li><li><p><strong>执行环境</strong></p><p>在浏览器中直接运行纯 JS 没有问题，但 JSX 代码需要先经过转译，才能被浏览器理解</p></li><li><p><strong>表达能力</strong></p><p>JSX 提供了一种更加声明式的方式来描述 UI 组件的结构和呈现逻辑，而不是在 JavaScript 中手动地创建和管理 DOM 元素</p></li></ol><p>JSX代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>它转换为以下JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：为什么在本地开发时，组件会渲染两次"><a href="#Q6：为什么在本地开发时，组件会渲染两次" class="headerlink" title="Q6：为什么在本地开发时，组件会渲染两次"></a>Q6：为什么在本地开发时，组件会渲染两次</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 严格模式会在开发环境中触发一些额外的检查和警告，以帮助开发者发现潜在的问题</p><p>具体来说，严格模式会在以下情况下触发组件的额外渲染：</p><ol><li><p><strong>识别副作用</strong></p><p>React 会在严格模式下对某些生命周期方法和 Hooks 进行双重调用，以便更容易地发现副作用</p><p>例如，<code>useEffect</code> 中的副作用会被调用两次，以确保副作用是幂等的（即多次调用不会产生不同的结果）</p></li><li><p><strong>检测不安全的生命周期方法</strong></p><p>严格模式会检测一些不安全的生命周期方法，如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code>，并给出警告</p></li><li><p><strong>确保一致性</strong></p><p>通过双重调用构造函数、渲染方法和某些生命周期方法，React 可以确保组件在不同环境下的一致性</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>如何确认是否是严格模式引起的</strong></p><p>你可以检查你的代码是否使用了严格模式</p><p>严格模式通常通过 <code>&lt;React.StrictMode&gt;</code> 包裹你的应用根组件来启用，如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>如何避免双重渲染</strong></p><p>严格模式的双重渲染仅在开发环境中启用，并不会影响生产环境</p><p>因此，通常不需要担心这种行为在生产环境中会带来性能问题</p><p>如果你确实需要在开发过程中避免双重渲染（例如，为了调试某些特定问题），你可以暂时移除 <code>&lt;React.StrictMode&gt;</code> 包裹，但请注意，这只是一个临时解决方案，不建议长期使用，因为严格模式提供了许多有价值的检查和警告</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：虚拟-dom-有什么优点？真实-dom-和虚拟-dom，谁快"><a href="#Q7：虚拟-dom-有什么优点？真实-dom-和虚拟-dom，谁快" class="headerlink" title="Q7：虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快"></a>Q7：虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>虚拟DOM（Virtual DOM）是一个编程概念，其中UI的表示形式保留在内存中，并与“实际”的DOM（Document Object Model）同步</p><p>这个过程称为调和(reconciliation)</p><p>虚拟DOM提供几个关键优点：</p><ol><li><p>高效的更新</p><p>虚拟DOM可以快速的在内存中重新渲染UI，因为它不立即操作真实的DOM</p><p>只有当虚拟DOM和真实DOM之间的差异计算完成后，真实DOM的必要部分才会更新，从而减少了直接操作真实DOM的次数</p></li><li><p>批量更新和最小化DOM操作</p><p>操作真实DOM相比操作JavaScript对象要慢得多</p><p>虚拟DOM使React能够批量更新，将多个更改放在一起，然后一次性将它们应用到真实DOM上，从而最小化DOM操作次数</p></li><li><p>抽象层</p><p>虚拟DOM作为一个抽象层，使得开发者不需要直接与DOM交互，简化了编程模型并提高了UI更新的效率和性能</p></li><li><p>跨平台</p><p>虚拟DOM不仅可以工作在浏览器环境，也可以用在其他环境（如服务器端渲染SSR、原生移动应用React Native）上，因为它是独立的</p></li></ol><p><strong>真实DOM与虚拟DOM比较</strong></p><ol><li><p>真实DOM：</p><ul><li><p>直接操作真实DOM会导致浏览器频繁重绘界面和回流，消耗性能较大</p></li><li><p>DOM操作是破坏性的，简单的更新操作可能会引发整个子树的重新渲染</p></li></ul></li><li><p>虚拟DOM：</p><ul><li><p>更新是在JavaScript内存中进行的，消耗较低</p></li><li><p>React等框架会智能计算出最小的DOM操作次数，仅修改需要更新的部分</p></li></ul></li></ol><p>所以在多数情况下，虚拟DOM都会比真实DOM更快，因为它减少了昂贵的DOM操作并在必要时才进行批处理更新</p><p>但是需要注意的是，在某些简单的操作或者超小的DOM结构的情况下，直接操作真实DOM可能会更快，因为引入虚拟DOM涉及到的差异比对(Diffing)算法和更新计划也有一定代价</p><p>总的来说，虚拟DOM并不是在所有情况下都绝对“快过”真实DOM</p><p>它的优势在于，对于大型和复杂的应用，它可以通过智能的更新策略大幅度提高效率</p><p>真实DOM的优势在于简单场景下的快速响应和直观操作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：什么是合成事件，与原生事件有什么区别"><a href="#Q8：什么是合成事件，与原生事件有什么区别" class="headerlink" title="Q8：什么是合成事件，与原生事件有什么区别"></a>Q8：什么是合成事件，与原生事件有什么区别</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，事件处理机制是通过合成事件（Synthetic Events）实现的</p><p>理解合成事件与原生事件之间的区别对开发 React 应用程序非常重要</p><p><strong>合成事件（Synthetic Events）</strong></p><p>合成事件是 React 实现的一种跨浏览器的事件系统，它封装了浏览器的原生事件，提供了一致的 API</p><p>React 使用合成事件来确保在不同浏览器中具有相同的行为</p><p><strong>合成事件与原生事件的区别</strong></p><ol><li><p><strong>跨浏览器兼容性</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 通过合成事件提供了一个跨浏览器的事件系统，确保在不同浏览器中具有一致的行为</p></li><li><p><strong>原生事件</strong></p><p>浏览器的原生事件在不同浏览器中可能会有不同的行为和 API</p></li></ul></li><li><p><strong>事件委托</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 使用事件委托（Event Delegation）模式，将所有的事件处理器都绑定到根元素上（如 <code>document</code> 或 <code>root</code> 元素）</p><p>当事件触发时，React 会通过事件冒泡机制找到相应的组件并调用其事件处理器</p></li><li><p><strong>原生事件</strong></p><p>原生事件处理器通常直接绑定到具体的 DOM 元素上</p></li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>由于事件处理器是绑定在根元素上的，React 可以通过事件委托减少内存消耗和提高性能，尤其是在有大量事件处理器的情况下</p></li><li><p><strong>原生事件</strong></p><p>直接绑定在具体 DOM 元素上的事件处理器，可能会在有大量事件处理器时导致性能问题</p></li></ul></li><li><p><strong>事件对象</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 提供的事件对象是 <code>SyntheticEvent</code>，它是对原生事件对象的封装</p><p><code>SyntheticEvent</code> 提供了一致的接口，并且在事件处理后会被回收以提高性能</p></li><li><p><strong>原生事件</strong></p><p>浏览器提供的事件对象，接口在不同浏览器中可能会有所不同</p></li></ul></li></ol><p><strong>示例：合成事件和原生事件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个合成事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent:&#x27;</span>, event);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent type:&#x27;</span>, event.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原生事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;NativeEvent:&#x27;</span>, event.<span class="property">nativeEvent</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;NativeEvent type:&#x27;</span>, event.<span class="property">nativeEvent</span>.<span class="property">type</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中，当按钮被点击时，<code>handleClick</code> 方法会被调用：</p><ol><li><code>event</code> 是一个合成事件对象 (<code>SyntheticEvent</code>)</li><li><code>event.nativeEvent</code> 是原生事件对象</li></ol><p><strong>主要特性</strong></p><ol><li><p><strong>自动清理</strong></p><p>合成事件对象会在事件处理函数执行完毕后被清理，以提高性能</p><p>这意味着你不能异步访问合成事件对象的属性</p><p>如果需要异步访问，可以调用 <code>event.persist()</code> 方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">persist</span>(); <span class="comment">// 防止事件对象被回收</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent:&#x27;</span>, event);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>一致性</strong></p><p>合成事件提供了一致的 API，解决了不同浏览器之间的差异。</p></li></ol><p><strong>总结</strong></p><ul><li><strong>合成事件</strong> 是 React 提供的一种跨浏览器的事件系统，封装了原生事件，提供了一致的 API，并通过事件委托提高性能</li><li><strong>原生事件</strong> 是浏览器提供的事件系统，不同浏览器可能存在差异，事件处理器通常直接绑定在具体的 DOM 元素上</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：数据如何在React组件中流动"><a href="#Q9：数据如何在React组件中流动" class="headerlink" title="Q9：数据如何在React组件中流动"></a>Q9：数据如何在React组件中流动</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>React组件通信</strong></p><p><strong>react组件通信方式有哪些</strong></p><p>组件通信的方式有很多种，可以分为以下几种：</p><ol><li>父组件向子组件通信</li><li>子组件向父组件通信</li><li>兄弟组件通信</li><li>父组件向后代组件通信</li><li>无关组件通信</li></ol><p><strong>父组件向子组件通信</strong></p><ul><li><strong>props传递</strong>，利用React单向数据流的思想，通过props传递</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;props.name&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span>	</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Parent</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;我是儿子&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>子组件向父组件通信</strong></p><ul><li><strong>回调函数</strong></li></ul><p>父组件向子组件传递一个函数，通过函数回调，拿到子组件传过来的值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">price</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getPrice</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">price</span>:val</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span>&gt;</span>价格:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;this.state.price&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">getPrice</span>=<span class="string">&#123;this.getPrice.bind(this)&#125;/</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">getItemPrice</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getPrice</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getItemPrice.bind(this)&#125;</span>&gt;</span>廓形大衣<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getItemPrice.bind(this)</span>&gt;</span>牛仔裤<span class="tag">&lt;/<span class="name">button</span>&gt;</span>	</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>	</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>事件冒泡</strong></li></ul><p>点击子组件的button按钮，事件会冒泡到父组件上</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码<span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">sayName</span> = name =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> sayName(&#x27;lyllovelemon&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Ref</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span>=<span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="title function_">changeVal</span>(<span class="string">&#x27;lyllovelemon&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">changeVal</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>兄弟组件通信</strong></p><p>实际上就是通过父组件中转数据的，子组件a传递给父组件，父组件再传递给子组件b</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildOne</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildTwo</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父组件向后代组件通信</strong></p><p><strong>Context</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PriceContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&quot;price&quot;</span>) </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">PriceContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;200&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">PriceContext</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="title class_">PriceContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">        &#123; <span class="function"><span class="params">price</span>=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>price:&#123;price&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &#125;</span><br><span class="line">      &lt;/<span class="title class_">PriceContext</span>.<span class="property">Consumner</span>&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HOC</strong></p><p><strong>Redux</strong></p><p>ref，useRef，forwardRef，useImperativeHandle</p><p>作者：lyllovelemon<br>链接：<a href="https://juejin.cn/post/7182382408807743548">https://juejin.cn/post/7182382408807743548</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：fiber架构"><a href="#Q10：fiber架构" class="headerlink" title="Q10：fiber架构"></a>Q10：fiber架构</h3><p>难度：⭐⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是fiber，fiber解决了什么问题</strong></p><p>在React16以前，React更新是通过<strong>树的深度优先遍历</strong>完成的，遍历是不能中断的，当树的层级深就会产生栈的层级过深，页面渲染速度变慢的问题，为了解决这个问题引入了fiber，React fiber就是虚拟DOM，它是一个链表结构，返回了return、children、siblings，分别代表父fiber，子fiber和兄弟fiber，随时可中断</p><p><strong>Fiber是纤程，比线程更精细，表示对渲染线程实现更精细的控制</strong></p><p><strong>应用目的</strong><br> 实现增量渲染，增量渲染指的是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里。增量渲染是为了实现任务的可中断、可恢复，并按优先级处理任务，从而达到更顺滑的用户体验</p><p><strong>Fiber的可中断、可恢复怎么实现的</strong></p><p><strong><em>fiber</em></strong>是协程，是比线程更小的单元，可以被人为中断和恢复，当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务</p><p>fiber是一个链表结构，它有三个指针，分别记录了当前节点的下一个兄弟节点，子节点，父节点。当遍历中断时，它是可以恢复的，只需要保留当前节点的索引，就能根据索引找到对应的节点</p><p><strong>Fiber更新机制</strong></p><p><strong>初始化</strong></p><ol><li>创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)</li><li>进入beginWork</li></ol><p><strong>workInProgress</strong>:正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树</p><p><strong>current</strong>:正在视图层渲染的树叫current fiber树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> = workInProgressFiber</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> = currentFiber</span><br></pre></td></tr></table></figure><ol><li>深度调和子节点，渲染视图</li></ol><p>在新建的alternate树上，完成整个子节点的遍历，包括fiber的创建，最后会以workInProgress树最为最新的渲染树，fiberRoot的current指针指向workInProgress使其变成current fiber，完成初始化流程</p><p><strong>更新</strong></p><ol><li>重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress</li></ol><p>渲染完成后，workInProgress树又变成current树</p><p><strong>双缓冲模式</strong></p><p>话剧演出中，演员需要切换不同的场景，以一个一小时话剧来说，在舞台中切换场景，时间来不及。一般是准备两个舞台，切换场景从左边舞台到右边舞台演出</p><p>在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉的抖动甚至卡顿。</p><p>react的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗</p><p><strong>React渲染流程</strong></p><p>如图，React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。vdom转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d05402136ac44f87971d9f0b89466911~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=992&amp;h=408&amp;s=19711&amp;e=jpg&amp;b=faf4e7" alt="img"></p><p>vdom（React Element对象）中只记录了子节点，没有记录兄弟节点，因此渲染不可打断</p><p>fiber（fiberNode对象）是一个链表，它记录了父节点、兄弟节点、子节点，因此是可以打断的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：React的设计思想"><a href="#Q11：React的设计思想" class="headerlink" title="Q11：React的设计思想"></a>Q11：React的设计思想</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>组件化</strong></p><p>每个组件都符合开放-封闭原则，封闭是针对渲染工作流来说的</p><p>指的是组件内部的状态都由自身维护，只处理内部的渲染逻辑</p><p>开放是针对组件通信来说的，指的是不同组件可以通过props（单项数据流）进行数据交互</p></li><li><p><strong>数据驱动视图</strong></p><p>UI=f(data)</p><p>通过上面这个公式得出，如果要渲染界面，不应该直接操作DOM，而是通过修改数据(state或prop)，数据驱动视图更新</p></li><li><p><strong>虚拟DOM</strong></p><p>由浏览器的渲染流水线可知，DOM操作是一个昂贵的操作，很耗性能，因此产生了虚拟DOM。虚拟DOM是对真实DOM的映射，React通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新</p></li></ol><p><a href="https://juejin.cn/post/7007214462813863950">React设计模式</a></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：类组件和函数式组件有何不同"><a href="#Q12：类组件和函数式组件有何不同" class="headerlink" title="Q12：类组件和函数式组件有何不同"></a>Q12：类组件和函数式组件有何不同</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>类组件（Class Components）和函数式组件（Function Components）是 React 中定义组件的两种主要方式</p><p>它们各有特点和适用场景</p><p>以下是它们的主要不同点：</p><ol><li><p>定义方式</p><ul><li><p>类组件</p><p>类组件使用 ES6 类语法，并继承自 <code>React.Component</code></p><p>它们需要定义一个 <code>render</code> 方法来返回 JSX</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello from Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyClassComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件是 JavaScript 函数，它们直接返回 JSX</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello from Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyFunctionComponent</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>状态管理</p><ul><li><p>类组件</p><p>类组件使用 <code>this.state</code> 来管理状态，并通过 <code>this.setState</code> 更新状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件使用 React Hooks（如 <code>useState</code>）来管理状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>生命周期方法</p><ul><li><p>类组件</p><p>类组件有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>，用于在组件的不同阶段执行代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件使用 <code>useEffect</code> Hook 来处理副作用，相当于组合了 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted or updated&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组作为依赖项，表示只在挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>性能优化</p><ul><li><p>类组件</p><p>类组件可以使用 <code>shouldComponentUpdate</code> 方法或 <code>PureComponent</code> 来优化性能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件可以使用 <code>React.memo</code> 来优化性能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyFunctionComponent</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可读性和简洁性</p><p>函数式组件通常更简洁、更易读，尤其是在使用 Hooks 后</p><p>它们更接近于纯函数的概念，使得代码更容易理解和测试</p></li></ol><p><strong>总结</strong></p><ul><li><strong>类组件</strong>：适合需要使用生命周期方法和复杂状态管理的场景</li><li><strong>函数式组件</strong>：更简洁，推荐用于大多数场景，特别是在引入 Hooks 之后</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：mobx和-redux-有什么区别"><a href="#Q13：mobx和-redux-有什么区别" class="headerlink" title="Q13：mobx和 redux 有什么区别"></a>Q13：mobx和 redux 有什么区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>设计理念</p><ul><li><p><strong>Redux</strong></p><ul><li><p><strong>单一状态树</strong>：Redux 使用单一的全局状态树来管理应用状态，这意味着所有的状态都存储在一个对象中</p></li><li><p><strong>不可变性</strong>：Redux 强调状态的不可变性，每次状态更新都会返回一个新的状态对象，而不是直接修改原有状态</p></li><li><p><strong>纯函数</strong>：Redux 的状态更新逻辑是通过纯函数（reducers）来实现的，这些函数接收当前状态和动作（action），然后返回新的状态</p></li><li><p><strong>可预测性</strong>：由于使用纯函数和不可变状态，Redux 的状态管理非常可预测和可调试</p></li></ul></li><li><p><strong>MobX</strong></p><ul><li><p><strong>多状态树</strong>：MobX 允许使用多个状态树（observables）来管理应用状态，可以根据需要将状态分散在不同的对象中</p></li><li><p><strong>可变性</strong>：MobX 允许直接修改状态对象，更新状态时不需要返回新的状态对象，状态变化是自动追踪和响应的</p></li><li><p><strong>响应式编程</strong>：MobX 采用响应式编程模型，通过观察（observables）和反应（reactions）来自动追踪和响应状态变化</p></li><li><p><strong>简洁性</strong>：MobX 的 API 和使用方式更简洁，适合快速开发和迭代</p></li></ul></li></ul></li><li><p>使用方式</p><ul><li><p><strong>Redux</strong></p><ol><li><strong>定义状态和动作</strong>：<ul><li>使用 <code>createStore</code> 创建全局状态树</li><li>定义动作类型（action types）和动作创建器（action creators）</li></ul></li><li><strong>定义 reducer</strong>：<ul><li>使用纯函数定义 reducer，根据动作类型返回新的状态</li></ul></li><li><strong>连接组件</strong>：<ul><li>使用 <code>connect</code> 高阶组件将 Redux 状态和动作绑定到 React 组件</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = initialState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params">&#123; count, increment &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">count</span>: state.<span class="property">count</span> &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, &#123; increment &#125;)(<span class="title class_">Counter</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>MobX</strong></p><ol><li><strong>定义状态和动作</strong>：<ul><li>使用 <code>observable</code> 定义状态</li><li>使用 <code>action</code> 定义状态更新逻辑</li></ul></li><li><strong>观察状态</strong>：<ul><li>使用 <code>observer</code> 高阶组件将 MobX 状态绑定到 React 组件</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterStore</span> &#123;</span><br><span class="line">  @observable count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  @action increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="keyword">new</span> <span class="title class_">CounterStore</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterStore <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="title function_">observer</span>(<span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;counterStore.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counterStore.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特性对比</p><ul><li><strong>状态管理方式</strong>：<ul><li>Redux：单一状态树，不可变状态，纯函数</li><li>MobX：多状态树，可变状态，响应式编程</li></ul></li><li><strong>学习曲线</strong>：<ul><li>Redux：相对较陡，需要理解不可变性、纯函数和中间件等概念</li><li>MobX：相对较平缓，更加直观和简洁</li></ul></li><li><strong>生态系统和社区</strong>：<ul><li>Redux：有一个庞大的生态系统和活跃的社区，提供了丰富的中间件和工具</li><li>MobX：社区和生态系统相对较小，但也有一些有用的工具和扩展</li></ul></li><li><strong>可调试性</strong>：<ul><li><strong>Redux</strong>：由于状态不可变和使用纯函数，Redux 的状态变化是可预测的，配合 Redux DevTools 等工具，可以方便地进行状态跟踪和时间旅行调试（time-travel debugging）</li><li><strong>MobX</strong>：MobX 的状态变化是响应式的，虽然也有调试工具（如 MobX DevTools），但由于状态是可变的，调试和跟踪状态变化可能没有 Redux 那么直观</li></ul></li><li><strong>性能</strong>：<ul><li><strong>Redux</strong>：由于状态变化需要通过纯函数和不可变对象，Redux 在处理大规模状态更新时可能会有性能开销，特别是在深层嵌套的状态结构中</li><li><strong>MobX</strong>：MobX 通过响应式编程和细粒度的观察机制，可以高效地追踪和响应状态变化，避免了不必要的重新渲染，性能通常较好</li></ul></li><li><strong>代码组织</strong>：<ul><li><strong>Redux</strong>：Redux 通常需要将状态、动作和 reducer 分开组织，代码结构相对清晰，但在大型应用中可能会导致样板代码（boilerplate）较多</li><li><strong>MobX</strong>：MobX 的代码组织更灵活，可以将状态和动作集中在一个类中，代码量通常较少，开发体验更加简洁</li></ul></li><li><strong>中间件和扩展</strong>：<ul><li><strong>Redux</strong>：Redux 有丰富的中间件（如 redux-thunk、redux-saga）和扩展工具，可以方便地处理异步操作和复杂的状态逻辑</li><li><strong>MobX</strong>：MobX 本身不需要中间件来处理异步操作，可以直接在 action 中使用异步函数，扩展性相对简单</li></ul></li></ul></li></ol><p><strong>选择指南</strong></p><ul><li><strong>选择 Redux</strong>：如果你的应用需要严格的状态管理、可预测性和强大的调试工具，特别是在团队协作和大型项目中，Redux 是一个不错的选择</li><li><strong>选择 MobX</strong>：如果你更倾向于简洁的代码、快速开发和响应式编程，MobX 可能更适合你，特别是在中小型项目或快速迭代的开发环境中</li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="Q1：简述React的生命周期"><a href="#Q1：简述React的生命周期" class="headerlink" title="Q1：简述React的生命周期"></a>Q1：简述React的生命周期</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，生命周期方法是指在组件的不同阶段（如挂载、更新和卸载）执行的特定方法。对于函数式组件，我们主要依赖于 Hooks 来管理这些生命周期事件。以下是 React 组件的生命周期阶段及其对应的 Hooks。</p><ol><li><p>挂载（Mounting）</p><p>当组件首次插入到 DOM 中时，会经历以下阶段：</p><ul><li><p><strong>构造函数（Constructor）</strong>：</p><ul><li>仅适用于类组件，用于初始化状态和绑定事件处理函数</li></ul></li><li><p><strong><code>getDerivedStateFromProps</code></strong>：</p><ul><li>适用于类组件，用于在渲染前更新状态</li></ul></li><li><p><strong><code>render</code></strong>：</p><ul><li>类组件和函数组件都会执行此方法，用于返回要渲染的元素</li></ul></li><li><p><strong><code>componentDidMount</code></strong>：</p><ul><li>类组件特有的方法，在组件挂载后立即调用</li><li>对应的 Hook：<code>useEffect</code>，可以通过传递空数组 <code>[]</code> 作为第二个参数来模拟 <code>componentDidMount</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件挂载后的逻辑</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>更新（Updating）</p><p>组件的状态或属性发生变化时，会经历以下阶段：</p><ul><li><p><strong><code>getDerivedStateFromProps</code></strong>：</p><ul><li>类组件特有的方法，用于在渲染前更新状态</li></ul></li><li><p><strong><code>shouldComponentUpdate</code></strong>：</p><ul><li>类组件特有的方法，用于控制组件是否需要重新渲染</li></ul></li><li><p><strong><code>render</code></strong>：</p><ul><li>类组件和函数组件都会执行此方法，用于返回要渲染的元素</li></ul></li><li><p><strong><code>getSnapshotBeforeUpdate</code></strong>：</p><ul><li>类组件特有的方法，用于在更新前获取一些信息</li></ul></li><li><p><strong><code>componentDidUpdate</code></strong>：</p><ul><li>类组件特有的方法，在组件更新后立即调用</li><li>对应的 Hook：<code>useEffect</code>，可以通过传递依赖数组来模拟 <code>componentDidUpdate</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件更新后的逻辑</span></span><br><span class="line">&#125;, [依赖项]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>卸载（Unmounting）</p><p>组件从 DOM 中移除时，会经历以下阶段：</p><ul><li><p><strong><code>componentWillUnmount</code></strong>：</p><ul><li>类组件特有的方法，用于在组件卸载前执行清理操作</li><li>对应的 Hook：<code>useEffect</code>，可以通过返回一个清理函数来模拟 <code>componentWillUnmount</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件卸载前的清理逻辑</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误处理（Error Handling）</p><p>当组件渲染过程中发生错误时，会经历以下阶段：</p><ul><li><code>componentDidCatch</code>：<ul><li>类组件特有的方法，用于捕获错误并处理</li><li>对应的 Hook：<code>useErrorBoundary</code>（在一些第三方库中提供）</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：并发模式是如何执行的"><a href="#Q2：并发模式是如何执行的" class="headerlink" title="Q2：并发模式是如何执行的"></a>Q2：并发模式是如何执行的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>并发模式是什么</strong></p><p>并发模式是React 18引入的一组新特性，用于使React能够更高效地处理大量更新，并提供更流畅的用户体验</p><p>并发模式允许React在不阻塞主线程的情况下执行渲染工作，从而使应用程序能够更好地响应用户交互</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 中的<code>并发</code>，并不是指同一时刻同时在做多件事情</p><p>因为 js 本身就是单线程的（同一时间只能执行一件事情），而且还要跟 UI 渲染竞争主线程</p><p>若一个很耗时的任务占据了线程，那么后续的执行内容都会被阻塞</p><p>为了避免这种情况，React 就利用 fiber 结构和时间切片的机制，将一个大任务分解成多个小任务，然后按照任务的优先级和线程的占用情况，对任务进行调度</p><p><strong>执行方式</strong></p><ol><li><p><strong>时间切片（Time Slicing）</strong></p><ul><li><p>React可以将渲染工作分成多个小的任务，并在任务之间进行切换</p><p>这使得React可以在处理昂贵的渲染工作时，仍然能够响应用户输入和其他高优先级的任务</p></li><li><p>例如，React可能会暂停一个低优先级的渲染任务，以便处理一个高优先级的用户输入事件</p></li></ul></li><li><p><strong>优先级调度（Priority Scheduling）</strong></p><ul><li><p>React会根据任务的重要性来分配优先级</p><p>高优先级的任务（如用户输入）会被优先处理，而低优先级的任务（如数据加载后的渲染）会被延后处理</p></li><li><p>这确保了用户的交互可以得到及时响应，而不必等待所有渲染工作完成</p></li></ul></li><li><p><strong>可中断渲染（Interruptible Rendering）</strong></p><ul><li><p>在并发模式下，React的渲染过程是可中断的</p><p>如果有更高优先级的任务需要处理，React可以暂停当前的渲染任务，处理完高优先级任务后再继续未完成的渲染任务</p></li></ul></li><li><p><strong>Suspense</strong></p><ul><li><p><code>Suspense</code>是并发模式中的一个重要特性，它允许组件在等待异步数据时显示备用内容（如加载指示器）</p><p>当异步数据加载完成后，React会自动更新组件</p></li><li><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>启用方式</strong></p><p>在React 18中，可以通过使用新的<code>createRoot</code> API来启用并发模式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(container); <span class="comment">// 使用 createRoot 启用并发模式</span></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：useEffect-的清除机制是什么？在什么时候执行"><a href="#Q3：useEffect-的清除机制是什么？在什么时候执行" class="headerlink" title="Q3：useEffect()的清除机制是什么？在什么时候执行"></a>Q3：useEffect()的清除机制是什么？在什么时候执行</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useEffect</code> 是 React 中用于在函数组件中执行副作用的 Hook</p><p>了解它的清除机制对于管理副作用和避免内存泄漏非常重要</p><p>下面是对 <code>useEffect</code> 清除机制的详细解释</p><ol><li><p><code>useEffect</code> 清除机制</p><p><code>useEffect</code> 接受一个函数作为参数，这个函数可以返回一个清除函数（cleanup function）</p><p>这个清除函数将在以下几种情况下执行：</p><ul><li><p><strong>组件卸载时</strong></p><p>当组件从 DOM 中被移除时，React 会执行清除函数</p><p>这有助于清理定时器、取消网络请求或清除任何其他副作用</p></li><li><p><strong>依赖项变化时</strong></p><p>如果 <code>useEffect</code> 的依赖项（通过第二个参数传递的数组）发生变化，React 会在执行新的副作用之前先执行清除函数</p><p>这确保了在副作用重新执行之前，任何之前的副作用都被正确清理</p></li></ul></li><li><p>示例：清除定时器</p><p>下面是一个使用 <code>useEffect</code> 设置和清除定时器的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除函数：在组件卸载或依赖项变化时清除定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组表示只在组件挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Timer</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong></p><ul><li><strong>设置副作用</strong>：在 <code>useEffect</code> 中，我们设置了一个定时器，每秒钟更新一次 <code>count</code> 状态</li><li><strong>清除函数</strong>：返回的清除函数会在组件卸载时执行，清除定时器以避免内存泄漏</li><li><strong>依赖项数组</strong>：空数组 <code>[]</code> 作为第二个参数，表示这个 <code>useEffect</code> 只在组件挂载和卸载时执行一次</li></ul></li><li><p><strong>清除函数执行时机</strong></p><ul><li><p><strong>组件卸载时</strong>：当组件从 DOM 中被移除时，清除函数会执行。例如，用户导航到另一个页面或条件渲染导致组件被移除时</p></li><li><p><strong>依赖项变化时</strong>：如果 <code>useEffect</code> 的依赖项数组中包含的值发生变化，清除函数会在重新运行副作用之前执行例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect ran&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cleanup ran&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [dependency]);</span><br></pre></td></tr></table></figure><p>每当 <code>dependency</code> 变化时，清除函数会先执行，然后 <code>useEffect</code> 会重新运行</p></li></ul></li></ul></li><li><p>总结</p><ul><li><strong>清除函数的作用</strong>：确保在组件卸载或副作用重新运行之前，清理任何可能导致内存泄漏或不必要行为的副作用</li><li><strong>执行时机</strong>：在组件卸载时或依赖项变化时执行</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：多次执行-useState-，会触发多次更新吗"><a href="#Q4：多次执行-useState-，会触发多次更新吗" class="headerlink" title="Q4：多次执行 useState()，会触发多次更新吗"></a>Q4：多次执行 useState()，会触发多次更新吗</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，调用 <code>useState</code> 更新状态会触发组件重新渲染</p><p>每次调用 <code>setState</code> 方法（<code>useState</code> 返回的更新函数）都会触发一次重渲染</p><p>然而，React 会对多次状态更新进行批处理，以优化性能</p><ol><li><p>多次调用 <code>useState</code> 的行为</p><p>假设你有以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>increment</code> 函数调用了三次 <code>setCount</code></p><p>你可能期望 <code>count</code> 会增加 3，但实际上只会增加 1</p><p>这是因为在同一个事件处理函数中，React 会对状态更新进行批处理</p></li><li><p>使用函数式更新</p><p>要确保每次调用 <code>setCount</code> 都基于最新的状态，你可以使用函数式更新：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setCount</code> 的参数是一个函数，该函数接收之前的状态值 <code>prevCount</code> 并返回新的状态值</p><p>这样，每次调用 <code>setCount</code> 都会基于最新的状态值进行更新，因此 <code>count</code> 将正确增加 3</p></li><li><p>状态更新批处理</p><p>React 在事件处理函数中会对状态更新进行批处理，以优化性能</p><p>这意味着在同一个事件处理函数中多次调用 <code>setState</code>，React 可能会合并这些更新并只进行一次重渲染</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 这里的 count 可能还是旧值</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在 <code>increment</code> 函数内部的 <code>console.log(count)</code> 可能会输出旧的 <code>count</code> 值，因为状态更新是异步的，且在事件处理函数结束之前不会立即反映出来</p></li><li><p>总结</p><ul><li><p><strong>多次调用 <code>setState</code></strong></p><p>在同一个事件处理函数中多次调用 <code>setState</code>，React 会进行批处理，只触发一次重渲染</p></li><li><p><strong>函数式更新</strong></p><p>使用函数式更新可以确保每次状态更新都基于最新的状态值</p></li><li><p><strong>批处理优化</strong></p><p>React 会对状态更新进行批处理，以优化性能</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：React-的-diff-过程"><a href="#Q5：React-的-diff-过程" class="headerlink" title="Q5：React 的 diff 过程"></a>Q5：React 的 diff 过程</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 diff 过程是 React 用来高效更新 DOM 的核心机制之一</p><p>这个过程被称为 “reconciliation”（协调），其核心算法被称为 “diffing algorithm”</p><p>React 通过 diff 算法比较新旧虚拟 DOM 树（Virtual DOM）之间的差异，并只更新实际需要变更的部分，从而实现高效的更新</p><p><strong>Diff 算法的基本原则</strong></p><p>React 的 diff 算法主要基于以下三个基本原则：</p><ol><li><strong>不同类型的元素会产生不同的树</strong>：<ul><li>如果两个元素类型不同，React 会销毁旧的树并创建新的树</li><li>例如，从 <code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>，React 会移除 <code>&lt;div&gt;</code> 及其子节点，并创建新的 <code>&lt;span&gt;</code> 及其子节点</li></ul></li><li><strong>相同类型的元素会保留 DOM 节点，仅更新属性</strong>：<ul><li>如果两个元素类型相同，React 会保留现有的 DOM 节点，仅更新其属性</li><li>例如，从 <code>&lt;div className=&quot;old&quot;&gt;</code> 变为 <code>&lt;div className=&quot;new&quot;&gt;</code>，React 只会更新 <code>className</code> 属性</li></ul></li><li><strong>通过 key 属性来识别列表中的元素</strong>：<ul><li>对于列表中的元素，React 通过 <code>key</code> 属性来识别每个元素</li><li>如果 <code>key</code> 发生变化，React 会认为元素发生了变化，从而销毁旧的并创建新的</li><li>使用 <code>key</code> 可以帮助 React 更高效地更新列表</li></ul></li></ol><p><strong>Diff 算法的具体步骤</strong></p><ol><li><strong>比较根节点</strong>：<ul><li>React 首先比较根节点。如果根节点类型不同，React 会直接替换整个节点树</li></ul></li><li><strong>比较子节点</strong>：<ul><li>如果根节点类型相同，React 会递归比较子节点</li><li>如果子节点是文本节点，React 会直接更新文本内容</li><li>如果子节点是元素节点，React 会比较属性并更新变化的部分</li></ul></li><li><strong>列表的比较</strong>：<ul><li>对于列表，React 使用 <code>key</code> 属性来跟踪每个元素。如果 <code>key</code> 发生变化，React 会重新创建元素</li><li>React 会尝试最小化 DOM 操作，通过移动、插入和删除节点来更新列表</li></ul></li></ol><p><strong>示例</strong></p><p>以下是一个简单的示例，展示了 React 如何通过 diff 算法更新 DOM：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = <span class="title function_">useState</span>([<span class="string">&#x27;Item 1&#x27;</span>, <span class="string">&#x27;Item 2&#x27;</span>, <span class="string">&#x27;Item 3&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateItems</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setItems</span>([<span class="string">&#x27;Item 1&#x27;</span>, <span class="string">&#x27;Item 3&#x27;</span>, <span class="string">&#x27;Item 4&#x27;</span>]); <span class="comment">// 更新列表</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;items.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;updateItems&#125;</span>&gt;</span>Update Items<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中，当点击 <code>Update Items</code> 按钮时，React 会使用 <code>key</code> 属性来比较新旧列表，并只更新变化的部分：</p><ul><li><code>Item 1</code> 保持不变</li><li><code>Item 2</code> 被移除</li><li><code>Item 3</code> 保持不变，但位置发生变化</li><li><code>Item 4</code> 被添加</li></ul><p><strong>总结</strong></p><p>React 的 diff 过程通过以下方式实现高效的 DOM 更新：</p><ul><li><strong>不同类型的元素会产生不同的树</strong>：类型不同直接替换</li><li><strong>相同类型的元素会保留 DOM 节点，仅更新属性</strong>：类型相同只更新变化的属性</li><li><strong>通过 key 属性来识别列表中的元素</strong>：使用 <code>key</code> 来高效更新列表</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Redux-遵循的三个原则是什么"><a href="#Q6：Redux-遵循的三个原则是什么" class="headerlink" title="Q6：Redux 遵循的三个原则是什么"></a>Q6：Redux 遵循的三个原则是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Redux 是一个用于 JavaScript 应用的状态管理库，特别适用于 React 应用</p><p>Redux 遵循三个核心原则，这些原则帮助开发者构建可预测、易于调试和维护的应用状态管理系统</p><ol><li><p>单一数据源（Single Source of Truth）</p><p>在 Redux 中，整个应用的状态被存储在一个单一的对象树（state tree）中，这个对象树被存储在一个单一的 store 中</p><p>这个原则确保了应用的状态是集中管理的，从而使得状态变得更可预测和容易调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const initialState = &#123;</span><br><span class="line">  user: null,</span><br><span class="line">  posts: [],</span><br><span class="line">  comments: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer, initialState);</span><br></pre></td></tr></table></figure></li><li><p>状态是只读的（State is Read-Only）</p><p>唯一改变应用状态的方法是触发一个 action</p><p>Action 是一个描述事件的普通 JavaScript 对象，它们必须具有一个 <code>type</code> 属性来指明事件的类型</p><p>这个原则确保了状态的不可变性，从而使得状态变更可追踪和可调试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_POST&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;My First Post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(action)</span><br></pre></td></tr></table></figure></li><li><p>使用纯函数来执行修改（Changes are Made with Pure Functions）</p><p>为了描述 action 如何改变 state 树，你需要编写纯函数</p><p>纯函数是指相同的输入总是会产生相同的输出，并且没有副作用</p><p>在 Redux 中，这些纯函数被称为 reducers。Reducer 接收当前的 state 和 action，并返回一个新的 state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postsReducer</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_POST&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.<span class="property">payload</span>];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">posts</span>: postsReducer,</span><br><span class="line">  <span class="comment">// 其他 reducers</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p>Redux 的三个核心原则是：</p><ol><li><strong>单一数据源（Single Source of Truth）</strong>：整个应用的状态被存储在一个单一的 store 中</li><li><strong>状态是只读的（State is Read-Only）</strong>：唯一改变状态的方法是触发一个 action</li><li><strong>使用纯函数来执行修改（Changes are Made with Pure Functions）</strong>：reducers 是纯函数，用于描述状态如何根据 action 改变</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：你对“单一事实来源”有什么理解"><a href="#Q7：你对“单一事实来源”有什么理解" class="headerlink" title="Q7：你对“单一事实来源”有什么理解"></a>Q7：你对“单一事实来源”有什么理解</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“单一事实来源”（Single Source of Truth, SSOT）是软件设计中的一个重要原则，特别是在状态管理和数据管理领域</p><p>这个原则的核心思想是系统中的所有数据都应该有一个唯一的、权威的来源</p><p>这种方法有助于避免数据的不一致性，简化数据管理，并提高系统的可维护性和可预测性</p><p><strong>在 Redux 中的应用</strong></p><p>在 Redux 中，单一事实来源的原则体现在整个应用的状态被存储在一个单一的对象树（state tree）中，这个对象树被存储在一个唯一的 Redux store 中</p><p>以下是这个原则的一些具体好处和实现方式：</p><p><strong>好处</strong></p><ol><li><p><strong>数据一致性</strong></p><p>当所有状态都集中在一个地方时，数据的一致性更容易维护</p><p>你不需要担心不同组件或模块之间的数据不同步问题</p></li><li><p><strong>可预测性</strong></p><p>由于状态集中管理，应用的行为变得更加可预测</p><p>你可以通过查看 store 来了解应用的当前状态</p></li><li><p><strong>易于调试</strong></p><p>使用单一的 store，可以很容易地跟踪状态的变化</p><p>Redux DevTools 等工具可以帮助开发者查看和回溯状态的变化历史</p></li><li><p><strong>简化开发</strong></p><p>集中管理状态使得应用的结构更加清晰，开发者可以更容易地理解和维护代码</p></li></ol><p><strong>实现方式</strong></p><p>在 Redux 中，实现单一事实来源的步骤包括：</p><ol><li><p><strong>创建 Redux Store</strong></p><p>使用 <code>createStore</code> 函数创建一个 Redux store，这个 store 将包含整个应用的状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer);</span><br></pre></td></tr></table></figure></li><li><p><strong>定义 State Tree</strong></p><p>应用的状态被定义为一个对象树，可以包含多个属性，每个属性代表应用的一个部分状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">posts</span>: [],</span><br><span class="line">  <span class="attr">comments</span>: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Reducers 管理状态</strong></p><p>reducers 是纯函数，用于描述状态如何根据 action 改变</p><p>所有的状态变更都通过 reducers 来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rootReducer</span>(<span class="params">state = initialState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_POST&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">posts</span>: [...state.<span class="property">posts</span>, action.<span class="property">payload</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="comment">// 其他 case</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 Actions 修改状态</strong></p><p>唯一修改状态的方法是通过 dispatch actions</p><p>actions 是描述状态变更的普通 JavaScript 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addPostAction = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_POST&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;My First Post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(addPostAction);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p>“单一事实来源”原则在 Redux 中的应用确保了整个应用的状态是集中管理的，从而使得状态变得更可预测、更一致，并且更容易调试和维护</p><p>这种方法不仅适用于 Redux，也可以应用于其他需要管理复杂状态和数据的一些系统和框架中</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Redux-有哪些优点"><a href="#Q8：Redux-有哪些优点" class="headerlink" title="Q8：Redux 有哪些优点"></a>Q8：Redux 有哪些优点</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>单一状态树</strong></p><p>Redux 使用单一的状态树（State Tree）来存储整个应用的状态</p><p>这意味着所有的状态都集中在一个地方，使得应用的状态管理更加清晰和可预测</p></li><li><p><strong>可预测的状态管理</strong></p><p>Redux 强调状态是不可变的，所有的状态变更必须通过纯函数（Reducers）来处理</p><p>这种方式使得状态变更的过程变得透明和可预测，便于调试和测试</p></li><li><p><strong>易于调试</strong></p><p>Redux 提供了强大的调试工具，如 Redux DevTools，可以帮助开发者查看状态的变化、回溯状态历史、时间旅行调试等</p><p>这些工具极大地提高了开发和调试的效率</p></li><li><p><strong>中间件支持</strong></p><p>Redux 具有强大的中间件机制，可以在 action 被发送到 reducer 之前进行处理</p><p>常见的中间件如 Redux Thunk 和 Redux Saga，可以处理异步操作、日志记录、错误报告等</p></li><li><p><strong>与 React 的良好集成</strong></p><p>Redux 与 React 紧密集成，通过 <code>react-redux</code> 库提供的 <code>Provider</code> 和 <code>connect</code> 方法，可以方便地将 Redux 的状态和方法注入到 React 组件中，使得组件间的状态共享和通信变得简单</p></li><li><p><strong>社区和生态系统</strong></p><p>Redux 拥有庞大的社区和丰富的生态系统，提供了大量的插件和工具，如 Redux Form、Redux Persist、Redux Toolkit 等，帮助开发者更高效地构建应用</p></li><li><p><strong>可扩展性和可维护性</strong></p><p>Redux 的设计模式使得应用的状态管理逻辑高度模块化和可扩展</p><p>随着应用的增长，Redux 的结构可以轻松地扩展和维护，而不需要对现有代码进行大规模的重构</p></li><li><p><strong>一致的数据流</strong></p><p>Redux 采用单向数据流的设计，即 action -&gt; reducer -&gt; state 的数据流动方向</p><p>这种设计使得数据流动更加简单和直观，减少了双向绑定带来的复杂性和潜在问题</p></li><li><p><strong>支持服务器渲染</strong></p><p>Redux 可以很好地支持服务器端渲染（SSR），通过在服务器端初始化和预填充状态，可以显著提高应用的性能和用户体验</p></li><li><p><strong>强类型支持</strong></p><p>对于使用 TypeScript 的项目，Redux 提供了良好的类型支持，可以显著减少运行时错误，提高开发效率和代码质量</p></li></ol><p><strong>示例代码</strong></p><p>以下是一个简单的 Redux 示例，展示了如何创建 store、定义 action 和 reducer，并在 React 组件中使用 Redux 状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;DECREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state = initialState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterReducer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span>, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：React事件机制"><a href="#Q9：React事件机制" class="headerlink" title="Q9：React事件机制"></a>Q9：React事件机制</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是合成事件</strong></p><p><strong>React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等</strong></p><p>React事件的设计动机(作用)：</p><ul><li><strong>在底层磨平不同浏览器的差异，React实现了统一的事件机制，我们不再需要处理浏览器事件机制方面的兼容问题，在上层面向开发者暴露稳定、统一的、与原生事件相同的事件接口</strong></li><li><strong>React把握了事件机制的主动权，实现了对所有事件的中心化管控</strong></li><li><strong>React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁</strong></li></ul><p><strong>React事件机制和原生DOM事件流有什么区别</strong></p><p><strong>虽然合成事件不是原生DOM事件，但它包含了原生DOM事件的引用，可以通过e.nativeEvent访问</strong></p><hr><p><strong>DOM事件流是怎么工作的</strong>，一个页面往往会绑定多个事件，页面接收事件的顺序叫事件流</p><p>W3C标准事件的传播过程：</p><ol><li>事件捕获</li><li>处于目标</li><li>事件冒泡</li></ol><p>常用的事件处理性能优化手段：<strong>事件委托</strong></p><p><strong>把多个子元素同一类型的监听函数合并到父元素上，通过一个函数监听的行为叫事件委托</strong></p><p><strong>我们写的React事件是绑定在DOM上吗，如果不是绑定在哪里</strong></p><p>React16的事件绑定在document上， React17以后事件绑定在container上,<strong>ReactDOM.render(app,container)</strong></p><p><strong>React事件机制</strong>总结如下：</p><p>事件绑定 事件触发</p><ul><li><strong>React所有的事件绑定在container上</strong>(react17以后),而不是绑定在DOM元素上（作用：减少内存开销，所有的事件处理都在container上，其他节点没有绑定事件）</li><li>React自身实现了一套冒泡机制，不能通过return false阻止冒泡</li><li>React通过<strong>SytheticEvent</strong>实现了<strong>事件合成</strong></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad1c0b6ee9c42578b6fc7b46a3a2e39~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1740&amp;h=1054&amp;s=45104&amp;e=webp&amp;b=2b2a33" alt="img"></p><p><strong>React实现事件绑定的过程</strong></p><p><strong>1.建立合成事件与原生事件的对应关系</strong></p><p><strong>registrationNameModule,</strong> 它建立了React事件到plugin的映射，它包含React支持的所有事件的类型，用于判断一个组件的prop是否是事件类型</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   onBlur:SimpleEventPlugin,</span><br><span class="line">   onClick:SimpleEventPlugin,</span><br><span class="line">   onClickCapture:SimpleEventPlugin,</span><br><span class="line">   onChange:ChangeEventPlugin,</span><br><span class="line">   onChangeCapture:ChangeEventPlugin,</span><br><span class="line">   onMouseEnter:EnterLeaveEventPlugin,</span><br><span class="line">   onMouseLeave:EnterLeaveEventPlugin,</span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>registrationNameDependencies，</strong> 这个对象记录了React事件到原生事件的映射</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onBlur: [<span class="string">&#x27;blur&#x27;</span>],</span><br><span class="line">  onClick: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">  onClickCapture: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">  onChange: [<span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;keyup&#x27;</span>, <span class="string">&#x27;selectionchange&#x27;</span>],</span><br><span class="line">  onMouseEnter: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">  onMouseLeave: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>plugins对象,</strong> 记录了所有注册的插件列表</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span> = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...]</span><br></pre></td></tr></table></figure><hr><p><strong>为什么针对同一个事件，即使可能存在多次回调，document（container）也只需要注册一次监听</strong></p><p>因为React注册到document(container)上的并不是一个某个DOM节点具体的回调逻辑，而是一个统一的事件分发函数dispatchEvent - &gt; 事件委托思想</p><p><strong>dispatchEvent是怎么实现事件分发的</strong></p><p>事件触发的本质是对dispatchEvent函数的调用</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8b7a2369a943118f865cb9369638b4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1188&amp;h=821&amp;s=205871&amp;e=png&amp;b=ebebeb" alt="img"></p><p><strong>React事件处理为什么要手动绑定this</strong></p><p>react组件会被编译为React.createElement,在createElement中，它的this丢失了，并不是由组件实例调用的，因此需要手动绑定this</p><p>为什么不能通过return false阻止事件的默认行为</p><p>因为React基于浏览器的事件机制实现了一套自己的事件机制，和原生DOM事件不同，它采用了事件委托的思想，通过dispatch统一分发事件处理函数</p><p><strong>React怎么阻止事件冒泡</strong></p><ul><li>阻止合成事件的冒泡用e.stopPropagation()</li><li>阻止合成事件和最外层document事件冒泡，使用e.nativeEvent.stopImmediatePropogation()</li><li>阻止合成事件和除了最外层document事件冒泡，通过判断e.target避免</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">target</span> &amp;&amp; e.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;div.stop&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">active</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：React-Router工作原理"><a href="#Q10：React-Router工作原理" class="headerlink" title="Q10：React-Router工作原理"></a>Q10：React-Router工作原理</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>为什么需要前端路由</strong></p><ol><li>早期：一个页面对应一个路由，路由跳转导致页面刷新，用户体验差</li><li>ajax的出现使得不刷新页面也可以更新页面内容，出现了<em>SPA</em>（单页应用）。<em>SPA</em>不能记住用户操作，只有一个页面对URL做映射，SEO不友好</li><li>前端路由帮助我们在仅有一个页面时记住用户进行了哪些操作</li></ol><p><strong>前端路由解决了什么问题</strong></p><ol><li>当用户刷新页面，浏览器会根据当前URL对资源进行重定向(发起请求)</li><li>单页面对服务端来说就是一套资源，怎么做到不同的URL映射不同的视图内容</li><li>拦截用户的刷新操作，避免不必要的资源请求；感知URL的变化</li></ol><p><strong>react-router-dom有哪些组件</strong></p><p>HashRouter/BrowserRouter 路由器</p><p>Route 路由匹配</p><p>Link 链接，在html中是个锚点</p><p>NavLink 当前活动链接</p><p>Switch 路由跳转</p><p>Redirect 路由重定向</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/home&quot;</span>&gt;<span class="title class_">Home</span>&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/abount&quot;</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React Router核心能力：<strong>跳转</strong></p><p><strong>路由</strong>负责定义路径和组件的映射关系</p><p><strong>导航</strong>负责触发路由的改变<br> 路由器根据Route定义的映射关系为新的路径匹配对应的逻辑</p><p><strong>BrowserRouter</strong>使用的<strong>HTML5</strong>的<strong>history api</strong>实现路由跳转<br> <strong>HashRoute</strong>r使用URL的<strong>hash属性</strong>控制路由跳转</p><p><strong>前端通用路由解决方案</strong></p><ul><li>hash模式</li></ul><blockquote><p>改变URL以#分割的路径字符串，让页面感知路由变化的一种模式,通过<em>hashchange</em>事件触发</p></blockquote><ul><li>history模式</li></ul><blockquote><p>通过浏览器的history api实现,通过<em>popState</em>事件触发</p></blockquote>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：React-Render方法的原理是什么？什么时候会被触发"><a href="#Q11：React-Render方法的原理是什么？什么时候会被触发" class="headerlink" title="Q11：React Render方法的原理是什么？什么时候会被触发"></a>Q11：React Render方法的原理是什么？什么时候会被触发</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 <code>render</code> 方法是 React 框架的核心概念之一，用于描述组件的 UI 结构</p><p>理解 <code>render</code> 方法的原理和触发条件有助于更好地优化和管理 React 应用的性能</p><p>以下是对 <code>render</code> 方法的详细解释：</p><p><strong><code>render</code> 方法的原理</strong></p><p>在 React 中，每个组件都有一个 <code>render</code> 方法（对于类组件）或一个返回 JSX 的函数（对于函数组件）</p><p>这个方法的主要职责是返回一个描述 UI 的 React 元素树</p><p>React 使用这些描述来构建和更新实际的 DOM</p><p><strong>类组件中的 <code>render</code> 方法</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数组件中的 <code>render</code> 方法</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>render</code> 方法的触发条件</strong></p><p><code>render</code> 方法会在以下几种情况下被触发：</p><ol><li><p><strong>组件挂载时</strong></p><p>当组件第一次被添加到 DOM 中时，<code>render</code> 方法会被调用。这是组件的初始渲染阶段。</p></li><li><p><strong>组件状态（state）更新时</strong></p><p>当组件的状态通过 <code>setState</code> 或 <code>useState</code> 更新时，<code>render</code> 方法会被调用，以反映状态的变化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件接收新的 props 时</strong></p><p>当父组件传递给子组件的 props 发生变化时，<code>render</code> 方法会被调用，以反映新的 props</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ParentComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ChildComponent</span> = (<span class="params">&#123; value &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>强制更新时</strong></p><p>可以通过调用 <code>forceUpdate</code> 方法强制组件重新渲染，但这种做法不常见，应尽量避免</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  forceUpdateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.forceUpdateComponent&#125;</span>&gt;</span>Force Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>上下文（context）变化时</strong></p><p>如果组件使用了上下文（context），当上下文的值发生变化时，<code>render</code> 方法也会被触发</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ParentComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ChildComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：对Redux的理解以及它的工作原理以及怎么使用"><a href="#Q12：对Redux的理解以及它的工作原理以及怎么使用" class="headerlink" title="Q12：对Redux的理解以及它的工作原理以及怎么使用"></a>Q12：对Redux的理解以及它的工作原理以及怎么使用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>Redux 的理解</strong></p><p>Redux 是一个用于 JavaScript 应用的状态管理库，通常与 React 一起使用</p><p>它提供了一个集中化的存储来管理应用的状态，使得状态管理变得更加可预测和可维护</p><p><strong>Redux 的工作原理</strong></p><p>Redux 的核心概念包括以下几个部分：</p><ol><li><p><strong>Store</strong></p><p>Redux 应用的整个状态树都存储在一个单一的 store 中</p><p>这个 store 是一个对象，包含了应用的所有状态</p></li><li><p><strong>Action</strong></p><p>Action 是一个描述发生了什么的普通 JavaScript 对象</p><p>每个 action 都必须有一个 <code>type</code> 属性，通常还会包含其他数据</p></li><li><p><strong>Reducer</strong></p><p>Reducer 是一个纯函数，接收当前的 state 和一个 action，并返回一个新的 state</p><p>Reducer 根据 action 的 <code>type</code> 来决定如何更新 state</p></li><li><p><strong>Dispatch</strong></p><p>Dispatch 是一个用于发送 action 的方法</p><p>通过调用 <code>store.dispatch(action)</code>，你可以触发 state 的更新</p></li><li><p><strong>Subscribe</strong></p><p>通过 <code>store.subscribe(listener)</code> 方法，你可以订阅 store 的更新</p><p>当 state 发生变化时，订阅的监听器会被调用</p></li></ol><p><strong>Redux 的使用步骤</strong></p><p>以下是如何在一个 React 应用中使用 Redux 的基本步骤：</p><ol><li><p>创建 Action</p><p>定义 action 类型和 action 创建函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">INCREMENT</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">DECREMENT</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建 Reducer</p><p>定义一个 reducer 函数来处理 state 更新：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT</span>, <span class="variable constant_">DECREMENT</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = initialState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterReducer;</span><br></pre></td></tr></table></figure></li><li><p>创建 Store</p><p>使用 <code>createStore</code> 函数创建 Redux store：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li><li><p>提供 Store</p><p>使用 <code>Provider</code> 组件将 Redux store 提供给 React 应用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>连接 React 组件</p><p>使用 <code>useSelector</code> 和 <code>useDispatch</code> 钩子在 React 组件中访问 Redux state 和 dispatch actions：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用组件</p><p>在应用中使用你的 Redux 连接组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Counter</span> <span class="keyword">from</span> <span class="string">&#x27;./Counter&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Redux Counter Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：jsx转换成真实Dom的过程"><a href="#Q13：jsx转换成真实Dom的过程" class="headerlink" title="Q13：jsx转换成真实Dom的过程"></a>Q13：jsx转换成真实Dom的过程</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，JSX 是一种语法糖，它让你可以在 JavaScript 中编写类似 HTML 的代码</p><p>为了在浏览器中渲染这些代码，JSX 需要被转换成真实的 DOM 元素</p><p>这个转换过程可以分为以下几个步骤：</p><ol><li><p>JSX 转换为 JavaScript</p><p>首先，JSX 会被 Babel（一个 JavaScript 编译器）转换成 <code>React.createElement</code> 调用。这一步通常在构建过程中完成。</p><p><strong>示例</strong></p><p>假设有以下 JSX 代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>Babel 会将其转换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>React.createElement 生成 React 元素</p><p><code>React.createElement</code> 是一个函数，用于创建一个 React 元素。React 元素是一个普通的 JavaScript 对象，描述了你想在屏幕上看到的内容。</p><p><strong>示例</strong></p><p>上面的 <code>React.createElement</code> 调用会生成以下 React 元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>React 元素渲染为虚拟 DOM</p><p>React 使用这个 React 元素来构建一个虚拟 DOM 树。虚拟 DOM 是一个轻量级的 JavaScript 对象树，描述了真实 DOM 的结构。</p><p><strong>示例</strong></p><p>虚拟 DOM 树可能看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> virtualDOM = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>虚拟 DOM 转换为真实 DOM</p><p>React 通过比较虚拟 DOM 和真实 DOM（即“调和”过程），将虚拟 DOM 转换为真实的 DOM 元素，并进行必要的更新。</p><p><strong>示例</strong></p><p>在初次渲染时，React 会创建一个新的 <code>h1</code> 元素，并将其插入到真实的 DOM 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">h1.<span class="property">textContent</span> = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>).<span class="title function_">appendChild</span>(h1);</span><br></pre></td></tr></table></figure></li><li><p>更新和调和</p><p>当组件的状态或属性发生变化时，React 会重新生成新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较。这个过程称为“调和”。React 会找出需要更新的部分，并只更新这些部分，从而提高性能。</p><p><strong>示例</strong></p><p>假设状态更新导致文本从“Hello, world!”变为“Hello, React!”：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newElement = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>新的虚拟 DOM 树会是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newVirtualDOM = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, React!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 会比较新旧虚拟 DOM 树，发现只有文本内容发生了变化，因此只会更新 <code>h1</code> 元素的文本内容</p></li></ol><p><strong>总结</strong></p><ol><li><strong>JSX 转换</strong>：JSX 被 Babel 转换为 <code>React.createElement</code> 调用</li><li><strong>生成 React 元素</strong>：<code>React.createElement</code> 创建一个描述 UI 的 React 元素对象</li><li><strong>虚拟 DOM</strong>：React 使用 React 元素来构建虚拟 DOM 树</li><li><strong>真实 DOM</strong>：React 将虚拟 DOM 转换为真实 DOM，并插入到页面中</li><li><strong>更新和调和</strong>：当状态或属性变化时，React 通过调和过程只更新必要的部分</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：React服务端渲染怎么做？原理是什么"><a href="#Q14：React服务端渲染怎么做？原理是什么" class="headerlink" title="Q14：React服务端渲染怎么做？原理是什么"></a>Q14：React服务端渲染怎么做？原理是什么</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>实现 React 服务端渲染的步骤</strong></p><ol><li><p>设置项目</p><p>首先，你需要一个基本的 React 项目和一个 Node.js 服务器。你可以使用 <code>create-react-app</code> 来创建一个 React 项目，然后进行一些配置来支持 SSR</p></li><li><p>安装必要的依赖</p><p>你需要安装一些额外的依赖，如 <code>express</code> 和 <code>react-dom/server</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express react-dom/server</span><br></pre></td></tr></table></figure></li><li><p>创建服务器文件</p><p>创建一个 <code>server.js</code> 文件，用于设置 Express 服务器并处理 SSR</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOMServer</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./src/App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">ReactDOMServer</span>.<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> indexFile = path.<span class="title function_">resolve</span>(<span class="string">&#x27;./build/index.html&#x27;</span>);</span><br><span class="line">  fs.<span class="title function_">readFile</span>(indexFile, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Something went wrong:&#x27;</span>, err);</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Oops, better luck next time!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(</span><br><span class="line">      data.<span class="title function_">replace</span>(<span class="string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>, <span class="string">`&lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;`</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is listening on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>package.json</code></p><p>在 <code>package.json</code> 中添加一个脚本来启动服务器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node server.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构建项目并启动服务器</p><p>首先构建项目，然后启动服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></li></ol><p><strong>React 服务端渲染的原理</strong></p><p>服务端渲染的基本原理是将 React 组件在服务器端渲染成 HTML 字符串，然后将其发送到客户端</p><p>客户端接收到 HTML 内容后，再通过 React 进行“同构”或“挂载”，使得 React 可以接管这些已经渲染好的 HTML 元素，继续处理后续的交互和状态更新</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>服务端渲染（<code>Server-Side Rendering</code> ，简称<code>SSR</code>），指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p><p><img src="https://s2.loli.net/2024/05/23/5v8EQn2TRVm4cIx.png" alt="image-20240523105838863"></p><p><strong>优点</strong></p><ol><li><strong>更快的首屏渲染</strong>：SSR 可以在服务器端生成完整的 HTML 页面，减少了客户端首次渲染的时间</li><li><strong>SEO 友好</strong>：搜索引擎可以更容易地抓取和索引服务器端渲染的页面内容</li><li><strong>更好的用户体验</strong>：用户可以更快地看到页面内容，减少了白屏时间</li></ol><p><strong>缺点</strong></p><ol><li><strong>增加了服务器负载</strong>：每次请求都需要在服务器端渲染页面，增加了服务器的负载</li><li><strong>复杂性增加</strong>：SSR 需要更多的配置和代码，增加了开发和维护的复杂性</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：说说你对-React-Hook的闭包陷阱的理解，有哪些解决方案"><a href="#Q15：说说你对-React-Hook的闭包陷阱的理解，有哪些解决方案" class="headerlink" title="Q15：说说你对 React Hook的闭包陷阱的理解，有哪些解决方案"></a>Q15：说说你对 React Hook的闭包陷阱的理解，有哪些解决方案</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Hooks 中的闭包陷阱（Closure Trap）是一个常见的问题，尤其是在处理状态更新和副作用时</p><p>这个问题主要源于 JavaScript 闭包的特性，当你在函数组件中使用 Hooks 时，闭包可能会捕获旧的状态值，从而导致一些意外行为</p><p><strong>问题示例</strong></p><p>假设你有一个计时器组件，每秒钟更新一次计数器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 这里的 `count` 是初始值 0</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setCount(count + 1)</code> 每次都会捕获初始的 <code>count</code> 值（即 0），因为 <code>useEffect</code> 中的函数只在组件挂载时被创建一次。结果是计数器不会正确更新。</p><p><strong>解决方案</strong></p><ol><li><p><strong>使用函数式更新</strong></p><p>React 提供了一种函数式更新的方式，可以确保你使用的是最新的状态值</p><p>你可以通过传递一个函数给 <code>setState</code> 来实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>); <span class="comment">// 使用最新的 `prevCount`</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li><p><strong>依赖数组</strong></p><p>在 <code>useEffect</code> 的依赖数组中添加需要使用的状态或属性，这样每次这些依赖变化时，<code>useEffect</code> 都会重新执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, [count]); <span class="comment">// 依赖 `count`</span></span><br></pre></td></tr></table></figure><p>但是这种方法在某些情况下可能会导致不必要的重新渲染，因此应谨慎使用</p></li><li><p><strong>使用 <code>useRef</code> 保存最新的状态</strong></p><p>你可以使用 <code>useRef</code> 来保存最新的状态值，并在副作用中引用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countRef = <span class="title function_">useRef</span>(count);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    countRef.<span class="property">current</span> = count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(countRef.<span class="property">current</span> + <span class="number">1</span>); <span class="comment">// 使用最新的 `countRef.current`</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义 Hook</strong></p><p>你可以创建一个自定义 Hook 来封装计时器逻辑，从而避免重复代码和闭包陷阱：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useInterval</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(callback, delay);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, [callback, delay]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li></ol><p>通过这些方法，你可以有效地避免 React Hooks 中的闭包陷阱，确保你的状态更新和副作用按预期工作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：React-Router有几种模式？实现原理是什么"><a href="#Q16：React-Router有几种模式？实现原理是什么" class="headerlink" title="Q16：React Router有几种模式？实现原理是什么"></a>Q16：React Router有几种模式？实现原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>BrowserRouter</code></p><p><strong>概述</strong></p><p><code>BrowserRouter</code> 使用 HTML5 的 <code>history</code> API 来处理路由</p><p>这种模式下，URL 看起来是干净的路径（例如 <code>/home</code>, <code>/about</code>），而不会带有 <code>#</code> 符号</p><p><strong>实现原理</strong></p><ul><li><p><strong>History API</strong></p><p><code>BrowserRouter</code> 利用 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 事件来管理浏览器历史记录和导航</p></li><li><p><strong>URL 结构</strong></p><p>直接使用路径名（pathname），例如 <code>/home</code></p></li><li><p><strong>服务器配置</strong></p><p>由于 URL 是干净的路径，服务器需要进行相应的配置，以便在用户直接访问某个路径时，服务器能够正确地返回应用的入口文件（通常是 <code>index.html</code>）</p><p>这通常涉及到配置服务器进行 URL 重写（URL Rewriting）</p></li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;./Home&#x27;;</span><br><span class="line">import About from &#x27;./About&#x27;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p><code>Hash Router</code></p><p><strong>概述</strong></p><p><code>HashRouter</code> 使用 URL 的 hash 部分（即 <code>#</code> 后面的部分）来管理路由</p><p>这种模式下，URL 会包含 <code>#</code> 符号（例如 <code>#/home</code>, <code>#/about</code>）</p><p><strong>实现原理</strong></p><ul><li><p><strong>Hash Fragment</strong></p><p><code>HashRouter</code> 利用浏览器的 <code>hashchange</code> 事件来检测 URL 变化，并根据 hash 值来导航</p></li><li><p><strong>URL 结构</strong></p><p>使用 hash 部分来表示路径，例如 <code>#/home</code></p></li><li><p><strong>服务器配置</strong>:</p><p>由于 hash 部分不会被发送到服务器，所以不需要进行额外的服务器配置</p><p>这使得 <code>HashRouter</code> 在一些静态文件服务器或不支持 URL 重写的环境中非常有用</p></li></ul><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./About&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li><strong>BrowserRouter</strong>:<ul><li>使用 HTML5 <code>history</code> API</li><li>URL 是干净的路径</li><li>需要服务器配置 URL 重写</li><li>更适合现代单页应用（SPA）</li></ul></li><li><strong>HashRouter</strong>:<ul><li>使用 URL 的 hash 部分</li><li>URL 包含 <code>#</code> 符号</li><li>不需要服务器配置</li><li>适合一些静态文件服务器或不支持 URL 重写的环境</li></ul></li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h3 id="Q1：子组件是一个-Portal，发生点击事件能冒泡到父组件吗"><a href="#Q1：子组件是一个-Portal，发生点击事件能冒泡到父组件吗" class="headerlink" title="Q1：子组件是一个 Portal，发生点击事件能冒泡到父组件吗"></a>Q1：子组件是一个 Portal，发生点击事件能冒泡到父组件吗</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在理解这个问题之前，首先要了解一些基本知识：</p><ol><li><p><strong>React Context</strong>：</p><p>React 使用 context 来存储组件树的一些信息，比如事件处理程序</p><p>当组件使用 Portal 时，Portal 在 React 内部仍然保持在父组件树中，即使在 DOM 上渲染到其他地方</p><p>也就是说，Portal 的 context 依然从其父组件继承而来</p></li><li><p><strong>DOM 事件冒泡</strong>：</p><p>DOM 中的事件（例如点击事件）通常会从触发事件的元素开始，然后逐步向上冒泡到父元素，直到 document 元素</p><p>在这个过程中，事件会按照 DOM 树的层级一层层地向上传递</p></li><li><p><strong>React 的事件代理</strong>：</p><p>React 使用事件代理模式将所有事件都代理到顶层（<code>document</code> 或者 <code>root</code> DOM 节点）进行处理</p><p>这意味着当在子组件中触发一个事件时，无论子组件是否使用了 Portal，React 都会将事件传递到其父组件，然后逐级往上冒泡，直到到达代理事件的顶层</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 Portal 通过 React 的 context 和事件冒泡的机制工作</p><p>在 React 中，当一个子组件使用 Portal 将其内容渲染到其他 DOM 节点时，尽管在 DOM 结构上子组件不再是父组件的直接子节点，但在 React 的组件树中，子组件仍然是父组件的子节点。这意味着 React 在监听和处理事件时，会沿着组件树的路径（而不是 DOM 树的路径）冒泡事件。因此，子组件中触发的事件仍然会冒泡到父组件。</p><p>总结：Portal 在 DOM 结构上将子组件渲染到其他位置，但在 React 的组件树中，它仍然是父组件的子组件。这使得事件可以从子组件沿着组件树冒泡到父组件。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：props-的变动，是否会引起-state-hook-中数据的变动"><a href="#Q2：props-的变动，是否会引起-state-hook-中数据的变动" class="headerlink" title="Q2：props 的变动，是否会引起 state hook 中数据的变动"></a>Q2：props 的变动，是否会引起 state hook 中数据的变动</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 组件的 props 变动，会让组件重新执行，但并不会引起 state 的值的变动</p><p>state 值的变动，只能由 setState() 来触发</p><p>因此若想在 props 变动时，重置 state 的数据，需要监听 props 的变动，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听 props 的变化，重置 count 的值</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;, [props]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：什么是受控组件和非受控组件"><a href="#Q3：什么是受控组件和非受控组件" class="headerlink" title="Q3：什么是受控组件和非受控组件"></a>Q3：什么是受控组件和非受控组件</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>受控</p><p>在受控组件中，表单元素的值完全由 React 组件的状态（state）来管理</p><p>每当表单元素的值发生变化时，会触发一个事件处理函数来更新状态，从而使表单元素的值与状态保持同步</p><p>特点</p><ul><li>表单元素的值由组件的状态控制</li><li>每次用户输入都会触发 <code>onChange</code> 事件，更新组件的状态</li></ul><p>示例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ControlledComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [inputValue, setInputValue] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setInputValue</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Submitted value: &#x27;</span> + inputValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Input:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ControlledComponent</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li><li><p>非受控</p><p>在非受控组件中，表单元素的值由 DOM 自身来管理，而不是通过 React 的状态</p><p>你可以使用 <code>ref</code> 来访问 DOM 元素，从而获取或设置其值</p><p>特点</p><ul><li>表单元素的值由 DOM 自身管理</li><li>使用 <code>ref</code> 来直接访问 DOM 元素</li></ul><p>示例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UncontrolledComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Submitted value: &#x27;</span> + inputRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Input:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">UncontrolledComponent</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>何时使用受控组件和非受控组件</strong></p><ol><li><strong>受控组件</strong>：<ul><li>适用于需要即时验证或格式化用户输入的场景</li><li>适合需要与其他组件共享或同步状态的场景</li><li>更符合 React 的单向数据流理念</li></ul></li><li><strong>非受控组件</strong>：<ul><li>适用于简单的表单，尤其是当你不需要对输入进行即时验证或格式化时</li><li>适合需要与第三方库集成的场景，这些库可能直接操作 DOM</li></ul></li></ol><p><strong>关键点总结</strong></p><ol><li><strong>受控组件</strong>：表单元素的值由 React 状态管理，使用 <code>onChange</code> 事件处理函数同步状态</li><li><strong>非受控组件</strong>：表单元素的值由 DOM 自身管理，使用 <code>ref</code> 直接访问 DOM 元素</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：高阶组件是什么"><a href="#Q4：高阶组件是什么" class="headerlink" title="Q4：高阶组件是什么"></a>Q4：高阶组件是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>高阶组件（Higher-Order Component，HOC）是 React 中的一种设计模式，用于复用组件逻辑</p><p>HOC 本质上是一个函数，它接收一个组件作为参数，并返回一个新的组件</p><p>通过这种方式，你可以在多个组件之间共享逻辑，而不需要重复代码</p><ol><li><p><strong>特点</strong></p><ul><li><p><strong>纯函数</strong>：HOC 是纯函数，不会修改传入的组件，而是返回一个新的组件。</p></li><li><p><strong>逻辑复用</strong>：HOC 可以将公共的逻辑抽离出来，在多个组件中复用。</p></li><li><p><strong>装饰器模式</strong>：HOC 类似于装饰器模式，通过增强组件的功能来实现逻辑复用</p></li><li><strong>强化 props</strong>：这个是 HOC 最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的 props,然后混入新的 props,来增强组件的功能。代表作 react-router 中的 withRouter</li><li><strong>赋能组件</strong>：HOC 有一项独特的特性，就是可以给被 HOC 包裹的业务组件，提供一些拓展功能，比如说额外的生命周期，额外的事件，但是这种 HOC，可能需要和业务组件紧密结合。典型案例 react-keepalive-router 中的 keepaliveLifeCycle 就是通过 HOC 方式，给业务组件增加了额外的生命周期</li><li><strong>控制渲染</strong>：劫持渲染是 hoc 一个特性，在 wrapComponent 包装组件中，可以对原来的组件，进行条件渲染，节流渲染，懒加载等功能，后面会详细讲解，典型代表做 react-redux 中 connect 和 dva 中 dynamic 组件懒加载</li></ul></li><li><p>示例</p><p>假设我们有一个需求，需要在多个组件中添加用户认证逻辑。我们可以创建一个 HOC 来实现这个功能</p><ul><li><p>创建 HOC</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件，添加认证逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withAuth</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟认证逻辑</span></span><br><span class="line">      <span class="keyword">const</span> isAuthenticated = <span class="literal">true</span>; <span class="comment">// 这里可以是实际的认证逻辑</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isAuthenticated) &#123;</span><br><span class="line">        <span class="comment">// 如果未认证，重定向到登录页面</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 如果已认证，渲染传入的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth;</span><br></pre></td></tr></table></figure></li><li><p>使用 HOC</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&#x27;./withAuth&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要认证的组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dashboard</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Dashboard: You are authenticated!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 HOC 包装组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProtectedDashboard</span> = <span class="title function_">withAuth</span>(<span class="title class_">Dashboard</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ProtectedDashboard</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>何时使用高阶组件</p><ul><li><p><strong>逻辑复用</strong>：当你需要在多个组件中复用相同的逻辑时，可以考虑使用 HOC</p></li><li><p><strong>代码分离</strong>：HOC 可以帮助你将关注点分离，使组件更专注于自身的逻辑，而将通用逻辑抽离到 HOC 中</p></li><li><p><strong>增强功能</strong>：HOC 可以用于增强组件的功能，例如添加认证、权限控制、数据获取等</p></li></ul></li><li><p>注意事项</p><ul><li><p><strong>不要在 render 方法中使用 HOC</strong>：避免在组件的 <code>render</code> 方法中使用 HOC，因为这会导致每次渲染时都创建新的组件，影响性能</p></li><li><p><strong>静态方法和属性的丢失</strong>：HOC 会返回一个新组件，这可能会导致传入组件的静态方法和属性丢失。可以使用 <code>hoist-non-react-statics</code> 库来解决这个问题</p></li><li><p><strong>refs 转发</strong>：如果需要在 HOC 中访问传入组件的 ref，可以使用 React 的 <code>forwardRef</code> API</p></li></ul></li><li><p>关键点总结</p><ul><li><p><strong>高阶组件</strong>：一个函数，接收一个组件作为参数，并返回一个新的组件</p></li><li><p><strong>逻辑复用</strong>：通过 HOC 可以在多个组件之间共享逻辑，减少重复代码</p></li><li><p><strong>注意事项</strong>：避免在 <code>render</code> 方法中使用 HOC，处理静态方法和属性的丢失，以及使用 <code>forwardRef</code> 转发 refs</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：如何实现组件的懒加载"><a href="#Q5：如何实现组件的懒加载" class="headerlink" title="Q5：如何实现组件的懒加载"></a>Q5：如何实现组件的懒加载</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在React 18及以上版本中，组件的懒加载可以通过<code>React.lazy()</code>函数和<code>Suspense</code>组件实现</p><p>懒加载对于提升应用的启动速度和性能非常有帮助，尤其是在加载大型组件或库时</p><p>它允许组件仅在需要时才加载，而不是在首次加载应用时加载所有组件</p><p><strong>实现步骤</strong></p><ol><li><p><strong>使用<code>React.lazy</code>导入组件</strong>：<br><code>React.lazy</code>函数允许你定义一个动态加载的组件</p><p>这个函数接受一个函数作为其参数，这个函数需要动态调用<code>import()</code>方法，指向你想要懒加载的组件</p><p>返回值是一个<code>Promise</code>，它解析为一个<code>default</code>导出的React组件</p></li><li><p><strong>使用<code>Suspense</code>组件包裹懒加载组件</strong>：<br><code>Suspense</code>组件让你可以在组件树中“等待”某些东西的加载，并且可以指定一个加载指示器（例如加载旋转器），在等待时展示</p></li></ol><p><strong>示例</strong></p><p>假设有一个名为<code>SomeComponent</code>的组件，你希望对其进行懒加载:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用React.lazy和动态import()实现懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./SomeComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* Suspense 组件用来回退到加载指示器（如Spinner） */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">LazyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p><code>Suspense</code>和<code>React.lazy</code>目前仅支持默认导出的组件</p><p>如果你想要懒加载一个命名导出的组件，你需要在导出组件的文件中创建一个中间组件，将命名导出转换成默认导出</p></li><li><p>目前<code>Suspense</code>在服务端渲染(ssr)中只支持加载数据，不支持懒加载组件</p><p>React团队在未来版本中可能会增加这项支持</p></li><li><p>在使用路由时（如<code>react-router-dom</code>），你也可以结合路由懒加载，以实现按路由划分代码，进一步优化应用性能</p></li></ul><p>通过这种方式，你可以显著减少应用的初始加载时间，提升用户体验</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：常用组件"><a href="#Q6：常用组件" class="headerlink" title="Q6：常用组件"></a>Q6：常用组件</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>错误边界</strong></p><p>React部分组件的错误不应该导致整个应用崩溃，为了解决这个问题，React16引入了错误边界</p><p>使用方法：</p><p>React组件在内部定义了getDerivedStateFromError或者componentDidCatch，它就是一个错误边界。getDerviedStateFromError和componentDidCatch的区别是前者展示降级UI，后者记录具体的错误信息，它只能用于class组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  staic <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>:<span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">err,info</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err,info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Oops,err<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">from</span> <span class="string">&quot;./components/ErrorBoundary&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&quot;./components/ComponentA&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentA</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误边界无法捕获自身的错误，也无法捕获事件处理、异步代码(setTimeout、requestAnimationFrame)、服务端渲染的错误</p><p><strong>Portal</strong></p><p>Portal提供了让子组件渲染在除了父组件之外的DOM节点的方式,它接收两个参数，第一个是需要渲染的React元素，第二个是渲染的地方(DOM元素)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child,container)</span><br></pre></td></tr></table></figure><p>用途：弹窗、提示框等</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Ffragments.html%23gatsby-focus-wrapper"><strong>Fragment</strong></a></p><p>Fragment提供了一种将子列表分组又不产生额外DOM节点的方法</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fcontext.html%23gatsby-focus-wrapper"><strong>Context</strong></a></p><p>常规的组件数据传递是使用props，当一个嵌套组件向另一个嵌套组件传递数据时，props会被传递很多层，很多不需要用到props的组件也引入了数据，会造成数据来源不清晰，多余的变量定义等问题，Context提供了一种跨层级组件数据传递的方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;light&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ToolBar</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ToolBar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">ThemeButton</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThemeButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-api.html%23suspense">Suspense</a></p><p>Suspense使组件允许在某些操作结束后再进行渲染，比如接口请求,一般与React.lazy一起使用</p><p>Transition</p><p>Transition是React18引入的一个并发特性，允许操作被中断，避免回到可见内容的Suspense降级方案</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：React-Children-map-和-js-的-map-有什么区别"><a href="#Q7：React-Children-map-和-js-的-map-有什么区别" class="headerlink" title="Q7：React.Children.map 和 js 的 map 有什么区别"></a>Q7：React.Children.map 和 js 的 map 有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>React.Children.map</code> 和JavaScript的数组<code>map</code>方法都用于遍历集合并对集合中的每一项应用一个函数，但它们之间存在一些关键的区别，特别是在应用场景和行为方面</p><p><strong>应用场景的区别</strong></p><ul><li><p><strong>JavaScript的<code>map</code>方法</strong></p><p>这是Array原型上的一个方法，用于遍历数组并对数组中的每一项执行给定的函数，最后返回一个新的数组</p><p>它是JavaScript数组操作的一部分，可以用于任何数组对象</p></li><li><p><strong><code>React.Children.map</code>方法</strong></p><p>这是React专门为处理<code>props.children</code>提供的方法</p><p>props.children<code>可能是不透明的数据结构，比如</code>Array<code>、</code>null<code>、</code>undefined<code>或单一的React元素</code></p><p><code>React.Children.map</code>方法解决了直接使用JavaScript数组的<code>map</code>方法处理<code>props.children</code>可能遇到的问题，它能够为我们智能处理这些情况</p></li></ul><p><strong>行为差异</strong></p><ul><li><p><strong>对于<code>null</code>和<code>undefined</code>的处理</strong></p><p>当<code>props.children</code>为<code>null</code>或<code>undefined</code>时，<code>React.Children.map</code>会直接返回<code>null</code>或<code>undefined</code>，而不会尝试进行任何遍历，这意味着它在处理空子节点时更加安全</p><p>相比之下，JavaScript的<code>map</code>方法在接收到<code>null</code>或<code>undefined</code>作为输入时会抛出异常，因为<code>null</code>和<code>undefined</code>并不是数组，也没有<code>map</code>方法</p></li><li><p><strong>键（key）管理</strong></p><p>当在React中处理多个子元素时，每个子元素应该有一个独一无二的“key”属性</p><p>React.Children.map<code>方法在遍历子元素时能够保留这些“key”的唯一性</code></p><p>在普通的JavaScript数组中使用<code>map</code>方法时，开发者需要手动管理这些“key”</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：React项目如何捕获错误"><a href="#Q8：React项目如何捕获错误" class="headerlink" title="Q8：React项目如何捕获错误"></a>Q8：React项目如何捕获错误</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 项目中，捕获和处理错误是确保应用稳定性和用户体验的重要部分</p><p>React 提供了多种方式来处理错误，包括错误边界（Error Boundaries）和使用 JavaScript 的 <code>try-catch</code> 语句</p><p>以下是一些常见的方法来捕获和处理错误</p><ol><li><p>使用错误边界（Error Boundaries）</p><p>错误边界是一个 React 组件，它可以捕获其子组件树中的 JavaScript 错误，并显示一个回退 UI，而不是崩溃整个应用。错误边界只能捕获生命周期方法和构造函数中的错误，不能捕获事件处理函数中的错误。</p><p><strong>创建一个错误边界组件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 以触发下一次渲染时显示回退 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你可以在这里记录错误信息到日志服务</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error caught by ErrorBoundary:&quot;</span>, error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义回退 UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ErrorBoundary</span>;</span><br></pre></td></tr></table></figure><p><strong>使用错误边界组件</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">from</span> <span class="string">&#x27;./ErrorBoundary&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>捕获事件处理函数中的错误</p><p>错误边界不能捕获事件处理函数中的错误。你需要在事件处理函数中手动使用 <code>try-catch</code> 语句。</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 可能会抛出错误的代码</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error caught in event handler:&#x27;</span>, error);</span><br><span class="line">      <span class="comment">// 你可以在这里显示错误信息或采取其他措施</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>捕获异步代码中的错误</p><p>对于异步代码，如 <code>async</code>/<code>await</code>，你也需要使用 <code>try-catch</code> 语句来捕获错误。</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error caught in async function:&#x27;</span>, error);</span><br><span class="line">      <span class="comment">// 你可以在这里显示错误信息或采取其他措施</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Data will be fetched when component mounts.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用第三方库</p><p>你还可以使用一些第三方库来捕获和处理错误，例如 Sentry 或者 LogRocket，这些库提供了更强大的错误监控和报告功能。</p><p><strong>示例（使用 Sentry）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @sentry/react @sentry/tracing</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">&#x27;@sentry/react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Integrations</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@sentry/tracing&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;YOUR_SENTRY_DSN&#x27;</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">BrowserTracing</span>()],</span><br><span class="line">  <span class="attr">tracesSampleRate</span>: <span class="number">1.0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// Your app code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Sentry</span>.<span class="title function_">withProfiler</span>(<span class="title class_">App</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ol><li><strong>错误边界</strong>：用于捕获组件树中的错误，显示回退 UI</li><li><strong>事件处理函数中的错误</strong>：使用 <code>try-catch</code> 语句</li><li><strong>异步代码中的错误</strong>：使用 <code>try-catch</code> 语句</li><li><strong>第三方库</strong>：如 Sentry，提供更强大的错误监控和报告功能</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：React-memo-和useMemo-的用法是什么有哪些区别"><a href="#Q9：React-memo-和useMemo-的用法是什么有哪些区别" class="headerlink" title="Q9：React.memo()和useMemo()的用法是什么有哪些区别"></a>Q9：React.memo()和useMemo()的用法是什么有哪些区别</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>React.memo()</code></p><p><strong>用法</strong></p><p><code>React.memo()</code> 是一个高阶组件（Higher-Order Component），用于优化函数组件的性能</p><p>它通过对比前后两次的 props 来决定是否重新渲染组件，如果 props 没有变化，组件将不会重新渲染</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering MyComponent&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>MyComponent</code> 的 <code>name</code> prop 没有变化，组件将不会重新渲染。</p><p><strong>用法扩展</strong></p><p>可以通过传递自定义的比较函数来进一步控制渲染逻辑：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(</span><br><span class="line">  <span class="function">(<span class="params">&#123; name, age &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering MyComponent&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;! You are &#123;age&#125; years old.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prevProps.<span class="property">name</span> === nextProps.<span class="property">name</span> &amp;&amp; prevProps.<span class="property">age</span> === nextProps.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>useMemo()</code></p><p><strong>用法</strong></p><p><code>useMemo()</code> 是一个 React Hook，用于在组件中缓存计算结果</p><p>它接受一个创建函数和一个依赖数组，当依赖数组中的值发生变化时，创建函数会重新执行并返回新的值；否则，返回缓存的值</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sortedItems = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Sorting items&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">sort</span>();</span><br><span class="line">  &#125;, [items]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;sortedItems.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>sortedItems</code> 只有在 <code>items</code> 发生变化时才会重新计算，从而避免不必要的计算</p></li></ol><p><strong>区别</strong></p><ol><li><strong>用途不同</strong>：<ul><li><code>React.memo()</code>：用于优化整个函数组件的渲染，通过比较 props 来决定是否重新渲染组件</li><li><code>useMemo()</code>：用于在组件内部缓存计算结果，通过依赖数组来控制何时重新计算</li></ul></li><li><strong>使用场景不同</strong>：<ul><li><code>React.memo()</code>：适用于需要防止不必要的重新渲染的函数组件</li><li><code>useMemo()</code>：适用于需要在渲染过程中进行昂贵计算并希望缓存结果的场景</li></ul></li><li><strong>使用方式不同</strong>：<ul><li><code>React.memo()</code>：是一个高阶组件，包裹在函数组件外部</li><li><code>useMemo()</code>：是一个 Hook，使用在函数组件内部</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h1><h3 id="Q1：useCallback-和-useMemo-的使用场景"><a href="#Q1：useCallback-和-useMemo-的使用场景" class="headerlink" title="Q1：useCallback 和 useMemo 的使用场景"></a>Q1：useCallback 和 useMemo 的使用场景</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useCallback</code> 和 <code>useMemo</code> 是 React 的两个钩子（Hooks），它们的目的都是为了优化组件性能，但它们各自的使用场景和目标有所不同</p><ol><li><p><code>useCallback</code></p><p><code>useCallback</code> 钩子用于缓存函数，以便在组件重渲染时不会重新创建函数实例，减少不必要的渲染</p><p><strong>使用场景:</strong></p><ol><li><p>将函数传递给经过优化的子组件，并使用<code>React.memo</code>或<code>shouldComponentUpdate</code>时，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b], // 仅当a或b改变时，才会重新创建这个函数</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在依赖项列表不经常变化，且函数体内有高开销计算时</p></li></ol></li><li><p><code>`useMemo</code></p><p><code>useMemo</code> 钩子用于缓存计算得出的值，这意味着你可以告诉React仅在某些依赖项改变时才重新计算该值。</p><p><strong>使用场景:</strong></p><ol><li><p>高开销计算：当有一个复杂计算且其依赖项不经常变化时，<code>useMemo</code>可以确保只有在依赖项变化时才重新执行计算</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure></li><li><p>避免渲染时的不必要的子组件渲染</p><p>如果计算得到的值是对象、数组、函数等引用类型，并且这个值被用作子组件的<code>props</code>，则可以使用<code>useMemo</code>来保持引用的稳定，避免子组件做无用的渲染</p></li></ol></li><li><p>注意事项</p><ol><li><code>useCallback</code> 和 <code>useMemo</code> 不保证完全的稳定性，React可能会在内存不足的情况下丢弃缓存值</li><li>过度优化：在没有性能问题的情况下使用这些钩子可能会使你的代码更复杂，不一定总是需要它们</li><li>缓存机制并不是免费的，它们本身也有开销，因此不应该滥用</li></ol></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何实现一个定时器的-hook"><a href="#Q2：如何实现一个定时器的-hook" class="headerlink" title="Q2：如何实现一个定时器的 hook"></a>Q2：如何实现一个定时器的 hook</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>实现一个定时器的 Hook 可以帮助你在 React 函数组件中更方便地使用定时器功能，比如 <code>setTimeout</code> 和 <code>setInterval</code></p><p>下面是一个实现定时器 Hook 的示例，名为 <code>useInterval</code>，它允许你在组件中设置和清除定时器</p><p><strong>实现 <code>useInterval</code> Hook</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Custom hook to use setInterval in functional components</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; <span class="variable">callback</span> - The callback function to be called at each interval</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">delay</span> - The delay in milliseconds for the interval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useInterval</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = <span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the latest callback</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.<span class="property">current</span> = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the interval</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">      savedCallback.<span class="title function_">current</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(tick, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useInterval;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>useInterval</code> Hook</strong></p><p>下面是一个使用 <code>useInterval</code> Hook 的示例组件。这个组件每秒更新一次计数器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useInterval <span class="keyword">from</span> <span class="string">&#x27;./useInterval&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Timer</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li><p><strong>useRef</strong></p><p>我们使用 <code>useRef</code> 来保存最新的回调函数，以便在定时器触发时调用最新的回调</p></li><li><p><strong>useEffect (保存回调)</strong></p><p>在第一个 <code>useEffect</code> 中，我们将最新的回调函数保存到 <code>savedCallback</code> 中</p><p>每当回调函数变化时，这个 <code>useEffect</code> 会被触发，确保 <code>savedCallback</code> 始终是最新的</p></li><li><p><strong>useEffect (设置定时器)</strong></p><p>第二个 <code>useEffect</code> 设置了定时器</p><p>每当 <code>delay</code> 变化时，这个 <code>useEffect</code> 会被触发</p><p>如果 <code>delay</code> 不为 <code>null</code>，我们设置一个新的定时器，并在组件卸载或 <code>delay</code> 变化时清除之前的定时器</p></li></ol><p><strong>注意事项</strong></p><ol><li><p><strong>清除定时器</strong></p><p>在 <code>useEffect</code> 中返回一个清除定时器的函数，以确保在组件卸载或 <code>delay</code> 变化时，定时器被正确清除，避免内存泄漏</p></li><li><p><strong>依赖项</strong></p><p>确保在第二个 <code>useEffect</code> 中将 <code>delay</code> 作为依赖项传递，以便在 <code>delay</code> 变化时重新设置定时器</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：useState-的-state-是否可以直接修改？是否可以引起组件渲染"><a href="#Q3：useState-的-state-是否可以直接修改？是否可以引起组件渲染" class="headerlink" title="Q3：useState()的 state 是否可以直接修改？是否可以引起组件渲染"></a>Q3：useState()的 state 是否可以直接修改？是否可以引起组件渲染</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，<code>useState</code> 提供的状态值是不可变的，不能直接修改</p><p>直接修改状态值不仅违反了 React 的最佳实践，而且不会触发组件的重新渲染</p><p>这是因为 React 依赖于状态的不可变性来检测状态的变化并决定何时重新渲染组件</p><p><strong>为什么不能直接修改状态</strong></p><p>React 需要知道状态何时发生变化，以便重新渲染组件</p><p>如果直接修改状态，React 无法检测到变化，因为它没有办法知道状态的引用是否发生了变化</p><p>这会导致组件的 UI 不会更新，甚至可能引起难以调试的错误</p><p><strong>示例</strong></p><p>假设你有以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">incrementDirectly</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count += <span class="number">1</span>; <span class="comment">// 直接修改状态（这是错误的做法）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 这里会显示更新后的 count 值</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">incrementProperly</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 使用 setCount 更新状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementDirectly&#125;</span>&gt;</span>Increment Directly<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementProperly&#125;</span>&gt;</span>Increment Properly<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，点击 <code>Increment Directly</code> 按钮不会导致组件重新渲染，因为直接修改 <code>count</code> 不会通知 React 状态已经改变</p><p>相反，点击 <code>Increment Properly</code> 按钮会正确更新状态并触发组件重新渲染</p><p><strong>正确的状态更新方式</strong></p><p>始终使用 <code>setState</code> 函数（<code>useState</code> 返回的更新函数）来更新状态</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的状态更新方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li><strong>不可变性</strong>：<code>useState</code> 提供的状态值是不可变的，不能直接修改</li><li><strong>状态更新</strong>：始终使用 <code>setState</code> 函数来更新状态</li><li><strong>组件渲染</strong>：直接修改状态不会触发组件重新渲染，正确的状态更新方式会触发重新渲染</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：SetState是同步还是异步的"><a href="#Q4：SetState是同步还是异步的" class="headerlink" title="Q4：SetState是同步还是异步的"></a>Q4：SetState是同步还是异步的</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>setState是一个异步方法，但是在setTimeout/setInterval等定时器里逃脱了React对它的掌控，变成了同步方法</p><p>实现机制类似于vue的$nextTick和浏览器的事件循环机制，每个setState都会被react加入到任务队列，多次对同一个state使用setState只会返回最后一次的结果，因为它不是立刻就更新，而是先放在队列中，等时机成熟在执行批量更新</p><p>React18以后，使用了createRoot api后，所有setState都是异步批量执行的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：React-Hooks是什么"><a href="#Q5：React-Hooks是什么" class="headerlink" title="Q5：React Hooks是什么"></a>Q5：React Hooks是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Hooks 是 React 16.8 引入的一种新特性，它允许你在函数组件中使用状态和其他 React 特性，而不需要编写类组件</p><p>Hooks 提供了一种更简洁、更直观的方式来管理组件的状态和副作用</p><p>以下是一些常用的 React Hooks：</p><ol><li><p><code>useState</code></p><p><code>useState</code> 是一个 Hook，用于在函数组件中添加状态管理</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useEffect</code></p><p><code>useEffect</code> 是一个 Hook，用于在函数组件中处理副作用，例如数据获取、订阅或手动更改 DOM</p><p>它相当于类组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的组合</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted or updated&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组作为依赖项，表示只在挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Example Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useContext</code></p><p><code>useContext</code> 是一个 Hook，用于在函数组件中使用上下文</p><p>它允许你在组件树中传递数据，而不需要显式地通过每一层组件传递 props</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;Hello, World!&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>useReducer</code></p><p><code>useReducer</code> 是一个 Hook，用于在函数组件中管理复杂的状态逻辑</p><p>它类似于 Redux 的 reducer 概念</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useRef</code></p><p><code>useRef</code> 是一个 Hook，用于在函数组件中访问 DOM 元素或保存一个可变值，该值在整个组件的生命周期内保持不变</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TextInput</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">focusInput</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;focusInput&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useMemo</code></p><p><code>useMemo</code> 是一个 Hook，用于在函数组件中优化性能，通过记住计算结果，只有在依赖项变化时才重新计算</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ExpensiveCalculation</span> = (<span class="params">&#123; num &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Calculating...&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Result: &#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>`useCallback``</p><p><code>`useCallback</code> 是一个 Hook，用于在函数组件中优化性能，通过记住函数定义，只有在依赖项变化时才重新创建函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button rendered&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 useCallback 记住这个回调函数，只有当 count 改变时才重新创建</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：React-事件和原生事件的执行顺序"><a href="#Q6：React-事件和原生事件的执行顺序" class="headerlink" title="Q6：React)事件和原生事件的执行顺序"></a>Q6：React)事件和原生事件的执行顺序</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，事件处理机制与原生 DOM 事件处理机制有一些不同</p><p>这些差异包括事件代理（event delegation）和合成事件（synthetic events）</p><p>理解 React 事件和原生事件的执行顺序有助于更好地调试和优化 React 应用</p><p><strong>React 事件系统</strong></p><p>React 使用合成事件（Synthetic Events）来处理事件</p><p>这种机制在所有浏览器中提供一致的事件行为，并且通过事件代理将所有事件处理程序附加到组件树的根节点上，从而提高性能</p><p><strong>执行顺序</strong></p><p>当一个事件被触发时，React 事件和原生事件的执行顺序如下：</p><ol><li><p><strong>原生事件捕获阶段</strong></p><p>在事件捕获阶段，事件从文档的根节点向下传播到目标元素</p><p>这时，任何在捕获阶段注册的原生事件处理程序都会被执行</p></li><li><p><strong>React 事件捕获阶段</strong></p><p>React 事件处理程序也可以在捕获阶段执行</p><p>如果你在 React 中使用捕获事件处理程序（通过在事件名后加 <code>Capture</code> 例如 <code>onClickCapture</code>），这些处理程序会在原生事件捕获阶段之后执行</p></li><li><p><strong>原生事件目标阶段</strong></p><p>在事件目标阶段，事件在目标元素上被触发，任何在目标元素上注册的原生事件处理程序会被执行</p></li><li><p><strong>React 事件目标阶段</strong></p><p>React 的合成事件处理程序会在目标阶段执行</p><p>这些处理程序会在原生事件处理程序之后执行</p></li><li><p><strong>原生事件冒泡阶段</strong></p><p>在事件冒泡阶段，事件从目标元素向上传播到文档的根节点</p><p>这时，任何在冒泡阶段注册的原生事件处理程序都会被执行</p></li><li><p><strong>React 事件冒泡阶段</strong></p><p>React 事件处理程序也可以在冒泡阶段执行</p><p>如果你在 React 中使用常规事件处理程序（例如 <code>onClick</code>），这些处理程序会在原生事件冒泡阶段之后执行</p></li></ol><p><strong>示例代码</strong></p><p>以下是一个示例，用于演示 React 事件和原生事件的执行顺序：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleNativeClickCapture</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Native Capture&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleNativeClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Native Bubble&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClick);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClickCapture, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClick);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClickCapture, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleReactClickCapture</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React Capture&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleReactClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React Bubble&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">id</span>=<span class="string">&quot;native-button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClickCapture</span>=<span class="string">&#123;handleReactClickCapture&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;handleReactClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        Click Me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><strong>执行顺序解释</strong></p><ol><li><strong>Native Capture</strong>：原生事件捕获阶段</li><li><strong>React Capture</strong>：React 事件捕获阶段</li><li><strong>Native Bubble</strong>：原生事件目标和冒泡阶段</li><li><strong>React Bubble</strong>：React 事件目标和冒泡阶段</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：为什么不能在循环、条件或嵌套函数中调用Hooks"><a href="#Q7：为什么不能在循环、条件或嵌套函数中调用Hooks" class="headerlink" title="Q7：为什么不能在循环、条件或嵌套函数中调用Hooks"></a>Q7：为什么不能在循环、条件或嵌套函数中调用Hooks</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，Hooks 是一套强大的 API，用于在函数组件中管理状态和副作用</p><p>然而，React 对 Hooks 的使用有一些严格的规则，其中之一就是不能在循环、条件语句或嵌套函数中调用 Hooks</p><p>这是因为 React 需要确保 Hooks 的调用顺序在每次渲染时都是一致的</p><p><strong>原因</strong></p><p>React 依赖于 Hooks 调用顺序来正确地管理状态和副作用</p><p>如果你在循环、条件语句或嵌套函数中调用 Hooks，Hooks 的调用顺序可能会在不同的渲染周期中发生变化，从而导致不可预测的行为和错误</p><p><strong>具体原因如下：</strong></p><ol><li><p><strong>Hooks 的调用顺序</strong></p><p>React 使用一个内部的调用栈来跟踪每个组件中的 Hooks 调用</p><p>如果 Hooks 的调用顺序在不同的渲染周期中发生变化，React 就无法正确地将状态和副作用与相应的组件实例对应起来</p></li><li><p><strong>状态和副作用的管理</strong></p><p>Hooks 是用来管理组件的状态和副作用的</p><p>如果它们的调用顺序不一致，React 可能会错误地更新状态或执行副作用，从而导致应用程序的行为异常</p></li></ol><p><strong>代码示例</strong></p><p>以下是一些违反规则的示例：</p><p><strong>在循环中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在条件语句中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在嵌套函数中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someFunction</span>();</span><br></pre></td></tr></table></figure><p><strong>正确的用法</strong></p><p>Hooks 应该在函数组件的顶层调用，确保每次渲染时它们的调用顺序都是一致的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确的用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以在条件语句中使用状态或副作用，但不能在条件语句中调用 Hooks</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行一些逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React 的官方规则</strong></p><p>React 官方提供了两条使用 Hooks 的规则：</p><ol><li><strong>只在最顶层调用 Hooks</strong>：不要在循环、条件语句或嵌套函数中调用 Hooks</li><li><strong>只在 React 函数组件和自定义 Hooks 中调用 Hooks</strong>：不要在普通的 JavaScript 函数中调用 Hooks</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：useRef-ref-forwardsRef-的区别是什么"><a href="#Q8：useRef-ref-forwardsRef-的区别是什么" class="headerlink" title="Q8：useRef/ref/forwardsRef 的区别是什么"></a>Q8：useRef/ref/forwardsRef 的区别是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>useRef</code></p><p><code>useRef</code> 是一个 React Hook，主要用于在函数组件中创建一个可变的引用对象</p><p>它可以用来持久化某个值，或者引用一个 DOM 元素</p><p><strong>用途</strong></p><ol><li>持久化某个值，不会因为组件的重新渲染而丢失</li><li>直接访问 DOM 元素</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ref</code></p><p><code>ref</code> 是一个属性，用于在类组件中创建对 DOM 元素或 React 组件实例的引用</p><p>它可以通过 <code>React.createRef</code> 创建</p><p><strong>用途</strong></p><ol><li>在类组件中引用 DOM 元素或组件实例</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>forwardsRef</code> </p><p><code>forwardRef</code> 是一个高阶组件，用于将 ref 转发到子组件</p><p>它允许父组件通过 ref 直接访问子组件的 DOM 元素或组件实例</p><p><strong>用途</strong></p><ol><li>在高阶组件中转发 ref</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以接收 ref 的子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyInput</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li><strong><code>useRef</code></strong>: 用于在函数组件中创建一个可变的引用对象，主要用于持久化某个值或引用 DOM 元素</li><li><strong><code>ref</code></strong>: 用于在类组件中创建对 DOM 元素或组件实例的引用，通过 <code>React.createRef</code> 创建</li><li><strong><code>forwardRef</code></strong>: 用于将 ref 转发到子组件，允许父组件通过 ref 直接访问子组件的 DOM 元素或组件实例</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：useEffect-的第二个参数-传空数组和传依赖数组有什么区别"><a href="#Q9：useEffect-的第二个参数-传空数组和传依赖数组有什么区别" class="headerlink" title="Q9：useEffect 的第二个参数,传空数组和传依赖数组有什么区别"></a>Q9：useEffect 的第二个参数,传空数组和传依赖数组有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>传空数组 (<code>[]</code>)</p><p>当你将一个空数组作为 <code>useEffect</code> 的第二个参数时，意味着这个副作用只会在组件挂载（即第一次渲染）和卸载时执行一次</p><p>它类似于类组件中的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 生命周期方法</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>MyComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><strong>挂载时</strong>: <code>console.log(&#39;Component mounted&#39;)</code> 会在组件挂载时执行</li><li><strong>卸载时</strong>: 返回的清理函数 <code>console.log(&#39;Component will unmount&#39;)</code> 会在组件卸载时执行</li></ul></li><li><p>传依赖数组（如 <code>[dependency1, dependency2]</code>）</p><p>当你将一个包含依赖项的数组作为 <code>useEffect</code> 的第二个参数时，意味着这个副作用会在组件挂载以及依赖项发生变化时执行</p><p>每次依赖项发生变化时，副作用都会重新执行</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect executed because count changed&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cleanup executed because count changed&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><strong>挂载时</strong>: <code>console.log(&#39;Effect executed because count changed&#39;)</code> 会在组件挂载时执行</li><li><strong>依赖项变化时</strong>: 当 <code>count</code> 发生变化时，副作用会重新执行</li><li><strong>清理副作用</strong>: 返回的清理函数 <code>console.log(&#39;Cleanup executed because count changed&#39;)</code> 会在组件卸载或依赖项变化之前执行</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>传空数组 (<code>[]</code>)</strong>:<ul><li>副作用只会在组件挂载和卸载时执行一次</li><li>类似于类组件中的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code></li></ul></li><li><strong>传依赖数组（如 <code>[dependency1, dependency2]</code>）</strong>:<ul><li>副作用会在组件挂载时执行，并且在任意一个依赖项发生变化时重新执行</li><li>类似于类组件中的 <code>componentDidUpdate</code>，同时也会在组件卸载时执行清理函数</li></ul></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：实现-个-useTimeout-Hook"><a href="#Q10：实现-个-useTimeout-Hook" class="headerlink" title="Q10：实现-个 useTimeout Hook"></a>Q10：实现-个 useTimeout Hook</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useTimeout</code> 是可以在函数式组件中，处理 <code>setTimeout</code> 计时器函数</p><p><strong>解决了什么问题？</strong></p><p>如果直接在函数式组件中使用 <code>setTimeout</code> ，会遇到以下问题：</p><ul><li>多次调用setTimeout</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">   <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="number">1</span>);  </span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">       <span class="title function_">setState</span>(state + <span class="number">1</span>);  </span><br><span class="line">   &#125;, <span class="number">3000</span>);  </span><br><span class="line">   <span class="keyword">return</span> (  </span><br><span class="line">       <span class="comment">// 我们原本的目的是在页面渲染完3s后修改一下state，但是你会发现当state+1后，触发了页面的重新渲染，就会重新有一个3s的定时器出现来给state+1，既而变成了每3秒+1。  </span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;state&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">   );  </span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure><ul><li>hooks 的闭包缺陷</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">const</span> [countTimeout, setCountTimeout] = <span class="title function_">useState</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">          <span class="title function_">setCountTimeout</span>(count)  </span><br><span class="line">      &#125;, <span class="number">3000</span>)  </span><br><span class="line">      <span class="title function_">setCount</span>(<span class="number">5</span>)  </span><br><span class="line">  &#125;, [])  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">       <span class="comment">//count发生了变化，但是3s后setTimout的count却还是0  </span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          Count: &#123;count&#125;  </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">br</span> /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          setTimeout Count: &#123;countTimeout&#125;  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>useTimeout 实现</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTimeout</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memorizeCallback = <span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    memorizeCallback.<span class="property">current</span> = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        memorizeCallback.<span class="title function_">current</span>();</span><br><span class="line">      &#125;, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>如何使用</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// callback 回调函数， delay 延迟时间</span></span><br><span class="line"><span class="title function_">useTimeout</span>(callback, delay);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="Q1：React-中为什么不直接使用requestldleCallback"><a href="#Q1：React-中为什么不直接使用requestldleCallback" class="headerlink" title="Q1：React 中为什么不直接使用requestldleCallback"></a>Q1：React 中为什么不直接使用requestldleCallback</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>requestIdleCallback</code> 是一个允许开发者在主线程空闲时运行低优先级函数的 Web API</p><ol><li><p>一致性问题</p><ul><li><p>由于 <code>requestIdleCallback</code> 的执行时机依赖于浏览器的空闲周期，这会导致在不同浏览器和设备上有不一致的行为</p><p>React 旨在提供一个一致且可预测的性能表现，以确保开发者能够构建跨平台的、具有一致体验的应用</p><p>这种不确定性是 React 选择不直接采用 <code>requestIdleCallback</code> 的一个主要原因</p></li></ul></li><li><p>实时性问题</p><ul><li><p>React 的核心之一是能够快速响应用户输入并立即更新 UI</p><p><code>requestIdleCallback</code> 执行的时间可能不足以满足这种实时性需求，尤其是在高优先级的更新（如动画或响应用户输入）应该立即发生时</p><p>这种潜在的延迟对于保持良好的用户体验来说是不可接受的。</p></li></ul></li><li><p>调度器控制</p><ul><li><p>React 内部实现了一个任务调度器，负责根据任务的优先级来管理和调度它们的执行</p><p>这样的设计允许 React 在保持用户界面响应性的同时进行高效的背景更新</p><p>直接使用 <code>requestIdleCallback</code> 可能会干扰这种精细调度策略，从而引起不可预测的行为</p></li><li><p>为了克服这些挑战，React 引入了 Scheduler 模块</p><p>Scheduler 模块使得 React 能够以更细粒度的方式安排任务的执行，确保关键任务（如用户输入响应）得到及时处理，同时也使得可以在浏览器空闲时执行低优先级任务</p><p>这种方法提供了更高的控制度和一致性，同时也保留了在合适的时机执行后台任务的能力</p></li></ul></li><li><p>总结</p><ul><li><p>综上所述，虽然 <code>requestIdleCallback</code> 提供了在浏览器空闲时执行任务的有趣机制，但对于 React 这样需要高度一致性、响应实时性，并且具有细粒度调度控制要求的库而言，直接使用它并不符合需求</p><p>React 通过实现 Scheduler 模块，提供了一个更加适配其内部机制的解决方案，既保证了应用的响应性和用户体验，也实现了背景任务的有效管理。这种设计选择反映了 React 团队对于性能优化和用户体验优先级的综合考虑</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：React-中为什么要使用-Hook"><a href="#Q2：React-中为什么要使用-Hook" class="headerlink" title="Q2：React 中为什么要使用 Hook"></a>Q2：React 中为什么要使用 Hook</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>简化代码结构</p><p>Hooks 使得函数组件可以处理状态和副作用，从而避免了类组件中复杂的生命周期方法和 <code>this</code> 绑定问题</p><p>函数组件通常更简洁、更直观</p></li><li><p>逻辑复用</p><p>在类组件中，共享状态逻辑通常需要使用高阶组件（HOC）或 Render Props，这可能导致组件层级嵌套过深</p><p>Hooks 允许你通过自定义 Hook 来提取状态逻辑，从而实现更好的逻辑复用和代码组织</p></li><li><p>更好的代码可读性和可维护性</p><p>使用 Hooks 可以将组件的逻辑按功能分块，而不是按生命周期方法分块</p><p>这使得代码更容易理解和维护</p><p>例如，一个自定义 Hook 可以封装数据获取逻辑，而另一个自定义 Hook 可以封装表单处理逻辑</p></li><li><p>避免类组件的复杂性</p><p>类组件中的 <code>this</code> 关键字使用容易出错，特别是对于初学者</p><p>Hooks 通过函数组件完全避免了 <code>this</code> 的使用，从而减少了错误和困惑</p></li><li><p>更细粒度的状态控制</p><p>Hooks 提供了更细粒度的状态控制</p><p>你可以使用多个 <code>useState</code> 或 <code>useReducer</code> Hook 来管理不同的状态变量，而不是将所有状态都放在一个大的 state 对象中</p></li><li><p>更好的性能优化</p><p>Hooks 使得 React 的性能优化（如 <code>useMemo</code> 和 <code>useCallback</code>）更加直观和易于使用，从而减少不必要的重新渲染和性能开销</p></li><li><p>常用的 Hooks</p><ul><li><p><code>useState</code>: 用于在函数组件中添加状态</p></li><li><p><code>useEffect</code>: 用于在函数组件中处理副作用（如数据获取、订阅等）</p></li><li><p><code>useContext</code>: 用于在函数组件中使用 React 的上下文</p></li><li><p><code>useReducer</code>: 用于在函数组件中管理复杂的状态逻辑</p></li><li><p><code>useMemo</code> 和 <code>useCallback</code>: 用于性能优化，避免不必要的计算和函数创建</p></li><li><p><code>useRef</code>: 用于访问 DOM 元素或保持不需要重新渲染的变量</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：key-的作用是什么"><a href="#Q3：key-的作用是什么" class="headerlink" title="Q3：key 的作用是什么"></a>Q3：key 的作用是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在React中，<code>key</code> 是一个特殊的属性，你应该在映射组件的列表时包含它</p><p>它的主要作用是帮助React识别哪些项已经改变、添加或者删除的</p><p>正确使用<code>key</code>可以带来一些重要的性能优化</p><p><strong>作用</strong></p><ol><li><p><strong>唯一性</strong></p><p>React使用<code>key</code>来匹配组件树上的组件实例与重新渲染过程中的新元素</p><p>key`需要是唯一的，以便于区分同一父元素下的不同子元素</p></li><li><p><strong>重用与重排序</strong></p><p>当组件的列表顺序改变时，<code>key</code>可以帮助React确定哪些组件可以保留并重新排序，而不是销毁重新创建</p><p>这可以提高效率和性能</p></li><li><p><strong>状态保留</strong></p><p>如果组件状态需要跨渲染周期保持一致，<code>key</code>用于追踪哪些组件是保持不变的</p><p>这意味着如果组件的<code>key</code>没有改变，它的状态会保持不变</p></li><li><p><strong>避免不必要的重新渲染</strong></p><p>当列表变动时，如果没有<code>key</code>，React将重新渲染整个列表，增加开销</p><p>合适的<code>key</code>确保组件能够正确地被复用，只有变动的部分被重新渲染</p></li></ol><p><strong>错误用法</strong></p><ul><li><p><strong>使用索引作为<code>key</code></strong></p><p>在一些情况下，使用数组索引作为<code>key</code>是可以的，比如静态列表或者不进行排序和修改的列表</p><p>但是如果项的顺序可能会改变，这会导致性能问题甚至错误的行为，因为React依赖于<code>key</code>来识别子元素</p></li><li><p><strong>随机生成的<code>key</code></strong></p><p>如果<code>key</code>是在每次渲染时生成的（如使用<code>Math.random()</code>），这将导致组件的不必要重渲染，因为React会认为<code>key</code>在每次渲染时都是新的</p></li></ul><p>在选择<code>key</code>的时候，最好使用能够代表列表项唯一性的字符串，这通常是来自数据本身的ID或者哈希值</p><p>这样做不仅保证了性能，也保证了组件状态的稳定</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：基于-React-框架的特点，可以有哪些优化措施"><a href="#Q4：基于-React-框架的特点，可以有哪些优化措施" class="headerlink" title="Q4：基于 React 框架的特点，可以有哪些优化措施"></a>Q4：基于 React 框架的特点，可以有哪些优化措施</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React是一个用于构建用户界面的JavaScript库，特别强调了组件化开发和声明式编程</p><p>虽然React自身提供了高效的渲染策略，但在实际开发中我们仍然可以通过多种方式来进一步优化应用性能和用户体验</p><p>以下是一些常用的React应用优化措施：</p><ol><li><p>使用<code>React.memo</code>优化组件渲染</p><p><code>React.memo</code>是一个高阶组件，它仅在组件的props发生变化时才重新渲染组件，从而避免了不必要的渲染</p></li><li><p>懒加载组件</p><p>对于大型应用，采用代码拆分和组件的懒加载非常有效</p><p>可以使用<code>React.lazy</code>和<code>Suspense</code>来按需加载组件，减少初始加载时间</p></li><li><p>使用<code>shouldComponentUpdate</code>或<code>React.PureComponent</code></p><p>在类组件中，通过实现<code>shouldComponentUpdate</code>方法，你可以控制组件是否需要更新</p><p><code>React.PureComponent</code>提供了一个浅比较的<code>shouldComponentUpdate</code>实现方式，如果你的组件渲染完全由props和state决定，这是一个很好的选择</p></li><li><p>键值(Key)优化</p><p>在渲染列表时，合理使用<code>key</code>可以帮助React识别哪些元素改变了、添加或删除</p><p>这可以提高渲染效率，减少重新渲染的开销</p></li><li><p>合理使用状态(State)和副作用(Effect)</p><ul><li>避免在一个组件内部过度使用状态，尤其是当数据可以通过props传递时</li><li>使用<code>useEffect</code>的依赖数组来精确控制副作用的执行时机，避免不必要的执行</li></ul></li><li><p>使用Context提供者和消费者模式优化</p><p>使用React的Context API可以避免<code>props</code>的层层传递，但是若不当使用也可能造成不必要的渲染</p><p>合理使用<code>useContext</code>钩子或<code>Context.Consumer</code>可以优化这一点</p></li><li><p>避免匿名函数和对象字面量作为props</p><p>组件的props中使用匿名函数和对象字面量会在每次父组件渲染时创建新的实例，这可能导致不必要的子组件渲染</p><p>可以通过使用useCallback和useMemo来避免这种情况</p></li><li><p>动态导入库和代码</p><p>利用<code>import()</code>函数可以实现对代码和库的动态导入，进一步减少应用的初始大小。</p></li><li><p>服务端渲染(SSR)</p><p>通过服务端渲染可以提高首屏加载速度，提升SEO性能。React提供了库如Next.js支持服务端渲染</p></li><li><p>使用Webpack优化构建</p><p>使用Webpack进行代码拆分，提取公共库，压缩代码，利用缓存策略等技术可以减少应用的加载时间</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：react-router-和-react-router-dom-的有什么区别"><a href="#Q5：react-router-和-react-router-dom-的有什么区别" class="headerlink" title="Q5：react-router 和 react-router-dom 的有什么区别"></a>Q5：react-router 和 react-router-dom 的有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Router 是一个用于在 React 应用中实现路由功能的库，而 <code>react-router-dom</code> 是其专门为浏览器环境设计的一个子包</p><p>为了更好地理解它们之间的区别，下面是详细的解释：</p><p><strong>React Router</strong></p><p><code>react-router</code> 是 React Router 库的核心包，包含了实现路由功能的核心逻辑</p><p>这个包可以在各种环境中使用，如浏览器、React Native、Electron 等</p><p>它提供了基础的路由组件和 API，例如：</p><ul><li><code>Router</code></li><li><code>Route</code></li><li><code>Switch</code></li><li><code>Redirect</code></li><li><code>Link</code></li><li><code>NavLink</code></li></ul><p><strong>React Router DOM</strong></p><p><code>react-router-dom</code> 是专门为浏览器环境设计的一个包，它依赖于 <code>react-router</code>，并在其基础上添加了一些特定于浏览器的功能和组件</p><p>这个包提供了浏览器特有的路由组件和 API，例如：</p><ul><li><code>BrowserRouter</code></li><li><code>HashRouter</code></li><li><code>Link</code></li><li><code>NavLink</code></li><li><code>Prompt</code></li><li><code>Redirect</code></li></ul><p><strong>主要区别</strong></p><ol><li><strong>使用环境</strong>：<ul><li><code>react-router</code> 是核心库，可以在多种环境中使用</li><li><code>react-router-dom</code> 是专门为浏览器环境设计的</li></ul></li><li><strong>组件</strong>：<ul><li><code>react-router</code> 提供了基本的路由组件，如 <code>Route</code>、<code>Switch</code> 等</li><li><code>react-router-dom</code> 在 <code>react-router</code> 的基础上，提供了浏览器特有的组件，如 <code>BrowserRouter</code>、<code>HashRouter</code> 等</li></ul></li><li><strong>依赖关系</strong>：<ul><li><code>react-router-dom</code> 依赖于 <code>react-router</code>，并扩展了其功能</li></ul></li></ol><p><strong>示例</strong></p><p>以下是一个使用 <code>react-router-dom</code> 的简单示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">About</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">About</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>BrowserRouter</code> 是 <code>react-router-dom</code> 提供的一个组件，用于在浏览器环境中实现路由</li><li><code>Link</code> 是 <code>react-router-dom</code> 提供的用于导航的组件</li><li><code>Route</code> 和 <code>Switch</code> 是 <code>react-router</code> 提供的基础路由组件</li></ul><p><strong>总结</strong></p><ul><li><strong><code>react-router</code></strong> 是 React Router 的核心包，包含了基础的路由功能，可以在多种环境中使用</li><li><strong><code>react-router-dom</code></strong> 是专门为浏览器环境设计的包，扩展了 <code>react-router</code> 的功能，提供了浏览器特有的路由组件</li></ul>
              </div>
            </details>
<p><br/></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io">Nanami Kento</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io/posts/f967bad7/">https://wutiaowu5t5.github.io/posts/f967bad7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wutiaowu5t5.github.io" target="_blank">Nanami Kento</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/376fa3ef/" title="《Vue 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Z42qJc7bzuGo9Bp.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Vue 面试题》</div></div></a></div><div class="next-post pull-right"><a href="/posts/75cf67a1/" title="《前端工程化 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/9UW3r8qCnNYgXAz.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《前端工程化 面试题》</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/179be34f/" title="《Css 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/ulgHOCdRZz2QP4B.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-12</div><div class="title">《Css 面试题》</div></div></a></div><div><a href="/posts/556519a1/" title="《Html 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/qvzTE9WGspLbhtO.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-11</div><div class="title">《Html 面试题》</div></div></a></div><div><a href="/posts/376fa3ef/" title="《Vue 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Z42qJc7bzuGo9Bp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="title">《Vue 面试题》</div></div></a></div><div><a href="/posts/cb2af883/" title="《手写JavaScript 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-19</div><div class="title">《手写JavaScript 面试题》</div></div></a></div><div><a href="/posts/75cf67a1/" title="《前端工程化 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/9UW3r8qCnNYgXAz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">《前端工程化 面试题》</div></div></a></div><div><a href="/posts/ed392c85/" title="面经汇总"><img class="cover" src="https://s2.loli.net/2024/04/09/jF8lya3XT7uJMsD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">面经汇总</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nanami Kento</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/wutiaowu5t5"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:Gojo5t5Satoru@outlook.com" target="_blank" title="Gojo5t5Satoru@outlook.com"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="wxid-ws0099"><i class="fab fa-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="1987053649"><i class="fab fa-qq" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The blog is still under construction, stay tuned!</div></div><div class="card-widget card-visitor"><div class="item-headline"><i class="fas fa-location-arrow"></i><span>来访者</span></div><div class="item-content"><div id="welcome-info"></div><script data-pjax>var longitude="114.03028607368469";var Latitude="22.610554348016493";var txkey="NAOBZ-ETV3Z-U6FXM-ZJOMI-62Q7K-I6B4H";var ipLoacation;window.onload = () => {welcometxmap()};</script></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9AReact-Portals-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">Q1：React Portals 有什么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9AReact18%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9B%B4%E6%96%B0"><span class="toc-text">Q2：React18有哪些更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Areact-%E5%92%8C-react-dom-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">Q3：react 和 react-dom 是什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-react-%E9%9C%80%E8%A6%81-fiber-%E6%9E%B6%E6%9E%84%EF%BC%8C%E8%80%8C-Vue-%E5%8D%B4%E4%B8%8D%E9%9C%80%E8%A6%81"><span class="toc-text">Q4：为什么 react 需要 fiber 架构，而 Vue 却不需要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9AJSX%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E5%92%8CJS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q5：JSX是什么，它和JS有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E6%97%B6%EF%BC%8C%E7%BB%84%E4%BB%B6%E4%BC%9A%E6%B8%B2%E6%9F%93%E4%B8%A4%E6%AC%A1"><span class="toc-text">Q6：为什么在本地开发时，组件会渲染两次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A%E8%99%9A%E6%8B%9F-dom-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E7%9C%9F%E5%AE%9E-dom-%E5%92%8C%E8%99%9A%E6%8B%9F-dom%EF%BC%8C%E8%B0%81%E5%BF%AB"><span class="toc-text">Q7：虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q8：什么是合成事件，与原生事件有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%9C%A8React%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%B5%81%E5%8A%A8"><span class="toc-text">Q9：数据如何在React组件中流动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9Afiber%E6%9E%B6%E6%9E%84"><span class="toc-text">Q10：fiber架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9AReact%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">Q11：React的设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9A%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-text">Q12：类组件和函数式组件有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9Amobx%E5%92%8C-redux-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q13：mobx和 redux 有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E7%AE%80%E8%BF%B0React%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Q1：简述React的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-text">Q2：并发模式是如何执行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9AuseEffect-%E7%9A%84%E6%B8%85%E9%99%A4%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C"><span class="toc-text">Q3：useEffect()的清除机制是什么？在什么时候执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C-useState-%EF%BC%8C%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%90%97"><span class="toc-text">Q4：多次执行 useState()，会触发多次更新吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9AReact-%E7%9A%84-diff-%E8%BF%87%E7%A8%8B"><span class="toc-text">Q5：React 的 diff 过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9ARedux-%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q6：Redux 遵循的三个原则是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A%E4%BD%A0%E5%AF%B9%E2%80%9C%E5%8D%95%E4%B8%80%E4%BA%8B%E5%AE%9E%E6%9D%A5%E6%BA%90%E2%80%9D%E6%9C%89%E4%BB%80%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-text">Q7：你对“单一事实来源”有什么理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9ARedux-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="toc-text">Q8：Redux 有哪些优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9AReact%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">Q9：React事件机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9AReact-Router%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">Q10：React-Router工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9AReact-Render%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A2%AB%E8%A7%A6%E5%8F%91"><span class="toc-text">Q11：React Render方法的原理是什么？什么时候会被触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9A%E5%AF%B9Redux%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="toc-text">Q12：对Redux的理解以及它的工作原理以及怎么使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9Ajsx%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9C%9F%E5%AE%9EDom%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">Q13：jsx转换成真实Dom的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9AReact%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q14：React服务端渲染怎么做？原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-React-Hook%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">Q15：说说你对 React Hook的闭包陷阱的理解，有哪些解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q16%EF%BC%9AReact-Router%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q16：React Router有几种模式？实现原理是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E5%AD%90%E7%BB%84%E4%BB%B6%E6%98%AF%E4%B8%80%E4%B8%AA-Portal%EF%BC%8C%E5%8F%91%E7%94%9F%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%83%BD%E5%86%92%E6%B3%A1%E5%88%B0%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%97"><span class="toc-text">Q1：子组件是一个 Portal，发生点击事件能冒泡到父组件吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9Aprops-%E7%9A%84%E5%8F%98%E5%8A%A8%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E5%BC%95%E8%B5%B7-state-hook-%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8A%A8"><span class="toc-text">Q2：props 的变动，是否会引起 state hook 中数据的变动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">Q3：什么是受控组件和非受控组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q4：高阶组件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">Q5：如何实现组件的懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-text">Q6：常用组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9AReact-Children-map-%E5%92%8C-js-%E7%9A%84-map-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q7：React.Children.map 和 js 的 map 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9AReact%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF"><span class="toc-text">Q8：React项目如何捕获错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9AReact-memo-%E5%92%8CuseMemo-%E7%9A%84%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-text">Q9：React.memo()和useMemo()的用法是什么有哪些区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%92%A9%E5%AD%90"><span class="toc-text">钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9AuseCallback-%E5%92%8C-useMemo-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Q1：useCallback 和 useMemo 的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84-hook"><span class="toc-text">Q2：如何实现一个定时器的 hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9AuseState-%E7%9A%84-state-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%BC%95%E8%B5%B7%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">Q3：useState()的 state 是否可以直接修改？是否可以引起组件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9ASetState%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-text">Q4：SetState是同步还是异步的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9AReact-Hooks%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q5：React Hooks是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9AReact-%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">Q6：React)事件和原生事件的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%BE%AA%E7%8E%AF%E3%80%81%E6%9D%A1%E4%BB%B6%E6%88%96%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8Hooks"><span class="toc-text">Q7：为什么不能在循环、条件或嵌套函数中调用Hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9AuseRef-ref-forwardsRef-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q8：useRef&#x2F;ref&#x2F;forwardsRef 的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9AuseEffect-%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-%E4%BC%A0%E7%A9%BA%E6%95%B0%E7%BB%84%E5%92%8C%E4%BC%A0%E4%BE%9D%E8%B5%96%E6%95%B0%E7%BB%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q9：useEffect 的第二个参数,传空数组和传依赖数组有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9A%E5%AE%9E%E7%8E%B0-%E4%B8%AA-useTimeout-Hook"><span class="toc-text">Q10：实现-个 useTimeout Hook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9AReact-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8requestldleCallback"><span class="toc-text">Q1：React 中为什么不直接使用requestldleCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9AReact-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-Hook"><span class="toc-text">Q2：React 中为什么要使用 Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Akey-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q3：key 的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E5%9F%BA%E4%BA%8E-React-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%8E%AA%E6%96%BD"><span class="toc-text">Q4：基于 React 框架的特点，可以有哪些优化措施</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9Areact-router-%E5%92%8C-react-router-dom-%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q5：react-router 和 react-router-dom 的有什么区别</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d7d36a8f/" title="Javascript工具函数抽取"><img src="https://s2.loli.net/2024/05/27/WjYo3UX62ynwsM7.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Javascript工具函数抽取"/></a><div class="content"><a class="title" href="/posts/d7d36a8f/" title="Javascript工具函数抽取">Javascript工具函数抽取</a><time datetime="2024-05-27T03:10:24.000Z" title="发表于 2024-05-27 11:10:24">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》"><img src="https://s2.loli.net/2024/05/09/DzJNVjYfem3M8wX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习ThreeJS-《Camera（官网案例）》"/></a><div class="content"><a class="title" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》">学习ThreeJS-《Camera（官网案例）》</a><time datetime="2024-04-18T07:24:24.000Z" title="发表于 2024-04-18 15:24:24">2024-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0a14b2/" title="学习ThreeJS-基础环境搭建"><img src="https://s2.loli.net/2024/05/09/GK9ruP7wU6qlCZn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习ThreeJS-基础环境搭建"/></a><div class="content"><a class="title" href="/posts/1d0a14b2/" title="学习ThreeJS-基础环境搭建">学习ThreeJS-基础环境搭建</a><time datetime="2024-04-17T07:24:24.000Z" title="发表于 2024-04-17 15:24:24">2024-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/54d94922/" title="Webapck创建Vue3项目"><img src="https://s2.loli.net/2024/05/09/K7VxfLSw1E6eDvR.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webapck创建Vue3项目"/></a><div class="content"><a class="title" href="/posts/54d94922/" title="Webapck创建Vue3项目">Webapck创建Vue3项目</a><time datetime="2024-04-16T07:24:24.000Z" title="发表于 2024-04-16 15:24:24">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11f6c0d3/" title="Webpack创建React项目"><img src="https://s2.loli.net/2024/05/09/AlgtPEVUNqkTd2i.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack创建React项目"/></a><div class="content"><a class="title" href="/posts/11f6c0d3/" title="Webpack创建React项目">Webpack创建React项目</a><time datetime="2024-04-15T07:24:24.000Z" title="发表于 2024-04-15 15:24:24">2024-04-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg')"><div id="footer-wrap"><div class="copyright">&copy;Fri Nov 12 1999 08:00:00 GMT+0800 (中国标准时间) - 2024 By Nanami Kento</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" id="change_dark_mode" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))--><!--  i.fas.fa-adjust--><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh fa-spin"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0%</span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><!--a.rightMenu-item(href="javascript:rmf.searchinThisPage();")--><!--  i.fas.fa-search--><!--  span='站内搜索'--><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><!--a.rightMenu-item(href="javascript:toggleWinbox();")--><!--  i.fas.fa-cog--><!--  span='博客设置'--><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span id="fullScreenText">进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '7b5408da757d7ca1909e',
      clientSecret: 'a34138bdde985783ed984fc84cec5538a0fe931d',
      repo: 'wutiaowu5t5.github.io',
      owner: 'wutiaowu5t5',
      admin: ['wutiaowu5t5'],
      id: '1980f3a90d7f7cd1ddf7182b2dcfd1d2',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async src="/js/debounceInit.js"></script><script async src="/js/console.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script async src="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.js"></script><script async src="/js/share.js"></script><script async src="/js/grayscale.js"></script><script async src="/js/randomPost.js"></script><script async src="/js/positionWelcome.js"></script><script async src="/js/rightMenu.js"></script><script async src="/js/showFPS.js"></script><div id="fps"></div><script async src="/js/refresh.js"></script><script data-pjax defer src="/js/hideAsideOnMobile.js"></script><script src="/js/nightModeSwitchAnimation.js" async></script><script src="/js/readPercent.js" async></script><script src="/js/mobileReadingModeHideSidebar.js" async></script><script async src="/js/articleEchartsDarkMode.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="五条悟,六眼,咒术「苍」,反转「赫」,虚式「茈」,无量空处,狗卷,鲑鱼,金枪鱼,木鱼花,鲣鱼干,蛋黄酱,大芥,明太子,腌高菜,海带,情绪,宿傩,束缚,「契阔」,「弥虚葛笼」,鹿紫云一,「幻兽琥珀」,「龙鳞」,「反发」,「黑闪」,里梅,冰凝咒法,九十九,星之怒,凰轮,冥冥,神风,涉谷,百鬼夜行,涉谷,乙骨,模仿,钉崎,夏油,伏黑惠,虎杖,「迳庭拳」,娜娜明,「瓦落」,猪肚包,小肚叽,小葵" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="fixedcard-dashboard"><button class="fixedcard-activebtn" type="button" title="用户信息" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-info&quot;,&quot;0&quot;)"><i class="fas fa-address-book"></i></button><button class="fixedcard-activebtn" type="button" title="最新文章" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-recent-post&quot;,&quot;0&quot;)"><i class="fas fa-history"></i></button><button class="fixedcard-activebtn" type="button" title="来访者" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-visitor&quot;,&quot;0&quot;)"><i class="fas fa-earth-americas"></i></button><div class="fixedcard-user-avatar fixedcard-activebtn" onclick="RemoveFixedCardWidget()"><img class="fixedcard-user-avatar-img" src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" title="Nanami Kento"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://hexo-circle-of-friends-api-jade.vercel.app/api?user=wutiaowu5t5";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="user=wutiaowu5t5";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                //console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:260px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                //console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    //console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '0bfa3e0417864a0cb4a14ccdd2517046';
  var gaud_map_key = '7ff01b85d8ea8f50c2e71a46c46e444d';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279, 28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>