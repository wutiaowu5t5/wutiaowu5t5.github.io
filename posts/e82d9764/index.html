<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《JavaScript 面试题》 | Nanami Kento</title><meta name="author" content="Nanami Kento"><meta name="copyright" content="Nanami Kento"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概念Q1：什么是DOM跟BOM难度：⭐  答案                               DOM（文档对象模型）和 BOM（浏览器对象模型）都是由浏览器提供的两个重要的 API（应用程序接口），用于处理和操纵网页内容以及浏览器窗口等相关功能。DOM（文档对象模型）：定义：DOM 是一种对文档的结构化表示，以树状的方式呈现 HTML 或 XML 文档，使开发者可以通过脚本语言（通常">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript 面试题》">
<meta property="og:url" content="https://wutiaowu5t5.github.io/posts/e82d9764/index.html">
<meta property="og:site_name" content="Nanami Kento">
<meta property="og:description" content="概念Q1：什么是DOM跟BOM难度：⭐  答案                               DOM（文档对象模型）和 BOM（浏览器对象模型）都是由浏览器提供的两个重要的 API（应用程序接口），用于处理和操纵网页内容以及浏览器窗口等相关功能。DOM（文档对象模型）：定义：DOM 是一种对文档的结构化表示，以树状的方式呈现 HTML 或 XML 文档，使开发者可以通过脚本语言（通常">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/07/DZHXR21erdnGQb4.jpg">
<meta property="article:published_time" content="2024-01-13T07:24:24.000Z">
<meta property="article:modified_time" content="2024-01-13T07:24:24.000Z">
<meta property="article:author" content="Nanami Kento">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/07/DZHXR21erdnGQb4.jpg"><link rel="shortcut icon" href="/img/header.jpg"><link rel="canonical" href="https://wutiaowu5t5.github.io/posts/e82d9764/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Nanami Kento","link":"链接: ","source":"来源: Nanami Kento","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《JavaScript 面试题》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-13 15:24:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 17
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/all.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Nanami Kento" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div id="loading-box-me"><div id="wrapper"><div id="mouse"></div><div class="loader"></div><div class="loading-bar-me"><div class="progress-bar"></div></div><div class="status"><div class="state"></div><div class="percentage"></div></div></div></div></div><script>const preloader = {
  endLoading: () => {
    var loadingBox = document.getElementById('loading-box');
    var loadingBoxme = document.getElementById('loading-box-me');
    loadingBoxme.addEventListener('animationend', () => {setTimeout(function() {loadingBox.classList.add("loaded");}, 2000) })
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  },
  otherendLoading: () => {
    document.getElementById('loading-box').classList.add("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.otherendLoading();},10000)

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.otherendLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2023/12/07/DZHXR21erdnGQb4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Nanami Kento"><span class="site-name">Nanami Kento</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《JavaScript 面试题》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-13T07:24:24.000Z" title="发表于 2024-01-13 15:24:24">2024-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-13T07:24:24.000Z" title="更新于 2024-01-13 15:24:24">2024-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">85.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>294分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《JavaScript 面试题》"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：什么是DOM跟BOM"><a href="#Q1：什么是DOM跟BOM" class="headerlink" title="Q1：什么是DOM跟BOM"></a>Q1：什么是DOM跟BOM</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>DOM（文档对象模型）和 BOM（浏览器对象模型）都是由浏览器提供的两个重要的 API（应用程序接口），用于处理和操纵网页内容以及浏览器窗口等相关功能。</p><p>DOM（文档对象模型）：</p><ol><li><strong>定义：</strong><ul><li>DOM 是一种对文档的结构化表示，以树状的方式呈现 HTML 或 XML 文档，使开发者可以通过脚本语言（通常是 JavaScript）动态地访问和修改文档的内容、结构和样式。</li></ul></li><li><strong>主要功能：</strong><ul><li>提供了一种将文档表示为树形结构的方式，每个 HTML 或 XML 元素都是树中的一个节点。</li><li>允许开发者通过脚本语言操作文档的内容，例如添加、删除、修改元素。</li><li>提供了一系列的 API，使开发者能够动态地操作页面的结构和样式，响应用户的交互。</li></ul></li></ol><p>BOM（浏览器对象模型）：</p><ol><li><strong>定义：</strong><ul><li>BOM 是浏览器提供的一组对象，用于表示浏览器窗口和浏览器本身的各种信息，而不是文档的结构。</li></ul></li><li><strong>主要对象：</strong><ul><li><code>window</code> 对象：表示浏览器窗口，包含了有关窗口的信息和方法。</li><li><code>navigator</code> 对象：包含有关浏览器的信息，如浏览器类型和版本。</li><li><code>screen</code> 对象：包含有关用户屏幕的信息，如屏幕宽度和高度。</li><li><code>location</code> 对象：包含有关当前文档 URL 的信息，可以用于导航到其他页面。</li><li><code>history</code> 对象：包含用户在浏览器窗口中访问的 URL 历史记录。</li></ul></li></ol><p>区别：</p><ul><li><strong>DOM 关注文档的内容和结构，提供了一种访问和操作文档的方式。</strong></li><li><strong>BOM 关注浏览器窗口和浏览器本身的信息，提供了一种管理浏览器窗口和与浏览器交互的方式</strong></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：说说你对轮询的理解"><a href="#Q2：说说你对轮询的理解" class="headerlink" title="Q2：说说你对轮询的理解"></a>Q2：说说你对轮询的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是轮询？</strong></p><p>轮询是一种用于获取信息或监视状态的计算机编程技术。在轮询中，程序会定期检查一个或多个资源的状态，以确定它们是否有可用数据或发生了特定事件。</p><p><strong>长短轮询有什么区别？</strong></p><ul><li><strong>长轮询（Long Polling）</strong>：客户端发送一个请求到服务器，服务器保持连接打开，直到有数据更新或超时才响应请求。如果超时，则客户端会立即发起新的请求。</li><li><strong>短轮询（Short Polling）</strong>：客户端定期向服务器发送请求，询问是否有数据更新。服务器会立即响应，并在每次响应后，客户端都会立即发起新的请求。</li></ul><p><strong>实现轮询的方式：</strong></p><ol><li><strong>传统轮询</strong>：客户端定期发送请求询问服务器是否有更新。</li><li><strong>长轮询</strong>：客户端发送请求到服务器，服务器保持连接，直到有数据更新或超时才响应。</li><li><strong>WebSocket</strong>：通过双向通信通道实现实时数据传输，避免了轮询的延迟和资源浪费。</li></ol><p><strong>轮询的优缺点对比（使用表格方式）：</strong></p><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>- 简单易实现<br>- 兼容性强<br>- 灵活性高<br></td><td>- 资源浪费（频繁轮询可能造成服务器负担增加）<br>- 延迟高（不能立即检测到状态变化）<br>- 不适用于实时应用场景</td></tr></tbody></table></div><p><strong>如何避免轮询的缺点？</strong></p><ol><li><strong>使用长轮询或WebSocket</strong>：长轮询和WebSocket可以降低延迟，提高实时性。</li><li><strong>优化轮询频率</strong>：根据应用场景的需要调整轮询频率，避免不必要的资源浪费。</li><li><strong>使用推送技术</strong>：使用服务器推送技术（如Server-Sent Events、WebSocket）可以在发生事件时立即将数据推送给客户端，避免了轮询的延迟和资源浪费。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获"><a href="#Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获" class="headerlink" title="Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获?"></a>Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li>捕获阶段点击事件触发</li><li>冒泡阶段点击事件触发</li></ol><p>这两个事件都会被执行一次。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>事件传播分为三个阶段：捕获阶段、目标阶段和冒泡阶段。当一个事件发生在 DOM 元素上时，它会经历这三个阶段。以下是对每个阶段的详细解释：</p><ol><li><strong>捕获阶段（Capturing Phase）</strong>：<ul><li>事件从顶层的根节点向下传播到目标节点之前的阶段。</li><li>在捕获阶段中，事件首先被捕获到最顶层的父节点，然后逐级向下传播到目标节点。</li></ul></li><li><strong>目标阶段（Target Phase）</strong>：<ul><li>事件到达目标节点后的阶段。</li><li>在目标阶段中，事件到达目标节点并在目标节点上触发。</li></ul></li><li><strong>冒泡阶段（Bubbling Phase）</strong>：<ul><li>事件从目标节点开始向上冒泡到顶层的根节点的阶段。</li><li>在冒泡阶段中，事件从目标节点开始，逐级向上传播到根节点。</li></ul></li></ol><p>事件传播过程中，如果某个阶段的处理函数调用了 <code>stopPropagation()</code> 方法，则会阻止事件继续传播到下一个阶段。如果某个阶段的处理函数返回 <code>false</code>，也会阻止事件继续传播到下一个阶段。否则，事件会继续传播到下一个阶段。</p><p>在实际开发中，可以利用事件传播的特性来实现事件委托（Event Delegation），即将事件绑定到父元素上，通过事件冒泡机制来处理子元素上的事件，从而提高性能和减少代码量。</p><p>总结：</p><ul><li>捕获阶段：从根节点向目标节点传播。</li><li>目标阶段：在目标节点上触发。</li><li>冒泡阶段：从目标节点向根节点传播。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：直接在script标签中写-export-为什么会报错"><a href="#Q4：直接在script标签中写-export-为什么会报错" class="headerlink" title="Q4：直接在script标签中写 export 为什么会报错?"></a>Q4：直接在script标签中写 export 为什么会报错?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 <code>&lt;script&gt;</code> 标签中直接写 <code>export</code> 会导致语法错误，因为 <code>export</code> 是 ECMAScript 模块的语法，而 <code>&lt;script&gt;</code> 标签内的代码通常被视为普通的 JavaScript 代码，不是模块。</p><p>如果要使用 <code>export</code>，需要将 JavaScript 代码放在一个模块中，并通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签引入，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 此处可以使用 export</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">const</span> greeting = <span class="string">&quot;Hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者将 <code>export</code> 语句放在独立的 JavaScript 文件中，然后通过 <code>&lt;script src=&quot;your-script.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code> 引入。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：mouseover-利-mouseenter-有什么区别"><a href="#Q5：mouseover-利-mouseenter-有什么区别" class="headerlink" title="Q5：mouseover 利 mouseenter 有什么区别?"></a>Q5：mouseover 利 mouseenter 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>mouseover</code> 和 <code>mouseenter</code> 是 DOM 事件中常见的鼠标事件，它们在触发时有一些区别：</p><ol><li><strong>mouseover</strong>：<ul><li><code>mouseover</code> 事件在鼠标指针从一个元素的外部移入到该元素或其子元素时触发。</li><li>当鼠标指针进入目标元素的任何子元素时，也会触发 <code>mouseover</code> 事件。</li><li>这个事件会冒泡，当鼠标指针穿过目标元素的多个子元素时，会在每个子元素上触发。</li></ul></li><li><strong>mouseenter</strong>：<ul><li><code>mouseenter</code> 事件在鼠标指针从一个元素的外部移入到该元素时触发，但不会在进入其子元素时触发。</li><li>即使鼠标指针进入目标元素的子元素，也不会触发 <code>mouseenter</code> 事件。</li><li>这个事件不会冒泡，只有在鼠标指针直接从外部移入目标元素时才会触发。</li></ul></li></ol><p>综上所述，主要区别在于 <code>mouseover</code> 事件在鼠标穿过目标元素的子元素时也会触发，而 <code>mouseenter</code> 事件只在鼠标直接从外部移入目标元素时触发，并且不会在鼠标进入目标元素的子元素时触发。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6-：offsetWidth-offsetHeight-clientWidth-clientHeight-与"><a href="#Q6-：offsetWidth-offsetHeight-clientWidth-clientHeight-与" class="headerlink" title="Q6 ：offsetWidth/offsetHeight,clientWidth/clientHeight 与"></a>Q6 ：offsetWidth/offsetHeight,clientWidth/clientHeight 与</h3><p>scrollWidth/scrollHeight 的区别?</p>
<p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这些属性都是用于获取元素的尺寸信息，但它们之间有一些区别：</p><ol><li><strong>offsetWidth/offsetHeight</strong>：<ul><li><code>offsetWidth</code> 和 <code>offsetHeight</code> 分别返回元素的宽度和高度，包括元素的边框(border)和内边距(padding)，以及垂直滚动条、水平滚动条（如果存在的话）的宽度和高度。</li><li>这些值通常是相对于父元素的内容框（content box）的。</li><li>即 <code>offsetWidth = width + border + padding + 滚动条宽度</code>，<code>offsetHeight = height + border + padding + 滚动条高度</code>。</li></ul></li><li><strong>clientWidth/clientHeight</strong>：<ul><li><code>clientWidth</code> 和 <code>clientHeight</code> 返回元素的内容框（content box）的宽度和高度，不包括边框和滚动条。</li><li>即 <code>clientWidth = width + padding</code>，<code>clientHeight = height + padding</code>。</li><li>这些值通常是相对于视口（viewport）的，即视口的宽度和高度。</li></ul></li><li><strong>scrollWidth/scrollHeight</strong>：<ul><li><code>scrollWidth</code> 和 <code>scrollHeight</code> 返回元素的内容区域的总宽度和总高度，包括了元素内容区域的实际宽度和高度以及被隐藏部分的宽度和高度（如果有的话）。</li><li>当元素内容区域大于其可视区域时，可以通过滚动来查看被隐藏的内容，此时 <code>scrollWidth</code> 和 <code>scrollHeight</code> 将会大于 <code>clientWidth</code> 和 <code>clientHeight</code>。</li><li>通常情况下，<code>scrollWidth</code> 和 <code>scrollHeight</code> 会大于或等于 <code>clientWidth</code> 和 <code>clientHeight</code>。</li></ul></li></ol><p>综上所述，这些属性提供了不同类型的尺寸信息，其中 <code>offsetWidth/offsetHeight</code> 包含了元素的边框、内边距和滚动条的尺寸，<code>clientWidth/clientHeight</code> 只包含了元素的内容区域的尺寸，而 <code>scrollWidth/scrollHeight</code> 则包含了元素内容的实际宽度和高度以及被隐藏的部分。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：JS中怎么阻止事件冒泡和默认事件"><a href="#Q7：JS中怎么阻止事件冒泡和默认事件" class="headerlink" title="Q7：JS中怎么阻止事件冒泡和默认事件?"></a>Q7：JS中怎么阻止事件冒泡和默认事件?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>阻止事件冒泡</strong>：</p><ul><li><p>使用 <code>event.stopPropagation()</code> 方法来停止事件冒泡。这会阻止事件进一步传播到父元素或其他祖先元素。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    <span class="comment">// 这里的代码不会触发父元素的 click 事件处理程序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>阻止默认事件行为</strong>：</p><ul><li><p>使用 <code>event.preventDefault()</code> 方法来阻止事件的默认行为。例如，阻止链接的默认点击行为、表单提交等。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="comment">// 阻止链接的默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>同时阻止事件冒泡和默认行为</strong>：</p><ul><li><p>如果需要同时阻止事件的冒泡和默认行为，可以先调用<code>return false</code> 。在某些情况下，使用 <code>return false</code> 可以达到同时阻止事件冒泡和默认行为的目的，但需要注意这种方式并不是严格意义上的标准做法。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 阻止事件冒泡和默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8："><a href="#Q8：" class="headerlink" title="Q8："></a>Q8：</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：谈谈你对事件冒泡和捕获的理解"><a href="#Q9：谈谈你对事件冒泡和捕获的理解" class="headerlink" title="Q9：谈谈你对事件冒泡和捕获的理解"></a>Q9：谈谈你对事件冒泡和捕获的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>事件冒泡（Event Bubbling）和事件捕获（Event Capturing）是 DOM 事件传播的两种不同的阶段。理解它们对于编写复杂的交互式网页应用程序至关重要。</p><p><strong>事件冒泡（Event Bubbling）：</strong></p><p>事件冒泡是指当在 DOM 树中触发某个事件时，该事件将从最具体的元素（事件目标）开始逐级向上传播到最不具体的元素（document）。换句话说，事件首先触发在目标元素上，然后向上冒泡直到根节点（document）。</p><p><img src="https://s2.loli.net/2024/03/10/A64yikwsxhCMmPG.gif" alt=""></p><ul><li>事件从目标元素开始向上传播到父元素、祖父元素，一直到根节点。</li><li>大多数事件都会冒泡，包括点击事件、键盘事件等。</li></ul><p><strong>事件捕获（Event Capturing）：</strong></p><p>事件捕获是事件传播的另一个阶段，它在事件冒泡之前发生。事件捕获从根节点（document）开始，逐级向下直到达到事件的实际目标元素。</p><p><img src="https://s2.loli.net/2024/03/10/A64yikwsxhCMmPG.gif" alt="img"></p><ul><li>在事件捕获阶段，事件从根节点向下传播到目标元素。</li><li>在事件捕获阶段触发的事件处理程序会在目标元素的祖先元素上触发。</li></ul><p><strong>事件传播的三个阶段：</strong></p><ol><li><strong>捕获阶段（Capture Phase）</strong>：事件从根节点向下传播到目标元素。</li><li><strong>目标阶段（Target Phase）</strong>：事件在目标元素上触发。</li><li><strong>冒泡阶段（Bubble Phase）</strong>：事件从目标元素向上传播到根节点。</li></ol><p><strong>事件处理：</strong></p><p>当一个元素上触发了某个事件时，事件首先在捕获阶段触发该元素的事件处理程序，然后在目标阶段触发该元素上的事件处理程序，最后在冒泡阶段触发该元素的父级元素的事件处理程序。</p><p><strong>使用场景：</strong></p><ul><li><strong>事件代理（Event Delegation）</strong>：事件代理通常利用事件冒泡机制，将事件处理程序绑定在父元素上，以处理大量子元素的事件，提高性能和代码简洁性。</li><li><strong>控制事件的传播</strong>：了解事件冒泡和捕获可以更好地控制事件的传播行为，有助于编写更灵活、高效的交互式应用程序。</li></ul><p>综上所述，事件冒泡和捕获是理解 DOM 事件传播机制的关键概念，掌握它们可以更好地处理和控制事件流。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：ES6有什么新特性"><a href="#Q10：ES6有什么新特性" class="headerlink" title="Q10：ES6有什么新特性"></a>Q10：ES6有什么新特性</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>箭头函数</strong></p><p> 箭头函数提供了更简洁的函数定义语法，并且自动绑定了 <code>this</code> 关键字</p></li><li><p><strong>let 和 const</strong></p><p> let 和 const 关键字用于声明变量，let 声明的变量具有块级作用域，而 const 声明的变量是常量，其值无法再次赋值</p></li><li><p><strong>模板字符串</strong></p><p> 使用反引号 `` 包裹的字符串，可以在其中插入变量和表达式，实现更灵活的字符串拼接</p></li><li><p><strong>解构赋值</strong></p><p> 可以通过解构赋值语法，从数组或对象中提取值并赋给变量，使代码更简洁</p></li><li><p>**扩展运算符和剩余参数：</p><p> 使用 <code>...</code> 来表示扩展运算符和剩余参数，用于处理可变长度的参数列表或数组</p></li><li><p><strong>类和继承</strong> </p><p>ES6 引入了类的概念，使得在 JavaScript 中可以更方便地使用面向对象的编程风格，并支持类的继承</p></li><li><p><strong>Promise</strong></p><p> Promise 是一种处理异步操作的方式，可以更清晰地表示异步操作的完成或失败，并使用链式调用来处理异步操作的结果</p></li><li><p><strong>模块化</strong> </p><p>ES6 引入了模块化的语法，可以更好地组织和管理 JavaScript 代码，使其更易于维护和重用</p></li><li><p><strong>新的数据结构</strong></p><p> ES6 提供了新的数据结构，如 Set、Map、WeakSet、WeakMap，用于存储数据并支持高效的查找和操作</p></li><li><p><strong>Iterator 和 Generator</strong></p><p> Iterator 是一种统一的遍历接口，而 Generator 是一种通过函数简化迭代器的定义的方式。</p></li><li><p><strong>Symbol</strong> </p><p>Symbol 是一种新的基本数据类型，用于创建唯一的标识符，可以用作对象的属性名，从而避免属性名冲突</p></li><li><p><strong>Proxy 和 Reflect</strong></p><p> Proxy 对象用于定义自定义的行为，如拦截对象的读取、写入和删除等操作，而 Reflect 对象提供了一组与 Proxy 对象相关的方法</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：xml和json什么区别"><a href="#Q11：xml和json什么区别" class="headerlink" title="Q11：xml和json什么区别"></a>Q11：xml和json什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>XML（可扩展标记语言）和 JSON（JavaScript 对象表示法）都是用于表示和传输数据的格式，它们有以下区别：</p><ol><li><strong>语法</strong>:<ul><li>XML 使用标签来描述数据结构，每个标签包含开始标签和结束标签，例如 <code>&lt;name&gt;John&lt;/name&gt;</code>。</li><li>JSON 使用键值对的形式来描述数据结构，键和值之间使用冒号分隔，键值对之间使用逗号分隔，最外层通常是一个对象或数组。</li></ul></li><li><strong>可读性</strong>:<ul><li>JSON 更加简洁和易读，因为它使用了更轻量级的语法，适合于数据交换和传输。</li><li>XML 的语法相对冗长，标签名、属性、值等都需要以文本形式表示，不如 JSON 直观。</li></ul></li><li><strong>数据类型</strong>:<ul><li>JSON 支持对象（键值对）、数组、字符串、数字、布尔值和 null。</li><li>XML 支持更多的数据类型，包括字符串、数字、布尔值、日期、时间、文本、元素、属性等。</li></ul></li><li><strong>扩展性</strong>:<ul><li>XML 是可扩展的，允许使用者自定义标签和属性，适用于定义复杂的数据结构和领域特定语言。</li><li>JSON 的结构相对固定，不支持自定义标签和属性，只能通过对象和数组来组织数据。</li></ul></li><li><strong>解析和处理</strong>:<ul><li>在 JavaScript 中，JSON 更容易解析和处理，因为它可以直接转换为 JavaScript 对象。</li><li>XML 需要使用 DOM 解析器或 SAX 解析器进行解析，相对来说处理起来更加繁琐。</li></ul></li></ol><p>综上所述，JSON 更加轻量、简洁、易读，并且更适合于数据交换和传输。而 XML 则更加灵活，支持更多的数据类型和自定义标签，适用于定义复杂的数据结构和领域特定语言。选择使用 JSON 还是 XML 取决于具体的应用场景和需求。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：为什么JavaScript是单线程"><a href="#Q12：为什么JavaScript是单线程" class="headerlink" title="Q12：为什么JavaScript是单线程?"></a>Q12：为什么JavaScript是单线程?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 是一种单线程语言，这意味着它在任何给定的时间只能执行一个任务或代码块。这种设计是由 JavaScript 的最初用途所决定的，即作为网页上交互式脚本的语言。下面是一些原因解释为什么 JavaScript 是单线程的：</p><ol><li><strong>简单性和一致性</strong>：单线程模型使得 JavaScript 的行为更加简单和可预测。它不需要开发者担心多线程之间的竞态条件、死锁等复杂的并发问题。</li><li><strong>网页交互</strong>：JavaScript 最初是为了在浏览器中操作网页元素而设计的。在这种情况下，多线程并发可能会导致混乱和不可预测的结果，例如多个脚本同时尝试修改同一个 DOM 元素。</li><li><strong>防止阻塞</strong>：JavaScript 在浏览器中是由浏览器引擎负责解释和执行的。如果 JavaScript 是多线程的，那么一个线程的阻塞可能会影响到其他线程的执行，从而导致用户界面的卡顿和不流畅。</li></ol><p>虽然 JavaScript 本身是单线程的，但是通过使用事件循环和异步编程模型，JavaScript 可以利用回调函数、Promise、async/await 等机制来处理异步操作，从而实现非阻塞的并发执行。这样的设计使得 JavaScript 在处理网络请求、定时器、用户输入等异步任务时可以更高效地利用资源，同时保持了简单性和可预测性。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>JavaScript 的事件循环（Event Loop）是一种处理程序执行、事件和调度消息的过程</p><p>它允许 JavaScript 在执行长时间的任务时，仍然可以处理其他的事件，例如用户输入、脚本加载等</p><p>在深入事件循环之前，首先需要了解 JavaScript 的运行环境是单线程的</p><p>这意味着在同一时间内只能执行一个任务</p><p>为了协调这些任务，使得高延迟操作不会阻塞线程，事件循环得以产生</p><p>事件循环的机制如下：</p><ol><li><strong>调用栈（Call Stack）</strong>：<ul><li>执行的所有代码块（函数调用）都按顺序进入一个“调用栈”</li><li>当 JS 引擎首次执行脚本时，全局代码作为一个主要的块首先被推送到栈中</li><li>每当一系列函数调用发生时，它们会按照调用顺序被推入栈中，并且当函数执行完毕，返回结果后，它们会从栈中被弹出</li></ul></li><li><strong>任务队列（Task Queue）</strong>：<ul><li>当异步事件完成时，例如：HTTP 请求、文件读取、setTimeout 等，相应的回调函数会被添加到“任务队列”中</li><li>如果调用栈为空，即所有当前任务已经执行完成，事件循环就会从任务队列中取出回调函数并推入调用栈来执行</li><li>有哪些宏任务？<ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code> (主要用在 Node.js)</li><li>I/O 操作（如文件读写、网络请求等）</li><li>UI 渲染事件 (例如 <code>requestAnimationFrame</code>，在浏览器环境中)</li><li><code>MessageChannel</code></li><li>主脚本的执行 (HTML 页面加载完毕后，浏览器中的全局执行上下文)</li></ul></li></ul></li><li><strong>微任务队列（Microtask Queue）</strong>：<ul><li>微任务队列是一个处理比任务队列优先级更高的任务的队列</li><li>当一个 Promise 被解决或拒绝时，相应的 <code>.then()</code>、<code>.catch()</code> 或 <code>.finally()</code> 处理程序会被添加到微任务队列中</li><li>微任务队列在每个宏任务执行完毕后会完全清空</li><li>有哪些微任务？<ul><li><code>Promise.then</code>、<code>Promise.catch</code> 和 <code>Promise.finally</code> 处理函数</li><li><code>queueMicrotask</code> (这是一个显式将任务排入微任务队列的方法)</li><li><code>MutationObserver</code> (浏览器中，用于观察 DOM 变化的回调)</li><li><code>process.nextTick</code> (在 Node.js 中)</li></ul></li></ul></li></ol><p>任务队列的执行逻辑是这样的：</p><ul><li><p>当一个宏任务执行完毕后，JavaScript 引擎会查看是否有微任务需要执行</p><p>如果微任务队列中有任务，那么它们会被依次执行，直到微任务队列为空</p></li><li><p>如果微任务执行过程中产生新的微任务，这些新的微任务也会被加入微任务队列并在本轮循环中执行完毕</p></li><li><p>微任务全部执行完毕后，渲染进程（在浏览器中）将有机会更新渲染，然后事件循环将进入下一个宏任务执行</p><p>在此之前，可能会处理其他的UI事件、操作等</p></li><li><p>接着，下一个宏任务开始执行，之后该宏任务的微任务，依此类推</p></li></ul><p>整个这个循环确保了异步任务的有效执行，同时允许通过微任务和宏任务</p><p><br /></p><p>事件循环的过程简化如下：</p><ol><li><p>执行全局脚本</p></li><li><p>执行调用栈中的同步代码</p></li><li><p>如果调用栈为空，检查微任务队列</p><p>如果微任务队列不为空，执行微任务，直到队列为空</p></li><li><p>取出任务队列中的下一个任务，推入调用栈中执行</p></li><li><p>重复上述流程</p></li></ol><p>由于微任务的优先级高于普通任务，所以在任何新的宏任务被处理之前，微任务队列会被完全清空</p><p>这包括在微任务中创建的微任务</p><p>而对于宏任务来说，每执行完一个宏任务，都会检查并清空微任务队列，然后再执行下一个宏任务</p><p>最后，由于 JavaScript 的这个单线程非阻塞的性质，它适合处理 I/O 密集型的操作，而不是 CPU 密集型的操作，因为复杂的计算可能会长时间占据 JS 线程，造成界面不流畅或卡顿</p><p>在 Web 应用中，影响用户体验是需要避免的</p><p>因此理解和合理地利用事件循环，对于编写高效的 JavaScript 代码至关重要</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：”严格模式”是什么"><a href="#Q13：”严格模式”是什么" class="headerlink" title="Q13：”严格模式”是什么?"></a>Q13：”严格模式”是什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“严格模式”（Strict Mode）是 ECMAScript 5 引入的一种 JavaScript 执行模式，它提供了更加严格的语法和错误检查，有助于编写更安全、更规范的 JavaScript 代码。启用严格模式可以帮助开发者避免一些常见的错误，并且提高代码质量和性能。</p><p>启用严格模式的方法是在代码的顶部（全局作用域）或者函数体的开头（函数作用域）添加如下语句之一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure><p>或者，在函数作用域内使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格模式对 JavaScript 的一些行为做了限制，其中一些主要的变化包括：</p><ol><li><strong>禁止使用未声明的变量</strong>：在严格模式下，使用未声明的变量会抛出 ReferenceError 错误。</li><li><strong>删除不可删除的属性</strong>：在严格模式下，删除不可删除的属性会抛出 TypeError 错误。</li><li><strong>禁止使用八进制表示法</strong>：在严格模式下，八进制数值的表示方式会被视为错误。</li><li><strong>禁止对只读属性赋值</strong>：在严格模式下，对只读属性赋值会抛出 TypeError 错误。</li><li><strong>函数参数名唯一性</strong>：在严格模式下，函数参数名不能重复。</li><li><strong>禁止使用 with 语句</strong>：在严格模式下，禁止使用 with 语句，因为它会导致作用域链被修改，增加代码的不可预测性。</li><li><strong>保留关键字</strong>：在严格模式下，一些在非严格模式下可以使用的关键字变成了保留字，不能作为变量名、函数名或参数名等标识符使用。</li></ol><p>启用严格模式的好处包括：</p><ul><li>帮助开发者捕获更多的错误，提高代码的健壮性。</li><li>使得 JavaScript 引擎可以更有效地优化代码，提高性能。</li><li>促使开发者遵循更严格的编程规范，减少不规范的代码写法。</li><li>为将来的 ECMAScript 版本引入新特性提供了更好的准备。</li></ul><p>因此，建议在 JavaScript 代码中尽可能使用严格模式，以获得更好的代码质量和执行性能。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：Node跟Element是什么关系？"><a href="#Q14：Node跟Element是什么关系？" class="headerlink" title="Q14：Node跟Element是什么关系？"></a>Q14：Node跟Element是什么关系？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在DOM（文档对象模型）中，Node 和 Element 是两个重要的接口，它们之间有一定的层次关系。</p><ol><li><strong>Node（节点）：</strong><ul><li><code>Node</code> 是 DOM 树中的基本构建块，代表文档树中的一个节点。<code>Node</code> 接口定义了所有节点类型的通用属性和方法。文档中的所有元素、属性、文本等都是节点。</li><li><code>Element</code> 是 <code>Node</code> 的子接口，因此每个 <code>Element</code> 对象也是 <code>Node</code> 对象。<code>Node</code> 接口提供了操作文档树的通用方法，比如查找父节点、子节点，添加、删除节点等。</li></ul></li><li><strong>Element（元素）：</strong><ul><li><code>Element</code> 接口表示文档中的元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等。<code>Element</code> 继承自 <code>Node</code>，因此具备了 <code>Node</code> 接口的所有属性和方法。</li><li><code>Element</code> 接口还提供了一些专门用于处理元素的属性和方法，如获取元素的标签名、设置和获取元素的属性、获取元素的子元素等。</li></ul></li></ol><p>在层次结构中，<code>Element</code> 是 <code>Node</code> 的一种特殊情况。所有的元素都是节点，但并非所有的节点都是元素。其他类型的节点包括文本节点、注释节点、文档节点等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node and Element<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Example Element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;exampleElement&quot;</span>&gt;</span>This is an example element.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Accessing the element using JavaScript</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> elementNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Checking if it&#x27;s a Node</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (elementNode <span class="keyword">instanceof</span> <span class="title class_">Node</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is a Node.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Checking if it&#x27;s an Element</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (elementNode <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is an Element.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>document.getElementById(&#39;exampleElement&#39;)</code> 返回的是一个 <code>Element</code> 对象，它同时也是一个 <code>Node</code> 对象。通过 <code>instanceof</code> 运算符，我们可以检查对象是否是 <code>Node</code> 或 <code>Element</code> 的实例。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：说说你对DOM树的理解"><a href="#Q15：说说你对DOM树的理解" class="headerlink" title="Q15：说说你对DOM树的理解"></a>Q15：说说你对DOM树的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>文档对象模型（Document Object Model，简称DOM）是一种表达和操作HTML、XML等文档结构的方式。DOM 将文档解析为一个由节点组成的树状结构，每个节点代表文档中的一个元素、属性、文本等。</p><p>以下是对DOM树的一些理解：</p><ol><li><strong>树状结构：</strong> DOM 将文档表示为一个树状结构，其中树的根是文档节点，树的每个分支代表文档的不同层次结构，叶子节点代表文档中的具体元素或内容。</li><li><strong>节点：</strong> 树中的每个元素都是一个节点。节点可以是元素节点、属性节点、文本节点等。元素节点表示HTML或XML中的标签，属性节点表示元素的属性，文本节点表示元素包含的文本内容。</li><li><strong>层次结构：</strong> DOM 树按照文档的层次结构组织，每个节点有父节点、子节点和兄弟节点。根节点是文档节点，它没有父节点，而其他节点通过层次关系相互连接。</li><li><strong>实时性：</strong> DOM 是动态的，可以通过脚本语言（如JavaScript）来操作。可以通过脚本动态地添加、修改或删除节点，从而改变页面的结构和内容。</li><li><strong>接口：</strong> DOM 提供了一种通过编程方式访问和操作文档的接口。通过这些接口，开发者可以获取节点、修改节点的属性和内容、添加新节点等。</li><li><strong>跨平台性：</strong> DOM 是与平台和编程语言无关的标准，因此可以在各种环境和语言中使用。在浏览器中，通过JavaScript可以直接访问和操作DOM。</li><li><strong>事件模型：</strong> DOM 提供了事件模型，允许开发者对用户交互和其他事件进行监听和响应。例如，可以通过DOM来捕获用户的点击事件、键盘事件等。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><strong>分词器将字节流转化为 Token：</strong></li></ol><ul><li><strong>字节流：</strong> HTML 文档以字节流的形式从服务器传输到浏览器。</li><li><strong>分词器工作：</strong> 浏览器使用分词器（Tokenizer）将字节流转换为一系列 Token。Token 是解析过程的基本单元，包括标签 Token 和文本 Token。分词器根据 HTML 规范逐个读取字符，生成相应的 Token。</li></ul><ol><li><strong>Token解析为 DOM 节点</strong>：</li></ol><ul><li><strong>DOM 节点：</strong> Token 被解析为 DOM 节点，每个 Token 对应一个节点。节点包括元素节点、文本节点、属性节点等。</li><li><strong>构建 DOM 树：</strong> 浏览器通过将 Token 解析为相应的 DOM 节点来构建 DOM 树。元素节点表示 HTML 元素，文本节点表示元素包含的文本内容，属性节点表示元素的属性。</li></ul><ol><li><strong>将 DOM 节点添加到 DOM 树中：</strong></li></ol><ul><li><strong>DOM 树的构建：</strong> 在解析过程中，浏览器逐步构建 DOM 树，树的根节点是 <code>&lt;html&gt;</code> 元素，它有子节点 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code>。</li><li><strong>节点关系：</strong> 构建过程中，建立节点之间的父子关系。每个元素节点都成为其父节点的子节点，文本节点则成为相应元素节点的子节点。</li><li><strong>完整的 DOM 树：</strong> 构建完成后，得到一个完整的 DOM 树，表示了 HTML 文档的结构和层次关系。</li></ul><p>这三个阶段是解析和构建 DOM 树的关键步骤，DOM 树的构建是为了将文档结构化表示，以便浏览器进一步处理、布局和渲染到用户界面。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：Javascript跟Css是怎么阻塞DOM树构建的？"><a href="#Q16：Javascript跟Css是怎么阻塞DOM树构建的？" class="headerlink" title="Q16：Javascript跟Css是怎么阻塞DOM树构建的？"></a>Q16：Javascript跟Css是怎么阻塞DOM树构建的？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>JavaScript 阻塞 DOM 树构建：</strong><ul><li>当浏览器解析到 <code>&lt;script&gt;</code> 标签时，它会立即停止 HTML 解析，然后下载并执行 JavaScript 代码。</li><li>如果 JavaScript 代码位于文档的头部（即在 <code>&lt;head&gt;</code> 中），它可能会阻塞 DOM 树的构建，因为浏览器会等待 JavaScript 代码执行完成才能继续解析 HTML。</li><li>这种情况下，用户可能会看到一个白屏或加载延迟，因为 DOM 树的构建被阻塞，直到 JavaScript 执行完毕。</li></ul></li><li><strong>CSS 阻塞 DOM 树构建：</strong><ul><li>如果浏览器解析到外部样式表（通过 <code>&lt;link&gt;</code> 标签或 <code>@import</code>）或在文档头部的内联样式（在 <code>&lt;style&gt;</code> 标签中），它会开始下载和解析 CSS 文件。</li><li>如果 CSS 文件很大或者在网络上加载耗时，它可能会阻塞 DOM 树的构建，因为浏览器希望尽早获取和应用样式信息以正确渲染页面。</li><li>类似于 JavaScript 阻塞，这也可能导致页面加载延迟。</li></ul></li></ol><p>为了解决这些阻塞问题，可以采取以下措施：</p><ul><li><p><strong>将 JavaScript 放在底部：</strong> 将 <code>&lt;script&gt;</code> 标签放在文档底部，确保 HTML 解析不会因为 JavaScript 而阻塞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">e<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSS 样式表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- JavaScript 脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>async</code> 或 <code>defer</code> 属性：</strong> 对于 <code>&lt;script&gt;</code> 标签，可以使用 <code>async</code> 或 <code>defer</code> 属性，使 JavaScript 异步加载和执行，减少对 DOM 树构建的阻塞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化 CSS 文件加载：</strong> 尽可能减小 CSS 文件的大小，考虑使用浏览器缓存等策略，以减轻对 DOM 树构建的影响。</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：什么是变量提升"><a href="#Q17：什么是变量提升" class="headerlink" title="Q17：什么是变量提升"></a>Q17：什么是变量提升</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>变量提升（Hoisting）是 JavaScript 中的一种特性，它会将变量声明提升到当前作用域的顶部，但不会提升变量的赋值。</p><p>在 JavaScript 中，变量提升的规则如下：</p><ol><li>变量声明（以及函数声明）会被提升到当前作用域的顶部，但赋值操作不会被提升。这意味着在声明变量之前就可以访问这些变量，但访问时会返回 <code>undefined</code>。</li><li>变量提升只影响声明本身，不会影响作用域内的代码执行顺序。</li><li>如果变量名重复声明，后面的声明会覆盖前面的声明。</li></ol><p>例如，以下代码演示了变量提升的行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 10;</span><br><span class="line"></span><br><span class="line">// 上面的代码实际上被 JavaScript 引擎理解为：</span><br><span class="line">var a;</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">a = 10;</span><br></pre></td></tr></table></figure><p>在上面的例子中，变量 <code>a</code> 在声明之前被访问，但由于变量提升的影响，代码不会报错，而是打印出 <code>undefined</code>。这是因为变量声明 <code>var a;</code> 被提升到了作用域的顶部，但赋值操作 <code>a = 10;</code> 并未被提升。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：JavaScript中的事件模型有哪些"><a href="#Q18：JavaScript中的事件模型有哪些" class="headerlink" title="Q18：JavaScript中的事件模型有哪些"></a>Q18：JavaScript中的事件模型有哪些</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 中的事件模型通常指的是 DOM 事件模型，它描述了在网页中处理和触发事件的机制。在 DOM 事件模型中，事件分为捕获阶段、目标阶段和冒泡阶段，而 JavaScript 提供了一些方法来注册和处理这些事件。以下是常见的几种事件模型：</p><ol><li><strong>DOM0级事件模型</strong>：<ul><li>在 DOM0 级事件模型中，事件处理程序直接赋值给 DOM 元素的属性。</li><li>示例：<code>element.onclick = function() { // 事件处理逻辑 }</code></li><li>特点：简单直接，适用于单一的事件处理。</li></ul></li><li><strong>DOM2级事件模型</strong>：<ul><li>在 DOM2 级事件模型中，通过 <code>addEventListener</code> 和 <code>removeEventListener</code> 方法来注册和移除事件处理程序。</li><li>示例：<code>element.addEventListener(&#39;click&#39;, function() { // 事件处理逻辑 }, false)</code></li><li>特点：支持多个事件处理程序，可以为同一个元素的同一种事件注册多个处理程序；支持事件捕获和冒泡；更加灵活和标准化。</li></ul></li><li><strong>IE 事件模型</strong>：<ul><li>IE 浏览器早期采用了与标准不同的事件模型，通过 <code>attachEvent</code> 和 <code>detachEvent</code> 方法来注册和移除事件处理程序。</li><li>示例：<code>element.attachEvent(&#39;onclick&#39;, function() { // 事件处理逻辑 })</code></li><li>特点：与 DOM2 级事件模型不同，IE 事件模型不支持事件捕获，只支持事件冒泡；事件处理程序的执行顺序与注册顺序相反。</li></ul></li><li><strong>事件委托模型</strong>：<ul><li>事件委托模型是利用事件冒泡的特性，将事件处理程序绑定在父元素上，通过判断事件目标来执行相应的逻辑。</li><li>特点：减少了事件处理程序的数量，提高了性能；适用于需要处理大量相似事件的情况，比如列表或表格中的事件处理。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19：-什么是同步和异步"><a href="#Q19：-什么是同步和异步" class="headerlink" title="Q19： 什么是同步和异步"></a>Q19： 什么是同步和异步</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<strong>同步</strong>和<strong>异步</strong>是两个描述代码执行模式的术语，它们用于处理代码的执行流程。理解这两个概念对编写高效、响应迅速的应用程序非常重要。</p><p><strong>同步（Synchronous）：</strong></p><ul><li><strong>定义</strong>：同步代码是指代码按照编写的顺序执行，前一个任务完成后，才会执行后一个任务。这种模式下，代码会阻塞在一个任务上，直到任务完成。</li><li><strong>执行方式</strong>：JavaScript 是单线程的，因此在同步代码中，所有代码在同一个线程中按顺序执行。如果某个任务（例如计算密集型任务或 I/O 操作）耗时较长，它会阻塞后续代码的执行，导致用户界面卡顿或响应迟钝。</li><li><strong>示例</strong>：例如，如果你在代码中执行一个循环，而循环内有一个密集计算操作，整个循环执行期间程序将一直阻塞在这个操作上。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 密集计算任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，密集计算任务会阻塞程序，导致第二个 <code>console.log</code> 语句的执行延迟。</p><p><strong>异步（Asynchronous）：</strong></p><ul><li><strong>定义</strong>：异步代码是指不按照顺序执行任务，而是让任务在后台进行。程序可以在等待任务完成的同时继续执行其他代码，这样的机制可以避免阻塞。</li><li><strong>执行方式</strong>：JavaScript 使用事件循环来管理异步任务。这意味着在执行同步代码的同时，异步任务可以在后台进行。一旦异步任务完成，它将通过回调函数、Promise、<code>async/await</code> 等方式来通知主线程。</li><li><strong>示例</strong>：例如，使用 <code>setTimeout</code> 来延迟执行某个代码块。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务完成&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;结束&#39;)</code> 会在 <code>setTimeout</code> 的回调函数执行之前立即执行。因此，”结束” 会先于 “异步任务完成” 输出。</p><p><strong>异步编程的常用方式：</strong></p><ul><li><strong>回调函数</strong>：使用函数作为参数传递给异步操作，当异步操作完成时调用。</li><li><strong>Promise</strong>：一种表示异步操作最终完成或失败的对象，允许链式处理异步任务。</li><li><strong><code>async/await</code></strong>：基于 Promise 的异步语法糖，使异步代码更类似于同步代码。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：CSS动画和JS实现的动画分别有哪些优缺点"><a href="#Q20：CSS动画和JS实现的动画分别有哪些优缺点" class="headerlink" title="Q20：CSS动画和JS实现的动画分别有哪些优缺点?"></a>Q20：CSS动画和JS实现的动画分别有哪些优缺点?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS 动画和 JavaScript 实现的动画是两种常用的网页动画方式，它们各有优缺点</p><p>理解它们的特性和适用场景可以帮助你在项目中做出最佳的选择</p><p><strong>CSS 动画</strong></p><p><strong>优点：</strong></p><ol><li><strong>性能优越</strong>：CSS 动画通常会被 GPU 加速，这可以减少 CPU 的负担，提高动画的流畅度。</li><li><strong>简单易用</strong>：CSS 动画通过定义样式来实现，代码简洁明了，不需要过多的 JavaScript 逻辑。</li><li><strong>自动化</strong>：CSS 动画可以在元素进入和离开 DOM 时自动触发，例如通过 <code>:hover</code>、<code>:focus</code> 等伪类。</li><li><strong>不阻塞页面渲染</strong>：CSS 动画不会阻塞页面渲染，因为它们是异步执行的。</li><li><strong>一致性</strong>：不同浏览器对 CSS 动画的实现一致，提供了良好的跨浏览器兼容性。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>控制有限</strong>：CSS 动画的功能较为简单，不如 JavaScript 实现的动画灵活</li><li><strong>事件监听受限</strong>：CSS 动画很难直接与 JavaScript 的事件监听器互动（可以通过监听 <code>animationend</code> 事件解决）</li><li><strong>调试困难</strong>：CSS 动画的调试和调整通常比 JavaScript 实现的动画更困难</li></ol><p><strong>JavaScript 实现的动画</strong></p><p><strong>优点：</strong></p><ol><li><strong>高度灵活</strong>：JavaScript 实现的动画可以控制动画的细节和行为，提供了更高的灵活性</li><li><strong>交互性强</strong>：JavaScript 动画可以与其他事件（如点击、鼠标移动等）和数据源（如 API）结合，实现更复杂的交互</li><li><strong>自定义</strong>：可以通过 JavaScript 控制动画的整个生命周期，包括开始、暂停、恢复、停止等</li><li><strong>链式调用</strong>：JavaScript 动画库（如 GSAP）通常支持链式调用，允许你方便地创建复杂的动画序列</li></ol><p><strong>缺点：</strong></p><ol><li><strong>性能可能较差</strong>：如果处理不当，JavaScript 动画可能导致性能问题，如 CPU 负载高、动画不流畅等</li><li><strong>代码复杂度高</strong>：JavaScript 实现的动画通常需要更多的代码和逻辑来管理，代码复杂度较高</li><li><strong>动画可能阻塞页面渲染</strong>：如果 JavaScript 动画在主线程中运行，它可能会阻塞页面渲染，导致用户体验下降</li></ol><p><strong>选择的权衡</strong></p><ul><li>对于简单的动画（例如元素的淡入淡出、滑动效果等），并且不需要高度灵活性，CSS 动画通常是最佳选择</li><li>对于需要高度交互和定制化的动画，或者需要与其他 JavaScript 逻辑密切配合的动画，JavaScript 是更好的选择</li><li>无论选择哪种方式，确保动画的性能和流畅性是关键。此外，可以结合两者的优势，CSS 用于简单的动画效果，而 JavaScript 用于更复杂的逻辑和交互</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：堆与栈有什么区别"><a href="#Q21：堆与栈有什么区别" class="headerlink" title="Q21：堆与栈有什么区别"></a>Q21：堆与栈有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>栈（Stack）</strong></p><ol><li><p><strong>管理方式</strong></p><p>栈由编译器自动管理，无需程序员手动控制</p></li><li><p><strong>内存分配和回收</strong></p><p>遵循后进先出（LIFO，Last In First Out）原则，意味着最后分配的内存块会被最先释放</p></li><li><p><strong>速度</strong></p><p>栈内存的分配和回收速度非常快</p></li><li><p><strong>大小限制</strong></p><p>栈的大小在程序启动时已经定好，因此空间有限</p></li><li><p><strong>用途</strong></p><p>主要用于存放局部变量、函数参数和返回地址等</p></li><li><p><strong>生命周期</strong></p><p>栈内存中的对象通常在其定义的代码块执行结束后即失效</p></li></ol><p><strong>堆（Heap）</strong></p><ol><li><p><strong>管理方式</strong></p><p>堆内存的分配和释放需要程序员通过代码手动管理（或通过垃圾回收机制自动管理，例如在 Java、Python 等语言中）</p></li><li><p><strong>内存分配和回收</strong></p><p>内存分配更为灵活，可以在任何时候申请和释放内存</p></li><li><p><strong>速度</strong></p><p>相比于栈，堆内存的分配和回收速度较慢</p></li><li><p><strong>大小限制</strong></p><p>堆的大小受到系统可用内存的限制，理论上比栈要大得多</p></li><li><p><strong>用途</strong></p><p>主要用于存储程序运行中动态分配的大块内存，比如用来存储由<code>new</code>操作符创建的对象和数组</p></li><li><p><strong>生命周期</strong></p><p>堆内存中的对象生命周期不由代码块控制，而是依赖于引用和垃圾回收机制</p></li></ol><p><strong>核心区别</strong></p><ul><li><p><strong>管理方式</strong></p><p>栈是由系统自动分配释放，而堆则需由程序员控制或依赖于垃圾回收机制</p></li><li><p><strong>性能</strong></p><p>栈操作更快但有大小限制，而堆内存更灵活但分配和回收速度较慢</p></li><li><p><strong>用途差异</strong></p><p>栈通常用来存储执行线程的临时变量，而堆则用来存储程序运行时动态分配的内存</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：Service-worker是什么"><a href="#Q22：Service-worker是什么" class="headerlink" title="Q22：Service worker是什么"></a>Q22：Service worker是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Service Worker 是一种在Web浏览器中运行的脚本，它充当客户端（例如Web应用）与网络之间的代理服务器</p><p>它可以帮助你通过以下方式控制网络请求、缓存资产、以及提供能够在网络不可用时仍能正常使用网站或应用的能力</p><p>这些特性在PWA（渐进式Web应用）中尤为关键</p><p>下面是 Service Worker 的一些主要功能和特点：</p><ol><li><p><strong>离线体验</strong></p><p>Service Worker 可以拦截并缓存网络请求，使得网站能够在无网络状态下运行，从而提供更好的离线体验</p></li><li><p><strong>背景同步</strong></p><p>即使页面关闭后，Service Worker 仍然可以同步数据，等你下次上线时更新状态或进行通知</p></li><li><p><strong>网络请求优化</strong></p><p>通过缓存一些重复的资源请求，Service Worker 能够优化应用的加载时间和性能</p></li><li><p><strong>推送通知</strong></p><p>Service Worker 有能力接收服务器的推送消息，并将这些消息作为系统通知展示给用户，即使网页没有打开</p></li><li><p><strong>生命周期独立</strong></p><p>Service Worker 与 Web 页面的生命周期是独立的，它可以在 Web 页面关闭后仍然活跃，与服务器进行通信</p></li><li><p><strong>不直接操作DOM</strong></p><p>Service Worker 运行在其自己的上下文中，无法直接操作DOM。它通过发送消息与页面通信</p></li><li><p><strong>安全性</strong></p><p>Service Worker 由于其强大的能力，要求在 HTTPS 环境下才能工作，以确保传输内容的安全性</p></li><li><p><strong>可编程网络代理</strong></p><p>开发者可以编写 Service Worker 中的事件响应器来自定义处理所有浏览器的网络请求</p></li></ol><p>由于 Service Worker 在浏览器后台作为一种独立的脚本运行，因此它能在你访问网页时启动，并且即使用户关闭了网页，它还可以打开新的网页</p><p>这为Web应用提供了更强的背景处理能力，大幅度扩展了Web的功能和可用性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：JSBridge是什么"><a href="#Q23：JSBridge是什么" class="headerlink" title="Q23：JSBridge是什么"></a>Q23：JSBridge是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>JSBridge</code> 是一种在移动应用的 <code>WebView</code> 中使用的技术，它允许 <code>JavaScript</code>（通常运行在 <code>WebView</code> 中的前端代码）与原生 <code>app</code> 代码（如 <code>Android</code> 或 <code>iOS</code>）进行通信</p><p><code>Bridge</code> 即是桥梁，指的是它作为前端代码和原生代码之间的桥梁，使得这两部分可以互相调用功能和数据</p><p>在开发过程中，通常会遇到一些网页功能无法直接实现或效率不高的问题，这时候就需要原生的支持</p><p>然而，网页端的 <code>JS</code> 无法直接访问手机系统的原生功能，如相机、文件系统等</p><p><code>JSBridge</code> 提供了这样的一种机制，允许网页端通过定义的协议发出调用指令，由原生端接收这个指令，执行相应的原生操作，并将结果返回给网页端</p><p>举个例子，如果你想在 <code>WebView</code> 中实现一个按钮，点击后打开手机相册并选择图片，你可能需要通过 <code>JSBridge</code> 来调用手机系统的相册功能</p><p>在 <code>JavaScript</code> 中，你可能会调用一个特定的函数或发送一个特定的消息，并通过 <code>JSBridge</code>，这个请求被原生应用捕获并处理，最终原生应用可以打开相册，用户选择图片后，原生代码再把选中的图片通过桥梁传递回 <code>JS</code> 端</p><p><code>JSBridge</code> 核心包含以下几个步骤：</p><ol><li><p><strong>消息发送</strong></p><p>网页端 <code>JS</code> 发起调用，发送消息</p></li><li><p><strong>消息拦截</strong></p><p>原生端拦截这些特定的消息/调用请求</p></li><li><p><strong>执行原生方法</strong></p><p>原生端执行对应的原生操作</p></li><li><p><strong>回调</strong></p><p>原生端处理完成后，通过桥梁将结果返回给网页端 <code>JS</code>，可能是通过回调函数或者是事件</p></li></ol><p>这种机制在很多移动应用中都有广泛的应用，特别是在混合应用（<code>Hybrid App</code>）开发中，混合应用是指同时包含原生界面元素和 <code>WebView</code> 的应用程序</p><p>使用 <code>JSBridge</code> 可以使得开发者既可以利用 <code>web</code> 技术的便捷和跨平台特性，又可以让应用有更丰富的功能，更好的性能和用户体验</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong><code>JSBridge</code>的实现原理是什么</strong></p><ul><li><p><code>URL Scheme</code></p><p>这是最早期的实现方式之一，通过拦截WebView的URL请求实现</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>JavaScript端通过修改<code>location.href</code>为特定的URL Scheme（如<code>myapp://functionName?param1=value1&amp;param2=value2</code>），然后原生代码可以通过WebView的代理方法拦截到这个URL请求，解析出要调用的函数和参数，执行相应的原生操作</p></li><li><p><strong>原生调用JavaScript</strong></p><p>原生代码执行完毕后，可以通过调用WebView的方法（如Android的<code>webView.loadUrl(&quot;javascript:methodName(params)&quot;)</code>，iOS的<code>webView.evaluateJavaScript(&quot;methodName(params)&quot;, completionHandler: nil)</code>）来执行JavaScript端的方法，以此来传递结果或者触发页面的更新</p></li></ul></li><li><p><code>JavaScriptInterface</code>（<code>Android</code>特有）</p><p>在Android中，可以通过向WebView添加JavaScript的接口来实现JSBridge</p><p>即通过<code>WebView.addJavascriptInterface(Object, String)</code>方法，将一个Java对象映射到JavaScript环境中，JavaScript代码就可以直接调用这个Java对象的方法</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>定义一个Java对象，其中的方法使用<code>@JavascriptInterface</code>注解标注，然后添加到WebView中。JavaScript通过映射的对象直接调用这些方法</p></li><li><p><strong>原生调用JavaScript</strong></p><p>同上，通过<code>webView.loadUrl(&quot;javascript:...&quot;)</code>或<code>webView.evaluateJavaScript</code>方法调用</p></li></ul></li><li><p><code>MessageChannel</code> 或 <code>postMessage</code> (现代方法)</p><p>这是一种更现代的、基于HTML5的交互方式，适用于进行更复杂的数据交换</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>通过WebView的<code>postMessage</code>方法发送消息，原生代码通过相应的监听器接收并处理这些消息</p></li><li><p><strong>原生调用JavaScript</strong></p><p>原生代码处理完业务逻辑后，可以通过调用<code>postMessage</code>方法向JavaScript发送消息，JavaScript端监听并处理这些消息</p></li></ul></li></ul></li></ul><p>不同的实现方式各有优缺点，比如URL Scheme简单但有安全风险，JavaScriptInterface易用但只限于Android，而MessageChannel或postMessage方式则更为安全和灵活，但需要较新的浏览器支持</p><p>在实践中，开发者需要根据自己的具体需求和目标平台的特点选择合适的实现方式</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：-JavaScript-中内存泄漏有哪几种情况"><a href="#Q24：-JavaScript-中内存泄漏有哪几种情况" class="headerlink" title="Q24： JavaScript 中内存泄漏有哪几种情况"></a>Q24： JavaScript 中内存泄漏有哪几种情况</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</p><p><img src="https://s2.loli.net/2024/05/10/jZoAS2xtUrBdOsq.png" alt="image-20240510182435283"></p><p>在JavaScript中，内存泄漏可能有以下几种常见情况：</p><ol><li><p><strong>全局变量意外赋值</strong></p><p>未经声明就赋值的变量会自动成为全局对象的属性，这意味着它们不会被当作局部变量进行垃圾收集</p></li><li><p><strong>被遗忘的计时器或回调函数</strong></p><p>如果你设置了定时器或者间隔（如 <code>setTimeout</code> 或 <code>setInterval</code>）并忘记清除它们，或者绑定了事件监听器并且没有适当移除，它们会一直存在，并且保持对它们回调函数中变量的引用</p></li><li><p><strong>脱离了DOM的引用</strong></p><p>如果你保存了一些DOM元素的引用然后删除了这些元素，除非这些引用也被明确地设置为null，否则它们不会被垃圾回收器回收</p></li><li><p><strong>闭包</strong></p><p>不正确或者不必要地使用闭包，可以造成父级函数作用域链中的变量无法被释放，特别是在闭包被长期保持的时候</p></li><li><p><strong>循环引用</strong></p><p>在早期的IE浏览器中，JavaScript中的对象和DOM对象之间的循环引用会导致内存无法释放</p><p>现代浏览器通过改进垃圾收集器来处理此问题，但在某些情况下循环引用仍然可能是问题</p></li></ol><p>为了避免内存泄漏，建议进行以下几个步骤</p><ul><li><p>明确生命周期</p><p>了解和规划你的代码和对象的生命周期以确保及时释放</p></li><li><p>使用工具和分析</p><p>利用浏览器提供的开发工具来监控和分析内存使用情况</p></li><li><p>减少全局变量使用</p><p>尽可能通过局部作用域和模块化来避免全局变量</p></li><li><p>清理定时器和监听器</p><p>确保用不到的时钟或者事件监听被清理掉</p></li><li><p>管理DOM引用</p><p>移除DOM元素时注意也要清理掉对应的JavaScript引用</p></li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>什么是垃圾回收机制</strong></p><p>垃圾回收（Garbage Collection，GC）是一种自动内存管理的形式</p><p>它的作用是回收程序中不再使用的内存空间，防止内存泄漏导致的资源浪费</p><p>大多数现代编程语言，包括JavaScript，都提供了某种形式的垃圾回收机制</p><p>垃圾回收主要基于这样一个事实：在程序运行过程中，有些对象会变得不再可达，即不存在任何方式来引用它们。这通常是因为对象已经超出了其作用域，或者没有任何变量或属性引用它</p><p>JavaScript中的垃圾回收通常由以下几个策略和算法实现：</p><ol><li><strong>标记-清除（Mark-and-Sweep）</strong><br>这是最常见的垃圾回收算法。当变量进入环境时，垃圾收集器会将它“标记”（通常设置一个位），以说明这个变量目前是活跃的。随后，收集器会去“扫描”内存中的所有变量，并标记那些还在被引用或者在作用域中可达的变量。之后，清除阶段启动，此时收集器会进行再次扫描，销毁那些在扫描阶段没被标记为活跃的变量，并回收它们占据的内存</li><li><strong>引用计数（Reference Counting）</strong><br>这是一种较早的垃圾回收算法，在该算法中，每个对象都有一个引用计数器。当有一个变量引用该对象时，引用计数增加；当引用被移除时，计数减少。如果一个对象的引用计数变为0，则意味着对象不再被引用，可以将其内存回收。然而，引用计数有一个主要问题，即循环引用。如果两个对象相互引用，即使它们都已不可访问，它们的引用计数也不会是0，导致内存无法释放</li><li><strong>分代收集（Generational Collection）</strong><br>这种算法是基于这样的事实：大多数对象都是短暂的。因此，它会将对象分为两组，新生代（Young Generation）和老年代（Old Generation）。新生代中的对象经常进行垃圾回收，因为许多对象都很快就不再需要了，而老年代中的对象不那么频繁进行回收，因为它们通常存活时间更长。在实际操作中，如果一个新生代的对象在多次收集后依然存活，它可能会被移至老年代</li><li><strong>增量收集（Incremental Collection）</strong>：<br>由于GC会暂停所有代码的执行，如果堆内存很大，这可能会导致明显的暂停。增量收集算法会将垃圾收集分成小片段执行，减少每次收集导致的停顿时间。这样，垃圾回收与应用程序代码可以交替执行</li><li><strong>空闲时间收集（Idle-time Collection）</strong><br>某些垃圾回收系统只会在CPU空闲时执行，减少对程序执行的影响</li></ol><p>JavaScript的垃圾收集是自动的，而我们作为开发者通常无需直接管理内存</p><p>但了解和遵循良好的编码习惯可以减少内存泄漏和过早的垃圾收集，从而提高应用程序的性能</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：什么是事件代理"><a href="#Q25：什么是事件代理" class="headerlink" title="Q25：什么是事件代理"></a>Q25：什么是事件代理</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>事件代理是一种利用事件冒泡原理来简化事件处理器管理的技术</p><p>在DOM中，如果一个元素发生了事件（比如点击），这个事件会依次冒泡至其所有的父元素，直至文档的根元素</p><p>事件代理就是在父元素上设置一个事件监听器，监听来自子元素的事件</p><p><br/></p><p><strong>文字例子</strong></p><p>想象你在一个图书馆里，有一个专门的儿童阅读区，这个区域里有很多本绘本供孩子们阅读</p><p>每当一个孩子对某本书感兴趣，并想要借阅时，他们都会举手示意</p><p>为了管理这些请求，图书管理员不会挨个去询问每一个举手的孩子想要阅读哪本书，而是只在儿童区设置一个“服务点”</p><p>每当有孩子举手时，他们就会到这个服务点告诉管理员他们想要的书</p><p>这样，无论儿童区有多少孩子想要借书，管理员只需要在一个地方就能管理所有的请求</p><p><br/></p><p><strong>代码例子</strong></p><p>假设我们有一个按钮列表，每个按钮点击时都会触发一个事件</p><p>不使用事件代理，我们可能需要为每个按钮单独添加事件监听器</p><p>使用事件代理，我们只需要在它们的父元素上添加一个事件监听器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;buttonList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;buttonList&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 检查事件来源是否是按钮</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&#x27;BUTTON&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">textContent</span> + <span class="string">&#x27; 被点击了&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>好处</strong></p><ul><li>减少内存使用：不需要为每个子元素单独绑定事件监听器，只在共同的父元素上绑定一个监听器即可</li><li>方便代理动态元素：对于动态添加到父元素中的子元素，无需再次手动添加事件监听器</li></ul><p><strong>局限性</strong></p><ul><li>不是所有事件都能冒泡：适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code>。某些事件（如<code>focus</code>、<code>blur</code>等）不会冒泡，对于这些事件，事件代理不适用</li><li>事件对象的<code>target</code>属性可能需要额外处理：在某些情况下，需要确切知道事件具体是在哪个子元素上被触发，这时可能需要对<code>event.target</code>进行额外的检查和处理</li><li>细粒度控制较困难：如果只想对特定的子元素进行事件处理，而这些元素并没有共同的父元素，用事件代理的方式就比较困难</li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>Javascript事件流</strong></p><p>JavaScript中的事件流描述了从页面中接收事件的顺序</p><p>事件流可以分为两种主要的模型：事件冒泡（Event Bubbling）和事件捕获（Event Capturing）</p><p>这两种事件流模型的主要区别在于事件触发的顺序</p><p><br/></p><p><strong>事件冒泡（Event Bubbling）</strong></p><p>事件冒泡是最常见的事件流模型，在这个模型中，当一个事件触发在DOM中的某个元素上时，这个事件会逐级向上传播至其所有的祖先元素直到文档的根元素（通常是<code>document</code>对象）</p><p>例如，如果你点击了一个按钮，那么首先这个点击事件会在按钮上触发，然后冒泡到按钮的父元素，然后是更高一级的父元素，一直冒泡到<code>document</code>对象</p><p><br/></p><p><strong>事件捕获（Event Capturing）</strong></p><p>事件捕获则是另一种事件流模型</p><p>事件捕获的顺序与事件冒泡相反，当一个事件发生后，浏览器首先会从<code>document</code>对象开始捕获事件，然后通过DOM树向下传递到事件实际发生的位置</p><p>事件捕获的目的是在事件到达预定目标前先捕获它</p><p><br/></p><p><strong>DOM标准事件流的三个阶段</strong></p><p>DOM事件标准定义了事件处理的三个阶段：</p><ol><li>捕获阶段（Capturing phase）：从<code>document</code>对象传导到事件目标的路径上的对象开始捕获事件</li><li>目标阶段（Target phase）：实际的事件目标对象对事件作出反应</li><li>冒泡阶段（Bubbling phase）：从事件目标对象传导回<code>document</code>对象的路径上的对象开始处理事件</li></ol><p><br/></p><p><strong>使用addEventListener进行事件处理</strong></p><p>使用<code>addEventListener</code>方法添加事件处理程序时，你可以指定第三个参数来决定是在捕获阶段还是冒泡阶段触发该处理程序</p><p>如果第三个参数设置为<code>true</code>，那么事件处理程序将在捕获阶段触发，如果设置为<code>false</code>（或者不设置，因为默认值就是<code>false</code>），事件处理程序将在冒泡阶段触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在冒泡阶段触发</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// handle click event</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在捕获阶段触发</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// handle click event</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>了解事件流对于开发者来说至关重要，因为它直接影响事件处理程序的行为和程序的整体性能</p><p>通过合适的使用事件捕获和冒泡，开发者可以更精确地控制事件处理的策略</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：什么是作用域、作用域链"><a href="#Q26：什么是作用域、作用域链" class="headerlink" title="Q26：什么是作用域、作用域链"></a>Q26：什么是作用域、作用域链</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li><p>作用域</p><p>作用域是指程序中定义变量的区域，该位置决定了变量的可见性和生命周期</p><p>它限定了一个变量的使用范围</p><p>在JavaScript中，作用域可以大致分为两种：全局作用域和局部作用域</p><ul><li><p><strong>全局作用域</strong></p><p>在代码中任何位置都能访问到的变量，都处于全局作用域</p><p>一般来说，在最外层定义的变量或者未经声明直接赋值的变量（这是不推荐的做法），都是全局作用域的变量</p></li><li><p><strong>局部作用域</strong></p><p>只能在定义它的函数内部访问到的变量</p><p>局部作用域可以进一步分为函数作用域和块级作用域（ES6新增）</p><ul><li><p><strong>函数作用域</strong></p><p>在函数内部声明的变量，只能在该函数内部被访问</p></li><li><p><strong>块级作用域</strong></p><p>由<code>{}</code>包括的区域定义的作用域，使用<code>let</code>和<code>const</code>声明的变量在相应的块级作用域中有效</p></li></ul></li></ul></li><li><p>作用域链</p><p>当代码在一个环境中执行时，会创建变量的作用域链</p><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问</p><p>作用域链的前端，始终都是当前执行的代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象</p><p>活动对象在最开始时只包含一个变量，即<code>arguments</code>对象（这个对象包含了调用函数时传入的所有参数）</p><p>作用域链向上逐级查询直到全局执行环境，全局环境的变量对象始终是作用域链的最后一个对象</p><ul><li><p><strong>作用域链的工作机制</strong></p><p>当代码需访问一个变量时，JavaScript引擎首先会尝试在当前执行环境的变量对象中查找标识符</p><p>如果没找到，继续在上一层作用域的变量对象中查找</p><p>一直向上直到全局执行环境</p><p>如果在整个作用域链中都没有找到标识符，则表明该变量未声明</p></li></ul></li><li><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;global&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&quot;outer&quot;</span>; <span class="comment">// 局部变量，函数outer的作用域</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> innerVar = <span class="string">&quot;inner&quot;</span>; <span class="comment">// 局部变量，函数inner的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(innerVar); <span class="comment">// &quot;inner&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// &quot;outer&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// &quot;global&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure><p>在<code>inner</code>函数中，尝试访问<code>innerVar</code>、<code>outerVar</code>和<code>globalVar</code></p><p>首先，在<code>inner</code>的作用域中找到了<code>innerVar</code></p><p>由于在<code>inner</code>作用域中找不到<code>outerVar</code>，它会去上一级作用域，即<code>outer</code>函数的作用域中查找，找到了<code>outerVar</code></p><p>同样的，<code>globalVar</code>在<code>inner</code>和<code>outer</code>的作用域中都找不到，所以它会继续向上查找直到全局作用域，最后在全局作用域中找到了<code>globalVar</code></p><p>这个过程就是作用域链的体现：从当前作用域开始，逐级向上查找变量，直到找到为止，或者最终在全局作用域结束查找</p><p>这确保了在函数嵌套的情况下，内部函数可以访问到外部函数以及全局变量</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：说一下对于SPA的理解"><a href="#Q27：说一下对于SPA的理解" class="headerlink" title="Q27：说一下对于SPA的理解"></a>Q27：说一下对于SPA的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>单页面应用程序（Single Page Application，SPA）</strong>是一种浏览器中运行的应用程序模型</p><p>在这种模型中，用户在浏览器中加载一个HTML页面，然后所有的交互都通过JavaScript完成，这些JavaScript代码会动态更新页面上的部分，而不是加载新页面</p><p>这种模式提供了一种更接近原生应用的用户体验</p><p>当你打开一个SPA，大部分资源（HTML + CSS + Scripts）都会在一次加载中完成</p><p>之后的每次操作，例如点击一个链接或者提交表单，都不会引发页面的重新加载</p><p>相反，JavaScript将运行，执行必要的操作（可能是AJAX请求到服务器获取新数据），并在当前页内动态更新HTML</p><p>这种页面渲染方式避免了页面间切换时常规的网络请求，大大提高了页面交互的速度和效率</p><p>典型的SPA框架有React、Angular、Vue.js等，他们提供了构建用户界面的集合工具，帮助你处理页面的动态更新等问题</p><p>然而，SPA不是没有缺点</p><p>它对于SEO（搜索引擎优化）不太友好，因为搜索引擎可能会不理解或者执行你的JavaScript代码，导致某些内容无法被搜索引擎抓取到</p><p>而且，由于它需要一次性加载所有的代码和资源，可能会导致初次加载速度比较慢</p><p>最后，SPA的安全性也需要额外的关注，因为大部分代码都在客户端执行，因此可能存在安全风险</p><p><br /></p><p><strong>优点</strong></p><ol><li><p><strong>改进的用户体验</strong></p><p>由于用户在使用SPA时无需等待页面重新加载，因此可以提供平滑的用户体验，类似于使用桌面应用程序或原生移动应用程序</p></li><li><p><strong>减少服务器负载</strong></p><p>由于服务器不需要重新处理HTML页面和发送响应，所以服务器只需处理数据请求，降低了服务器的负载和带宽使用</p></li><li><p><strong>快速的响应时间</strong></p><p>页面不需要重新加载所有资源，只需加载新数据，这通常可以提供比传统多页应用更快的响应时间</p></li><li><p><strong>前后端分离</strong></p><p>SPA架构促进了前后端分离发展，前端负责用户界面和用户体验，后端负责数据管理和业务逻辑。这使得开发工作可以更好地协作分工</p></li><li><p><strong>简化的调试过程</strong></p><p>在SPA中，开发者可以只关注单一页面，使用Chrome开发者工具等辅助工具进行调试变得更加容易</p></li><li><p><strong>流畅的跨设备体验</strong></p><p>SPA能够适应不同的设备，而不要专门为移动设备或桌面设备开发不同的版本</p></li><li><p><strong>易于维护</strong></p><p>由于应用由模块化、互相独立的组件构建，开发者更容易添加新功能或者更新现有功能</p></li><li><p><strong>缓存效率</strong></p><p>SPA通过发送单一页面，可以有效地缓存本地数据或资源，因此可以离线使用</p></li><li><p><strong>实时交互</strong></p><p>SPA适合需要实时数据更新的应用，如游戏、绘图应用或社交网络，可以提供较好的实时交互体验</p></li></ol><p><br /></p><p><strong>缺点</strong></p><ol><li><p><strong>SEO（搜索引擎优化）问题</strong></p><p>传统的SPA往往难以被搜索引擎有效索引，因为它们的内容是动态通过JavaScript加载的，这可能导致搜索引擎抓取工具难以抓取到所有内容</p></li><li><p><strong>首次加载时间较长</strong></p><p>尽管SPA在页面间的切换上非常快，但其首次加载时，需要加载应用的所有脚本和资源，这可能导致相比于多页应用（MPA）更长的加载时间</p></li><li><p><strong>浏览器的前进/后退按钮可能不工作</strong></p><p>由于SPA在单个页面内动态更改内容，没有加载新页面，所以对浏览器的前进和后退按钮支持可能不那么直观。开发者需要额外实现这些功能，以保证用户体验</p></li><li><p><strong>内存利用问题</strong></p><p>单页应用可能会因为长时间运行而消耗大量浏览器内存，尤其是当应用未正确管理内存时（如未清理定时器或事件监听器）</p></li><li><p><strong>安全性问题</strong></p><p>SPA可能更容易受到某些类型的安全攻击，如跨站脚本（XSS）攻击，因为所有页面逻辑都由客户端JavaScript控制</p></li><li><p><strong>JavaScript依赖性</strong></p><p>如果用户禁用了浏览器的JavaScript，或者浏览器不支持当前使用的JavaScript特性，那么SPA将无法正常工作</p></li><li><p><strong>难以调试</strong></p><p>SPA由于大量用到JavaScript和异步请求，可能在出现问题时难以追踪和调试</p></li><li><p><strong>用户体验一致性</strong></p><p>SPA的表现和行为完全依赖于客户端设备的性能，这导致不同用户可能会有不同的体验，特别是在老旧或性能较低的设备上</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>多页应用（MPA）是传统的Web应用模式，在这种模式中，每当页面跳转发生时，服务器将会提供一个新的页面</p><p>这跟单页面应用（SPA）不同，在SPA中，页面不会重新加载，只会动态地替换内容</p><p>以下是MPA的一些具体特点：</p><ol><li><strong>全页刷新</strong>：<ul><li>在MPA中，用户的每一个操作，如链接点击、表单提交等，都可能导致整个页面的重新加载或跳转到一个新页面</li><li>这可能会导致更明显的用户等待时间，因为客户端每次都需要从服务器加载新的HTML、CSS和JavaScript</li></ul></li><li><strong>SEO友好</strong>：<ul><li>因为每个页面都有独立的链接，搜索引擎可以很容易地爬取和索引每一个页面</li><li>这是MPA的一个强大优势，尤其适合那些需要良好搜索引擎优化的大型网站</li></ul></li><li><strong>前后端耦合</strong>：<ul><li>在MPA应用中，后端不仅负责业务逻辑和数据库操作，还负责控制页面的渲染</li><li>这种耦合方式简化了开发流程，适合小的团队和小到中端的项目</li></ul></li><li><strong>开发工具和框架</strong>：<ul><li>开发MPA可以采用各种后端语言（如PHP、Java、Ruby等）和框架（如Express.js、Django</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">特点</th><th style="text-align:left">SPA</th><th style="text-align:left">MPA</th></tr></thead><tbody><tr><td style="text-align:left">单一页面加载</td><td style="text-align:left">✓</td><td style="text-align:left">✕</td></tr><tr><td style="text-align:left">用户体验</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">SEO优化</td><td style="text-align:left">需要优化</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">首次加载速度</td><td style="text-align:left">一般，取决于项目大小</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">页面切换速度</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">前后端分离</td><td style="text-align:left">✓</td><td style="text-align:left">可以实现</td></tr><tr><td style="text-align:left">缓存管理</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">浏览器历史导航</td><td style="text-align:left">需要优化</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">初始开发复杂性</td><td style="text-align:left">较高</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">状态管理</td><td style="text-align:left">✓</td><td style="text-align:left">可以实现</td></tr><tr><td style="text-align:left">服务器负载</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">依赖JavaScript</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：原型、原型链是什么"><a href="#Q28：原型、原型链是什么" class="headerlink" title="Q28：原型、原型链是什么"></a>Q28：原型、原型链是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>原型（Prototype）</strong></p><p>在JavaScript中，原型是一种让对象继承属性和方法的机制。每个JavaScript对象（除了<code>null</code>）都具有一个特殊的内置属性，称为<code>[[Prototype]]</code>，但在代码中通常通过<code>__proto__</code>属性的形式来访问（虽然这种方式现在被JavaScript社区视为过时和不推荐。在ES6中，<code>Object.getPrototypeOf()</code>方法可以更标准地获取对象的原型</p><p>更正式地，所有JavaScript对象都是通过引用一个原型对象来继承属性和方法的当你创建一个新对象时，你可以选择某个对象作为它的原型。JavaScript提供了<code>Object.create</code>方法来创建一个新对象，同时让你指定这个对象的原型</p><p><strong>原型链（Prototype Chain）</strong></p><p>原型链是JavaScript的一种基本工作机制，用于在对象之间共享属性和方法。当你尝试访问一个对象的某个属性时，如果这个对象本身没有这个属性，JavaScript会自动去其原型（即<code>__proto__</code>属性指向的对象）中查找。如果这个原型对象也没有这个属性，那么JS将继续搜索这个原型的原型，以此类推，直至找到该属性或者到达原型链的末尾（<code>Object.prototype</code>的原型是<code>null</code>）。</p><p>原型链的这种机制让对象可以共享方法和属性，极大地节省了内存资源，因为这意味着JavaScript中的所有对象实例可以共享它们的构造函数的原型上的属性和方法，而不是在每个对象实例中复制一份。</p><p><img src="https://s2.loli.net/2024/05/11/1ns4IhfcHJCwOTX.png" alt="image-20240511173637440"></p><p><strong>示例</strong></p><p>为了更好地理解，让我们来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>Person</code>是一个构造函数</p></li><li><p>通过<code>Person.prototype.sayHello</code>给<code>Person</code>的原型添加了一个<code>sayHello</code>方法</p></li><li><p><code>person1</code>和<code>person2</code>都是<code>Person</code>的实例</p><p>它们是通过<code>new Person()</code>创建的，因此它们的原型都是<code>Person.prototype</code></p></li><li><p>当调用<code>person1.sayHello()</code>时，JS首先检查<code>person1</code>自身有没有<code>sayHello</code>方法</p><p>没有找到时，它会沿着原型链往上查找，即查找<code>Person.prototype</code>是否有这个方法</p><p>找到后就执行这个方法</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：对JS模块化方案的理解"><a href="#Q29：对JS模块化方案的理解" class="headerlink" title="Q29：对JS模块化方案的理解"></a>Q29：对JS模块化方案的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript模块化方案是寻求在逻辑上划分代码，并通过公开和获取进口接口来组合这些代码块的一种方法</p><p>这意味着，我们可以将复杂的代码分离成可维护的小文件，并且这些文件可以在不同的项目之间轻松重用</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在JavaScript中，有几种不同的模块化标准：</p><ol><li><p><strong>CommonJS</strong></p><ul><li><p><strong>概念</strong> </p><p>CommonJS是一个在服务器端对模块的定义，特别是为了Node.js设计的</p><p>它的目标是弥补JavaScript没有标准库的缺陷，以及提供一个模块化的标准，以便JavaScript也能在服务器端运行</p></li><li><p><strong>核心思想</strong></p><p>使用<code>require</code>函数来同步加载依赖，使用<code>module.exports</code>或<code>exports</code>来导出模块</p><p>由于是设计给服务器端使用的，因此其同步的本质不会造成问题，因为服务器端的文件通常都是本地可访问的，而无需像在浏览器端那样从网络上异步加载</p></li><li><p>这是Node.js使用的模块标准，它允许使用<code>require</code>语句来加载模块，并通过<code>module.exports</code>或<code>exports</code>导出</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = libMethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> libMethod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>AMD (Asynchronous Module Definition)</strong></p><ul><li><p><strong>概念</strong></p><p>AMD即异步模块定义，它是一种针对浏览器而设计的模块化方案</p><p>AMD采用异步方式加载模块，是为了解决浏览器环境下模块代码可能需要从服务器异步加载的问题</p></li><li><p><strong>核心思想</strong></p><p>通过<code>define</code>函数定义模块，<code>require</code>函数来异步加载依赖</p><p>AMD最大的特点就是支持浏览器端的异步加载，且允许指定回调函数，以便在所有需要的模块都加载完成后进行操作</p></li><li><p>主要用于异步加载模块，并在浏览器端使用，RequireJS是实现AMD规范的著名库</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="title function_">define</span>([], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> libMethod;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;lib&#x27;</span>], <span class="keyword">function</span>(<span class="params">libMethod</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>ES Modules (ESM)</strong></p><ul><li><p><strong>概念</strong></p><p>ESM是ECMAScript标准的一部分，是JavaScript的官方模块系统</p><p>它设计之初就考虑到了代码的静态分析，允许浏览器和服务器（如Node.js）对模块进行优化载入</p></li><li><p><strong>核心思想</strong></p><p>通过<code>import</code>和<code>export</code>语句来导入导出模块</p><p>ESM支持静态导入也支持动态导入（通过<code>import()</code>表达式）</p><p>ESM的模块是单例的，且导入导出是实时绑定的，并且ESM模块是异步解析的</p></li><li><p>这是现代浏览器支持的原生JavaScript模块系统，利用<code>import</code>和<code>export</code>关键字实现模块化</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; libMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>UMD</strong></p><ul><li><p><strong>概念</strong></p><p>UMD是一种兼容CommonJS和AMD的模块定义方式，它使得模块可以在AMD环境、CommonJS环境以及全局变量使用场景下运行</p></li><li><p><strong>核心思想</strong></p><p> UMD通过一个立即执行的函数表达式(IIFE)来检测当前环境支持哪模块方案，并相应地初始化模块</p><p>它试图提供一个在前后端都可以通用的方案，实现代码的最大兼容性</p></li><li><p>UMD是一种支持两种模块化标准（CommonJS和AMD）的模式，以便模块能够在AMD环境、CommonJS环境和全局变量的使用环境中使用</p></li><li><p>UMD尤其适合那些要在浏览器和服务器（比如Node）上运行的模块</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">    <span class="title function_">define</span>([], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span> ? self : <span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Actual module code</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> libMethod;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (CommonJS)</span></span><br><span class="line"><span class="keyword">const</span> libMethod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (AMD)</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;lib&#x27;</span>], <span class="keyword">function</span>(<span class="params">libMethod</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (Browser Global)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">returnExports</span>());</span><br></pre></td></tr></table></figure></li></ol><p>ESM是目前推荐的JavaScript模块化标准，因为它是JavaScript语言的官方标准，得到了现代浏览器和Node.js的原生支持，无需额外的工具或编译</p><p>模块化使得开发者能够构建大型、复杂的应用程序，通过模块划分可以让不同的功能和组件彼此隔离，变得更易于理解和调试</p><p>同时也促进了社区共享代码，例如通过npm上的包</p><div class="table-container"><table><thead><tr><th style="text-align:left">特点/标准</th><th style="text-align:left">CommonJS</th><th style="text-align:left">AMD</th><th style="text-align:left">ESM</th><th style="text-align:left">UMD</th></tr></thead><tbody><tr><td style="text-align:left">环境</td><td style="text-align:left">Node.js</td><td style="text-align:left">浏览器</td><td style="text-align:left">现代浏览器和Node.js</td><td style="text-align:left">浏览器和Node.js</td></tr><tr><td style="text-align:left">异步加载</td><td style="text-align:left">不支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持（依条件）</td></tr><tr><td style="text-align:left">导入语法</td><td style="text-align:left">require</td><td style="text-align:left">define/require</td><td style="text-align:left">import</td><td style="text-align:left">根据环境使用require或define</td></tr><tr><td style="text-align:left">导出语法</td><td style="text-align:left">module.exports</td><td style="text-align:left">return</td><td style="text-align:left">export</td><td style="text-align:left">module.exports或return</td></tr><tr><td style="text-align:left">本地变量</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">循环依赖</td><td style="text-align:left">支持</td><td style="text-align:left">有限支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">标准</td><td style="text-align:left">非官方标准</td><td style="text-align:left">非官方标准</td><td style="text-align:left">ECMA标准</td><td style="text-align:left">综合式非官方标准</td></tr><tr><td style="text-align:left">加载方式</td><td style="text-align:left">同步</td><td style="text-align:left">异步</td><td style="text-align:left">同步和异步</td><td style="text-align:left">适应性</td></tr><tr><td style="text-align:left">浏览器支持</td><td style="text-align:left">通常需要打包工具</td><td style="text-align:left">通常需要RequireJS</td><td style="text-align:left">原生支持，可能需要编译</td><td style="text-align:left">无需特定库或工具</td></tr><tr><td style="text-align:left">执行时机</td><td style="text-align:left">立即执行</td><td style="text-align:left">延时执行</td><td style="text-align:left">导入时执行</td><td style="text-align:left">根据模块系统选择立即执行或延时执行</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：JavaScript对象里面的可枚举性是什么"><a href="#Q30：JavaScript对象里面的可枚举性是什么" class="headerlink" title="Q30：JavaScript对象里面的可枚举性是什么"></a>Q30：JavaScript对象里面的可枚举性是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，对象属性（包括数据属性和访问器属性）有一个名为“可枚举性”的特性（enumerable）</p><p>可枚举性决定了一个属性是否能够出现在对象的枚举属性中，也就是说，它是否可以通过某些循环或方法（如<code>for...in</code>循环、<code>Object.keys()</code>方法、<code>JSON.stringify()</code>函数等）来访问</p><p>如果一个属性的可枚举性特性为<code>true</code>，那么它就可以被这些操作发现或访问</p><p>反之，如果可枚举性为<code>false</code>，则这些操作会忽略该属性</p><p>这里有一个例子来说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象上定义一个不可枚举的属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;nonEnumerableProperty&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;This is non-enumerable&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象上定义一个可枚举的属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;enumerableProperty&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;This is enumerable&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出对象的所有可枚举属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果： &quot;enumerableProperty: This is enumerable&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>enumerableProperty</code>的可枚举性为<code>true</code>，所以它可以在<code>for...in</code>循环中被访问到</p><p>而<code>nonEnumerableProperty</code>的可枚举性为<code>false</code>，所以它在循环中被忽略</p><p>需要注意的是，尽管可枚举性决定了属性是否可以通过<code>for...in</code>循环或<code>Object.keys()</code>方法等方式访问，但并不阻止通过点标记法（<code>.</code>）或方括号（<code>[]</code>）来直接访问属性</p><p>即使属性的可枚举性为<code>false</code>，我们仍然可以直接获取或设置其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">nonEnumerableProperty</span>); </span><br><span class="line"><span class="comment">// 输出结果：&quot;This is non-enumerable&quot;</span></span><br></pre></td></tr></table></figure><p>简而言之，可枚举性特性控制了一些枚举操作如何与属性交互，而不是控制访问属性的能力</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：对函数式编程的理解"><a href="#Q31：对函数式编程的理解" class="headerlink" title="Q31：对函数式编程的理解"></a>Q31：对函数式编程的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数式编程（Functional Programming, FP）是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据</p><p>与面向对象编程强调对象包含数据和行为不同，函数式编程强调了应用函数和函数之间的组合，以创建更复杂的函数和过程</p><p><strong>优点:</strong></p><ol><li><p><strong>易于测试和调试</strong> </p><p>因为纯函数遵循相同输入相同输出的原则，不依赖于程序中的其他状态，这使得纯函数更容易进行单元测试。</p></li><li><p><strong>更好的模块化</strong> </p><p>函数式编程鼓励将大问题分解为小问题，通过函数组合的方式将小函数组合起来解决复杂的问题。</p></li><li><p><strong>更少的副作用</strong></p><p> 函数式编程的纯函数减少了意外的副作用，使得程序的状态更加可控，降低了程序运行过程中出现bug的风险。</p></li><li><p><strong>并行处理</strong> </p><p>不可变数据和无副作用函数意味着没有线程之间的冲突，可以更安全地进行并行代码的编写。</p></li><li><p><strong>代码的可读性</strong> </p><p>通过函数组合可以写出声明式的代码，意图更加明确，可读性更好。</p></li></ol><p><strong>缺点:</strong></p><ol><li><p><strong>学习曲线</strong> </p><p>对于习惯了命令式编程的开发者来说，需要时间适应函数式编程的思维方式</p></li><li><p><strong>性能问题</strong></p><p> 递归和不可变数据结构可能导致性能下降，尤其是在那些不自动进行尾调用优化的环境中</p></li><li><p><strong>内存使用</strong> </p><p>纯粹函数式编程使用不可变数据，可能会增加内存的使用量，因为每次数据修改都会创建一个新的数据副本</p></li><li><p><strong>语言支持</strong> </p><p>不是所有编程语言都原生支持函数式编程概念，有些语言可能只能通过库来实现，这可能会制约函数式编程的应用</p></li><li><p><strong>递归的复杂性</strong></p><p> 在一些场景下，使用递归比迭代循环更难以理解，且如果递归深度过大也可能导致栈溢出</p></li><li><p><strong>资源消耗</strong> </p><p>某些函数式编程操作，比如尤其在组合多个函数操作大数据集时，可能会导致计算资源（CPU/内存）的高消耗</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>函数式编程的一些关键特征和概念：</p><ol><li><p><strong>不可变性（Immutability）</strong></p><p>在函数式程序中，状态是不可变的。一旦创建了数据结构（如对象、数组等），它就不能被修改。任何“修改”操作都会产生一个新的数据结构，而原有的数据结构保持不变。</p></li><li><p><strong>纯函数（Pure Functions）</strong></p><p>函数的输出仅由输入决定，不依赖于程序的状态（无状态）、不修改程序状态，也不具有可观察的副作用，使得它们更易于推理与测试</p></li><li><p><strong>函数组合（Function Composition）</strong></p><p>小函数可以组合成更复杂的函数，就像在数学中的函数组合（f o g）</p><p>这种方式可以构建出复杂的操作，而每一个操作都由简单清晰的函数构成</p></li><li><p><strong>高阶函数（Higher-Order Functions）</strong></p><p>函数可以作为参数或返回值传递。这使得抽象和重复的逻辑能够被轻易地重用</p></li><li><p><strong>惰性评估（Lazy Evaluation）</strong></p><p>计算会被推迟直到绝对需要结果，这可以提升性能，通过避免不必要的计算，并能处理无限数据结构（比如无限列表）</p></li><li><p><strong>递归（Recursion）</strong></p><p>在函数式编程中，循环被递归结构所替代</p><p>因为没有可变状态，函数式编程利用递归来执行重复任务或迭代数据结构</p></li><li><p><strong>模式匹配（Pattern Matching）</strong></p><p>这通常用于FP中，可以简化对数据结构的解构和分析，是一种更直观的数据访问与处理方式</p></li><li><p><strong>尾调用优化（Tail Call Optimization）</strong></p><p>尾调用是指函数的最后一个动作是返回另一个函数调用</p><p>尾调用优化降低了递归函数的空间复杂度，从而避免栈溢出</p></li></ol><p>函数式编程的目标是使用这些原则和技术来创造更可预测、更少出错并易于测试的软件</p><p>然而，实际应用时，完全的不可变性或纯函数可能难以实现或低效</p><p>因而，现代函数式编程语言和库通常提供了一些实用主义的策略，以便更好的融入实际问题解决之中</p><p>其中，JavaScript并不是一种纯粹的函数式编程语言，但是它支持许多函数式编程的特性，并且社区内有大量的库来应用函数式编程概念</p><p><br /></p><p>命令式编程（Imperative Programming）是一种计算机编程范式，它通过详细描述计算机需要执行的步骤来更改程序状态</p><p>这一范式是通过编写一系列指令来告诉计算机如何达到期望的结果，这些指令会改变程序的状态</p><p>命令式编程可以视为一系列的命令，指导计算机完成特定的操作，类似于烹饪食谱中的步骤，每个步骤告诉你如何做</p><p><strong>特征</strong></p><p><strong>详细性：</strong> 在命令式编程中，开发人员需要给出获取输出的确切步骤指令</p><p><strong>状态变化：</strong> 程序由一系列的状态组成，各个命令将导致状态的变化</p><p><strong>控制结构：</strong> 包括循环、条件分支、顺序结构等，控制程序的执行流程</p><p><strong>变量：</strong> 功能上类似于存储数据的 “容器”，它们的值可以改变</p><p><strong>迭代：</strong> 重复执行同一块代码，直到满足特定条件</p><p><strong>常见语言</strong></p><p>许多流行的编程语言是支持命令式编程的：</p><ul><li>C</li><li>C++</li><li>Java</li><li>Python（虽然它同时也支持其他编程范式）</li></ul><p><strong>优点与缺点</strong></p><p><strong>优点：</strong></p><ul><li><strong>直观性：</strong> 思考和解决问题的方式更符合我们进行日常任务时的顺序逻辑</li><li><strong>控制性：</strong> 开发者可以控制程序的每一步，使得可以进行微观管理</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性：</strong> 当应用程序变得复杂时，管理和理解所有的状态变化变得困难</li><li><strong>可维护性：</strong> 代码重复和难以追踪的状态可能导致程序难以维护</li><li><strong>并发性：</strong> 变化的状态使得处理并发任务更加复杂</li></ul><p>命令式编程和函数式编程最主要的区别在于，命令式编程关注如何执行，而函数式编程关注什么需要被执行</p><p>在函数式编程中，状态的变化被尽量避免，而命令式编程则大量依赖于状态变化</p><p>在实际的工作中，很多语言和项目会融合多种编程范式，以适合不同的用例和优化开发体验</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：对闭包的理解"><a href="#Q32：对闭包的理解" class="headerlink" title="Q32：对闭包的理解"></a>Q32：对闭包的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>闭包（Closure）在编程中是一个非常重要的概念，尤其是在JavaScript等支持词法作用域的编程语言中</p><p><strong>闭包的定义</strong></p><p>闭包是函数和声明该函数的词法环境的组合</p><p>它允许一个函数访问并操纵函数外部的变量</p><p>即使外部函数执行完毕，闭包仍然能记住和访问函数外部的变量</p><p><strong>闭包的优点包括：</strong></p><ul><li><p><strong>数据封装性</strong></p><p> 闭包可以帮助创建私有变量，其他代码不能直接访问这些变量，只能通过提供的方法来操作</p></li><li><p><strong>持久性</strong> </p><p>常规的局部变量在函数执行完后会被销毁，但闭包中的数据可以维持状态，即使外部函数调用结束后仍然存在</p></li><li><p><strong>记忆状态</strong> </p><p>闭包可以记住它被创建时的环境，这使得它非常适合在如实现迭代器或生成器等场景</p></li></ul><p><strong>闭包的缺点包括：</strong></p><ul><li><p><strong>内存消耗</strong> </p><p>因为闭包可能会长时间保存变量，所以它可能会导致比普通函数更大的内存消耗</p></li><li><p><strong>复杂性</strong> </p><p>对于不熟悉闭包的开发者来说，闭包可能会带来不必要的复杂性和理解障碍</p></li><li><p><strong>调试困难</strong> </p><p>由于闭包的特殊作用域，有时候调试它们的状态和行为可能会比较困难</p></li></ul><p><strong>闭包的使用场景：</strong></p><ul><li><p><strong>事件处理</strong> </p><p>在JavaScript中，闭包广泛用于事件监听和处理中，以便在事件回调中使用在外部函数中定义的数据</p></li><li><p><strong>模拟私有方法和变量</strong> </p><p>在JavaScript中模拟对象的私有成员</p></li><li><p><strong>函数柯里化</strong></p><p> 闭包可以用于函数柯里化，创建一个新函数，这个新函数持有一些已设定的参数</p></li><li><p><strong>模块化</strong></p><p>创建模块，闭包能够将一组相关的功能封装起来，形成一个模块，公开一些方法，隐藏其他状态和方法</p></li></ul><p>例如，下面的代码展示了一个创建闭包的例子，其中的<code>makeAdder</code>函数创建了一个闭包，包括函数<code>adder</code>和该函数能记住的自由变量<code>x</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = <span class="title function_">makeAdder</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add10</span>(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>add5</code>和<code>add10</code>是闭包，它们分别记忆了<code>x</code>为5和10</p><p>即使<code>makeAdder</code>函数的执行上下文结束后，这两个闭包仍然可以访问和操纵它们自己的<code>x</code>变量</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>函数柯里化（Currying）是函数式编程中的一个重要概念，它是指将一个接受多个参数的函数转换成接受单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数的技术</p><p><strong>基本原理</strong></p><p>柯里化的核心是闭包</p><p>利用闭包可以存储函数的状态，还可以继续接收剩余的参数，直到所有参数都被传递完毕，最后统一处理这些参数</p><p><strong>柯里化的作用</strong></p><p>柯里化主要有以下几个作用：</p><ul><li><p><strong>参数复用</strong> </p><p>柯里化可以将一个多参数的函数转换成多个单参数函数，这样部分参数可以被复用</p></li><li><p><strong>延迟计算/执行</strong> </p><p>通过柯里化可以延迟函数的执行，只有在接收了所有需要的参数之后，才执行原函数</p></li><li><p><strong>动态生成函数</strong></p><p> 可以根据传入的参数，动态地生成具有特定功能的新函数</p></li></ul><p><strong>一个简单的柯里化函数示例</strong></p><p>来看一个简化的柯里化函数的例子，用以加深理解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果提供的参数数量足够，则直接调用原函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，返回一个接受剩余参数的函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的未柯里化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后的函数</span></span><br><span class="line"><span class="keyword">const</span> curriedSum = <span class="title function_">curry</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>curry</code>函数接收一个函数<code>fn</code>并返回一个新的函数<code>curried</code></p><p>当<code>curried</code>函数被调用，它检查传递给它的参数数量</p><p>如果参数数量不够，它返回一个新的函数，这个函数期待更多的参数</p><p>这个过程会一直进行直到收到了足够的参数，最终原始函数被调用</p><p><strong>使用场景</strong></p><p>常见的柯里化使用场景有事件处理、部分求值等需要预置某些参数的情况</p><p><strong>注意事项</strong></p><p>柯里化函数通常的实现依赖于闭包，这意味着柯里化可能会导致与闭包相同的一些问题，例如变量作用域混淆和内存消耗问题</p><p>柯里化是一种强大但稍显复杂的技术</p><p>在实际应用中，它可以帮助我们编写高度模块化和重用性强的代码</p><p>了解和掌握柯里化，可以提升你在函数式编程领域的技能，并能帮助你更好的理解JavaScript这门语言的函数式特性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：深拷贝跟浅拷贝"><a href="#Q33：深拷贝跟浅拷贝" class="headerlink" title="Q33：深拷贝跟浅拷贝"></a>Q33：深拷贝跟浅拷贝</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>深拷贝</p><ul><li><p>浅拷贝是创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</p></li><li><p>实现方式</p><ul><li><p><strong>Object.assign</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扩展运算符</strong></p><p>当对象里面只有基础类型的时候，拓展运算符就会变成深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>浅拷贝</p><ul><li><p>深拷贝会拷贝所有的属性，并且会递归到所有层级的子属性，直到找到所有的基本类型为止。这样的话，一个对象改变不会影响另一个对象</p></li><li><p>实现方式</p><ul><li><p><strong>JSON.parse(JSON.stringify(object))</strong></p><p>需要特别注意，<code>JSON.parse(JSON.stringify(object))</code>会忽略掉原对象中的<code>undefined</code>、<code>function</code>和<code>symbol</code></p><p>并且，如果对象中存在循环引用的情况也无法正确处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>递归拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            copy[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>lodash 的 _.cloneDeep</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h3 id="Q1：typeof-NaN的结果是什么"><a href="#Q1：typeof-NaN的结果是什么" class="headerlink" title="Q1：typeof NaN的结果是什么"></a>Q1：typeof NaN的结果是什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>NaN（Not a Number）是一种特殊的数值，表示一个本来要返回数值的操作未返回数值的情况。虽然 NaN 是一种特殊的数值，但它的数据类型仍然被归类为 <code>&#39;number&#39;</code>。</p><p>这种设计的原因在于 JavaScript 的 <code>typeof</code> 操作符返回数据类型的字符串表示，而 <code>&#39;number&#39;</code> 是 NaN 实际的数据类型。因此，<code>typeof NaN</code> 返回 <code>&#39;number&#39;</code> 是符合语言规范的结果。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>typeof NaN</code> 的结果是 <code>&#39;number&#39;</code></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>NaN</code> 是一个特殊的值，表示 “Not a Number”，通常用于表示数学运算中产生的非数值结果。虽然 <code>NaN</code> 本身不是一个有效的数字，但是它仍然可以参与一些操作。</p><p>以下是一些 <code>NaN</code> 的用法示例：</p><ol><li><p><strong>检查是否为 <code>NaN</code></strong>： 可以使用全局函数 <code>isNaN()</code> 来检查一个值是否为 <code>NaN</code>。这个函数会尝试将传入的值转换为数字，如果不能成功转换为数字，或者转换后的值是 <code>NaN</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查是否为有效数字</strong>： 由于 <code>NaN</code> 表示 “Not a Number”，因此可以使用 <code>isNaN()</code> 函数来检查一个值是否为有效的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数学运算中的 <code>NaN</code></strong>： 当数学运算中出现非法操作时，通常会产生 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断是否为 <code>NaN</code></strong>： 可以使用 <code>===</code> 运算符直接比较一个值是否等于 <code>NaN</code>。注意，<code>NaN</code> 与任何其他值，包括自身，都不相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>总之，<code>NaN</code> 在 JavaScript 中代表着 “Not a Number”，通常用于表示数学运算中产生的非数值结果，可以通过 <code>isNaN()</code> 函数来检查一个值是否为 <code>NaN</code>，并且在一些操作中需要小心处理 <code>NaN</code> 的情况</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何区分数组和对象"><a href="#Q2：如何区分数组和对象" class="headerlink" title="Q2：如何区分数组和对象?"></a>Q2：如何区分数组和对象?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Array.isArray() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myArray)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>typeof 操作符</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myObject === <span class="string">&#x27;object&#x27;</span> &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myObject)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>instanceof 操作符</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (myArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查构造函数</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myArray.<span class="property">constructor</span> === <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myObject.<span class="property">constructor</span> === <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查原型链</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myArray) === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObject) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：js中如何判断一个值是否是数组类型"><a href="#Q3：js中如何判断一个值是否是数组类型" class="headerlink" title="Q3：js中如何判断一个值是否是数组类型?"></a>Q3：js中如何判断一个值是否是数组类型?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>instanceof 操作符</strong>：使用 <code>instanceof</code> 操作符可以检查一个值是否是某个对象的实例，对于数组来说，可以检查是否是 <code>Array</code> 类型的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用对象的 constructor 属性</strong>：每个 JavaScript 对象都有一个 <code>constructor</code> 属性，可以通过它来获取对象的构造函数。对于数组来说，其构造函数是 <code>Array</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">constructor</span> === <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Object.prototype.toString() 方法</strong>：通过调用 <code>Object.prototype.toString()</code> 方法，可以获取对象的字符串表示，对于数组来说，其返回的字符串格式是 <code>[object Array]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) === <span class="string">&#x27;[object Array]&#x27;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用数组的原型链</strong>：数组是原型链的一部分，可以通过 <code>Array.prototype</code> 来检查一个值是否具有数组的方法和属性。如果一个值具有数组的方法和属性，那么它很可能是一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>以上方法都可以用来判断一个值是否是数组类型，但各有优劣。<code>Array.isArray()</code> 方法是最简单直接的方式，而其他方法更多是作为了解 JavaScript 内部工作原理的参考。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：null和-undefined-有什么区别"><a href="#Q4：null和-undefined-有什么区别" class="headerlink" title="Q4：null和 undefined 有什么区别?"></a>Q4：null和 undefined 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>null</code> 和 <code>undefined</code> 是 JavaScript 中的两种特殊的数据类型，它们之间有一些区别：</p><ol><li><p><strong>undefined</strong>:</p><ul><li><p><code>undefined</code> 是表示未定义的值，用于表示变量声明了但没有赋值的情况，或者函数调用时没有提供参数的情况。</p></li><li><p>在 JavaScript 中，未初始化的变量默认值为 <code>undefined</code>。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">console.log(x); // 输出 undefined</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>null</strong>:</p><ul><li><p><code>null</code> 是表示空值的特殊值，用于表示一个变量被显式地赋值为“空”。</p></li><li><p><code>null</code> 值不代表任何对象，它是 JavaScript 中的关键字。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var y = null;</span><br><span class="line">console.log(y); // 输出 null</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>主要区别：</p><ul><li><code>undefined</code> 表示变量未定义或者属性不存在，而 <code>null</code> 表示变量已经定义并且赋值为“空”。</li><li>在使用条件语句时，<code>undefined</code> 会被转换为 <code>false</code>，而 <code>null</code> 不会。</li><li>当想要表示一个“空”值时，通常使用 <code>null</code>，而不是 <code>undefined</code>。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：’1’-toString-为什么不会报错"><a href="#Q5：’1’-toString-为什么不会报错" class="headerlink" title="Q5：’1’.toString()为什么不会报错?"></a>Q5：’1’.toString()为什么不会报错?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，基本数据类型（如数字、字符串和布尔值）并没有方法</p><p>然而，JavaScript 允许你像对待对象一样对待这些基本类型的值，比如调用方法</p><p>这是因为 JavaScript 会临时地将它们转换成对应的对象，这个过程称为“装箱”（Boxing）</p><p>之后，就可以在这个对象上调用方法了</p><p>其实在这个语句运行的过程中做了这样几件事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;1&#x27;</span>); </span><br><span class="line">s.<span class="title function_">toString</span>();</span><br><span class="line">s = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，当调用<code>&#39;1&#39;.toString()</code>时，JavaScript 内部会自动创建一个临时的<code>String</code>对象，然后在这个对象上调用<code>toString</code>方法</p><p>调用完成后，这个临时对象就被丢弃</p><p>这个过程对于开发者来说是透明的，开发者看到的只是原始类型值似乎拥有了调用方法的能力</p><p>整个过程体现了 <code>基本包装类型</code> 的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String</p><p>在JavaScript中，基本包装类型是一些特殊的内置构造函数，这些构造函数用于为简单的基本数据类型（如String, Number, Boolean）创建对应的对象</p><p>这样做使得基本数据类型可以像对象一样使用，且能访问一些方法去处理数据，比如字符串的拼接、大小写转换，数字的转换，以及布尔值的逻辑操作等</p><p>这三个基本包装类型如下：</p><ol><li><strong>String</strong>：用于创建一个包含字符串的对象</li><li><strong>Number</strong>：用于创建一个包含数字的对象</li><li><strong>Boolean</strong>：用于创建一个包含布尔值（true或false）的对象</li></ol><p>以下展示了如何使用基本包装类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这些基本包装类型的对象版和基本类型的值版（如直接使用字面量创建的字符串、数字或布尔值）在许多情况下行为很相似，但它们是不同的</p><p>对象是引用类型，而基本数据类型是直接值</p><p>这意味着基本类型的值存储是按值访问的，并且它们是不可变的</p><p>而包装对象则是按照引用访问的，它们有自己的内存地址，并且是可以添加属性的对象</p><p>大多数情况下，没有必要直接使用基本包装类型，因为JavaScript会自动进行装箱和拆箱操作</p><p>当对一个基本类型值调用方法时，JavaScript会临时使用相应的包装类型来使这一方法的调用成为可能</p><p>在方法执行完之后，这个临时创建的包装对象就会被销毁</p><p>这个过程是自动和隐形的，从而让基本数据类型看起来像是具有对象的性质</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>这个现象根源于JavaScript语言的设计原则及其类型系统的构造</p><p>JavaScript是一种动态类型语言，它通过一套称为自动装箱（autoboxing）的机制使得原始数据类型（如字符串、数字和布尔值）能够调用与之对应的对象原型上的方法</p><p>这种设计使得基础数据类型在使用上更加灵活，同时保持了性能效率</p><p><strong>自动装箱转换机制</strong></p><p>在JavaScript中，当对一个原始值（比如字符串、数字或布尔值）执行对象的操作时，JavaScript会临时把这个原始值包装成一个相应类型的对象</p><p>这个过程是自动的，发生在原始值上调用方法的那一刻</p><p>例如，当你对一个字符串调用<code>.toString()</code>方法时，JavaScript内部会创建一个<code>String</code>对象，然后在这个临时对象上调用<code>.toString()</code>方法</p><p>方法调用完成后，这个对象会被丢弃，不会影响原始值</p><p><strong>为何不能跨类型调用方法</strong></p><p>原始数据类型包装对象的设计初衷是为了提供对相应类型相关操作的便捷性，并不意味着可以让数据类型之间无限制地互相调用对方的方法：</p><ol><li><p><strong>类型安全</strong></p><p>不同的数据类型支持不同的方法，这基于它们各自的用途和行为</p><p>允许一个类型的原始值随意调用另一个类型的方法会破坏类型之间的边界，引入潜在的类型安全问题和逻辑错误</p></li><li><p><strong>明确性和可维护性</strong></p><p>JavaScript的设计鼓励明确而直接的代码</p><p>类型之间的明确界限让代码更容易理解和维护</p><p>如果原始数据类型之间可以相互调用方法，这将大大增加理解和使用语言时的复杂度</p></li><li><p><strong>性能问题</strong></p><p>自动的类型转换和方法调用如果不受限制地发生，可能会导致性能问题</p><p>为了维护运行时的效率，避免不必要的类型转换和装箱操作是重要的</p></li></ol><p><strong>实用性</strong></p><p>在实际应用中，如果你需要对一个数据类型执行不自然的操作（例如，把字符串当作数组处理），通常有专门的方法或者是模式来实现这个需求，比如使用<code>split</code>方法把字符串转换为数组，再对数组操作</p><p>这样的处理方式更加明确且高效</p><p>JavaScript提供了足够的工具和方法来在不同类型之间进行转换和操作，同时保持代码的清晰和效率</p><p>总的来说，虽然JavaScript通过自动装箱允许原始数据类型调用对象方法，这种机制的存在是为了增强编程的便利性和灵活性，而不是让不同数据类型之间的方法随意横跨调用</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：typeof-与instanceof-有什么区别"><a href="#Q6：typeof-与instanceof-有什么区别" class="headerlink" title="Q6：typeof 与instanceof 有什么区别"></a>Q6：typeof 与instanceof 有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>typeof</code> 和 <code>instanceof</code> 是 JavaScript 中用于检查数据类型的两种操作符，它们有以下区别：</p><ol><li><strong>typeof</strong>：<ul><li>用法：<code>typeof</code> 是一个一元操作符，可以用来检查一个值的数据类型。</li><li>返回值：<code>typeof</code> 返回一个表示值的数据类型的字符串，包括 <code>&quot;undefined&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;bigint&quot;</code>、<code>&quot;symbol&quot;</code>、<code>&quot;function&quot;</code> 和 <code>&quot;object&quot;</code>。</li><li>特点：<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，这是一个历史遗留问题；<code>typeof</code> 对于函数和数组也返回 <code>&quot;function&quot;</code> 和 <code>&quot;object&quot;</code>，无法准确区分。</li><li>适用范围：通常用于检查基本数据类型（除了 <code>null</code>）和函数的数据类型。</li></ul></li><li><strong>instanceof</strong>：<ul><li>用法：<code>instanceof</code> 是一个二元操作符，用于检查对象是否属于某个类或其原型链上是否存在某个构造函数的 prototype 属性。</li><li>返回值：如果对象是指定类的实例，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>特点：<code>instanceof</code> 通过原型链检查对象的构造函数是否存在于指定类的原型链上，因此可以准确地检查对象是否是指定类的实例。</li><li>适用范围：通常用于检查对象是否是特定类的实例，特别适用于自定义对象或继承关系的检查。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：JavaScript中的错误有哪几种类型"><a href="#Q7：JavaScript中的错误有哪几种类型" class="headerlink" title="Q7：JavaScript中的错误有哪几种类型?"></a>Q7：JavaScript中的错误有哪几种类型?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>语法错误（Syntax Errors）</strong></p><p>也称为解析错误（Parsing Errors），是由于代码中的语法不正确而导致的错误</p><p>这种错误通常在代码解析阶段就会被检测到，并在控制台中显示错误消息</p></li><li><p><strong>类型错误（Type Errors）</strong></p><p>当操作或表达式的类型不符合预期时，会引发类型错误</p><p>例如，对非函数对象进行函数调用、对未定义或空值进行属性访问、非法的操作符操作等</p><p>这种错误通常会在运行时抛出异常</p></li><li><p><strong>引用错误（Reference Errors）</strong></p><p>当代码尝试引用一个不存在的变量或属性时，会抛出引用错误</p><p>例如，访问未定义的变量、调用未声明的函数、使用未定义的对象属性等</p></li><li><p><strong>范围错误（Range Errors）</strong></p><p>当操作超出有效范围时，会引发范围错误</p><p>例如，尝试使用超出数组长度的索引、使用负数作为参数传递给内置函数（如 <code>Array</code> 构造函数的 <code>length</code> 属性）等</p></li><li><p><strong>URI 错误（URI Errors）</strong></p><p>在处理统一资源标识符（URI）时发生的错误，例如使用 <code>encodeURI()</code> 和 <code>decodeURI()</code> 函数时的错误</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：js中的undefined和-ReferenceError-xxx-is-not-defined-有什么区别"><a href="#Q8：js中的undefined和-ReferenceError-xxx-is-not-defined-有什么区别" class="headerlink" title="Q8：js中的undefined和 ReferenceError: xxx is not defined 有什么区别?"></a>Q8：js中的undefined和 ReferenceError: xxx is not defined 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>JavaScript 中的 <code>undefined</code> 和 <code>ReferenceError</code> 的区别在于它们表示的含义和产生的原因不同。</p><ol><li><p><strong><code>undefined</code></strong>：</p><ul><li><p><code>undefined</code> 表示一个变量已被声明，但尚未被赋值，或者一个函数没有明确返回值时的默认返回值。</p></li><li><p>当你访问一个已声明但未赋值的变量时，或者调用一个没有返回值的函数时，其结果会是 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>ReferenceError</code></strong>：</p><ul><li><p><code>ReferenceError</code> 表示一个变量不存在，即在作用域中未声明或未定义该变量。</p></li><li><p>当你访问一个未声明的变量时，或者尝试访问一个未在当前作用域内定义的变量时，会导致 <code>ReferenceError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>undefined</code> 是一个表示未赋值的特殊值，而 <code>ReferenceError</code> 表示变量或函数在当前作用域中未定义</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：null是对象吗？为什么"><a href="#Q9：null是对象吗？为什么" class="headerlink" title="Q9：null是对象吗？为什么"></a>Q9：null是对象吗？为什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>null</code> 被认为是一种特殊的对象类型，但实际上它并不是一个对象。<code>null</code> 表示一个空值或者不存在的对象，用于表示一个变量不指向任何对象。</p><p>尽管在 JavaScript 中，<code>typeof null</code> 的结果是 <code>&quot;object&quot;</code>，但这其实是一个历史遗留问题，起源于 JavaScript 最初的设计。在 JavaScript 的早期版本中，表示对象的第一个字节的值为 <code>000</code>，而 <code>null</code> 的二进制表示是全 <code>0</code>，因此被错误地判断为对象类型。这个问题至今仍然保留了下来，为了保持向后兼容性，JavaScript 的设计者们没有修复这个问题。</p><p>因此，尽管 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>，但 <code>null</code> 实际上不是一个对象，而是一个原始值。可以使用 <code>===</code> 运算符来判断一个值是否为 <code>null</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：数据类型检测的方式有哪些"><a href="#Q10：数据类型检测的方式有哪些" class="headerlink" title="Q10：数据类型检测的方式有哪些"></a>Q10：数据类型检测的方式有哪些</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>typeof</code>运算符</p><p><code>typeof</code>是最常用的检测数据类型的方法，适用于基本类型（如String, Number, Boolean, Undefined, Symbol）的检测，但对于Array, Null, Object的检测则会返回<code>&quot;object&quot;</code>，对于Function会返回<code>&quot;function&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">42</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>)); <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.isArray()</code>方法</p><p>由于<code>typeof</code>不能准确判断数组类型，<code>Array.isArray()</code>方法能够准确检测一个值是否为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>instanceof</code>运算符</p><p><code>instanceof</code>可以检测一个对象是否是其原型链中某个构造函数的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.prototype.toString.call()</code></p><p>这个方法通过调用<code>Object</code>原型上的<code>toString</code>方法检测对象的类型，可以准确区分大部分内置对象类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;Hello World&quot;</span>)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())); <span class="comment">// [object Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>))); <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数名称<code>（constructor.name）</code></p><p>每个对象都有一个<code>constructor</code>属性，该属性指向创建该对象的构造函数</p><p>通过检查<code>constructor.name</code>属性的值，可以得知对象类型的名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Function</span></span><br></pre></td></tr></table></figure></li></ol><p>每种方法都有其优缺点，选择哪种方法取决于具体的应用场景和对准确度的要求</p><p>通常，<code>Object.prototype.toString.call()</code>提供了最准确的类型检测结果</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：isNaN-和-NumberisNaN-函数有什么区别"><a href="#Q11：isNaN-和-NumberisNaN-函数有什么区别" class="headerlink" title="Q11：isNaN 和 NumberisNaN 函数有什么区别"></a>Q11：isNaN 和 NumberisNaN 函数有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>isNaN</code>（全局函数）</p><ul><li><code>isNaN</code>函数将其参数转换成数字，然后判断该数字是否为<code>NaN</code></li><li>如果参数不能被转换成数字（比如一个字符串或对象），或者转换后的数字是<code>NaN</code>，则返回<code>true</code></li><li>也就是说，如果你传递给<code>isNaN</code>的参数在转换为数字过程中变成了<code>NaN</code>，那么<code>isNaN</code>就会返回<code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// true - &quot;hello&quot; 转换为数字失败，所以是 NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true - undefined 转换为数字得到 NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// true - &#123;&#125; 转换为数字失败</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">37</span>);        <span class="comment">// false - 37 是一个数字</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isNaN</code>（ES6中引入）</p><ul><li><code>Number.isNaN</code>不会将参数转换成数字，只有当参数类型为<code>Number</code>且值为<code>NaN</code>时，才返回<code>true</code></li><li>它是对<code>NaN</code>的直接判断，不会有任何类型转换，这意味着除了<code>NaN</code>本身，对于其他不是数字类型的参数，即使它们在类型转换后可能会是<code>NaN</code>，<code>Number.isNaN</code>也返回<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// false - 这里不会尝试将字符串 &quot;hello&quot; 转换成数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// false - undefined 不是数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// false - &#123;&#125; 不是数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">37</span>);        <span class="comment">// false - 37 是一个数字</span></span><br></pre></td></tr></table></figure></li></ol><p><code>Number.isNaN</code>是一个更严格的检查，它避免了<code>isNaN</code>因为类型强制转换导致的一些可能会引起混淆的情况</p><p>因此，在判断一个值是否为<code>NaN</code>时，通常推荐使用`Number.isNaN</p>
              </div>
            </details>
<p><br/></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="Q1：怎么获取到一个实例对象的原型对象？"><a href="#Q1：怎么获取到一个实例对象的原型对象？" class="headerlink" title="Q1：怎么获取到一个实例对象的原型对象？"></a>Q1：怎么获取到一个实例对象的原型对象？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>Object.getPrototypeOf(obj)</code>：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype1 = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype1);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>__proto__</code> 属性（非标准）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype2 = obj.<span class="property">__proto__</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype2);</span><br><span class="line"><span class="comment">// 虽然在一些环境中有效，但不是标准的 JavaScript，而且在未来可能会被废弃</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数的 <code>prototype</code> 属性：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomObject</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">CustomObject</span>(); <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype3 = <span class="title class_">CustomObject</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype3);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过实例对象的构造函数的 <code>constructor</code> 属性和 <code>prototype</code> 属性：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomObject</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">CustomObject</span>(); <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype4 = obj.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype4);</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：改变this指向的方法有哪些？"><a href="#Q2：改变this指向的方法有哪些？" class="headerlink" title="Q2：改变this指向的方法有哪些？"></a>Q2：改变this指向的方法有哪些？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，有几种方式可以改变函数执行时的 <code>this</code> 指向：</p><ol><li><p><strong>使用 <code>bind</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunction = sayHello.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">boundFunction</span>(); <span class="comment">// Hello, Alice!</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用箭头函数：</strong></p><p>箭头函数不会创建自己的 <code>this</code>，而是捕获当前所处上下文的 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// Hello, Bob!</span></span><br></pre></td></tr></table></figure><p>请注意，箭头函数的 <code>this</code> 是在定义时确定的，而不是在运行时确定的。</p></li><li><p><strong>使用 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法：</strong></p><p>这些方法可以在调用函数的同时传递一个对象作为 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// Hello, Charlie!</span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(obj); <span class="comment">// Hello, Charlie!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunction = sayHello.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">boundFunction</span>(); <span class="comment">// Hello, Charlie!</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>this</code>对象在JavaScript中是一个特别重要的概念，它是在运行时基于函数的执行环境动态绑定的</p><p><code>this</code>的值并不是在函数定义的时候被绑定的，而是在函数被调用的时候决定的</p><p>以下是<code>this</code>在不同情境下的一些基本行为：</p><ol><li><p>全局上下文</p><p>在全局执行上下文（不在任何函数内部）中，<code>this</code>指向全局对象</p><p>在浏览器中，全局对象是<code>window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// 在浏览器中返回true</span></span><br></pre></td></tr></table></figure></li><li><p>函数上下文</p><p>在函数内部，<code>this</code>的值取决于函数是如何被调用的。</p><ul><li><strong>非严格模式下</strong>：未指定上下文的函数调用中，<code>this</code>指向全局对象</li><li><strong>严格模式下</strong>：<code>this</code>的值为<code>undefined</code></li><li>使用<code>call</code>、<code>apply</code>或者<code>bind</code>：可以将<code>this</code>显式地设置为第一个参数指定的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 在非严格模式下返回 window，在严格模式下返回 undefined</span></span><br><span class="line"></span><br><span class="line">func.<span class="title function_">call</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;example&#x27;</span> &#125;); <span class="comment">// 返回 &#123; a: &#x27;example&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>对象方法</p><p>当函数作为对象的方法调用时，<code>this</code>指向该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">method</span>(); <span class="comment">// 返回 obj</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><p>在构造函数中，<code>this</code>指的是一个新创建的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;example&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">a</span>); <span class="comment">// 返回 &#x27;example&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数</p><p>箭头函数不绑定自己的<code>this</code>，它们继承了上层代码块的<code>this</code>值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">method</span>()(); <span class="comment">// 返回 obj</span></span><br></pre></td></tr></table></figure></li><li><p>事件处理器</p><p>在事件处理函数中，<code>this</code>通常指向触发事件的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向按钮元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>理解<code>this</code>的工作机制对于编写可预测和有效的代码非常重要</p><p>不同的调用方式和函数类型会影响<code>this</code>的绑定，正确的使用<code>this</code>可以使代码更简洁、逻辑更清晰</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：对ToPrimitive的理解"><a href="#Q3：对ToPrimitive的理解" class="headerlink" title="Q3：对ToPrimitive的理解"></a>Q3：对ToPrimitive的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>ToPrimitive</code> 是 JavaScript 中的一个抽象操作符，用于将值转换为基本类型（primitive type）。这个操作通常由内置函数调用，例如进行运算或将对象转换为原始值的时候。</p><p><code>ToPrimitive</code> 的具体规则如下：</p><ol><li>如果一个对象有 <code>Symbol.toPrimitive</code> 方法，就调用该方法，返回其结果。</li><li>否则，如果 hint 参数是 “string”，尝试调用对象的 <code>valueOf</code> 和 <code>toString</code> 方法，如果其中任意一个返回原始值，则返回该值。</li><li>否则，如果 hint 参数是 “number” 或默认（没有提供 hint 参数），尝试调用对象的 <code>valueOf</code> 和 <code>toString</code> 方法，如果其中任意一个返回原始值，则返回该值。</li><li>否则，抛出 <code>TypeError</code>。</li></ol><p>以下是一些示例：</p><p><strong>对象有 <code>Symbol.toPrimitive</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// 输出 &#x27;Hello&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(obj)); <span class="comment">// 输出 42</span></span><br></pre></td></tr></table></figure><p><strong>对象没有 <code>Symbol.toPrimitive</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// 输出 &#x27;Hello&#x27;，toString 返回原始值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(obj)); <span class="comment">// 输出 42，valueOf 返回原始值</span></span><br></pre></td></tr></table></figure><p><code>ToPrimitive</code> 主要用于规范中描述对象转换为原始值的过程，通常在 JavaScript 引擎内部处理。开发者在日常编码中不经常直接使用这个抽象操作符</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：Object与Map有什么区别"><a href="#Q4：Object与Map有什么区别" class="headerlink" title="Q4：Object与Map有什么区别?"></a>Q4：Object与Map有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>Object</code> 和 <code>Map</code> 都是用于存储键值对的数据结构，但它们有一些重要的区别：</p><ol><li><strong>键的类型</strong>：<ul><li><strong>Object</strong>：对象的键必须是字符串或者 Symbol 类型。如果试图使用其他类型的值作为键，JavaScript 引擎会将其转换为字符串。</li><li><strong>Map</strong>：Map 可以接受任意类型的值作为键，包括原始类型和对象引用。</li></ul></li><li><strong>键值对的顺序</strong>：<ul><li><strong>Object</strong>：对象的键值对是无序的。尽管在一些实现中，属性的遍历顺序可能会按照添加的顺序，但 JavaScript 规范并不保证这一点。</li><li><strong>Map</strong>：Map 保留键值对的插入顺序。当你迭代一个 Map 对象时，它会按照键值对被添加的顺序进行迭代。</li></ul></li><li><strong>大小</strong>：<ul><li><strong>Object</strong>：对象的大小没有直接的属性或方法来获取。要获取对象的键值对数量，需要手动计算属性的数量或者使用 <code>Object.keys(obj).length</code>。</li><li><strong>Map</strong>：Map 对象有一个 size 属性，可以直接获取键值对的数量。</li></ul></li><li><strong>迭代</strong>：<ul><li><strong>Object</strong>：要遍历对象的属性，可以使用 <code>for...in</code> 循环或者 <code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code> 方法。</li><li><strong>Map</strong>：Map 对象实现了迭代器协议，可以使用 <code>for...of</code> 循环直接遍历 Map 对象。</li></ul></li><li><strong>内存占用</strong>：<ul><li><strong>Object</strong>：对象的键值对在某些情况下可能会占用更多的内存，因为对象会维护原型链和额外的属性。</li><li><strong>Map</strong>：Map 对象的实现通常会对内存进行优化，特别是在大型数据集上时。Map 可以更有效地存储大量的键值对。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：cookie-的有效时间设置为-0会怎么样"><a href="#Q5：cookie-的有效时间设置为-0会怎么样" class="headerlink" title="Q5：cookie 的有效时间设置为 0会怎么样"></a>Q5：cookie 的有效时间设置为 0会怎么样</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>将 cookie 的有效时间设置为 0 实际上是告诉浏览器在会话结束时将其删除。在 HTTP 协议中，如果 cookie 的过期时间设置为 0 或者省略，则 cookie 会成为一个会话 cookie，它仅在用户当前会话期间有效，一旦用户关闭浏览器，这个 cookie 就会被删除。</p><p>设置 cookie 的有效时间为 0 通常用于创建会话 cookie，这些 cookie 存储了在用户会话期间需要保持的数据，例如用户登录状态或者临时会话标识。当用户关闭浏览器时，这些 cookie 就会被删除，从而保护用户的隐私和安全。</p><p>总之，将 cookie 的有效时间设置为 0 表示这是一个会话 cookie，它只在用户当前会话期间有效，并在用户关闭浏览器时被删除。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Dom操作有哪些"><a href="#Q6：Dom操作有哪些" class="headerlink" title="Q6：Dom操作有哪些"></a>Q6：Dom操作有哪些</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>DOM（文档对象模型）操作是指对网页中的 HTML 元素进行增、删、改、查等操作，使得页面的结构、样式和内容能够动态地改变。以下是常见的 DOM 操作：</p><ol><li><strong>获取元素</strong>：<ul><li><code>document.getElementById(id)</code>：通过元素的 id 属性获取元素。</li><li><code>document.getElementsByClassName(className)</code>：通过元素的类名获取元素集合。</li><li><code>document.getElementsByTagName(tagName)</code>：通过元素的标签名获取元素集合。</li><li><code>document.querySelector(selector)</code>：通过 CSS 选择器获取第一个匹配的元素。</li><li><code>document.querySelectorAll(selector)</code>：通过 CSS 选择器获取所有匹配的元素集合。</li></ul></li><li><strong>创建元素</strong>：<ul><li><code>document.createElement(tagName)</code>：创建一个指定标签名的元素节点。</li><li><code>document.createTextNode(text)</code>：创建一个包含指定文本的文本节点。</li></ul></li><li><strong>添加、移除和替换元素</strong>：<ul><li><code>parentNode.appendChild(newNode)</code>：将一个新节点添加到指定节点的子节点列表的末尾。</li><li><code>parentNode.removeChild(node)</code>：从指定节点的子节点列表中移除一个子节点。</li><li><code>parentNode.replaceChild(newNode, oldNode)</code>：用一个新节点替换指定节点的子节点列表中的一个子节点。</li></ul></li><li><strong>修改元素的属性和内容</strong>：<ul><li><code>element.setAttribute(attribute, value)</code>：设置指定元素的属性值。</li><li><code>element.getAttribute(attribute)</code>：获取指定元素的属性值。</li><li><code>element.innerHTML</code>：获取或设置指定元素的 HTML 内容。</li><li><code>element.innerText</code>：获取或设置指定元素的文本内容。</li></ul></li><li><strong>添加和移除事件监听器</strong>：<ul><li><code>element.addEventListener(event, handler)</code>：为指定元素添加事件监听器。</li><li><code>element.removeEventListener(event, handler)</code>：移除指定元素的事件监听器。</li></ul></li><li><strong>样式操作</strong>：<ul><li><code>element.style.property = value</code>：直接设置元素的样式属性。</li><li><code>element.classList.add(className)</code>：为元素添加类名。</li><li><code>element.classList.remove(className)</code>：移除元素的类名。</li><li><code>element.classList.toggle(className)</code>：切换元素的类名。</li></ul></li><li><strong>查询元素的位置和尺寸</strong>：<ul><li><code>element.getBoundingClientRect()</code>：返回元素的大小及其相对于视口的位置。</li><li><code>element.offsetParent</code>：返回最近的包含该元素的定位元素。</li><li><code>element.offsetWidth</code>、<code>element.offsetHeight</code>、<code>element.offsetTop</code>、<code>element.offsetLeft</code>：返回元素的宽度、高度、相对于父元素的顶部距离和左侧距离。</li></ul></li><li><strong>其他常用操作</strong>：<ul><li><code>document.createDocumentFragment()</code>：创建一个文档片段，用于高效地进行多个 DOM 操作。</li><li><code>element.scrollIntoView()</code>：使元素滚动到浏览器窗口的可视区域内。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：ES6中对象新增了哪些扩展"><a href="#Q7：ES6中对象新增了哪些扩展" class="headerlink" title="Q7：ES6中对象新增了哪些扩展?"></a>Q7：ES6中对象新增了哪些扩展?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>对象字面量的简写语法</strong>：</p><ul><li><p>可以在定义对象时使用更简洁的语法，不再需要写重复的属性名。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; x, y &#125;; <span class="comment">// 等价于 &#123; x: x, y: y &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>计算属性名</strong>：</p><ul><li><p>在对象字面量中可以使用计算属性名，使得属性名可以动态计算。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propName = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propName]: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>方法简写</strong>：</p><ul><li><p>在对象字面量中定义方法时可以省略 <code>function</code> 关键字。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Object.assign()</strong>：</p><ul><li><p>可以用于将一个或多个源对象的属性复制到目标对象中。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source); <span class="comment">// target 变为 &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Object.keys()、Object.values() 和 Object.entries()</strong>：</p><ul><li><p><code>Object.keys()</code>：返回一个包含目标对象所有可枚举属性名的数组。</p></li><li><p><code>Object.values()</code>：返回一个包含目标对象所有可枚举属性值的数组。</p></li><li><p><code>Object.entries()</code>：返回一个包含目标对象所有可枚举属性键值对的数组，每个键值对以数组形式表示。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// 返回 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj); <span class="comment">// 返回 [1, 2, 3]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj); <span class="comment">// 返回 [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对象的扩展方法</strong>：</p><ul><li><code>Object.setPrototypeOf()</code>：设置一个对象的原型（即修改 <code>__proto__</code> 属性）。</li><li><code>Object.getPrototypeOf()</code>：获取一个对象的原型。</li><li><code>Object.getOwnPropertyDescriptors()</code>：获取一个对象的所有属性的描述符。</li></ul></li><li><p><strong>Symbol 类型</strong>：</p><ul><li><p><code>Symbol</code> 类型是一种新的原始数据类型，表示独一无二的值。</p></li><li><p>可以用作对象的属性名，用于创建唯一标识符。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [sym]: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Proxy-能够监听到对象中的对象的引用吗"><a href="#Q8：Proxy-能够监听到对象中的对象的引用吗" class="headerlink" title="Q8：Proxy 能够监听到对象中的对象的引用吗?"></a>Q8：Proxy 能够监听到对象中的对象的引用吗?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>是的，<code>Proxy</code> 可以监听到对象中的对象引用的变化。</p><p>当使用 <code>Proxy</code> 对象对某个对象进行代理时，代理对象可以拦截对目标对象的各种操作，包括对对象属性的访问、修改、添加和删除等。如果目标对象的属性值是对象，那么对该属性的操作也会被拦截，包括对该属性值对象内部属性的修改。</p><p>下面是一个示例，演示了如何使用 <code>Proxy</code> 监听对象中的对象引用的变化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">nestedObj</span>: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">nestedObj</span>.<span class="property">key</span> = <span class="string">&#x27;new value&#x27;</span>; <span class="comment">// 输出 &quot;Setting key to new value&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，当通过 <code>proxy</code> 对象修改 <code>nestedObj</code> 的 <code>key</code> 属性时，<code>set</code> 拦截器会捕获到操作，并输出相关信息。这表明 <code>Proxy</code> 可以监听到对象中的对象引用的变化。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：导致-JavaScript-中-this-指向混乱的原因是什么"><a href="#Q9-：导致-JavaScript-中-this-指向混乱的原因是什么" class="headerlink" title="Q9 ：导致 JavaScript 中 this 指向混乱的原因是什么?"></a>Q9 ：导致 JavaScript 中 this 指向混乱的原因是什么?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 中 this 指向混乱的原因主要有以下几点：</p><ol><li>函数调用方式不同：JavaScript 中函数的调用方式有多种，包括普通函数调用、方法调用、构造函数调用和箭头函数等。不同的调用方式会导致 this 的指向不同。</li><li>丢失绑定：当一个函数被单独调用时，即没有任何对象或上下文与之相关联时，this 将指向全局对象（在浏览器环境中通常是 <code>window</code> 对象）。这种情况下，如果函数内部使用了 this，则可能会出现意外结果。</li><li>隐式绑定丢失：当一个方法从对象中切割出来并作为独立函数调用时，隐式绑定将会丢失，导致 this 不再指向原对象。这往往发生在将对象方法作为回调函数传递给其他函数的情况下。</li><li>显式绑定问题：使用 <code>.call()</code>、<code>.apply()</code> 或 <code>.bind()</code> 方法可以显式地绑定函数的 this，但如果不小心使用或错误地使用这些方法，也可能导致 this 指向混乱。</li><li>箭头函数中的 this：箭头函数没有自己的 this 绑定机制，它会从外围作用域继承 this。这意味着箭头函数中的 this 与其定义时的上下文相关联，而不是调用时的上下文。</li><li>异步操作中的 this：在异步函数或回调函数中，this 的指向可能会发生变化，因为它们的执行上下文可能会改变。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>为了避免 this 指向混乱的问题，可以采取以下措施：</p><ul><li>使用箭头函数，它能够继承外部作用域的 this。</li><li>使用 <code>.bind()</code>、<code>.call()</code> 或 <code>.apply()</code> 方法显式地绑定函数的 this。</li><li>使用闭包将需要引用的 this 缓存起来。</li><li>在方法调用时确保上下文正确。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：e-target跟e-currentTarget有什么区别？"><a href="#Q10：e-target跟e-currentTarget有什么区别？" class="headerlink" title="Q10：e.target跟e.currentTarget有什么区别？"></a>Q10：e.target跟e.currentTarget有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong><code>e.target</code>：</strong><ul><li><code>e.target</code> 表示触发事件的实际目标元素。</li><li>对于事件冒泡，它是最深层次的元素，即实际接收到事件的元素。</li><li>对于事件捕获，它是最外层的元素，即最先接收到事件的元素。</li><li>通常用于获取用户实际与之交互的元素。</li></ul></li><li><strong><code>e.currentTarget</code>：</strong><ul><li><code>e.currentTarget</code> 表示当前正在处理事件的元素，即事件处理程序所附加到的元素。</li><li>对于事件冒泡，它是在事件流上当前正在处理事件的元素。</li><li>对于事件捕获，它是在事件流下当前正在处理事件的元素。</li><li>通常用于在事件处理函数内部引用附加处理程序的元素。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>e.target</code> 表示触发事件的实际元素</p><p> <code>e.currentTarget</code> 表示当前正在处理事件的元素</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span>哈哈哈哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/25/txhNyCamkpZ7ovB.png" alt="image-20240125161544126"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">a.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">d.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别点击这几个之后的结果</span></span><br><span class="line"><span class="comment">// target是d currentTarget是d</span></span><br><span class="line"><span class="comment">// target是d currentTarget是c</span></span><br><span class="line"><span class="comment">// target是d currentTarget是b</span></span><br><span class="line"><span class="comment">// target是d currentTarget是a</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：说说你对-new-target-的理解"><a href="#Q11：说说你对-new-target-的理解" class="headerlink" title="Q11：说说你对 new.target 的理解"></a>Q11：说说你对 new.target 的理解</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 输出: [Function: Person]</span></span><br><span class="line"><span class="title class_">Person</span>(); <span class="comment">// 输出: undefined</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>Person()</code> 构造函数中的 <code>new.target</code> 分别输出了 <code>[Function: Person]</code> 和 <code>undefined</code>。这是因为第一个调用是通过 <code>new</code> 关键字调用的，所以 <code>new.target</code> 指向 <code>Person</code> 构造函数本身；而第二个调用是普通函数调用，所以 <code>new.target</code> 是 <code>undefined</code>。</p><p><code>new.target</code> 主要用于确定构造函数或者类是否通过 <code>new</code> 关键字调用，从而执行不同的逻辑，例如在类的构造函数中可以使用 <code>new.target</code> 来确保类只能通过 <code>new</code> 关键字调用。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>new.target</code> 是 ECMAScript 6 引入的一个元属性，它在构造函数或者类的构造函数中表示通过 <code>new</code> 关键字调用的构造函数或者类的引用。</p><p>具体来说，<code>new.target</code> 返回一个指向正在执行的构造函数或者类的引用。如果构造函数或者类是通过 <code>new</code> 关键字调用的，则 <code>new.target</code> 会指向该构造函数或者类本身；如果构造函数或者类是通过普通函数调用的，则 <code>new.target</code> 会是 <code>undefined</code>。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：如何判断一个对象是不是空对象"><a href="#Q12：如何判断一个对象是不是空对象" class="headerlink" title="Q12：如何判断一个对象是不是空对象"></a>Q12：如何判断一个对象是不是空对象</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Object.keys()</code> 方法</p><p>我们可以使用<code>Object.keys()</code>方法来获取对象的所有键，然后检查键的数量。如果键的数量为 0，意味着对象为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object1));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object2));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...in</code> 循环</p><p>通过 <code>for...in</code> 循环遍历对象。如果循环没有执行，那么对象就是空的</p><p>其中 <code>obj.hasOwnProperty(key)</code> 用于确保属性是对象自己的属性，而非继承自原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object1));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object2));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：正则表达式是什么"><a href="#Q13：正则表达式是什么" class="headerlink" title="Q13：正则表达式是什么"></a>Q13：正则表达式是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“正则表达式”（Regular Expression）是一种强大的文本处理工具，用于字符串的搜索、替换、检索和拆分等操作</p><p>它通过定义一个规则来匹配一系列符合某个句法规则的字符串</p><p>正则表达式非常灵活且高效，广泛应用于文本编辑器、编程语言、数据库查询等多种领域</p><p>正则表达式由普通字符（例如字母和数字）以及特殊字符（称为”元字符”）组成</p><p>这些规则简洁但功能强大，可以非常精确地描述和匹配文本模式，包括：</p><ul><li><p><strong>字面字符</strong></p><p>直接匹配文本中的指定字符</p></li><li><p><strong>元字符</strong></p><p>具有特殊含义的字符，例如用于表示空白字符、单词边界、字符集合等</p></li><li><p><strong>量词</strong></p><p>指明了模式出现的频率，如“一次或更多次”、“零次或一次”等</p></li><li><p><strong>位置匹配</strong></p><p>比如单词的开始和结束、字符串的开头和结尾</p></li><li><p><strong>分组和引用</strong></p><p>可以将模式的一部分组合在一起，以便可以后续引用或应用量词</p></li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>匹配规则</strong></p><ol><li>字符匹配<ul><li><code>.</code>：匹配除换行符 <code>\n</code> 之外的任意单个字符</li><li><code>\d</code>：匹配任意一位数字，等同于 <code>[0-9]</code></li><li><code>\D</code>：匹配任意非数字字符，等同于 <code>[^0-9]</code></li><li><code>\w</code>：匹配任意字母、数字或下划线（Word Character），等同于 <code>[a-zA-Z0-9_]</code></li><li><code>\W</code>：匹配任意非单词字符，等同于 <code>[^a-zA-Z0-9_]</code></li><li><code>\s</code>：匹配任意空白字符，包括空格、制表符、换行符等</li><li><code>\S</code>：匹配任意非空白字符</li><li><code>[abc]</code>：字符集合，匹配包含的任一字符</li><li><code>[^abc]</code>：否定字符集，匹配不在指定集合中的任一字符</li><li><code>[a-z]</code> 或 <code>[A-Z]</code> 或 <code>[0-9]</code>：范围，匹配指定范围内的任意字符</li><li><code>^</code>：在字符集合中使用时，表示否定，如 <code>[^a-e]</code> 表示非 a 到 e 的字符。在其他时候表示行的起始</li><li><code>$</code>：匹配行的结束</li><li><code>\b</code>：匹配单词的边界</li><li><code>\B</code>：匹配非单词边界</li><li><code>\</code>：转义字符，用来匹配那些特殊字符，如 <code>\\.</code>, <code>\\$</code>, <code>\(</code> 等</li><li><code>|</code>：选择，匹配符号左边或者右边的表达式</li><li><code>(expr)</code>：分组符号，用来定义一个组</li><li><code>(?:expr)</code>：非捕获分组，该组匹配的内容不会被捕获，不分配组号</li><li><code>(?=expr)</code>：正向先行断言，表示之后的内容必须匹配表达式 <code>expr</code></li><li><code>(?!expr)</code>：负向先行断言，表示之后的内容不匹配表达式 <code>expr</code></li><li><code>expr1(?&lt;=expr2)</code>：正向后行断言，表示 <code>expr1</code> 前面的内容必须匹配 <code>expr2</code></li><li><code>expr1(?&lt;!expr2)</code>：负向后行断言，表示 <code>expr1</code> 前面的内容不匹配 <code>expr2</code></li><li><code>x*</code>：匹配前面的模式 <code>x</code> 0 或多次</li><li><code>x+</code>：匹配前面的模式 <code>x</code> 1 或多次</li><li><code>x?</code>：匹配前面的模式 <code>x</code> 0 或 1 次</li><li><code>x{n}</code>：匹配前面的模式 <code>x</code> 恰好 <code>n</code> 次</li><li><code>x{n,}</code>：匹配前面的模式 <code>x</code> 至少 <code>n</code> 次</li><li><code>x{n,m}</code>：匹配前面的模式 <code>x</code> 至少 <code>n</code> 次，但不超过 <code>m</code> 次</li></ul></li><li>位置匹配<ul><li><code>^</code>：匹配输入字符串的开始位置</li><li><code>$</code>：匹配输入字符串的结束位置</li><li><code>\b</code>：匹配一个单词边界，也就是指单词和空格间的位置</li><li><code>\B</code>：匹配非单词边界，<code>&#39;er\B&#39;</code> 可以匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’</li><li><code>(?=p)</code>：匹配 ‘p’ 前面的位置</li><li><code>(?!p)</code>：匹配 ‘p’ 不在其后的位置</li></ul></li><li>分组引用<ul><li><code>(abc)</code>：匹配abc并捕获该匹配项</li><li><code>(?:abc)</code>：匹配abc但不捕获该匹配项（非捕获组）</li><li><code>\1</code>：匹配之前第1个分组捕获的文本</li></ul></li><li>量词<ul><li><code>*</code>：匹配前面的子表达式零次或多次</li><li><code>+</code>：匹配前面的子表达式一次或多次</li><li><code>?</code>：匹配前面的子表达式零次或一次</li><li><code>{n}</code>：匹配确定的n次</li><li><code>{n,}</code>：至少匹配n次</li><li><code>{n,m}</code>：最少匹配n次且最多匹配m次</li></ul></li><li>选择<ul><li><code>|</code>：或运算符，匹配两项之一</li></ul></li><li>转义字符<ul><li><code>\</code>：将下一个字符标记为特殊字符或字面值</li></ul></li></ol><p><br /></p><p><strong>模式</strong></p><p>在正则表达式中，贪婪模式（Greedy Mode）和懒惰模式（Lazy Mode，也叫非贪婪模式或惰性模式）是与量词相关的两种匹配模式</p><p>它们决定了正则表达式匹配字符的方式，即是尽可能多地匹配（贪婪）还是尽可能少地匹配（懒惰）</p><ol><li><p>贪婪模式</p><p>贪婪模式是正则表达式的默认匹配模式，它会尽可能多地匹配字符</p><p>也就是说，它会匹配尽可能多的字符，直到整个表达式能够匹配为止</p><p>例如，在表达式 <code>a.*b</code> 中，它会匹配从第一个 <code>&quot;a&quot;</code> 到最后一个 <code>&quot;b&quot;</code> 之间的所有内容</p></li><li><p>懒惰模式</p><p>懒惰模式或非贪婪模式，会尽可能少地匹配字符</p><p>在量词后加上问号 <code>?</code> 可以实现懒惰匹配</p><p>例如，在表达式 <code>a.*?b</code> 中，它会匹配从第一个 <code>&quot;a&quot;</code> 到最近的一个 <code>&quot;b&quot;</code> 之间的内容，使用尽可能少的匹配尝试找到满足条件的匹配项</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is a &lt;div&gt;simple&lt;/div&gt; div.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line"><span class="keyword">let</span> greedyRegex = <span class="regexp">/&lt;.*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> greedyResult = text.<span class="title function_">match</span>(greedyRegex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greedy Result:&quot;</span>, greedyResult[<span class="number">0</span>]); <span class="comment">// Greedy Result: &lt;div&gt;simple&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line"><span class="keyword">let</span> lazyRegex = <span class="regexp">/&lt;.*?&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> lazyResult = text.<span class="title function_">match</span>(lazyRegex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lazy Result:&quot;</span>, lazyResult[<span class="number">0</span>]); <span class="comment">// Lazy Result: &lt;div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>贪婪匹配的结果是 <code>&quot;&lt;div&gt;simple&lt;/div&gt;&quot;</code>。它匹配了从字符串中的第一个 <code>&lt;</code> 到最后一个 <code>&gt;</code> 的整段文本。</li><li>懒惰匹配的结果是 <code>&quot;&lt;div&gt;&quot;</code>。它只匹配了开头的 <code>&lt;div&gt;</code> 标签，因为懒惰模式会在找到第一个满足条件的 <code>&gt;</code> 后停止匹配。</li></ul><p><br /></p><p><strong>匹配方法</strong></p><ol><li><code>exec()</code><ul><li>此方法由正则表达式对象调用</li><li>它返回一个数组（包含匹配的信息）或在没有匹配项时返回null</li><li>例子: <code>/[a-e]/i.exec(&quot;Hello World&quot;)</code></li></ul></li><li><code>test()</code><ul><li>此方法同样由正则表达式对象调用</li><li>它返回一个布尔值，表示是否存在匹配</li><li>例子: <code>/hello/i.test(&quot;Hello world&quot;)</code></li></ul></li><li><code>match()</code><ul><li>这个方法由字符串对象调用</li><li>它返回一个包含匹配结果的数组或在没有匹配项时返回null</li><li>例子: <code>&quot;Hello world&quot;.match(/[a-e]/i)</code></li></ul></li><li><code>matchAll()</code><ul><li>此方法由字符串对象调用</li><li>它返回一个包含所有匹配的迭代器</li><li>例子: <code>&quot;test1test2&quot;.matchAll(/\d/g)</code></li></ul></li><li><code>replace()</code><ul><li>由字符串对象调用</li><li>它返回一个新字符串，其中的匹配项被替换</li><li>例子: <code>&quot;Hello World&quot;.replace(/world/i, &quot;Mars&quot;)</code></li></ul></li><li><code>replaceAll()</code><ul><li>类似于 <code>replace()</code>，但它会替换掉字符串中所有的匹配项</li><li>例子: <code>&quot;2022/05/11&quot;.replaceAll(/\//g, &quot;-&quot;)</code></li></ul></li><li><code>search()</code><ul><li>此方法由字符串对象调用</li><li>返回第一个匹配项的索引，如果没有匹配则返回-1</li><li>例子: <code>&quot;Hello World&quot;.search(/world/i)</code></li></ul></li><li><code>split()</code><ul><li>此方法由字符串对象调用</li><li>它使用正则表达式或一个固定字符串来分割字符串，并返回一个数组</li><li>例子: <code>&quot;Hello World&quot;.split(/\s/)</code></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：Javascript里面的继承方式有哪些？"><a href="#Q14：Javascript里面的继承方式有哪些？" class="headerlink" title="Q14：Javascript里面的继承方式有哪些？"></a>Q14：Javascript里面的继承方式有哪些？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，继承是一种让一个对象获得另一个对象的属性和方法的机制。以下是主要的继承方式：</p><ol><li><p><strong>原型链继承</strong></p><p>每个对象都有一个指向另一个对象的链接称为原型（prototype）</p><p>当你试图访问一个对象的属性时，如果对象本身没有这个属性，则会去它的原型（及原型的原型，依次类推）中查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentProperty</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getParentProperty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">parentProperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childProperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Parent</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getParentProperty</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数继承</strong></p><p>通过在子类的构造函数中调用父类的构造函数，可以继承父类的属性，但没法继承父类原型的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>); <span class="comment">// &#x27;child1&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>组合继承</strong></p><p>结合了原型链继承和构造函数继承，既能继承属性也能继承方法</p><p>通常是在子类构造函数中调用父类构造函数，并将子类的原型设置为父类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>原型式继承</strong></p><p>是ECMAScript 5中通过<code>Object.create</code>方法实现的，可以创建一个新对象，用现有的对象来提供新创建的对象的<code>__proto__</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">colors</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br><span class="line">child.<span class="property">name</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// &#x27;child&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">colors</span>); <span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄生式继承</strong></p><p>创建一个仅用于封装继承过程的函数来增强对象，然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">colors</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">createAnother</span>(parent);</span><br><span class="line">child.<span class="title function_">sayHi</span>(); <span class="comment">// &#x27;Hi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// &#x27;parent&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄生组合式继承</strong></p><p>为了解决组合继承调用两次父构造函数的问题，寄生组合式继承将父对象的原型赋给子对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ES6类继承 <code>extends</code> 和 <code>super</code></strong></p><p>ES6引入了类（class）概念，通过<code>class</code>和<code>extends</code>关键字，提供了更清晰和易于理解的继承语法</p><p><code>super</code>关键字用于调用父类的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>每种继承方式都有其特定的适用场景、优点和缺点</p><p>了解这些可以帮助你更好地选择适合你项目的继承策略：</p><ol><li><strong>原型链继承</strong><ul><li>优点：简单易理解。</li><li>缺点：来自原型的所有属性被所有实例共享，无法实现多继承。</li></ul></li><li><strong>构造函数继承</strong><ul><li>优点：可以实现多继承，创建子类实例时可以向父类传递参数。</li><li>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul></li><li><strong>组合继承</strong><ul><li>优点：融合了原型链继承和构造函数继承的优点，能够实现函数复用。</li><li>缺点：调用了两次父类构造函数，生成了两份实例。</li></ul></li><li><strong>原型式继承</strong><ul><li>优点：适用于不需要单独创建构造函数，但仍然需要在多个对象间共享信息的场景。</li><li>缺点：包含引用类型的属性值始终会共享相应的值，这样的话就不适合单独实例。</li></ul></li><li><strong>寄生式继承</strong><ul><li>优点：可以为对象添加新方法。</li><li>缺点：使用函数创造对象，无法做到函数复用，效率较低。</li></ul></li><li><strong>寄生组合式继承</strong><ul><li>优点：避免了组合继承的缺点，只调用一次父类构造函数，并且原型链保持不变。</li><li>缺点：实现起来较为复杂。</li></ul></li><li><strong>ES6类继承 (<code>extends</code> 和 <code>super</code>)</strong><ul><li>优点：语法更清晰简洁，更接近传统面向对象语言的写法，易于理解和使用。</li><li>缺点：<code>class</code>关键字实质上还是原型继承的语法糖，不能完全摆脱原型链继承的限制。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：base64编码图片，为什么会让数据量变大"><a href="#Q15：base64编码图片，为什么会让数据量变大" class="headerlink" title="Q15：base64编码图片，为什么会让数据量变大"></a>Q15：base64编码图片，为什么会让数据量变大</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Base64 是一种用64个字符来表示任意二进制数据的方法</p><p>它用 64 个可打印的 ASCII 字符来表示二进制数据</p><p>为什么 Base64 会使数据变大呢？</p><p>这是因为 Base64 编码设计的初衷是在无法直接处理二进制数据的情况下，将二进制数据转换为只包含ASCII字符的字符串，以便二进制数据可以以文本的形式在网络上进行传输或存储</p><p>然而，这种转换是有代价的</p><p>Base64编码过程中，每3个字节（24位）的数据，会被编码为4个字节的ASCII字符</p><p>这就导致了增加了约33%的数据量（4/3）</p><p>如果原始数据没有足够的数据（如不是3的倍数），那么 Base64 还会在末尾添加填充字符(‘=’)，这可能会导致数据量进一步增加</p><p>因此，Base64编码并不适合用于压缩数据或减小数据大小，对于大量数据或者大文件，使用Base64会显著增加数据量</p><p>然而，如果你需要在无法直接发送二进制数据的环境中发送数据（例如在 JSON 中发送图像），或者需要将二进制数据存储为文本（如 CSS 中的内联图像），那么Base64是非常方便的工具</p><p>Base64编码的根本目的并不是为了减少数据大小，而是为了能在仅支持文本的环境中处理二进制数据</p>
              </div>
            </details>
<p><br/></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="Q1：将数组的length设置为0，获取它的第一个元素会返回什么"><a href="#Q1：将数组的length设置为0，获取它的第一个元素会返回什么" class="headerlink" title="Q1：将数组的length设置为0，获取它的第一个元素会返回什么"></a>Q1：将数组的length设置为0，获取它的第一个元素会返回什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>当将数组的 <code>length</code> 设置为0时，数组实际上被清空，不包含任何元素。在这种情况下，获取数组的第一个元素将返回 <code>undefined</code>。</p><p>这是因为数组为空，没有任何元素可以被访问。当你尝试获取一个不存在的元素时，JavaScript 返回 <code>undefined</code>，表示值不存在或未定义。因此，如果数组的 <code>length</code> 被设置为0，任何尝试获取数组元素的操作都将返回 <code>undefined</code>。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>undefined</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：什么是类数组对象"><a href="#Q2：什么是类数组对象" class="headerlink" title="Q2：什么是类数组对象"></a>Q2：什么是类数组对象</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>类数组对象（Array-like Object）是具有类似数组结构的对象，但并不是真正的数组。这些对象在结构上类似数组，通常有数值索引和 <code>length</code> 属性，但它们不继承自数组（Array）原型，因此不具备数组原型上的方法</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>常见的类数组对象包括：</p><ol><li><strong>arguments 对象：</strong> 在函数内部可用，包含了传递给函数的参数，具有数值索引和 <code>length</code> 属性。</li><li><strong>NodeList 对象：</strong> 代表文档中的节点列表，例如使用 <code>document.querySelectorAll</code> 或 <code>element.childNodes</code> 得到的对象。</li><li><strong>字符串（String）：</strong> 字符串也可以被视为类数组对象，因为它们有类似数组的索引和 <code>length</code> 属性。</li><li><strong>函数的 <code>arguments</code> 对象：</strong> 函数内部的 <code>arguments</code> 对象也是一个类数组对象。</li></ol><p>类数组对象在某些情况下非常有用，但由于它们不具备数组原型上的方法，例如 <code>push</code>、<code>pop</code>、<code>slice</code> 等，因此在需要使用数组方法的场合，需要将其转换为真正的数组</p><p>有多种方法可以将类数组对象转换为数组。以下是几种常见的方法：</p><ol><li><p>使用 Array.from()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用扩展运算符 (…)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [...arrayLikeObject];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Array.prototype.slice.call()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Array.prototype.concat.apply()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 forEach()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(arrayLikeObject, <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 for…of 循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arrayLikeObject) &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：空数组调用reduce会发生什么"><a href="#Q3：空数组调用reduce会发生什么" class="headerlink" title="Q3：空数组调用reduce会发生什么"></a>Q3：空数组调用reduce会发生什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在空数组上调用 <code>reduce</code> 方法时，如果没有提供初始值（initialValue），会抛出 <code>TypeError</code>。这是因为 <code>reduce</code> 需要至少有一个元素来执行归约操作，而在空数组中没有元素可供归约</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"><span class="keyword">const</span> result = emptyArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>为了避免这个错误，可以在调用 <code>reduce</code> 时提供一个初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"><span class="keyword">const</span> result = emptyArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：数组的reduce有什么用法"><a href="#Q4：数组的reduce有什么用法" class="headerlink" title="Q4：数组的reduce有什么用法"></a>Q4：数组的reduce有什么用法</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>reduce</code> 是数组方法之一，用于迭代数组的每个元素，并将它们汇总为单个值。下面列举了一些 <code>reduce</code> 方法的常见用途：</p><ol><li><p><strong>累加（Summation）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>累积（Product）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> product = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator * currentValue, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(product); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最大值：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> max = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(accumulator, currentValue));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最小值：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> min = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(accumulator, currentValue));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拼接字符串：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> sentence = words.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence); <span class="comment">// &#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>统计元素出现次数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> countByFruit = fruits.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[currentValue] = (accumulator[currentValue] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countByFruit); <span class="comment">// &#123; apple: 3, orange: 2, banana: 1 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扁平化数组：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class="title function_">concat</span>(currentValue), []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将对象数组转换为对象：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> peopleMap = people.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, person</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[person.<span class="property">id</span>] = person.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(peopleMap); <span class="comment">// &#123; 1: &#x27;Alice&#x27;, 2: &#x27;Bob&#x27;, 3: &#x27;Charlie&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些只是 <code>reduce</code> 方法的一些用途，它的强大之处在于其灵活性，可以根据具体需求执行各种汇总操作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：arguments-这种类数组，如何遍历类数组"><a href="#Q5：arguments-这种类数组，如何遍历类数组" class="headerlink" title="Q5：arguments 这种类数组，如何遍历类数组?"></a>Q5：arguments 这种类数组，如何遍历类数组?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，类数组是类似数组的对象，它们通常具有数字索引和 length 属性，但不具有数组原型链上的方法（例如 forEach、map 等）。在遍历类数组时，可以使用多种方法：</p><ol><li><p><strong>for 循环</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 对 arguments 中的每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Array.prototype.forEach()</strong>（需要将类数组转换为真正的数组）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为真正的数组后使用其他数组方法</strong>（例如 map、filter 等）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> argsArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">argsArray.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 ES6 中的扩展运算符</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="variable language_">arguments</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Javscript数组的常用方法有哪些"><a href="#Q6：Javscript数组的常用方法有哪些" class="headerlink" title="Q6：Javscript数组的常用方法有哪些?"></a>Q6：Javscript数组的常用方法有哪些?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>push()</strong>：向数组末尾添加一个或多个元素，并返回修改后的数组的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 返回值为 4，arr 变为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>pop()</strong>：移除数组末尾的元素，并返回移除的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> removedElement = arr.<span class="title function_">pop</span>(); <span class="comment">// 返回值为 3，arr 变为 [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shift()</strong>：移除数组的第一个元素，并返回移除的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> removedElement = arr.<span class="title function_">shift</span>(); <span class="comment">// 返回值为 1，arr 变为 [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>unshift()</strong>：向数组的开头添加一个或多个元素，并返回修改后的数组的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">1</span>); <span class="comment">// 返回值为 3，arr 变为 [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>concat()</strong>：将两个或多个数组合并成一个新数组，不修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// newArr 变为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>slice()</strong>：从数组中提取出指定范围的元素，返回一个新数组，不修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slicedArr = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// slicedArr 变为 [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>splice()</strong>：从数组中添加、移除或替换元素，会修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> removedElements = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值为 [2, 3]，arr 变为 [1, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>forEach()</strong>：对数组的每个元素执行指定的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item)); <span class="comment">// 依次输出 1、2、3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>map()</strong>：对数组的每个元素执行指定的操作，并返回操作后的结果组成的新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>); <span class="comment">// newArr 变为 [2, 4, 6]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>filter()</strong>：筛选数组中满足条件的元素，并返回满足条件的元素组成的新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// filteredArr 变为 [2, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reduce()</strong>：对数组中的所有元素执行指定的累加操作，返回累加结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>); <span class="comment">// sum 变为 15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>every()</strong>：检测数组中的所有元素是否都满足指定条件，如果所有元素都满足条件，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> allEven = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>some()</strong>：检测数组中是否有至少一个元素满足指定条件，如果有至少一个元素满足条件，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> hasEven = arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>find()</strong>：查找数组中第一个满足指定条件的元素，并返回该元素；如果未找到满足条件的元素，则返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> found = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">3</span>); <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>findIndex()</strong>：查找数组中第一个满足指定条件的元素的索引，并返回该索引；如果未找到满足条件的元素，则返回 <code>-1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> foundIndex = arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">3</span>); <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>includes()</strong>：检测数组是否包含指定元素，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> hasElement = arr.<span class="title function_">includes</span>(<span class="number">3</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reverse()</strong>：颠倒数组中元素的顺序，原地修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>(); <span class="comment">// arr 变为 [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>sort()</strong>：对数组元素进行排序，默认按照字母顺序进行排序，原地修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(); <span class="comment">// arr 变为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>join()</strong>：将数组中所有元素以指定的分隔符连接成一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 返回 &#x27;a-b-c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>toString()</strong>：将数组转换为字符串，效果与 <code>join()</code> 方法一样，默认使用逗号 <code>,</code> 连接元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">toString</span>(); <span class="comment">// 返回 &#x27;a,b,c&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="Q1：js的函数声明有几种方式？有什么区别？"><a href="#Q1：js的函数声明有几种方式？有什么区别？" class="headerlink" title="Q1：js的函数声明有几种方式？有什么区别？"></a>Q1：js的函数声明有几种方式？有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，函数声明有三种主要方式：函数声明（Function Declaration）、函数表达式（Function Expression）、箭头函数（Arrow Function）。它们之间的区别主要体现在语法和行为上。</p><ol><li><p><strong>函数声明（Function Declaration）</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>在代码执行前进行预解析（hoisting），可以在声明之前调用。</li><li>函数名是必须的，函数名会被添加到当前作用域（通常是全局作用域或函数作用域）。</li><li>可以直接调用，不需要赋值给变量。</li></ul></li></ul></li><li><p><strong>函数表达式（Function Expression）</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>在代码执行到赋值语句时创建函数，因此不能在定义之前调用。</li><li>函数名是可选的，可以省略，这种情况下函数被称为匿名函数。</li><li>赋值给变量或作为参数传递给其他函数。</li></ul></li></ul></li><li><p><strong>箭头函数（Arrow Function）</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">functionName</span> = (<span class="params">parameters</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>箭头函数是ES6新增的一种函数定义方式，语法更简洁。</li><li>不绑定this，会捕获所在上下文的this值。</li><li>不能用作构造函数，不具备自己的this，不能使用arguments对象。</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：对“立即执行函数”的理解"><a href="#Q2：对“立即执行函数”的理解" class="headerlink" title="Q2：对“立即执行函数”的理解"></a>Q2：对“立即执行函数”的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>立即执行函数（Immediately Invoked Function Expression，IIFE）是一种在定义后立即执行的 JavaScript 函数。它的语法形式是将函数声明或函数表达式包裹在圆括号中，然后紧接着使用另一对圆括号来立即调用这个函数。</p><p>下面是一个典型的立即执行函数的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="keyword">function</span> (<span class="params">test</span>) &#123;    <span class="comment">//使用!运算符,输出123</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line">&#125;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>这个函数在声明后立即被调用执行。()，！，+，-，=等运算符都能起到立即执行的作用</p><p>立即执行函数的主要特点和用途包括：</p><ol><li><strong>作用域隔离</strong>：立即执行函数可以创建一个独立的作用域，其中的变量不会污染到全局作用域，避免了变量命名冲突。</li><li><strong>模块化开发</strong>：通过立即执行函数，可以创建模块化的代码结构，将代码封装在独立的作用域中，提高了代码的可维护性和可重用性。</li><li><strong>防止变量提升</strong>：立即执行函数中的变量会在函数执行完毕后被销毁，不会污染全局作用域，避免了变量提升可能带来的问题。</li><li><strong>封装变量</strong>：可以将一些私有的变量或函数封装在立即执行函数中，只暴露需要暴露的接口，隐藏实现细节，增强了代码的安全性。</li><li><strong>初始化代码</strong>：立即执行函数常被用于执行一些初始化代码，确保代码在加载后立即执行。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：new-fn与new-fn（）有什么区别吗"><a href="#Q3：new-fn与new-fn（）有什么区别吗" class="headerlink" title="Q3：new fn与new fn（）有什么区别吗?"></a>Q3：new fn与new fn（）有什么区别吗?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>new fn</code> 和 <code>new fn()</code> 看起来很相似，但实际上它们之间有重要的区别：</p><ol><li><strong>new fn</strong>： 这种写法是在调用构造函数 <code>fn</code> 时省略了括号。它会创建一个新的对象，并将构造函数的作用域绑定到这个新对象上，但不传递任何参数给构造函数。因此，如果构造函数 <code>fn</code> 没有参数，那么这两种写法会得到相同的结果。</li><li><strong>new fn()</strong>： 这是标准的构造函数调用语法，它会创建一个新的对象，并将构造函数的作用域绑定到这个新对象上，并传递括号内的参数给构造函数。即使构造函数不需要参数，也必须使用括号。</li></ol><p>因此，主要区别在于是否传递参数给构造函数。如果构造函数需要参数，则必须使用 <code>new fn()</code>，而如果构造函数不需要参数，则可以使用 <code>new fn</code>，两者效果是一样的。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：ES6中函数新增了哪些扩展"><a href="#Q4：ES6中函数新增了哪些扩展" class="headerlink" title="Q4：ES6中函数新增了哪些扩展?"></a>Q4：ES6中函数新增了哪些扩展?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>箭头函数（Arrow Functions）</strong>：<ul><li>箭头函数是一种更简洁的函数定义语法，使用箭头（<code>=&gt;</code>）来定义函数。</li><li>箭头函数没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code> 或 <code>new.target</code>，它们会从父作用域中继承这些值。</li><li>示例：<code>(param1, param2) =&gt; expression</code></li></ul></li><li><strong>默认参数（Default Parameters）</strong>：<ul><li>可以为函数参数设置默认值，如果调用函数时未传递参数，则使用默认值。</li><li>示例：<code>function func(param1 = defaultValue) { }</code></li></ul></li><li><strong>剩余参数（Rest Parameters）</strong>：<ul><li>使用剩余参数语法（<code>...args</code>）来捕获函数中的剩余参数，将它们放入一个数组中。</li><li>示例：<code>function func(param1, ...args) { }</code></li></ul></li><li><strong>扩展运算符（Spread Operator）</strong>：<ul><li>使用扩展运算符（<code>...</code>）可以将数组展开为独立的参数。</li><li>示例：<code>function func(param1, param2, ...restParams) { }</code></li></ul></li><li><strong>函数的扩展方法</strong>：<ul><li><code>Function.prototype.bind()</code> 方法现在支持在箭头函数上调用，可以创建绑定了指定 <code>this</code> 的箭头函数。</li><li><code>Function.prototype.toString()</code> 方法现在返回函数原始代码，包括 ES6 中新增的箭头函数和方法简写。</li></ul></li><li><strong>模板字符串（Template Strings）</strong>：<ul><li>模板字符串是一种新的字符串语法，使用反引号（``）来定义字符串，并支持嵌入表达式和多行字符串。</li><li>示例：<code>Hello, ${name}!</code></li></ul></li><li><strong>函数参数的解构赋值</strong>：<ul><li>可以在函数参数中使用解构赋值语法，将传入的对象或数组解构为单独的变量。</li><li>示例：<code>function func({param1, param2}) { }</code></li></ul></li><li><strong><code>arguments</code> 对象的限制</strong>：<ul><li>在箭头函数中，<code>arguments</code> 对象会继承自父作用域，而不是创建一个独立的 <code>arguments</code> 对象。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：什么是尾调用优化和尾递归"><a href="#Q5：什么是尾调用优化和尾递归" class="headerlink" title="Q5：什么是尾调用优化和尾递归"></a>Q5：什么是尾调用优化和尾递归</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>尾调用</p><p>尾调用准确来说，是在一个函数的最后一部操作是另外一个函数的调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcA</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">funcB</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 funcA 中，最后一步操作是调用 funcB，所以这就是一个尾调用</p></li><li><p>尾调用优化 (Tail Call Optimization)</p><p>在函数调用时，为了回到函数调用位置，及恢复所需环境，操作系统会在调用栈中维护所谓的“调用记录”或“帧”，这会占用一些内存</p><p>对于一般的函数调用，新的函数调用需要维护一个新的帧，因此如果有大量的函数调用（例如在深度递归中），这个帧的堆栈可能会非常大，占用很多内存空间，甚至可能导致“栈溢出”</p><p>然而对于尾调用来说，由于它是函数的最后一个操作，所以没有必要保留当前的帧</p><p>尾调用优化就是利用这个性质来节约内存的一种技术</p><p>在支持尾调用优化的环境中，如果一个函数的最后一步是尾调用，则解释器或编译器不会创建新的帧，而是复用当前的帧</p></li><li><p>尾递归</p><p>尾递归是特殊的尾调用，它指的在函数的最后一步调用了函数自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 factorial 函数这个例子中，我们实现了一个用于计算阶乘的尾递归函数</p><p>在这个函数中，每次函数调用自身（也就是进行递归）的时候，都是在函数的最后一步，所以它就是个尾递归</p><p>而且由于我们把 total 参数传递给下一次调用，使得下一次递归有了起始值，这样就能确保递归在结束条件满足时能立即得到结果</p><p>这样的方法在编程中被称为累积传递风格（Accumulate Passing Style，简称APS），经常被用于实现尾递归</p></li></ol><p>在支持尾调用优化的环境中，尾递归函数不会因为递归深度过大而导致栈溢出或者内存消耗过大，它的性能和循环差不多</p><p>不过需要注意的是，目前并不是所有的 JavaScript 环境都支持尾调用优化</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong>尾调用优化如何帮助减少内存占用？</strong></p><p>尾调用优化（Tail Call Optimization，TCO）帮助减少内存占用的方式与其工作原理紧密相关</p><p>一般来说，每当一个函数调用另一个函数时，计算机需要在内存中保留一些信息，如函数在哪里被调用的，该函数的参数，还有局部变量等等。这种信息记录被称为”栈帧”(stack frame)</p><p>如果有一个函数在其函数体最后的语句中调用了另一个函数（不管是相同的函数还是不同的函数），这样的调用被称为”尾调用”。由于尾调用是函数的最后一步操作，函数的栈帧已经可以被废弃，因为我们已经没有其他的操作需要使用这个栈帧了</p><p>在不进行尾调用优化的情况下，对每一个函数调用，系统都会为其创建一个新的栈帧，即使是尾调用。然而在开启尾调用优化的环境中，如果发生尾调用，不会创建新的栈帧，而是清除当前的栈帧并复用，因为我们知道老的栈帧已经不再需要了</p><p>这样就实现了内存的优化，即使在大量的递归调用中，也仅需要维护一个栈帧，极大地优化了内存占用，因此就避免了内存溢出或者栈溢出的问题</p></li><li><p><strong>为什么目前并不是所有的 JavaScript 环境都支持尾调用优化</strong></p><ol><li><strong>技术挑战</strong>：在 JavaScript 引擎中实现 TCO 要处理诸多技术问题和挑战。由于 JavaScript 的动态特性，很多情况下很难判断是否可以安全地进行尾调用优化。引擎必须确保优化不会对代码的预期行为产生副作用。</li><li><strong>性能考量</strong>：虽然 TCO 在理论上能节省内存，并防止栈溢出的问题，但在实践中，并不是所有应用场景都能体现这种优化的效果。尤其是在目前大多数的 web 应用中，深层次的递归调用并不常见，因此浏览器厂商可能认为投入资源来实现这一特性的优先级不高。</li><li><strong>规范更迭</strong>：Javascript 的规范在不断发展和更迭之中，一些特性可能在接下来的版本中被调整或替换。一部分实现者可能在等待规范的稳定，从而避免在未来需要重做相关的实现。</li><li><strong>向后兼容性</strong>：引入 TCO 可能会影响到现有代码的功能，特别是那些依赖于栈追踪信息的代码，因此，实现 TCO 需要仔细考虑如何与旧代码兼容。</li><li><strong>优先级与资源分配</strong>：浏览器和 JavaScript 环境的开发者可能有其他更紧急或更重要的优先级，这决定了他们如何分配时间和资源来实现语言规范的各个部分。</li></ol></li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h3 id="Q1：以下等式是成立的吗？1-000-000-1000000"><a href="#Q1：以下等式是成立的吗？1-000-000-1000000" class="headerlink" title="Q1：以下等式是成立的吗？1_000_000 === 1000000"></a>Q1：以下等式是成立的吗？1_000_000 === 1000000</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，下划线（<code>_</code>）在数字中的使用是为了提高数字的可读性，而不影响其值。这种表示法通常用于表示较大的数字，以便更容易阅读和理解数字的大小。</p><p>在你的例子中，<code>1_000_000</code> 和 <code>1000000</code> 实际上表示相同的数值，因为下划线在JavaScript中被视为一个合法的数字分隔符，但在计算时会被忽略。这就意味着，无论你是用下划线分隔还是没有下划线，这两个表示法都代表相同的数字1,000,000。</p><p>这种语法的引入是为了方便阅读和书写较大的数字，而不改变其实际值。这样的可读性改进对于理解代码或数据中的大数字是很有帮助的。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>true</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：空值合并运算符是什么？有什么使用场景"><a href="#Q2：空值合并运算符是什么？有什么使用场景" class="headerlink" title="Q2：空值合并运算符是什么？有什么使用场景"></a>Q2：空值合并运算符是什么？有什么使用场景</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>空值合并运算符（nullish coalescing operator），通常表示为 <code>??</code>，是 JavaScript 的一个逻辑运算符。它提供了一种简洁的方式来处理值为 <code>null</code> 或 <code>undefined</code> 时的默认值设置。</p><p>语法形式为：<code>a ?? b</code>，它的行为是：如果 <code>a</code> 是 <code>null</code> 或 <code>undefined</code>，则返回 <code>b</code>，否则返回 <code>a</code>。</p><p>下面是一些示例说明空值合并运算符的使用场景：</p><p><strong>设置默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: null,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userName = user.name ?? &#x27;Guest&#x27;;</span><br><span class="line">const userAge = user.age ?? 18;</span><br><span class="line"></span><br><span class="line">console.log(userName); // &#x27;Alice&#x27;</span><br><span class="line">console.log(userAge);   // 18</span><br></pre></td></tr></table></figure><p><strong>防止使用空值运算符时，<code>0</code> 或 <code>&#39;&#39;</code> 被认为是空值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const height = 0;</span><br><span class="line">const minHeight = height || 100; // 如果 height 为 falsy（0），则使用默认值 100</span><br><span class="line"></span><br><span class="line">console.log(minHeight); // 100</span><br><span class="line"></span><br><span class="line">const minHeightWithNullish = height ?? 100; // 只有在 height 为 null 或 undefined 时才使用默认值 100</span><br><span class="line"></span><br><span class="line">console.log(minHeightWithNullish); // 0</span><br></pre></td></tr></table></figure><p><strong>避免未定义属性引发错误</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  server: &#123;</span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    port: null,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const serverPort = config.server.port ?? 3000;</span><br><span class="line"></span><br><span class="line">console.log(serverPort); // 3000</span><br></pre></td></tr></table></figure><p>在上述示例中，如果 <code>config.server.port</code> 为 <code>null</code>，使用空值合并运算符可以安全地提供一个默认值，而不引发错误。</p><p>空值合并运算符与传统的逻辑运算符 <code>||</code> 相比，更明确地处理只有在值为 <code>null</code> 或 <code>undefined</code> 时才提供默认值的情况。这使得代码更容易理解，避免了一些潜在的意外行为</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：请简述-的机制"><a href="#Q3：请简述-的机制" class="headerlink" title="Q3：请简述 == 的机制"></a>Q3：请简述 == 的机制</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>==</code> 是 JavaScript 中的相等运算符，用于比较两个值是否相等。它的比较规则如下：</p><ol><li><strong>类型转换</strong>：<ul><li>如果比较的两个操作数类型相同，则直接进行值的比较。</li><li>如果比较的两个操作数类型不同，则 JavaScript 会尝试将它们转换为相同的类型再进行比较。</li></ul></li><li><strong>转换规则</strong>：<ul><li>如果一个操作数是布尔值，则将其转换为数值进行比较。<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>。</li><li>如果一个操作数是字符串，另一个是数字，则将字符串转换为数字再进行比较。</li><li>如果一个操作数是对象，另一个不是，则将对象转换为原始值（通过 <code>valueOf()</code> 和 <code>toString()</code> 方法），然后再进行比较。</li><li>如果一个操作数是 <code>null</code>，另一个是 <code>undefined</code>，则它们被认为是相等的。</li><li>如果一个操作数是 <code>NaN</code>，则它与任何其他值（包括自身）都不相等。</li></ul></li><li><strong>特殊情况</strong>：<ul><li>当比较的操作数是 <code>null</code> 或 <code>undefined</code> 时，它们相等。但如果其中一个是 <code>NaN</code>，则它们不相等。</li><li>如果其中一个操作数是对象，另一个是原始值（字符串、数字、布尔值），则将对象转换为原始值再进行比较。</li></ul></li><li><strong>注意事项</strong>：<ul><li>由于 <code>==</code> 运算符进行类型转换，因此可能会导致一些意想不到的结果。为了避免这种情况，通常应该优先使用严格相等运算符 <code>===</code>，它要求操作数的值和类型都相等才返回 <code>true</code>。</li><li>在条件语句中，使用 <code>==</code> 比较时要格外小心，确保理解其转换规则并且符合预期的结果。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：-和-有什么区别，分别在什么情况使用"><a href="#Q4：-和-有什么区别，分别在什么情况使用" class="headerlink" title="Q4：==和 ===有什么区别，分别在什么情况使用?"></a>Q4：==和 ===有什么区别，分别在什么情况使用?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>==</code> 和 <code>===</code> 都是 JavaScript 中的比较运算符，用于比较两个值是否相等，它们之间的区别如下：</p><ol><li><strong><code>==</code>（相等运算符）</strong>：<ul><li>使用 <code>==</code> 进行比较时，如果两个操作数的类型不同，会先进行类型转换，然后再比较值是否相等。</li><li>如果操作数的类型不同，则会尝试将它们转换为相同的类型，再进行比较。</li><li>如果操作数之一是对象，则比较它们是否引用了相同的对象，而不是对象的内容。</li><li>示例：<code>0 == &#39;0&#39;</code> 返回 <code>true</code>，因为 <code>&#39;0&#39;</code> 被转换为数字 <code>0</code> 进行比较。</li></ul></li><li><strong><code>===</code>（严格相等运算符）</strong>：<ul><li>使用 <code>===</code> 进行比较时，不会进行类型转换，而是严格比较两个操作数的值和类型是否完全相等。</li><li>只有在操作数的值和类型完全相等时，才会返回 <code>true</code>；否则返回 <code>false</code>。</li><li>示例：<code>0 === &#39;0&#39;</code> 返回 <code>false</code>，因为它们的类型不同。</li></ul></li></ol><p><strong>使用情况</strong>：</p><ul><li>通常情况下，推荐使用 <code>===</code> 进行严格相等比较，因为它不会进行隐式类型转换，更加安全和准确。</li><li>当需要忽略类型的差异时，或者需要进行隐式类型转换时，可以使用 <code>==</code> 进行相等比较，但需要注意可能会产生的意外结果。</li><li>在开发过程中，应根据具体的需求和情况选择合适的比较运算符。如果不确定应该使用哪个运算符，最好使用 <code>===</code> 进行严格相等比较</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：如果new一个箭头函数会怎么样"><a href="#Q5：如果new一个箭头函数会怎么样" class="headerlink" title="Q5：如果new一个箭头函数会怎么样"></a>Q5：如果new一个箭头函数会怎么样</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>如果你尝试用<code>new</code>操作符去实例化一个箭头函数，会抛出一个错误</p><p>这是因为箭头函数并没有自己的<code>this</code>，它们不绑定自己的<code>this</code>值，在箭头函数中的<code>this</code>实际上是继承自外围上下文</p><p>因此，箭头函数不能被用作构造函数</p><p>例如，以下代码将会抛出一个错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ArrowFunction</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">ArrowFunction</span>(); <span class="comment">// 错误 - ArrowFunction is not a constructor</span></span><br></pre></td></tr></table></figure><p>当你运行上述代码时，JavaScript将会抛出一个TypeError，指出ArrowFunction不是一个构造函数</p><p>这是因为你无法用<code>new</code>关键字来实例化一个箭头函数</p><p>因此，如果你想要创建一个可以使用<code>new</code>操作符的函数，你应该使用传统的函数声明或者函数表达式，不要使用箭头函数</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>new一个函数的时候，new操作符做了什么操作</strong></p><p>使用<code>new</code>操作符创建一个函数的实例时，它执行了几个步骤来构建和返回一个新对象。以下是详细的步骤：</p><ol><li><p><strong>创建空对象</strong></p><p><code>new</code>操作符首先创建一个空的JavaScript对象<code>{}</code></p></li><li><p><strong>设置原型</strong></p><p>新创建的对象的<code>__proto__</code>会被链接到构造函数的<code>prototype</code>对象，让新创建的对象可以访问构造函数原型链上的属性和方法</p></li><li><p><strong>绑定<code>this</code></strong></p><p>在构造函数中，<code>this</code>被改变并指向了新创建的对象</p><p>因此，在构造函数内部，我们可以使用<code>this</code>来引用和初始化新对象的属性</p></li><li><p><strong>运行构造函数中的代码</strong>（包括它定义的属性和方法）</p><p>这将定义新对象的属性和方法</p></li><li><p><strong>返回新对象</strong></p><p>如果构造函数没有显示地返回一个对象，那么<code>new</code>操作符将自动返回新创建的对象</p><p>需要注意的是，如果构造函数返回非空对象（Object或者Array）则<code>new</code>操作符返回的是这个对象，而不是新创建的对象</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Object-is（）与比较操作符“-”、“-”的区别"><a href="#Q6：Object-is（）与比较操作符“-”、“-”的区别" class="headerlink" title="Q6：Object.is（）与比较操作符“===”、“==”的区别"></a>Q6：Object.is（）与比较操作符“===”、“==”的区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><code>Object.is()</code><ul><li><code>Object.is()</code>用于判断两个值是否为相同的值</li><li>它与<code>===</code>非常相似，但在两个特殊情况下有所不同：<ul><li>对于<code>NaN</code>，<code>Object.is(NaN, NaN)</code>返回<code>true</code>（而<code>NaN === NaN</code>返回<code>false</code>）</li><li>对于<code>+0</code>和<code>-0</code>，<code>Object.is(+0, -0)</code>返回<code>false</code>（而<code>+0 === -0</code>返回<code>true</code>）</li></ul></li></ul></li><li><code>===</code>（严格等于）<ul><li><code>===</code>不会进行类型转换，如果两个值的类型不同，它直接返回<code>false</code></li><li>对于大多数值，<code>===</code>的行为和<code>Object.is()</code>一样</li><li>除了上面提到的两个特殊情况，也就是<code>NaN</code>不等于自身，以及认为<code>+0</code>和<code>-0</code>是相等的</li></ul></li><li><code>==</code>（抽象等于）<ul><li><code>==</code>在比较前会进行类型转换，尝试将两个值转换为相同类型，然后再进行值的比较</li><li>由于涉及到类型转换，使用<code>==</code>时可能出现一些非直观的结果，尤其是当比较不同类型的值时</li><li>举个例子，<code>&#39;2&#39; == 2</code>会返回<code>true</code>，因为字符串<code>&#39;2&#39;</code>会被转换为数字<code>2</code></li></ul></li></ol><p>在编写代码时，推荐使用<code>===</code>来避免意外的类型转换，从而使代码的行为更加可预测</p><p><code>Object.is()</code>在需要区分<code>+0</code>和<code>-0</code>，或者判断<code>NaN</code>的相等性时很有用</p><p>而<code>==</code>由于其类型转换的特性，一般不推荐使用，除非明确需要这种行为</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：0-1-0-2为什么不等于0-3"><a href="#Q7：0-1-0-2为什么不等于0-3" class="headerlink" title="Q7：0.1+0.2为什么不等于0.3"></a>Q7：0.1+0.2为什么不等于0.3</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>0.1 + 0.2</code> 不等于 <code>0.3</code> 是浮点数精度问题的一个典型示例，这个问题存在于很多编程语言中，不仅仅是JavaScript。原因在于这些语言通常遵循IEEE 754标准来表示浮点数。</p><ol><li><p>浮点数和精度</p><p>在这个标准中，数字是以二进制格式存储的</p><p>整数可以精确地表示为二进制数，但很多分数在二进制中是无限循环小数</p><p>比如，<code>1/10</code> 和 <code>1/5</code> 在二进制中不能精确表示</p><p>在十进制中：</p><ul><li><code>1/10</code> 等于 `0.1``</li><li><code>`1/5</code> 等于 <code>0.2</code></li></ul><p>但在二进制中，它们是无限循环小数：</p><ul><li><code>1/10</code> 的二进制形式近似为 `0.0001100110011001100110011001100…``</li><li><code>`1/5</code> 的二进制形式近似为 <code>0.00110011001100110011001100110011...</code></li></ul><p>由于计算机存储容量是有限的，这些小数点后无限循环的二进制数必须在某处切断，这意味着它们是近似值，而不是精确值</p></li><li><p>精确性问题</p><p>当执行 <code>0.1 + 0.2</code> 这样的操作时，二进制中的近似值相加会产生一个比实际 <code>0.3</code> 略微不同的结果</p><p>在十进制中，这个结果经常是 <code>0.30000000000000004</code>，而不是我们期望的 <code>0.3</code></p></li><li><p>如何解决</p><p>为了应对这个问题，在处理金融或精度重要的数学计算时，采取特别的策略：</p><ul><li><p>四舍五入</p><p> JavaScript 提供了内置的 <code>toFixed</code> 方法，可以把浮点数四舍五入到指定的小数位</p><p>比如，<code>(0.1 + 0.2).toFixed(1)</code> 将返回字符串 “0.3”</p></li><li><p>使用整数进行计算</p><p>如果我们知道我们正在处理的小数点后的位数，我们可以把浮点数转换为整数，进行整数运算，然后再转回浮点数</p><p>比如，把 <code>0.1</code> 和 <code>0.2</code> 乘以10得到 <code>1</code> 和 <code>2</code>，然后相加得到 <code>3</code>，再除以10得到 <code>0.3</code></p></li><li><p>使用第三方库</p><p>有许多JavaScript库，比如 decimal.js、bignumber.js 或者 math.js，这些库提供了更精确的计算，可以解决浮点数精度的问题</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h3 id="Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？"><a href="#Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？" class="headerlink" title="Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？"></a>Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>ES6 中新增的 Set 和 Map 是两种不同的数据结构，分别用于存储一组唯一的值和键值对。下面分别对 Set 和 Map 进行简要的理解：</p><p><strong>Set（集合）</strong></p><ol><li><strong>唯一性</strong>：<ul><li>Set 中的元素是唯一的，不能重复。</li><li>如果试图向 Set 中添加重复的元素，它会被忽略。</li></ul></li><li><strong>元素的顺序</strong>：<ul><li>Set 中的元素按照插入的顺序排列，不会像对象那样根据键排序。</li></ul></li><li><strong>API 方法</strong>：<ul><li><code>add(value)</code>：向 Set 中添加元素。</li><li><code>delete(value)</code>：删除 Set 中的指定元素。</li><li><code>has(value)</code>：检查 Set 中是否包含某个元素。</li><li><code>clear()</code>：清空 Set 中的所有元素。</li></ul></li><li><strong>应用场景</strong>：<ul><li>用于存储一组唯一的值，比如去重。</li></ul></li></ol><p><strong>Map（映射）</strong></p><ol><li><strong>键值对</strong>：<ul><li>Map 中存储的是键值对，其中键可以是任意数据类型。</li></ul></li><li><strong>键的唯一性</strong>：<ul><li>Map 中的键是唯一的，每个键只能对应一个值。</li></ul></li><li><strong>元素的顺序</strong>：<ul><li>Map 中的元素按照插入的顺序排列，与 Set 类似，不会根据键的顺序排序。</li></ul></li><li><strong>API 方法</strong>：<ul><li><code>set(key, value)</code>：向 Map 中添加键值对。</li><li><code>get(key)</code>：获取 Map 中指定键的值。</li><li><code>delete(key)</code>：删除 Map 中指定键的键值对。</li><li><code>has(key)</code>：检查 Map 中是否包含某个键。</li><li><code>clear()</code>：清空 Map 中的所有键值对。</li></ul></li><li><strong>应用场景</strong>：<ul><li>用于存储键值对，提供更灵活的数据结构，例如保存对象的属性和值。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li>Set 适合存储一组唯一的值，不关心键值对的情况。</li><li>Map 适合存储键值对，每个键对应一个值。</li><li>它们都提供了高效的查找和删除操作，适用于各种场景，提供了更丰富的 API 方法。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：Math-ceil跟Meth-floor有什么区别"><a href="#Q2：Math-ceil跟Meth-floor有什么区别" class="headerlink" title="Q2：Math.ceil跟Meth.floor有什么区别"></a>Q2：Math.ceil跟Meth.floor有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Math.ceil</code> 和 <code>Math.floor</code> 是 JavaScript 中用于处理数字的 Math 对象的两个方法，它们分别用于向上取整和向下取整。</p><ol><li><p><strong><code>Math.ceil(x)</code>：</strong></p><ul><li><code>Math.ceil</code> 方法返回大于或等于传入数字 <code>x</code> 的最小整数。</li><li>例如，<code>Math.ceil(4.3)</code> 返回 <code>5</code>，因为 <code>5</code> 是大于 <code>4.3</code> 的最小整数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultCeil = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">4.3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultCeil); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.floor(x)</code>：</strong></p><ul><li><code>Math.floor</code> 方法返回小于或等于传入数字 <code>x</code> 的最大整数。</li><li>例如，<code>Math.floor(4.9)</code> 返回 <code>4</code>，因为 <code>4</code> 是小于或等于 <code>4.9</code> 的最大整数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultFloor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">4.9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultFloor); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong><code>Math.abs(x)</code>：</strong> 返回给定数字 <code>x</code> 的绝对值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> absoluteValue = <span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(absoluteValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.round(x)</code>：</strong> 返回给定数字 <code>x</code> 的四舍五入值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> roundedValue = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">4.6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(roundedValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.max(x, y, ...)</code>：</strong> 返回传入的一组数字中的最大值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxValue = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxValue); <span class="comment">// 输出 12</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.min(x, y, ...)</code>：</strong> 返回传入的一组数字中的最小值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(minValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.sqrt(x)</code>：</strong> 返回给定数字 <code>x</code> 的平方根。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> squareRoot = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">25</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(squareRoot); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：document-write和innerHTML有什么区别"><a href="#Q3：document-write和innerHTML有什么区别" class="headerlink" title="Q3：document.write和innerHTML有什么区别"></a>Q3：document.write和innerHTML有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong><code>document.write</code>：</strong></p><ul><li><code>document.write</code> 是 <code>Document</code> 对象的方法，可以直接在文档中写入字符串。</li><li>它通常用于在页面加载过程中动态生成内容，但不太推荐在页面加载后使用，因为它会覆盖整个文档。</li><li>如果在文档已加载后使用 <code>document.write</code>，它将重写整个文档，可能导致文档结构被破坏。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello, World!&lt;/p&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>innerHTML</code>：</strong></p><ul><li><code>innerHTML</code> 是 <code>Element</code> 对象的属性，允许你获取或设置元素的 HTML 内容。</li><li>它更适用于在已存在的元素中动态插入或更新内容。</li><li>使用 <code>innerHTML</code> 时，你只需操作需要更新的元素，而不会影响文档的其他部分。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素的 HTML 内容</span></span><br><span class="line"><span class="keyword">const</span> elementContent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>).<span class="property">innerHTML</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置元素的 HTML 内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;p&gt;New content&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>主要区别：</strong></p><ul><li><code>document.write</code> 是一个全局方法，它直接操作整个文档，可能导致文档结构被覆盖，而且在文档加载后使用时存在一些问题。</li><li><code>innerHTML</code> 是元素的属性，更适用于操作元素的 HTML 内容，且更安全可控。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：Math-max跟Math-min怎么用于数组里面取最值"><a href="#Q4：Math-max跟Math-min怎么用于数组里面取最值" class="headerlink" title="Q4：Math.max跟Math.min怎么用于数组里面取最值"></a>Q4：Math.max跟Math.min怎么用于数组里面取最值</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Math.max</code> 和 <code>Math.min</code> 分别用于获取数组中的最大值和最小值。这两个方法可以结合使用 <code>apply</code> 或扩展运算符 <code>...</code> 来处理数组。以下是使用示例：</p><p><strong>使用 <code>apply</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [2, 5, 1, 8, 3];</span><br><span class="line"></span><br><span class="line">const maxNumber = Math.max.apply(null, numbers);</span><br><span class="line">const minNumber = Math.min.apply(null, numbers);</span><br><span class="line"></span><br><span class="line">console.log(maxNumber); // 输出 8</span><br><span class="line">console.log(minNumber); // 输出 1</span><br></pre></td></tr></table></figure><p><strong>使用扩展运算符 <code>...</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [2, 5, 1, 8, 3];</span><br><span class="line"></span><br><span class="line">const maxNumber = Math.max(...numbers);</span><br><span class="line">const minNumber = Math.min(...numbers);</span><br><span class="line"></span><br><span class="line">console.log(maxNumber); // 输出 8</span><br><span class="line">console.log(minNumber); // 输出 1</span><br></pre></td></tr></table></figure><p>在这两个示例中，<code>Math.max</code> 和 <code>Math.min</code> 都被用于处理数组 <code>numbers</code>，得到了数组中的最大值和最小值。</p><p>请注意，在处理非常大的数组时，可能会遇到 <code>apply</code> 或 <code>...</code> 的参数列表长度限制。在这种情况下，可以采用其他方法，如使用循环或使用 <code>reduce</code> 函数来找到最大值和最小值</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：对requestIdleCallback的理解"><a href="#Q5：对requestIdleCallback的理解" class="headerlink" title="Q5：对requestIdleCallback的理解"></a>Q5：对requestIdleCallback的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>requestIdleCallback</code> 是浏览器提供的一个用于在浏览器空闲时执行任务的 API。它的主要目的是充分利用浏览器的空闲时间，执行一些不紧急但耗时较长的任务，而不影响用户界面的响应性能。</p><p><strong>使用方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(callback[, options]);</span><br></pre></td></tr></table></figure><ul><li><code>callback</code>: 要在空闲时执行的函数。</li><li><code>options</code> (可选): 一个对象，用于指定调用 <code>callback</code> 的条件，例如 <code>timeout</code> 表示最长等待时间。</li></ul><p><strong>工作原理：</strong></p><ol><li>当浏览器空闲时，会执行注册的回调函数。</li><li>如果回调函数执行时间较长，浏览器会在执行过程中中断它，以确保其他高优先级任务（例如用户交互）的及时响应。</li><li>在下一个空闲周期继续执行未完成的部分。</li></ol><p><strong>适用场景：</strong></p><ul><li><strong>异步操作：</strong> 执行一些不需要立即完成的异步操作，如图片加载、数据请求等。</li><li><strong>性能优化：</strong> 执行一些耗时较长的性能优化任务，如计算复杂布局、懒加载等。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performIdleTask</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> ((deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> || deadline.<span class="property">didTimeout</span>) &amp;&amp; tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = tasks.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="title function_">task</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(performIdleTask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTask</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(performIdleTask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">addTask</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task 1&#x27;</span>));</span><br><span class="line"><span class="title function_">addTask</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task 2&#x27;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上述代码创建了一个简单的任务队列，并通过 <code>requestIdleCallback</code> 在浏览器空闲时执行队列中的任务。这可以用于将一些非紧急的任务推迟到浏览器处于空闲状态时执行，以提高性能。</p><p><code>requestIdleCallback</code> 的作用就是将一些非关键性的任务从主线程中分离出来，等到浏览器闲置时再执行。这样就可以避免占用主线程，提高页面的响应速度和流畅度。</p><p>使用 <code>requestIdleCallback</code> 需要传入一个回调函数，该函数会在浏览器空闲时被调用。回调函数的参数是一个 IdleDeadline 对象，它包含有关浏览器还剩余多少时间可供执行任务的信息。根据该对象的时间戳信息，开发人员可以自行决定是否继续执行任务或推迟执行。</p><p><code>requestIdleCallback</code> 可以帮助我们优化 Web 应用程序的性能和响应速度，减少资源的浪费。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：map和和-filter-有什么区别"><a href="#Q6：map和和-filter-有什么区别" class="headerlink" title="Q6：map和和 filter 有什么区别?"></a>Q6：map和和 filter 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>map()</code> 和 <code>filter()</code> 都是 JavaScript 中常用的数组方法，用于对数组进行操作和转换，但它们的作用和使用方式有所不同。</p><p><strong>区别：</strong></p><ol><li><strong>作用</strong>：<ul><li><code>map()</code> 方法用于对数组中的每个元素执行指定的操作，并返回一个新的数组，新数组的每个元素都是原始数组对应位置元素经过操作后的结果。</li><li><code>filter()</code> 方法用于根据指定的条件过滤数组中的元素，并返回一个新的数组，新数组包含满足条件的元素。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>map()</code> 方法返回一个新的数组，包含每个元素经过操作后的结果。</li><li><code>filter()</code> 方法返回一个新的数组，包含满足指定条件的元素。</li></ul></li><li><strong>使用方式</strong>：<ul><li><code>map()</code> 方法接受一个回调函数作为参数，该回调函数会被传入数组中的每个元素和它们的索引，并返回操作后的结果。</li><li><code>filter()</code> 方法接受一个回调函数作为参数，该回调函数会被传入数组中的每个元素和它们的索引，并根据回调函数返回的布尔值来决定是否保留该元素。</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 map() 方法将数组中的每个元素乘以 2</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubledNumbers); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter() 方法过滤出数组中的偶数</span></span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evenNumbers); <span class="comment">// 输出 [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>map()</code> 方法将数组中的每个元素乘以 2，并返回一个新的数组，而 <code>filter()</code> 方法则过滤出数组中的偶数，并返回一个新的数组。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：map-和-forEach-有什么区别"><a href="#Q7：map-和-forEach-有什么区别" class="headerlink" title="Q7：map 和 forEach 有什么区别?"></a>Q7：map 和 forEach 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>map()</code> 和 <code>forEach()</code> 都是 JavaScript 中用于处理数组的方法，但它们之间有一些重要的区别：</p><ol><li><strong>返回值</strong>：<ul><li><code>map()</code> 方法返回一个新的数组，该数组包含了对原数组中每个元素调用回调函数后的返回值组成的数组。</li><li><code>forEach()</code> 方法没有返回值（或者说返回值为 <code>undefined</code>），它仅用于迭代数组中的每个元素，执行回调函数但不会修改原数组。</li></ul></li><li><strong>使用场景</strong>：<ul><li><code>map()</code> 适合用于需要对数组中的每个元素进行某种转换或映射的场景，例如将每个元素乘以 2、转换为大写等。</li><li><code>forEach()</code> 适合用于需要对数组中的每个元素执行一些操作，但不需要返回新数组的场景，例如打印数组中的元素、向数组中添加新元素等。</li></ul></li><li><strong>对原数组的影响</strong>：<ul><li><code>map()</code> 方法不会修改原数组，它会返回一个新数组。</li><li><code>forEach()</code> 方法也不会修改原数组，但是可以在回调函数中对原数组进行修改，因为它在迭代过程中可以访问原数组的每个元素。</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 map() 方法将数组中的每个元素乘以 2，并返回一个新的数组</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubledNumbers); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 方法打印数组中的每个元素</span></span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)); <span class="comment">// 输出每个元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 方法向数组中添加新元素</span></span><br><span class="line"><span class="keyword">const</span> newArray = [];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> newArray.<span class="title function_">push</span>(num * <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>map()</code> 方法将数组中的每个元素乘以 2，并返回一个新的数组，而 <code>forEach()</code> 方法用于打印数组中的每个元素以及向新数组中添加新元素。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：const声明了数组，还能push元素吗，为什么"><a href="#Q8：const声明了数组，还能push元素吗，为什么" class="headerlink" title="Q8：const声明了数组，还能push元素吗，为什么?"></a>Q8：const声明了数组，还能push元素吗，为什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，使用 <code>const</code> 声明的变量不允许重新分配（重新赋值），但是它并不限制对其引用的对象或数组进行修改。因此，虽然你不能给 <code>const</code> 声明的变量重新赋值，但是你可以修改其所引用的对象或数组的内容。</p><p>举例来说，你可以使用 <code>const</code> 声明一个数组，并且在之后调用数组的 <code>push</code> 方法向其中添加新元素。这是因为 <code>const</code> 保护的是变量本身的重新赋值，而不是其引用的对象或数组的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 可以正常执行，向数组添加了一个新元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>总之，<code>const</code> 保护的是变量的重新赋值，而不是变量所引用的对象或数组的内容，因此在使用 <code>const</code> 声明的数组中，你仍然可以修改数组的内容，包括使用 <code>push</code> 方法向数组中添加新元素。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：Math-ceil-、Math-round-、Math-floor-三者的区别是什么"><a href="#Q9-：Math-ceil-、Math-round-、Math-floor-三者的区别是什么" class="headerlink" title="Q9 ：Math.ceil()、Math.round()、Math.floor()三者的区别是什么?"></a>Q9 ：Math.ceil()、Math.round()、Math.floor()三者的区别是什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Math.ceil()</strong>：</p><ul><li><p><code>Math.ceil()</code> 方法返回大于或等于给定数字的最小整数。</p></li><li><p>如果参数是一个整数，则返回该整数。</p></li><li><p>如果参数是一个小数，则返回比它大的最小整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(5.3); // 输出 6</span><br><span class="line">Math.ceil(-5.3); // 输出 -5</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Math.round()</strong>：</p><ul><li><p><code>Math.round()</code> 方法返回最接近给定数字的整数，四舍五入到最接近的整数。</p></li><li><p>如果参数的小数部分大于或等于 0.5，则返回下一个更大的整数；否则返回前一个更小的整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.round(5.3); // 输出 5</span><br><span class="line">Math.round(5.6); // 输出 6</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Math.floor()</strong>：</p><ul><li><p><code>Math.floor()</code> 方法返回小于或等于给定数字的最大整数。</p></li><li><p>如果参数是一个整数，则返回该整数。</p></li><li><p>如果参数是一个小数，则返回比它小的最大整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(5.3); // 输出 5</span><br><span class="line">Math.floor(-5.3); // 输出 -6</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>总结来说，这三个方法都是用来对数字进行取整操作，但它们的取整规则略有不同。<code>Math.ceil()</code> 总是向上取整到最接近的整数，<code>Math.round()</code> 则是四舍五入到最接近的整数，而 <code>Math.floor()</code> 总是向下取整到最接近的整数。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：toPrecision-和-toFixed-和-Math-round-有什么区别"><a href="#Q10：toPrecision-和-toFixed-和-Math-round-有什么区别" class="headerlink" title="Q10：toPrecision 和 toFixed 和 Math.round 有什么区别?"></a>Q10：toPrecision 和 toFixed 和 Math.round 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>toPrecision()</code>, <code>toFixed()</code>, 和 <code>Math.round()</code> 是 JavaScript 中用于处理数字的三种不同方法，它们有以下区别：</p><ol><li><strong>toPrecision()</strong>:<ul><li><code>toPrecision()</code> 是一个数字对象的方法，用于将数字转换为指定精度的字符串表示。</li><li>该方法接受一个参数，该参数表示数字的有效位数（包括整数部分和小数部分），并返回一个字符串表示该数字。</li><li>它可以处理较大或较小的数字，并以科学计数法的形式显示。</li><li>例如：<code>var num = 123.456789; num.toPrecision(4); // &quot;123.5&quot;</code></li></ul></li><li><strong>toFixed()</strong>:<ul><li><code>toFixed()</code> 是一个数字对象的方法，用于将数字转换为指定小数位数的字符串表示。</li><li>该方法接受一个参数，表示保留的小数位数，然后返回一个带有指定小数位数的字符串表示。</li><li>它会进行四舍五入并将结果舍入到指定的小数位数。</li><li>例如：<code>var num = 123.456789; num.toFixed(2); // &quot;123.46&quot;</code></li></ul></li><li><strong>Math.round()</strong>:<ul><li><code>Math.round()</code> 是一个全局对象 Math 的方法，用于将数字四舍五入到最接近的整数。</li><li>该方法接受一个数字参数，并返回最接近的整数。</li><li>它不会更改数字的小数部分，而是根据小数部分的值将数字舍入到最接近的整数。</li><li>例如：<code>Math.round(123.456789); // 123</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li><code>toPrecision()</code> 和 <code>toFixed()</code> 都返回字符串，而 <code>Math.round()</code> 返回数字。</li><li><code>toPrecision()</code> 可以控制有效位数，包括小数点前后的位数。</li><li><code>toFixed()</code> 用于固定小数位数。</li><li><code>Math.round()</code> 用于简单的四舍五入到最接近的整数。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：什么是-Polyfil"><a href="#Q11：什么是-Polyfil" class="headerlink" title="Q11：什么是 Polyfil ?"></a>Q11：什么是 Polyfil ?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Polyfill（填充物）是用于模拟浏览器中缺失功能的代码块，通常用于使较新的Web技术能够在较旧的浏览器中正常运行。在Web开发中，不同的浏览器可能支持不同的JavaScript标准和API版本，这可能导致代码在某些浏览器中无法正常运行。</p><p>Polyfill 的目的是填补这些功能的缺失。通过在代码中包含 Polyfill，开发人员可以向较旧的浏览器提供与较新浏览器相同的功能，从而确保网站或应用程序在各种浏览器中具有一致的行为和体验。</p><p>Polyfill 通常是由开发者编写的 JavaScript 代码，其功能是检测浏览器是否支持某个特定的功能，如果不支持，则通过代码模拟这个功能。例如，如果某个浏览器不支持 <code>Array.prototype.forEach()</code> 方法，那么可以编写一个 Polyfill 来模拟这个方法的行为，使得在该浏览器中也可以使用 <code>forEach()</code>。</p><p>Polyfill 可以是个别功能的填充，也可以是一个包含多个功能填充的库。它们通常在需要时被引入到项目中，以解决特定的兼容性问题。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>下面是一个使用 Polyfill 的简单例子，假设我们想要在不支持 <code>Array.prototype.includes()</code> 方法的浏览器中使用这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Polyfill for Array.prototype.includes()</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span> = <span class="keyword">function</span>(<span class="params">searchElement <span class="comment">/*, fromIndex*/</span></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array.prototype.includes called on null or undefined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">parseInt</span>(O.<span class="property">length</span>, <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">parseInt</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>], <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> k;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      k = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = len + n;</span><br><span class="line">      <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentElement;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      currentElement = O[k];</span><br><span class="line">      <span class="keyword">if</span> (searchElement === currentElement ||</span><br><span class="line">         (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (array.<span class="title function_">includes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数组包含 3&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数组不包含 3&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先检查是否存在 <code>Array.prototype.includes()</code> 方法。如果不存在，我们将定义一个 Polyfill 来模拟这个方法的行为。然后我们使用这个方法来检查数组中是否包含特定的元素。这样，即使浏览器不支持 <code>Array.prototype.includes()</code> 方法，我们也可以在代码中使用它。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：setTimeout-为什么不能保证能够及时执行"><a href="#Q12：setTimeout-为什么不能保证能够及时执行" class="headerlink" title="Q12：setTimeout 为什么不能保证能够及时执行?"></a>Q12：setTimeout 为什么不能保证能够及时执行?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>setTimeout()</code> 函数用于在指定的时间间隔之后执行一次 JavaScript 代码或函数。虽然在理论上 <code>setTimeout()</code> 应该在指定的时间间隔之后立即执行，但在实际应用中，它并不能保证能够及时执行的原因有几个：</p><ol><li><strong>JavaScript 单线程模型</strong>：JavaScript 在浏览器中是单线程执行的，意味着所有的代码都是按顺序执行的。如果前面的代码需要花费大量时间来执行，那么 <code>setTimeout()</code> 中的代码就会被推迟执行，直到前面的代码执行完成。这可能会导致 <code>setTimeout()</code> 中的代码延迟执行，即使指定的时间间隔已经到了。</li><li><strong>事件循环机制</strong>：在浏览器中，JavaScript 的执行是基于事件循环的。当执行栈中的任务执行完成后，浏览器会检查任务队列中是否有待执行的任务。如果有，它会将任务移到执行栈中执行。由于事件循环的机制，<code>setTimeout()</code> 中的代码可能需要等待前面的任务完成并且执行栈为空时才会被执行，这也会导致延迟执行的情况发生。</li><li><strong>最小延迟时间</strong>：<code>setTimeout()</code> 的精度受到浏览器和操作系统的限制，通常来说，<code>setTimeout()</code> 的最小延迟时间在几毫秒到几十毫秒之间。因此，如果你指定的延迟时间非常短，例如 1 毫秒，那么由于浏览器的限制，<code>setTimeout()</code> 也可能无法保证精确执行。</li></ol><p>综上所述，虽然 <code>setTimeout()</code> 是用来在指定的时间后执行代码的方法，但由于上述原因，它并不能保证能够及时执行。在编写代码时，应该考虑到这些因素，并避免依赖于严格的时间控制。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：Javascript字符串的常用方法有哪些"><a href="#Q13：Javascript字符串的常用方法有哪些" class="headerlink" title="Q13：Javascript字符串的常用方法有哪些?"></a>Q13：Javascript字符串的常用方法有哪些?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>charAt(index)</code>: 返回指定索引位置的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">1</span>)); <span class="comment">// 输出 &quot;e&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>charCodeAt(index)</code>: 返回指定索引位置字符的 Unicode 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat(str1, str2, ...)</code>：连接两个或多个字符串，返回新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">concat</span>(<span class="string">&quot;, &quot;</span>, str2)); <span class="comment">// 输出 &quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>includes(searchString, position)</code>：判断字符串中是否包含指定的子字符串，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>indexOf(searchValue, fromIndex)</code>：返回指定值在字符串中首次出现的位置，如果没有找到则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure></li><li><p><code>lastIndexOf(searchValue, fromIndex)</code>：返回指定值在字符串中最后一次出现的位置，如果没有找到则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure></li><li><p><code>slice(start, end)</code>：提取字符串的一个片段，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">11</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>substring(start, end)</code>：提取字符串的一个子串，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">11</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>substr(start, length)</code>：提取字符串中从指定位置开始的指定长度的子串，并返回一个新字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">6</span>, <span class="number">5</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>split(separator, limit)</code>：将字符串分割成子串，返回一个由子串组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)); <span class="comment">// 输出 [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>toLowerCase()</code>：将字符串转换为小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toLowerCase</span>()); <span class="comment">// 输出 &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>toUpperCase()</code>：将字符串转换为大写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toUpperCase</span>()); <span class="comment">// 输出 &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>trim()</code>：去除字符串两端的空白字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;   Hello World   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>()); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>replace(searchValue, replaceValue)</code>：替换字符串中的子串，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>)); <span class="comment">// 输出 &quot;Hello Universe&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>startsWith(searchString, position)</code>：判断字符串是否以指定的子串开头，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>endsWith(searchString, position)</code>：判断字符串是否以指定的子串结尾，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>match(regexp)</code>：检索字符串内指定的值，返回一个或多个匹配的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;The rain in Spain falls mainly in the plain&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/ain/g</span>)); <span class="comment">// 输出 [&quot;ain&quot;, &quot;ain&quot;, &quot;ain&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>search(regexp)</code>：检索与正则表达式相匹配的值，返回匹配的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;The rain in Spain falls mainly in the plain&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">search</span>(<span class="regexp">/ain/g</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><code>repeat(count)</code>：复制字符串指定次数，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">repeat</span>(<span class="number">3</span>)); <span class="comment">// 输出 &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：addEventListener-第三个参数是干什么的"><a href="#Q14：addEventListener-第三个参数是干什么的" class="headerlink" title="Q14：addEventListener 第三个参数是干什么的"></a>Q14：addEventListener 第三个参数是干什么的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 <code>addEventListener</code> 方法中，第三个参数是一个布尔值或者一个对象，用于指定事件处理函数的配置。常见的配置包括：</p><ol><li><strong>捕获或冒泡</strong>：布尔值，默认为 false（冒泡阶段）。如果设置为 true，则在捕获阶段触发事件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">true</span>); <span class="comment">// 在捕获阶段触发事件</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>); <span class="comment">// 在冒泡阶段触发事件（默认）</span></span><br></pre></td></tr></table></figure><ol><li><strong>可选参数对象</strong>：可以使用一个对象来指定更多的事件处理函数的配置，包括 <code>capture</code>、<code>once</code>、<code>passive</code> 等属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, &#123;</span><br><span class="line">  <span class="attr">capture</span>: <span class="literal">true</span>, <span class="comment">// 在捕获阶段触发事件</span></span><br><span class="line">  <span class="attr">once</span>: <span class="literal">true</span>,    <span class="comment">// 仅触发一次，然后移除监听器</span></span><br><span class="line">  <span class="attr">passive</span>: <span class="literal">true</span>  <span class="comment">// 告知浏览器事件处理函数不会调用 preventDefault()</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>capture</code>：一个布尔值，表示事件是否在捕获阶段触发。默认为 false。</li><li><code>once</code>：一个布尔值，表示事件是否仅触发一次，触发后即移除事件监听器。默认为 false。</li><li><code>passive</code>：一个布尔值，表示事件处理函数是否调用了 <code>preventDefault()</code>。如果设置为 true，告知浏览器事件处理函数不会调用 <code>preventDefault()</code>，从而可以提高滚动性能。默认为 false。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景"><a href="#Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景" class="headerlink" title="Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景?"></a>Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>存储方式</th><th>区别</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>Cookies</td><td>浏览器提供的存储机制</td><td>- 客户端与服务器端都可以读取和写入； - 有大小限制，但可以设置过期时间； - 支持跨域传输，但存在安全性限制。</td><td>- 大小限制，一般只能存储几 KB 数据； - 每次请求都会自动发送，影响性能； - 受同源策略和安全性限制。</td><td>存储少量的用户身份验证信息、会话标识、用户偏好设置等。</td></tr><tr><td>localStorage</td><td>HTML5 提供的持久化本地存储机制</td><td>- 可以存储大量的数据，大小限制一般在几 MB； - 数据在浏览器关闭后仍然保留。</td><td>- 存储的数据仅限于字符串，不能存储复杂数据类型； - 受同源策略限制，只能存储在同一个域名下； - 可能受浏览器隐私模式影响。</td><td>长期保存在客户端的数据，比如用户偏好设置、本地缓存数据等。</td></tr><tr><td>sessionStorageIndexedDB</td><td>HTML5 提供的临时本地存储机制HTML5 提供的客户端数据库系统</td><td>- 可以存储大量的数据，大小限制一般在几 MB； - 数据在会话结束后被清除，不会保留到下一次会话。- 支持存储大量结构化数据； - 提供灵活的查询和索引功能； - 支持事务和版本控制。</td><td>- 存储的数据仅限于字符串，不能存储复杂数据类型； - 受同源策略限制，只能存储在同一个域名下； - 可能受浏览器隐私模式影响。- 相对复杂，学习曲线较陡； - API 不够简洁易用； - 可能受浏览器兼容性影响。</td><td>临时存储在客户端的会话相关数据，比如表单数据、单次会话的状态等。存储大量结构化数据，并需要进行复杂查询和索引的应用，比如离线 Web 应用、在线文件存储等。</td></tr><tr><td>WebSQL</td><td>HTML5 提供的关系型数据库（已废弃）</td><td>- 支持类似 SQL 的查询语言； - 提供事务支持和复杂的查询功能。</td><td>- 技术规范已废弃，不推荐在新项目中使用； - 可能受浏览器兼容性和安全性限制。</td><td>已废弃，不建议在新项目中使用；仅适用于需要在客户端进行复杂查询和数据处理的应用，且无需考虑兼容性和未来性的项目。</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：var、let、const之间有什么区别"><a href="#Q16：var、let、const之间有什么区别" class="headerlink" title="Q16：var、let、const之间有什么区别?"></a>Q16：var、let、const之间有什么区别?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>var</code>、<code>let</code> 和 <code>const</code> 是 JavaScript 中用于声明变量的关键字，它们之间有以下区别：</p><ol><li><strong>作用域</strong>：<ul><li><code>var</code> 声明的变量具有函数作用域（function scope），即在函数内部声明的变量在整个函数内部都可见。</li><li><code>let</code> 和 <code>const</code> 声明的变量具有块级作用域（block scope），即在 <code>{}</code> 内部声明的变量只在该块内部可见，超出块作用域范围则无法访问。</li></ul></li><li><strong>变量提升</strong>：<ul><li>使用 <code>var</code> 声明的变量会发生变量提升（hoisting），即变量声明会被提升到当前作用域的顶部，但初始化操作不会被提升。</li><li>使用 <code>let</code> 和 <code>const</code> 声明的变量也存在变量提升，但在变量声明前访问该变量会抛出 ReferenceError 错误。</li></ul></li><li><strong>重复声明</strong>：<ul><li>使用 <code>var</code> 可以重复声明同名变量，不会报错，但会覆盖之前的值。</li><li>使用 <code>let</code> 和 <code>const</code> 在同一作用域内重复声明同名变量会导致 SyntaxError 错误。</li></ul></li><li><strong>赋值和重新赋值</strong>：<ul><li>使用 <code>var</code> 和 <code>let</code> 声明的变量可以进行赋值和重新赋值。</li><li>使用 <code>const</code> 声明的变量必须在声明时进行初始化，且初始化后不能再修改其值（常量）。</li></ul></li><li><strong>全局对象属性</strong>：<ul><li>使用 <code>var</code> 声明的变量会成为全局对象的属性（在全局作用域下声明的变量）。</li><li>使用 <code>let</code> 和 <code>const</code> 声明的变量不会成为全局对象的属性，它们仅在声明的作用域内可见。</li></ul></li></ol><p>综上所述，<code>let</code> 和 <code>const</code> 是 ES6 新引入的块级作用域变量声明方式，相较于 <code>var</code> 具有更加严格的作用域和行为。在实际开发中，推荐使用 <code>let</code> 和 <code>const</code> 来代替 <code>var</code>，以避免由于变量提升和作用域问题而引发的错误。同时，根据变量的特性选择合适的声明方式，如需要定义常量或避免重复赋值的情况下可以使用 <code>const</code>。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：Promise-then-第二个参数和catch的区别是什么"><a href="#Q17：Promise-then-第二个参数和catch的区别是什么" class="headerlink" title="Q17：Promise then 第二个参数和catch的区别是什么"></a>Q17：Promise then 第二个参数和catch的区别是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong><code>Promise.then()</code>方法的第二个参数</strong></p><ul><li><code>Promise.then()</code>方法接收两个参数，第一个参数是用于处理Promise成功解决时的结果（成功处理函数），第二个参数是用于处理Promise拒绝时的错误（失败处理函数）</li><li>这意味着，如果Promise被拒绝，第二个参数（失败处理函数）将被调用，传递给它的参数是拒绝的原因</li><li>例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发拒绝</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resolved with:&quot;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rejected with:&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个例子中，如果Promise被拒绝，<code>then()</code>方法的第二个参数（失败处理函数）将被调用</p><p><strong><code>Promise.catch()</code>方法</strong></p><ul><li><code>Promise.catch()</code>方法是专门用于处理Promise拒绝的错误的。它等同于<code>Promise.then(null, failureHandler)</code></li><li><code>Promise.catch()</code>接收一个参数（失败处理函数），当Promise被拒绝时会调用这个函数</li><li>使用<code>Promise.catch()</code>可以使代码更清晰，因为它专门用于错误处理，而不是与<code>then()</code>方法的成功处理混在一起</li><li>例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发拒绝</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resolved with:&quot;</span>, result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rejected with:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>catch()</code>方法将处理Promise被拒绝的情况</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Promise.then()</code>方法和<code>Promise.catch()</code>方法都是用于处理Promise对象的结果和错误的，但它们在处理错误方面有不同的用法和行为</p><p><strong>区别</strong></p><ul><li><p><code>then()</code>方法的第二个参数和<code>catch()</code>方法在功能上非常相似</p><p>主要区别在于语义和可读性</p><p><code>catch()</code>明确表示只处理错误，而<code>then()</code>的第二个参数则是用于处理错误</p></li><li><p>使用<code>catch()</code>可以让代码更清晰，因为它明确表示了只处理错误的情况</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：postMessage-有哪些使用场景"><a href="#Q18：postMessage-有哪些使用场景" class="headerlink" title="Q18：postMessage 有哪些使用场景"></a>Q18：postMessage 有哪些使用场景</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>postMessage</code> 是浏览器环境中的一种用于跨文档（例如 iframe 和其父页面之间）或跨窗口（例如弹出窗口和其父窗口之间）进行消息传递的机制。它允许一个文档向另一个文档发送异步消息，并且可以指定接收消息的目标来源（origin）。以下是 <code>postMessage</code> 的一些常见使用场景：</p><ol><li><strong>跨域通信</strong>：<ul><li>当你在一个页面内嵌入一个跨域的 iframe 时，你可以通过 <code>postMessage</code> 来与 iframe 进行通信。可以将数据从父页面发送到 iframe，也可以从 iframe 发送到父页面</li></ul></li><li><strong>父窗口和弹出窗口之间的通信</strong>：<ul><li>当一个页面打开一个新的弹出窗口时，你可以通过 <code>postMessage</code> 在父窗口和弹出窗口之间传递信息。这可以用于在父窗口中控制弹出窗口的内容，或者从弹出窗口中返回数据给父窗口</li></ul></li><li><strong>与 Web Workers 的通信</strong>：<ul><li>Web Workers 是一种在浏览器中执行并行任务的方式。<code>postMessage</code> 是与 Web Workers 通信的主要方式。你可以向 Web Worker 发送数据，并接收来自 Web Worker 的消息</li></ul></li><li><strong>与 Service Workers 的通信</strong>：<ul><li><code>postMessage</code> 也可以用于与 Service Workers 通信。这对于在离线模式下提供推送通知和缓存管理等功能非常有用</li></ul></li><li><strong>跨浏览器选项卡或窗口的通信</strong>：<ul><li>在某些情况下，你可能需要在同一个浏览器中打开的不同选项卡或窗口之间进行通信。通过共享同一个窗口对象并使用 <code>postMessage</code>，可以实现跨选项卡或窗口的消息传递</li></ul></li><li><strong>单页应用程序（SPA）与嵌入式第三方内容的通信</strong>：<ul><li>在单页应用程序中嵌入第三方内容（如广告或小部件）时，可以通过 <code>postMessage</code> 与这些内容进行通信，以确保数据的安全传递</li></ul></li></ol><p><strong>使用 <code>postMessage</code> 的注意事项：</strong></p><ul><li><strong>目标来源</strong>：<code>postMessage</code> 的第二个参数是目标来源（origin），即接收消息的目标文档的源。出于安全考虑，应该始终指定目标来源，以防止消息被发送到意外的接收方</li><li><strong>安全性</strong>：在接收 <code>postMessage</code> 消息时，注意验证消息的来源和内容，确保只处理来自可信源的消息，并且避免潜在的安全风险（例如跨站点脚本攻击）</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19-：async-await-怎么进行错误处理"><a href="#Q19-：async-await-怎么进行错误处理" class="headerlink" title="Q19 ：async/await 怎么进行错误处理"></a>Q19 ：async/await 怎么进行错误处理</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>async/await</code> 是一种基于 Promise 的异步编程模式，它使异步代码的写法更接近于同步代码。为了进行错误处理，你可以使用 <code>try...catch</code> 语句来捕获 <code>async/await</code> 中可能出现的错误</p><p>下面是一些常见的错误处理方式：</p><p><strong>1. <code>try...catch</code> 语句：</strong></p><p>使用 <code>try...catch</code> 块来捕获异步函数中的错误。当异步函数中的 Promise 拒绝（即发生错误）时，错误会被抛出，并在 <code>catch</code> 块中被捕获，你可以在 <code>catch</code> 块中进行相应的错误处理</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数</span></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，如果 <code>fetch</code> 请求失败或返回的状态码不是成功的状态（例如 404 或 500），会抛出错误，并在 <code>catch</code> 块中捕获。<code>catch</code> 块会输出错误信息</p><p><strong>2. <code>async</code> 函数的返回值：</strong></p><p>当你在一个异步函数中使用 <code>async/await</code> 时，函数的返回值将是一个 Promise。如果你想在异步函数调用时进行错误处理，可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理函数的返回值</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数并处理返回的 Promise</span></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>在这个示例中，异步函数 <code>fetchData</code> 返回的是一个 Promise，我们可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法处理该 Promise 的成功和失败情况</p><p><strong>总结：</strong></p><ul><li>使用 <code>try...catch</code> 块在异步函数内进行错误处理</li><li>在异步函数调用时，可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法处理异步函数返回的 Promise</li><li>在 <code>catch</code> 块中，你可以记录错误、显示错误消息或采取其他错误处理措施</li><li>合理的错误处理有助于确保你的应用程序在发生错误时不会意外崩溃，并且能够提供良好的用户体验</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：script标签内的async跟defer有什么区别跟作用？"><a href="#Q20：script标签内的async跟defer有什么区别跟作用？" class="headerlink" title="Q20：script标签内的async跟defer有什么区别跟作用？"></a>Q20：script标签内的async跟defer有什么区别跟作用？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" grey><summary> 解析 </summary>
              <div class='content'>
              <p>在 HTML 中会遇到以下三类 script：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script标签用于加载脚本与执行脚本，直接使用script脚本时，html会按照顺序来加载并执行脚本，在脚本加载&amp;执行的过程中，会阻塞后续的DOM渲染。</p><p>比如现在大家习惯于在页面中引用各种第三方脚本，但如果第三方服务商出现了一些小问题，比如延迟之类的，就会使得页面白屏。</p><p>针对上述情况，script标签提供了两种方式来解决问题，就是加入属性async以及defer，这两个属性使得script标签加载都不会阻塞DOM的渲染。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defer：此布尔属性被设置为向浏览器指示脚本在文档被解析后执行</span><br><span class="line">async：设置此布尔属性，以指示浏览器如果可能的话，应异步执行脚本</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>defer：设置这个属性的script标签，浏览器将会异步下载该文件并不影响后续dom渲染，多个defer标签则会按顺序执行，在文档渲染完之后的DOMContentLoaded事件调用前执行</p><p>async：脚本将会异步加载并且不按顺序执行，谁加载的快就会执行谁</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：setTimeout的延时写成0，一般在什么场景下使用？"><a href="#Q21：setTimeout的延时写成0，一般在什么场景下使用？" class="headerlink" title="Q21：setTimeout的延时写成0，一般在什么场景下使用？"></a>Q21：setTimeout的延时写成0，一般在什么场景下使用？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>将 <code>setTimeout</code> 的延时设置为 0 的情况通常用于创建一个宏任务，让回调函数尽可能快地放入任务队列中等待执行。这种技术被称为“0 毫秒定时器”或“宏任务调度”。</p><p>需要注意的是，使用 0 毫秒延时并不能真正实现“立即执行”，而是将任务推迟到下一个宏任务。此外，滥用这种技术可能会导致性能问题，因此应该根据具体场景慎重使用。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>主要场景包括：</p><ol><li><strong>UI 渲染优化</strong>：<ul><li>在处理大量计算或操作时，通过将一部分任务延迟到下一个宏任务执行，可以优化 UI 渲染和响应速度，避免长时间的同步操作导致页面卡顿。</li></ul></li><li><strong>事件回调</strong>：<ul><li>在事件回调中使用 0 毫秒延时，可以确保回调函数在当前事件循环的末尾执行，而不会阻塞后续事件的处理。这对于确保一些状态的及时更新是有帮助的。</li></ul></li><li><strong>Promise 的微任务</strong>：<ul><li>在处理 Promise 的 <code>.then()</code> 或 <code>async/await</code> 时，通过 <code>setTimeout</code> 设置为 0，可以将后续的任务放入微任务队列，确保在当前任务执行完毕后立即执行。</li></ul></li><li><strong>模拟 nextTick</strong>：<ul><li>在一些前端框架（如 Vue.js）中，<code>nextTick</code> 方法的实现通常使用了 <code>setTimeout</code> 设置为 0，用于在下一个宏任务中执行回调，以确保在 DOM 更新后执行。</li></ul></li><li><strong>事件循环</strong>：<ul><li>通过 <code>setTimeout</code> 设置为 0，可以在当前事件循环的最后插入一个宏任务，用于处理一些异步操作，确保不会影响当前任务的执行。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：webSocket如何兼容低浏览器"><a href="#Q22：webSocket如何兼容低浏览器" class="headerlink" title="Q22：webSocket如何兼容低浏览器"></a>Q22：webSocket如何兼容低浏览器</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>Adobe Flash Socket</strong>：Flash 曾经是一种用于在浏览器中实现实时通信的常用技术，可以通过 Flash 插件来模拟 WebSocket 的行为。但需要注意的是，由于 Flash 的安全性问题和日益废弃的趋势，这不是一个长期可行的解决方案。</li><li><strong>ActiveX HTMLFile (IE)</strong>：在早期版本的 Internet Explorer 浏览器中，可以使用 ActiveX 控件 HTMLFile 来实现长轮询技术，以模拟实时通信。这种方法只能在 IE 浏览器中使用，并且不适用于其他浏览器。</li><li><strong>基于 multipart 编码发送 XHR</strong>：这种方法是通过使用 XMLHttpRequest 对象来模拟 WebSocket 的通信过程。数据会以 multipart 编码的方式发送，服务器需要进行解析。这种方法比较复杂，而且在性能上可能不如 WebSocket。</li><li><strong>基于长轮询的 XHR</strong>：长轮询是一种通过不断发起 HTTP 请求来模拟实时通信的技术。客户端发送一个 HTTP 请求给服务器，服务器只有在有新消息时才会响应，否则保持连接处于挂起状态。一旦收到响应，客户端立即发送另一个请求。这种方法可以实现实时性，但是效率较低，并且可能会产生较高的服务器负载。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：ajax、axios、fetch有什么区别"><a href="#Q23：ajax、axios、fetch有什么区别" class="headerlink" title="Q23：ajax、axios、fetch有什么区别"></a>Q23：ajax、axios、fetch有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">特性/库</th><th style="text-align:left">AJAX</th><th style="text-align:left">Axios</th><th style="text-align:left">Fetch</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基于</strong></td><td style="text-align:left">XMLHttpRequest 对象</td><td style="text-align:left">XMLHttpRequest \Promise</td><td style="text-align:left">原生js的Fetch API</td></tr><tr><td style="text-align:left"><strong>返回数据类型</strong></td><td style="text-align:left">默认为纯文本</td><td style="text-align:left">默认为JSON</td><td style="text-align:left">默认为Response对象（需要转换为JSON）</td></tr><tr><td style="text-align:left"><strong>优点</strong></td><td style="text-align:left">- 在老版本的浏览器上有广泛支持<br /> - 灵活，可以支持各种请求和内容类型</td><td style="text-align:left">- 支持Promise - 请求拦截器、响应拦截器<br /> - 自动转换JSON数据<br /> - 客户端支持防御XSRF</td><td style="text-align:left">- 基于Promise，语法简洁<br /> - 可以很容易地通过一个API处理所有的HTTP请求<br /> - 响应可以被多次读取</td></tr><tr><td style="text-align:left"><strong>缺点</strong></td><td style="text-align:left">- 不支持Promise，回调地狱<br /> - 代码可能会比较复杂</td><td style="text-align:left">- 不是浏览器内建，需要额外安装<br /> - 不能取消请求 - 浏览器兼容性问题</td><td style="text-align:left">- 默认不发送cookies<br /> - 可能需要多步骤来处理响应<br /> - 浏览器支持不如XHR</td></tr><tr><td style="text-align:left"><strong>相同点</strong></td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td></tr><tr><td style="text-align:left"><strong>不同点</strong></td><td style="text-align:left">- 基于底层接口XMLHttpRequest</td><td style="text-align:left">- 封装了XMLHttpRequest，提供了更现代的API<br /> - 提供拦截器，请求取消，全局的axios实例</td><td style="text-align:left">- 基于Promise的新技术<br /> - 更为简洁的API<br /> - 与Service Worker的集成</td></tr><tr><td style="text-align:left"><strong>开发封装</strong></td><td style="text-align:left">- 通常直接使用，或者基于jQuery等库进一步封装</td><td style="text-align:left">- 独立库，提供现代的API和特性</td><td style="text-align:left">- 内建在现代浏览器中，不需外部库</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：for…in和for…of有什么区别"><a href="#Q24：for…in和for…of有什么区别" class="headerlink" title="Q24：for…in和for…of有什么区别"></a>Q24：for…in和for…of有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>for...in</code>循环和<code>for...of</code>循环在JavaScript中用于遍历数据，但它们之间有一些重要的区别。下面是对这两种循环方式的主要区别的概述：</p><p><strong>for…in循环</strong></p><ul><li><strong>用途</strong>：<code>for...in</code>循环主要用于遍历对象的属性。</li><li><strong>行为</strong>：遍历对象的所有可枚举属性，包括继承的可枚举属性。</li><li><strong>迭代值</strong>：在每次迭代中，迭代变量存储的是对象属性的键（即属性名）。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出 &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for…of循环</strong></p><ul><li><strong>用途</strong>：<code>for...of</code>循环主要用于遍历可迭代对象的元素，如数组、字符串、Map、Set等。</li><li><strong>行为</strong>：直接遍历可迭代对象的值。</li><li><strong>迭代值</strong>：在每次迭代中，迭代变量存储的是元素的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要区别</strong></p><ol><li><strong>遍历对象不同</strong>：<code>for...in</code>遍历对象的属性（键），适用于对象；而<code>for...of</code>主要遍历可迭代对象的元素值，适用于数组、字符串等。</li><li><strong>应用场景</strong>：<code>for...in</code>更适合于遍历对象的属性；<code>for...of</code>提供了一种简洁的方式来遍历数组、Map、Set、字符串等可迭代对象的元素。</li><li><strong>继承属性的遍历</strong>：<code>for...in</code>也可以遍历对象原型链上的可枚举属性，而<code>for...of</code>不会遍历原型链，它只遍历当前对象的值。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：Map跟WeakMap什么区别"><a href="#Q25：Map跟WeakMap什么区别" class="headerlink" title="Q25：Map跟WeakMap什么区别"></a>Q25：Map跟WeakMap什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Map</code> 和 <code>WeakMap</code> 都是JavaScript中的集合类型，用于存储键值对，但它们在某些关键特性上有所不同。</p><ol><li><p><code>map</code></p><p><code>Map</code> 是ECMAScript 2015规范中引入的一种新的数据结构，它类似于对象，也是键值映射，但键的范围不限于字符串，可以是任何类型的值</p><ul><li><strong>键的多样性</strong>: <code>Map</code> 的键可以是任意类型的值，包括函数、对象或任何基本类型</li><li><strong>有序性</strong>: <code>Map</code> 对象维护键插入的顺序</li><li><strong>大小可测</strong>: 通过 <code>Map.prototype.size</code> 属性可以直接获取一个 <code>Map</code> 的元素数量</li><li><strong>性能</strong>: 在频繁增删键值对的场景下，<code>Map</code> 有着比普通对象更好的性能</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>WeakMap</code></p><p><code>WeakMap</code> 是ECMAScript 2015规范中一起引入的一种集合类型。它与 <code>Map</code> 的主要差别在于它的键必须是对象，不能是原始值，而且<code>WeakMap</code> 中的键是弱引用的</p><ul><li><strong>键必须是对象</strong>: <code>WeakMap</code> 的键只能是对象引用</li><li><strong>弱引用</strong>: <code>WeakMap</code> 中的键所指向的对象是弱引用，这意味着如果没有其他引用和该对象相连，这些对象将会被垃圾回收机制回收。因此，<code>WeakMap</code> 适合做关联额外数据到对象上，而无需担心内存泄漏问题</li><li><strong>不可枚举</strong>: <code>WeakMap</code> 的内容不可枚举。这是出于垃圾回收机制的考虑。因为不能确切知道当前哪些键已经被回收，所以不可提供遍历其键或值的方法</li><li><strong>无法清空</strong>: <code>WeakMap</code> 没有 <code>clear</code> 方法，也无法获取大小，也就是说，没有办法直接清除 <code>WeakMap</code> 的所有键值对</li><li><strong>用途限定</strong>: 由于以上特性，<code>WeakMap</code> 多用于私有数据的存储，以及与对象生命周期绑定的信息存储</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> objKey = &#123;&#125;;</span><br><span class="line">weakMap.<span class="title function_">set</span>(objKey, <span class="string">&#x27;value1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>objKey</code> 外部没有其他引用，它最终会被垃圾回收掉，相应地，<code>weakMap</code> 对 <code>objKey</code> 的引用不会阻止回收</p></li></ol><p><strong>总结</strong></p><p><code>Map</code> 更适合做数据集合，而 <code>WeakMap</code> 用于细粒度的对象级别的数据存储，它不阻止垃圾回收器清理键所引用的对象</p><p>了解这两者的差别，有助于选择适合不同场景的数据结构</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：如何确保你的构造函数只能被new调用，而不能被普通调用"><a href="#Q26：如何确保你的构造函数只能被new调用，而不能被普通调用" class="headerlink" title="Q26：如何确保你的构造函数只能被new调用，而不能被普通调用"></a>Q26：如何确保你的构造函数只能被new调用，而不能被普通调用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>instanceof</code> 运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyConstructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">MyConstructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyConstructor must be called with new&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里写你的构造函数代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用方式，使用 new</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="title class_">MyConstructor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的调用方式，没有使用 new，将会抛出错误</span></span><br><span class="line"><span class="title class_">MyConstructor</span>();</span><br></pre></td></tr></table></figure><p>这段代码中使用的 <code>instanceof</code> 运算符检查 <code>this</code> 是否是 <code>MyConstructor</code> 的一个实例</p><p>如果不是，那就意味着构造函数是被作为普通函数调用的，就会抛出一个错误</p><p>所以当你尝试不使用 <code>new</code> 关键字调用 <code>MyConstructor</code> 时，就会触发这个错误</p></li><li><p><code>class</code> 关键字</p><p>随着ES6的引入，现在更普遍和推荐的做法是使用 <code>class</code> 关键字来定义构造函数</p><p>当试图执行不使用 <code>new</code> 的类构造方法时，JavaScript 会自动抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里添加构造函数代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">const</span> wrongInstance = <span class="title class_">MyClass</span>(); <span class="comment">// 这将会抛出TypeError: Class constructor MyClass cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>在ES6类构造函数中，如果试图以普通函数的方式调用 <code>MyClass()</code>，JavaScript 会抛出 <code>TypeError</code>，因此在这种情况下不需要额外的检查</p></li><li><p><code>new.target</code> 属性</p><p>《ECMAScript 6 入门》中讲到: <code>ES6</code> 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数</p><p>如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，<code>new.target</code> 会返回 <code>undefined</code> ，<strong>因此这个属性可以用来确定构造函数是怎么调用的</strong></p><p><code>new.target</code> 在通过 <code>new</code> 调用函数时是定义过的，而通过普通函数方式调用时是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyFunction must be called with new&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里写你的构造函数代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用方式，使用 new</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的调用方式，没有使用 new，将会抛出错误</span></span><br><span class="line"><span class="title class_">MyFunction</span>();</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：怎么中断forEach循环"><a href="#Q27：怎么中断forEach循环" class="headerlink" title="Q27：怎么中断forEach循环"></a>Q27：怎么中断forEach循环</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，<code>Array.prototype.forEach</code> 方法是无法在循环过程中被中断的</p><p>这是因为按照其设计，<code>Array.prototype.forEach</code> 是用来对数组的每一项都执行一遍给定的函数，无法直接中断或者跳出</p><p><br /></p><p>在出现错误的情况下，可以使用<code>try-catch</code>语句来停止 JavaScript <code>Array.prototype.forEach</code>中的循环，但这并非其设计初衷，如果需要在循环中实现某种条件的停止，不推荐使用这种方法</p><p>这是因为<code>try-catch</code>通常用于处理异常或错误，如果滥用<code>try-catch</code>来中断正常流程，可能会对代码的可读性和性能产生负面影响</p><p>例如，虽然我们能够通过抛出一个错误（<code>throw</code>）来退出<code>forEach</code>循环，然后在外层使用<code>try-catch</code>来捕捉这个错误，实现中止<code>forEach</code>循环的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// If element meets condition, throw error</span></span><br><span class="line">        <span class="keyword">if</span> (el === <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Stop loop&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">message</span> === <span class="string">&#x27;Stop loop&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Loop stopped.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Real error, handle it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，假设我们在遇到元素 <code>3</code> 时中止循环，当元素 <code>3</code> 出现时，我们抛出一个错误并立即停止 <code>forEach</code>。错误然后被 <code>catch</code> 块捕捉，并打印出 <code>&#39;Loop stopped.&#39;</code></p><p>但正如刚才我提到的，这并非<code>try-catch</code>的原始用途，如果只是想中止一个循环，应该选择更合适的循环结构，比如<code>for</code>，<code>while</code>或者<code>some</code>/<code>every</code>等方法</p><p><br /></p><p>替换方式</p><p><strong>1. 使用 <code>for</code> 循环或 <code>while</code> 循环：</strong><br><code>for</code> 和 <code>while</code> 两种循环在满足某种条件时，都可以使用 <code>break</code> 关键字来提前退出循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] === target) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>Array.prototype.some</code> 或 <code>Array.prototype.every</code></strong><br>这两个方法是用于判断数组中所有元素是否都满足（<code>every</code>）或者有至少一个元素满足（<code>some</code>）某个条件，如果一旦找到满足条件（或者不满足条件）的元素，就会立即停止迭代并返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：try…catch-可以捕获到异步代码中的错误吗"><a href="#Q28：try…catch-可以捕获到异步代码中的错误吗" class="headerlink" title="Q28：try…catch 可以捕获到异步代码中的错误吗"></a>Q28：try…catch 可以捕获到异步代码中的错误吗</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>try...catch</code> 结构在 JavaScript 中用于捕获和处理同步代码中的错误</p><p>对于异步代码，其行为会有所不同，这取决于异步代码的具体实现方式</p><ul><li><p>对于使用 <code>Promise</code> 或 <code>async/await</code> 的异步代码，<code>try...catch</code> 可以有效地捕获异步操作中的错误</p><p>这是因为 <code>async/await</code> 语法是基于 <code>Promise</code> 的，它允许你用看似同步的方式写异步代码</p><p>在这种情况下，<code>await</code> 关键字会等待 <code>Promise</code> 完成，并且如果 <code>Promise</code> 被拒绝，<code>await</code> 会抛出一个错误，这个错误可以被同一个<code>try...catch</code> 块捕获</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://example.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到错误：&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于传统的异步回调（如使用 <code>setTimeout</code>、<code>setInterval</code> 或者传统的异步回调模式），<code>try...catch</code> 无法直接捕获到异步操作中的错误</p><p>这是因为当 <code>try...catch</code> 代码块执行时，异步代码可能尚未执行，错误也就不会在 <code>try...catch</code> 中被捕获</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;错误！&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 无法捕获到错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到错误：&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setTimeout</code> 中的错误不会被 <code>try...catch</code> 捕获，因为 <code>setTimeout</code> 是异步执行的，当错误发生时，<code>try...catch</code> 块已经执行完毕了</p><p>总结来说，<code>try...catch</code> 可以捕获到使用 <code>Promise</code>、<code>async/await</code> 等现代异步编程模式中的错误，但对于传统的异步回调模式，<code>try...catch</code> 无法直接捕获异步操作中的错误</p><p>对于这些情况，应该利用诸如 <code>Promise</code> 的 <code>.catch()</code> 方法或者 <code>async/await</code> 结合 <code>try...catch</code> 来处理错误</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：Generator是怎么做到中断和恢复的"><a href="#Q29：Generator是怎么做到中断和恢复的" class="headerlink" title="Q29：Generator是怎么做到中断和恢复的"></a>Q29：Generator是怎么做到中断和恢复的</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Generator 是 JavaScript ES6 引入的一种新的函数语法，它可以通过 <code>yield</code> 关键字来暂停函数的执行，然后通过外部控制恢复执行</p><p>一个 Generator 函数在初次调用时并不会执行，而是返回一个遵循迭代器协议的 Generator 对象</p><p>这个对象实际上是一个迭代器，它包含一个 <code>next()</code> 方法</p><p>每次调用迭代器的 <code>next()</code> 方法时，Generator 函数会执行到下一个 <code>yield</code> 表达式，并暂停，即“中断”的操作</p><p>此时，生成器代码的状态（包括变量的值和指令指针）都会被保留</p><p>在此状态下，代码外部可以处理当前 <code>yield</code> 出的值，然后再决定是否继续执行</p><p>以下是一个基本的 Generator 函数的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numberGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">numberGenerator</span>(); <span class="comment">// 获取到 Generator 对象，但函数尚未开始执行。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 1，并暂停执行。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 从上一次暂停的地方恢复执行，输出 2。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 3。</span></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ol><li>当 <code>numberGenerator()</code> 被调用时，它返回一个迭代器对象但不执行函数体内的代码</li><li>调用迭代器的 <code>next()</code> 方法时，Generator 函数开始执行，直到遇到第一个 <code>yield</code></li><li><code>yield</code> 暂停函数的执行并将值返回给迭代器的 <code>next()</code> 方法调用</li><li>当再次调用 <code>next()</code> 时，Generator 函数会从上一次暂停的地方 <code>yield</code> 继续执行，直到遇到下一个 <code>yield</code> 或 <code>return</code>，或者到达函数体的末尾</li><li>可以重复此过程，直到 Generator 函数内没有更多的 <code>yield</code>，或者直到到达 <code>return</code> 语句，这会导致 Generator 完全终止</li></ol><p>Generator 函数在可能涉及异步操作和需要暂停和恢复的场景中特别有用，因为它允许你编写看起来像同步代码的异步行为，并且在每个阶段都可以控制函数的执行</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：async-await、generator、promise-这三者的关联和区别是什么"><a href="#Q30：async-await、generator、promise-这三者的关联和区别是什么" class="headerlink" title="Q30：async/await、generator、promise 这三者的关联和区别是什么"></a>Q30：async/await、generator、promise 这三者的关联和区别是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Promise</strong></p><p>Promise 是一个代表了异步操作最终完成或者失败的对象</p><p>它是一个包装了异步操作结果的对象</p><p>每个 Promise 有三种状态：pending（等待中）、fulfilled（已完成）或rejected（已失败）</p><p>Promise的主要优点是可以链式调用（<code>.then()</code> 后可以继续 <code>.then()</code>），并且有统一的错误处理机制（<code>.catch()</code>）</p><p>但是，代码可能会因为 <code>.then()</code>的嵌套而变得难以阅读和维护</p></li><li><p><strong>Generator</strong></p><p>Generator 是 ES6 引入的一个特性，允许一个函数在执行过程中暂停，并在稍后重新开始，类似于线程的挂起和恢复</p><p>Generator 函数返回了一个遍历器对象，可以通过 <code>.next()</code> 方法来得到一个 <code>{ value, done }</code> 结构的对象，其中 <code>value</code> 是返回的结果，<code>done</code> 是一个布尔值表示函数是否执行完毕</p><p>Generator 通常和 yield 关键字一起使用，yield 可以将函数的执行“暂停”，再次调用 <code>.next()</code> 时从上次“暂停”的地方开始</p><p>Generator本身并没有异步处理能力，但可以配合 Promise 使用来处理异步操作</p></li><li><p><strong>Async/Await</strong></p><p>Async/Await 是 ES2017 引入，可以看作是 Generator 的语法糖，用于简化 Promise 的使用，并使异步的代码看起来就像同步的代码一样</p><p>一个 async 函数内部可以使用 await 关键字等待一个 Promise resolve，然后获取它的结果</p><p>这就好像是将异步代码暂停在那里，等待 Promise 完成</p><p>实际上，async/await 内部就是通过类似 Generator 的方式，使得函数在等待 Promise 时“暂停”，在 Promise 完成时“恢复”</p></li></ol><p><strong>简单的关系是</strong></p><p>Promise 提供了对异步操作的封装，解决了回调地狱的问题</p><p>Generator 提供了更进一步的流控制，使得代码可以在某个点“暂停”并在稍后“恢复”</p><p>而 Async/Await 是基于 Promise 和 Generator 的同步化处理异步操作的语法糖</p><p>同时，需要注意的是，虽然 async/await 让异步代码看起来就像同步代码一样，但实际上它们的行为仍然是异步的，只是语法变得更容易理解和阅读</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：如何让Promise-all在抛出异常后依然有效"><a href="#Q31：如何让Promise-all在抛出异常后依然有效" class="headerlink" title="Q31：如何让Promise.all在抛出异常后依然有效"></a>Q31：如何让Promise.all在抛出异常后依然有效</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在默认情况下，<code>Promise.all</code> 方法如果在等待所有<code>promise</code>解决（<code>resolve</code>）的过程中，有任何一个<code>promise</code>被拒绝（<code>reject</code>），那么它会立即结束，并返回一个拒绝（<code>reject</code>）状态的<code>promise</code></p><p>如果你希望即便有一个或多个<code>promise</code>被拒绝，<code>Promise.all</code> 依然能够继续执行并返回所有<code>promise</code>的结果，你需要自己处理每个<code>promise</code>，确保它们不会抛出异常</p><p>这可以通过在每个<code>promise</code>后面附加一个 <code>.catch()</code> 方法来实现，这样可以捕获并处理错误，你也可以仅仅返回错误信息而不是抛出，这样外层的 <code>Promise.all</code> 就不会因为<code>reject</code>而立即停止了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promises = [<span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint1&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint2&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint3&#x27;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(results))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Some promise failed: &#x27;</span>, e));</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>promises.map</code> 方法遍历了所有的promise，并为每个promise附加了一个 <code>.catch</code> 方法</p><p>如果任何一个promise失败了，<code>.catch</code> 方法会处理异常，并且将错误信息作为结果返回</p><p>这会保证 <code>Promise.all</code> 方法得到的总是一个包含每个原promise结果的数组，无论它是成功的值还是错误</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>使用 <code>Promise.allSettled</code> 替代 <code>Promise.all()</code></p><blockquote><p><code>Promise.allSettled()</code>方法返回一个promise，该promise在所有给定的promise已被解析或被拒绝后解析，并且每个对象都描述每个promise的结果</p></blockquote>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么"><a href="#Q32：object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么" class="headerlink" title="Q32：object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么"></a>Q32：object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong>浅拷贝与深拷贝</strong></p><ul><li><p><strong>浅拷贝</strong></p><p>仅复制对象的第一层属性</p><p>如果一个对象的某个属性值是引用类型（如对象或数组），浅拷贝会复制这个引用，而不是复制引用所指向的真实对象</p><p>因此，原始对象与拷贝后的对象会共享这个引用类型的属性</p></li><li><p><strong>深拷贝</strong></p><p>复制对象的所有层级，创建完全独立的副本</p><p>如果原始对象中包含引用类型的属性，深拷贝会递归地复制这些属性所指向的对象，确保拷贝后的对象与原始对象之间完全独立，修改一个不会影响另一个</p></li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.assign()</code>方法和扩展运算符（<code>...</code>）都是用于对象克隆或者合并对象的操作，但重要的是，它们都执行的是<strong>浅拷贝</strong>，而不是深拷贝</p><blockquote><p>[!IMPORTANT]</p><p>当对象属性仅为第一层且全部为基本数据类型时，使用<code>Object.assign()</code>或扩展运算符（<code>...</code>）进行的实际上可以被视为深拷贝，因为这些基本类型的属性会被直接复制，而不是共享引用</p><p>因此，在这种特定情况下，修改拷贝对象的属性不会影响到原始对象，这表现得就像深拷贝一样</p></blockquote><p><strong><code>Object.assign()</code>与扩展运算符的共同点</strong></p><ol><li><p><strong>操作类型</strong></p><p>它们都可以用来克隆对象或合并对象</p></li><li><p><strong>拷贝方式</strong></p><p>它们都是浅拷贝。在拷贝过程中，对象的第一层属性会被复制到新对象中</p><p>如果属性值是引用类型，那么复制的将是这个引用，而不是引用所指向的值</p></li></ol><p><strong>不同点</strong></p><p>尽管在拷贝行为上类似，<code>Object.assign()</code>和扩展运算符在语法上还是有所差异，主要体现在用途和功能上</p><ol><li><p><strong>语法与应用场景</strong></p><ul><li><p><code>Object.assign(target, ...sources)</code>方法的第一个参数是目标对象，后续参数是一个或多个源对象</p><p>它会将所有源对象的可枚举和自有属性复制到目标对象</p></li><li><p>扩展运算符（<code>...</code>）用于将一个对象的所有可枚举属性，复制到了一个新的对象中</p><p>与<code>Object.assign()</code>不同，扩展运算符常用在变量解构（destructuring assignment）和数组合并等操作中</p></li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>Object.assign()</code>方法会直接修改目标对象，并返回这个修改后的目标对象</li><li>使用扩展运算符创建的是一个新对象，源对象保持不变</li></ul></li><li><p><strong>表达式简洁性</strong>：</p><ul><li>扩展运算符在写法上更为简洁，尤其是在需要克隆对象或与其他操作（如解构赋值）结合时</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：对window-requestAnimationFrame-的理解"><a href="#Q33：对window-requestAnimationFrame-的理解" class="headerlink" title="Q33：对window.requestAnimationFrame 的理解"></a>Q33：对window.requestAnimationFrame 的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>window.requestAnimationFrame()</code> 是一种高效率的，专门为浏览器绘制动画设计的方法</p><p>相比之下，传统的 <code>setTimeout</code> 和 <code>setInterval</code> 方法不够精确和平滑，而且通常会耗费更多的CPU资源</p><p>以下是<code>window.requestAnimationFrame()</code>的一些要点：</p><ol><li><p>精准的帧控制</p><p><code>requestAnimationFrame()</code>方法可以让浏览器在每次重绘之前调用指定的函数，这意味着你的动画将尽可能平滑</p><p>而且这个函数的调用频率会自动调整为适合浏览器以及设备的最佳显示效果，一般而言，这个频率是每秒60次，也就是60帧</p></li><li><p>CPU和电池友好</p><p>requestAnimationFrame()<code>在未激活的标签页，隐藏的iframe中会被暂停，这对于未处于聚焦状态的标签页十分有用</code> </p><p><code>在这种情况下，动画将不会浪费CPU进行渲染</code></p><p><code>因此，</code>requestAnimationFrame()` 在使用起来更加省电，同时也不会因动画导致风扇过度运转</p></li><li><p>使用方式</p><p>调用 <code>requestAnimationFrame()</code> 需要传入一个函数作为参数，这个函数会在下次重绘之前调用</p><p>更常见的是在调用的函数内部继续递归调用 <code>requestAnimationFrame()</code>，以此创建一个动画循环</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是你的动画代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据动画的情况来决定是否需要继续下一帧的动画</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始动画</span></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>animate()</code> 函数会在浏览器每次重绘时被调用，从而实现了一个连续的动画效果</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：Object-defineProperty与-Proxy-的区别"><a href="#Q34：Object-defineProperty与-Proxy-的区别" class="headerlink" title="Q34：Object.defineProperty与 Proxy 的区别"></a>Q34：Object.defineProperty与 Proxy 的区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.defineProperty</code> 和 <code>Proxy</code> 都可以用来监视和干预对象的操作，但二者有一些重要区别</p><ol><li><p><strong>Object.defineProperty</strong></p><p><code>Object.defineProperty</code> 方法用于在对象上定义新属性，或者修改对象上的现有属性，然后返回对象</p><p>通过它可以精确地添加或修改对象的属性</p><p>你可以控制这些属性的值，是否可枚举，是否可配置，是否可写，甚至可以定义 get 和 set 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;property&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>)&#123;...&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然而，<code>Object.defineProperty</code> 有一些限制：</p><ul><li>它只能监视单个对象上的单个属性，这就意味着如果你想监视多个属性或者整个对象，你需要手动为每个属性调用 <code>Object.defineProperty</code></li><li>它无法监视数组的变化</li><li>它无法监视对象属性的创建和删除</li></ul></li><li><p><strong>Proxy</strong></p><p><code>Proxy</code> 可以在 JavaScript 的许多对象操作中进行拦截，这使得它更加强大和灵活</p><p>它可以用来创建对象的代理，这些代理可以自定义原对象的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property, receiver</span>) &#123;...&#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>) &#123;...&#125;</span><br><span class="line">  <span class="comment">// 更多的 handler</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 相对 <code>Object.defineProperty</code> 的优点是：</p><ul><li><p><code>Proxy</code> 可以拦截并自定义更多的对象操作，不仅仅是属性访问</p><p>例如，<code>Proxy</code> 可以监视属性查询、赋值、删除，函数调用，对象构造等等</p></li><li><p><code>Proxy</code> 可以监视整个对象，而无需为每个属性单独设置</p></li><li><p><code>Proxy</code> 可以监视数组操作</p></li></ul><p>然而，<code>Proxy</code> 的兼容性不如 <code>Object.defineProperty</code>，在不支持 <code>Proxy</code> 的环境中无法使用</p></li></ol><p>最后，选择使用哪一个取决于你的具体需求和目标环境</p><p>如果需要更精细的控制或者操作更复杂的功能，<code>Proxy</code> 是一个更好的选择</p><p>但如果你只需要基本的属性监视，并且需要更好的兼容性，那么 <code>Object.defineProperty</code> 就足够了</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：ES6中的-Reflect-对象有什么用"><a href="#Q35：ES6中的-Reflect-对象有什么用" class="headerlink" title="Q35：ES6中的 Reflect 对象有什么用"></a>Q35：ES6中的 Reflect 对象有什么用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>ES6（ECMAScript 2015）引入了<code>Reflect</code>对象，它为某些通常由操作符完成的操作提供新的函数式API</p><p><code>Reflect</code>对象提供了一系列静态方法，这些方法与<code>Proxy</code>对象的处理程序方法对应</p><p>这些方法的用途主要分为几个方面：</p><ol><li><p><strong>操作对象</strong></p><p><code>Reflect</code>提供了用于执行JavaScript对象基本操作的方法，例如属性的获取、设置、删除，属性描述符的获取，以及对象的扩展等</p><p>这些方法基本上与<code>Object</code>的相应方法功能相同，但用法略有不同</p><p>例如，<code>Reflect.get</code>、<code>Reflect.set</code>、<code>Reflect.deleteProperty</code>、<code>Reflect.getOwnPropertyDescriptor</code>等</p></li><li><p><strong>改善与代理（Proxy）对象的交互</strong></p><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的捕获器（trap）功能相对应</p><p>代理对象可以拦截并重定义基本语言操作（如读取属性、赋值、函数调用等）</p><p><code>Reflect</code>的方法可以在捕获器内部被调用，以实现默认行为</p><p>例如，当你在<code>Proxy</code>的<code>get</code>捕获器中需要获取一个属性的值时，可以使用<code>Reflect.get</code>来做到这一点</p></li><li><p><strong>提供更可靠的函数式API</strong></p><p>与直接使用操作符或全局函数不同，<code>Reflect</code>的方法总是期望对象作为它的第一个参数，这意味着它们能够在非对象值上抛出可预见的错误，而不是静默失败或者抛出非常不清晰的错误</p><p>这对于编写更加清晰、容错的代码非常有帮助</p></li><li><p><strong>动态地调用函数</strong></p><p><code>Reflect.construct</code>方法允许你动态地调用一个构造函数，类似于<code>new</code>操作符的作用，但提供了更多的灵活性</p><p><code>Reflect.apply</code>方法则允许动态地调用函数，这类似于<code>Function.prototype.apply</code>的作用，但用法更为简洁</p></li></ol><p>通过以上介绍，可以看出<code>Reflect</code>对象的引入主要是为了提供一种更规范、功能更强大且易于理解的方式来处理JavaScript中的基本操作，以及改善与<code>Proxy</code>对象的协同工作，使得元编程（metaprogramming）在JavaScript中变得更加容易和可控</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：详细的介绍一下ES6里面的迭代器"><a href="#Q36：详细的介绍一下ES6里面的迭代器" class="headerlink" title="Q36：详细的介绍一下ES6里面的迭代器"></a>Q36：详细的介绍一下ES6里面的迭代器</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 ES6 (ECMAScript 2015) 中，迭代器（Iterator）是一个新引入的概念，它为创建和工作 with 集合（如数组、对象、集合 或其他可迭代的数据类型）提供了一种更一致、更简洁的方式</p><p>迭代器是一个对象，它提供了一个<code>next()</code> 方法，可以返回序列中的下一个元素</p><p>这个<code>next()</code> 方法返回一个包含两个属性的对象：<code>value</code> 和 <code>done</code>。<code>value</code> 属性表示当前的值，而 <code>done</code> 属性是一个布尔值，当没有更多的数据可供迭代时，其值为 <code>true</code></p><p>这是一个简单的迭代器例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterator = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>],</span><br><span class="line">  <span class="attr">currentIndex</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>++,], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;apple&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;orange&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;banana&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">done</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 ES6 中，引入了一个叫做 <code>Iterable</code> 的协议</p><p>如果一个对象实现了 <code>Iterable</code> 接口（即该对象（或其原型链中的某个对象）包含一个名为 <code>Symbol.iterator</code> 的方法），那么它就可以被 <code>for...of</code> 循环遍历</p><p>Symbol.iterator` 方法应该返回一个迭代器对象</p><p>例如，数组就是一个内置的可迭代对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arrIterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;apple&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;orange&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;banana&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">done</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>此外，以新的 <code>Map</code> 和 <code>Set</code> 对象，以及新的字符串方法、<code>Array.from()</code> 和展开运算符等，这些新功能的引入，都依赖于 <code>Iterable</code> 和 <code>Iterator</code> 概念</p><p>通过迭代器，JavaScript开发者可以创建自定义的迭代逻辑，或者工作 with 一些可能不支持直接迭代的数据结构</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：forEach能不能用await"><a href="#Q37：forEach能不能用await" class="headerlink" title="Q37：forEach能不能用await"></a>Q37：forEach能不能用await</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>forEach</code>方法本身不能直接与<code>await</code>一起使用来实现数组中每个异步操作的顺序执行</p><p>这是因为<code>forEach</code>仅为数组中的每个元素执行提供的函数，但不会等待异步操作完成</p><p>如果在<code>forEach</code>的回调函数中使用<code>await</code>，它将不会按期望的方式工作，因为<code>forEach</code>不会等待异步操作完成，而是会立即继续执行下一个循环迭代</p><p>如果你需要按顺序等待每个异步操作完成，你可以使用<code>for...of</code>循环代替<code>forEach</code></p><p>在<code>for...of</code>循环中，你可以直接使用<code>await</code>等待每个异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFunction</span> = <span class="keyword">async</span> (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟异步操作</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sequentialAsync</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">asyncFunction</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sequentialAsync</span>();</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>asyncFunction</code>将会为数组中的每个元素依次被调用，并且每次调用都会等待前一个异步操作完成后才继续</p><p>这与直接在<code>forEach</code>中使用<code>await</code>达不到的效果是不同的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：为什么部分请求中，参数需要使用encodeURlComponent-进行转码"><a href="#Q38：为什么部分请求中，参数需要使用encodeURlComponent-进行转码" class="headerlink" title="Q38：为什么部分请求中，参数需要使用encodeURlComponent 进行转码"></a>Q38：为什么部分请求中，参数需要使用encodeURlComponent 进行转码</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在发送HTTP请求时，URL通常具有一定的格式和限制，这是由URI（统一资源标识符）标准规定的</p><p>如果请求的URL包含某些特殊字符，可能会影响URL的解析，导致请求无法正确处理，或者服务器解释请求参数的方式不正确</p><p>为了确保URL的特殊字符被正确地传输和接收，这些字符需要进行编码</p><p><code>encodeURIComponent</code> 函数用于对统一资源标识符（URI）的组成部分进行编码，以下是一些关键点解释为什么在某些情况下需要使用这个函数：</p><ol><li><p><strong>特殊字符</strong></p><p>URL中只允许一小部分字符的直接使用，如字母、数字和一些符号（<code>- _ . ~</code>）。其他字符，如空格 (), 冒号 (<code>:</code>), 斜杠 (<code>/</code>), 问号 (<code>?</code>), 和号 (<code>&amp;</code>), 等在URI中有特殊含义，所以它们必须被编码。</p></li><li><p><strong>保留字符</strong></p><p>即使某些字符在URI中是允许的，它们也可能有特殊的含义，比如<code>?</code>和<code>#</code>分别用于指示查询字符串开始和锚点的开始</p><p>如果你的参数值中包含了这样的字符，并且它们的意图并不是作为URL的这些特定部分，那么必须对它们进行编码</p></li><li><p><strong>不可见字符</strong></p><p>如空格在URL中不可见，或者在URL环境中无法直观理解，因此将它们转换为%20这样的编码很重要</p></li><li><p><strong>国际化内容</strong></p><p>对于非ASCII字符（如中文、阿拉伯文、俄文等），以及一些符号，如货币符号，也需要进行编码以确保它们能够正确传输</p></li><li><p><strong>服务器解析</strong></p><p>如果没有正确编码，服务器可能会错误地解析URL，或者甚至完全不接受这样的请求，因为它可能被视为不安全或无效的</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：Object-create跟new什么区别"><a href="#Q39：Object-create跟new什么区别" class="headerlink" title="Q39：Object.create跟new什么区别"></a>Q39：Object.create跟new什么区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.create()</code> 和 <code>new</code> 关键字在JavaScript中都用于创建新的对象，但是它们在如何创建对象以及这些对象的性质方面有本质的区别：</p><ol><li><p><strong>原型链</strong>:</p><ul><li><p><code>Object.create(obj)</code></p><p>会创建一个新的对象，其原型指向你传递给它的对象<code>obj</code></p><p>这意味着新创建的对象将继承<code>obj</code>中的所有属性和方法</p></li><li><p><code>new Constructor()</code></p><p>会创建一个新的对象，并将这个对象的原型指向构造函数的<code>prototype</code>对象</p><p>该对象接着通过构造函数初始化，这通常意味着它会具有构造函数中定义的属性和方法，不过原型链上的属性和方法也会被继承</p></li></ul></li><li><p><strong>属性初始化</strong>:</p><ul><li><p><code>Object.create(obj)</code></p><p>不会自动调用构造器</p><p>如果有第二个参数，你可以为新对象定义额外的属性</p></li><li><p><code>new Constructor()</code></p><p>会执行构造函数，构造函数中的代码通常会初始化对象的属性</p></li></ul></li><li><p><strong>用法区别</strong>:</p><ul><li><code>Object.create(null)</code>可以创建一个干净的对象，它没有原型链，连基本的Object方法如<code>.toString()</code>等都不会继承</li><li><code>new Object()</code> 或者 <code>new Constructor()</code> 创建的对象，其原型至少会继承自<code>Object.prototype</code>，除非在构造函数中显式更改原型</li></ul></li></ol><p>举个例子来说明两者的使用差异：</p><p>假设我们有以下的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>new</code>关键字创建的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">greet</span>(); <span class="comment">// 输出: &quot;Hello, my name is Alice.&quot;</span></span><br></pre></td></tr></table></figure><p>这里，<code>person1</code>会继承<code>Person</code>的构造函数中的属性和<code>Person.prototype</code>中定义的方法。</p><p>使用<code>Object.create()</code>创建的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(person2, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">person2.<span class="title function_">greet</span>(); <span class="comment">// 输出: &quot;Hello, my name is Bob.&quot;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>person2</code>直接继承自<code>Person.prototype</code></p><p>注意，我们需要显式地调用<code>Person</code>构造函数来初始化<code>person2</code>对象的<code>name</code>属性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：箭头函数跟普通函数之间的区别"><a href="#Q40：箭头函数跟普通函数之间的区别" class="headerlink" title="Q40：箭头函数跟普通函数之间的区别"></a>Q40：箭头函数跟普通函数之间的区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>箭头函数与传统的函数声明（function declaration）或函数表达式（function expression）在几个关键方面有所不同：</p><ol><li><p><strong><code>this</code>关键字的绑定</strong>：</p><ul><li><p>箭头函数</p><p>箭头函数不创建自己的<code>this</code>绑定。它们的<code>this</code>值继承自包裹它们的上下文</p><p>这使得箭头函数特别适合非方法的函数和回调，比如setTimeout</p></li><li><p>普通函数</p><p>传统函数和构造函数会为其内部代码块创建一个新的<code>this</code>上下文，通常，如果一个函数被作为一个对象的方法来调用，<code>this</code>就会引用那个对象</p><p>如果是在非严格模式下独立调用函数，<code>this</code>将会是全局对象（通常是<code>window</code>）</p><p>在严格模式下，<code>this</code>将是<code>undefined</code></p></li></ul></li><li><p><strong>是否可以用作构造函数</strong>：</p><ul><li><p>箭头函数</p><p>不能被用作构造函数，调用<code>new</code>会抛出错误</p></li><li><p>普通函数</p><p>可以使用<code>new</code>关键字来调用，并创建新的对象实例</p></li></ul></li><li><p><strong><code>arguments</code>对象</strong>：</p><ul><li><p>箭头函数</p><p>没有自己的<code>arguments</code>对象，只能访问包含它的普通函数的<code>arguments</code></p></li><li><p>普通函数</p><p>有自己的<code>arguments</code>对象，包含了被调用时传递的所有参数</p></li></ul></li><li><p><strong>语法简洁性</strong>：</p><ul><li><p>箭头函数</p><p>有更简洁的语法，没有<code>function</code>关键字，并且可以简化单个表达式的返回：<code>param =&gt; param + 1</code></p></li><li><p>普通函数</p><p>需要<code>function</code>关键字，并且需要<code>return</code>语句来返回结果（除非函数体指定为<code>{}</code>，在这种情况下，函数不返回任何内容）</p></li></ul></li><li><p><strong>函数名</strong>：</p><ul><li><p>箭头函数</p><p>通常是匿名的，除非它们被赋值给一个变量</p></li><li><p>普通函数</p><p>函数声明会创建一个具有其名称的函数，而函数表达式则是匿名的，除非它们被赋值给一个变量</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q41：Websocket中的心跳是为了解决什么问题"><a href="#Q41：Websocket中的心跳是为了解决什么问题" class="headerlink" title="Q41：Websocket中的心跳是为了解决什么问题"></a>Q41：Websocket中的心跳是为了解决什么问题</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Websocket中的心跳机制主要用于解决以下几个问题：</p><ol><li><p><strong>维护连接状态</strong></p><p>在基于TCP的长连接如Websocket中，双方在建立连接后，如果一段时间内没有任何数据传输，那么网络设备（如路由器等）可能会认为连接已经不再使用，从而将其断开</p><p>通过在连接上定期发送心跳消息，可以让网络设备知道这个连接仍然在使用中，从而避免被断开</p></li><li><p><strong>检测网络故障</strong></p><p>如果一个连接在设定的时间间隔内没有收到心跳消息，可以认为连接可能已经不可用了</p><p>可以启用一些恢复机制，如尝试重新连接，或者报告错误</p></li><li><p><strong>检测对端是否存活</strong></p><p>如果Websocket的服务端或客户端崩溃或者处于非响应状态，对端是无法立即知道这个情况的</p><p>通过心跳机制，如果在规定时间内没有收到心跳回应，对端可以判断出网络对端可能已经不可用</p></li><li><p><strong>与服务器同步</strong></p><p>在某些场景下，也能利用心跳来进行时间同步或者执行定时任务</p><p>比如，客户端可以根据每次收到服务器心跳的时间，来校准自己的计时器</p></li></ol><p>心跳机制是网络编程中常见的技巧，它可以帮助软件更好地处理网络状态的变化，让软件运行得更加健壮</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：Axios的原理是什么"><a href="#Q42：Axios的原理是什么" class="headerlink" title="Q42：Axios的原理是什么"></a>Q42：Axios的原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Axios 是一个基于Promise用于浏览器和node.js的HTTP客户端，它提供了一套简洁的API用于处理XmlHttpRequests（浏览器环境）和http请求（node.js环境）</p><p>一些核心原理和特性：</p><ol><li><strong>请求和响应拦截器（Interceptors）</strong><ul><li>Axios 允许在请求或响应被 then 或 catch 处理之前拦截它们</li><li>实现方式是通过维护一个拦截器管理对象，管理用于处理请求和响应的拦截函数</li></ul></li><li><strong>适配器（Adapters）</strong><ul><li>Axios 使用适配器模式来定义对不同环境下发送HTTP请求的具体实现</li><li>在浏览器中使用XMLHttpRequest对象发送请求，在Node.js中使用HTTP模块</li></ul></li><li><strong>请求取消（Cancellation）</strong><ul><li>Axios 提供了取消请求的功能，让你可以使用取消令牌来中断HTTP请求</li><li>实现是基于<code>AbortController</code> 接口，这是一个 Web 标准，可以配合原生的 <code>fetch</code> 使用</li></ul></li><li><strong>错误处理（Error Handling）</strong><ul><li>Axios 在请求发生任何错误时，返回Promise的拒绝（reject）状态，并提供详细的错误信息</li></ul></li><li><strong>转换请求和响应数据（Transforming）</strong><ul><li>在请求或响应被 then 或 catch 处理之前，可以通过转换函数修改请求或响应数据</li></ul></li><li><strong>自动转换JSON数据</strong><ul><li>在发送请求时，如果数据类型是对象，Axios 会自动转换为JSON字符串</li><li>在接收响应数据时，如果发现响应的<code>Content-Type</code>是<code>application/json</code>，Axios 会尝试将字符串转换成JSON对象</li></ul></li></ol><p>待补充手写实现简易版<code>Axios</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：try…catch代码是否有问题"><a href="#Q43：try…catch代码是否有问题" class="headerlink" title="Q43：try…catch代码是否有问题"></a>Q43：try…catch代码是否有问题</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代码有问题吗？如果有问题，应该怎么修改</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>这段代码有问题。原因在于JavaScript的错误处理机制和异步行为之间的交互</p><p>在 JavaScript 中，<code>try-catch</code> 结构只能捕获同步代码中的异常，因此，既不能捕获<code>setTimeout</code> 也不能捕获 <code>Promise</code> 中的错误，这是因为它们都是异步的</p><p>换句话说，<code>try-catch</code> 块在事件队列中添加的函数（异步函数）执行时已经退出了</p><p>解决这个问题的方法是在异步代码自身内部处理错误</p><p>确认要捕获每个可能抛出错误的 Promise，并对 <code>setTimeout</code> 异步代码进行适当的错误处理</p>
              </div>
            </details>
<p><br/></p>
<h1 id="代码运行题"><a href="#代码运行题" class="headerlink" title="代码运行题"></a>代码运行题</h1><p>查看本题需要严格学习<strong>概念Q12、Q19、Q26</strong></p>
<h3 id="Q1：Promise-1-输出结果"><a href="#Q1：Promise-1-输出结果" class="headerlink" title="Q1：Promise(1)输出结果"></a>Q1：Promise(1)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在浏览器环境中，Promise 的执行顺序是通过事件循环（Event Loop）和微任务队列来进行的。让我详细解释一下这段代码在浏览器中的执行过程：</p><ol><li><p><strong>第一个Promise链：</strong></p><ul><li><p>```<br>Promise.resolve().then(() =&gt; { console.log(0); return Promise.resolve(4); })</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     ：</span><br><span class="line"></span><br><span class="line">     - `console.log(0)` 输出 0，然后创建一个新的Promise。</span><br><span class="line">     - `return Promise.resolve(4);` 返回一个Promise，但它的微任务（Promise Resolution）被添加到微任务队列中。</span><br><span class="line">     - `.then((res) =&gt; &#123; console.log(res); &#125;)` 中的微任务被添加到微任务队列中。</span><br><span class="line"></span><br><span class="line">2. **第二个Promise链：**</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     Promise.resolve().then(() =&gt; &#123; console.log(1); &#125;)</span><br></pre></td></tr></table></figure><p>：</p><ul><li><code>console.log(1)</code> 输出 1，然后将微任务添加到微任务队列。</li></ul></li><li><p>后续的 <code>.then</code> 语句按顺序执行，每个 <code>.then</code> 中的 <code>console.log</code> 语句被添加到微任务队列中。</p></li></ul></li></ol><p>微任务队列是在当前事件循环结束后执行的，确保微任务按照它们被添加的顺序执行。所以，整体的执行顺序如下：</p><ol><li>执行 <code>console.log(0)</code>，输出 0。</li><li>将第一个 <code>.then</code> 中的 <code>return Promise.resolve(4);</code> 返回的Promise的微任务添加到微任务队列。</li><li>执行 <code>console.log(1)</code>，输出 1。</li><li>执行 <code>.then(() =&gt; { console.log(2); })</code> 的微任务，输出 2。</li><li>执行 <code>.then(() =&gt; { console.log(3); })</code> 的微任务，输出 3。</li><li>执行 <code>return Promise.resolve(4);</code> 返回的Promise的微任务，输出 4。</li><li>执行 <code>.then((res) =&gt; { console.log(res); })</code> 的微任务，输出 4。</li><li>执行 <code>.then(() =&gt; { console.log(5); })</code> 的微任务，输出 5。</li><li>执行 <code>.then(() =&gt; { console.log(6); })</code> 的微任务，输出 6。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：this指向（1）输出结果"><a href="#Q2：this指向（1）输出结果" class="headerlink" title="Q2：this指向（1）输出结果"></a>Q2：this指向（1）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line"> <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 <code>obj.print</code> 方法内部，有一个函数 <code>a</code>。在 JavaScript 中，函数内部的 <code>this</code> 默认指向全局对象（在浏览器中是 <code>window</code>）。因此，在函数 <code>a</code> 内部的 <code>console.log(this.name)</code> 中，<code>this.name</code> 实际上是访问了全局变量 <code>name</code>，其值为 <code>&#39;123&#39;</code>。</p><p>如果你想在函数 <code>a</code> 中访问到 <code>obj</code> 的 <code>name</code> 属性，可以使用箭头函数，因为箭头函数的 <code>this</code> 不会被重新绑定，而是沿用外层的 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line"> <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>(); <span class="comment">// 输出 &#x27;456&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个修改后的代码中，箭头函数 <code>a</code> 中的 <code>this</code> 将指向外部函数 <code>print</code> 的 <code>this</code>，因此能够正确地访问到 <code>obj</code> 的 <code>name</code> 属性</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码会输出 <code>&#39;123&#39;</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：类型判断（1）输出结果"><a href="#Q3：类型判断（1）输出结果" class="headerlink" title="Q3：类型判断（1）输出结果"></a>Q3：类型判断（1）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>typeof typeof typeof null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li><code>typeof null</code> 返回 <code>&#39;object&#39;</code>，因为在 JavaScript 中 <code>null</code> 被认为是一个空的对象引用。</li><li>然后，<code>typeof &#39;object&#39;</code> 返回 <code>&#39;string&#39;</code>，因为 <code>&#39;object&#39;</code> 是一个字符串。</li><li>最后，<code>typeof &#39;string&#39;</code> 返回 <code>&#39;string&#39;</code>。</li></ul><p>所以，这个表达式的输出是 <code>&#39;string&#39;</code>。</p></li><li><p><code>typeof console.log(1)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li><code>console.log(1)</code> 执行后，会先输出 <code>1</code> 到控制台，然后 <code>console.log</code> 返回 <code>undefined</code>。</li><li>接着，<code>typeof undefined</code> 返回 <code>&#39;undefined&#39;</code>。</li></ul><p>所以，这个表达式的输出是 <code>&#39;undefined&#39;</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>两个表达式的输出分别是 <code>&#39;string&#39;</code> 和 <code>&#39;undefined&#39;</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：变量提升（1）运行题"><a href="#Q4：变量提升（1）运行题" class="headerlink" title="Q4：变量提升（1）运行题"></a>Q4：变量提升（1）运行题</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码使用了自执行的匿名函数，并在函数内部声明了一个同名的函数 <code>b</code>。由于 JavaScript 具有变量提升，函数声明会被提升到作用域的顶部，因此这段代码的执行结果可能会令人困惑。</p><p>让我们来详细分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li><code>var b = 10;</code> 定义了全局变量 <code>b</code>，其值为 <code>10</code>。</li><li><code>(function b(){ ... })();</code> 创建了一个自执行的匿名函数，并在函数内部声明了一个同名的函数 <code>b</code>。这个函数 <code>b</code> 的作用域仅限于自执行函数内部。</li><li>在函数内部，<code>b = 20;</code> 尝试给函数 <code>b</code> 赋值为 <code>20</code>。然而，由于函数声明提升，这行代码实际上在执行之前已经被解释器解释为 <code>var b;</code>，因此它尝试给函数 <code>b</code> 赋值，而不是全局变量 <code>b</code>。</li><li>在 <code>console.log(b);</code> 中，输出的是自执行函数内部的 <code>b</code>，即该函数本身。因为在自执行函数内部，函数声明 <code>b</code> 会覆盖外部的全局变量 <code>b</code>。</li></ol><p>结果是，自执行函数内部的函数 <code>b</code> 被调用，输出函数本身，而全局变量 <code>b</code> 的值仍然是 <code>10</code>。这样做可能会导致混淆和不易理解的代码，通常应该避免在函数内部声明与外部变量同名的函数</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：代码结果（7）运行题"><a href="#Q5：代码结果（7）运行题" class="headerlink" title="Q5：代码结果（7）运行题"></a>Q5：代码结果（7）运行题</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span><span class="string">&#x27;,3].map(parselnt) </span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>map</code> 方法在每次迭代时会将当前元素、当前索引和数组本身作为参数传递给传入的回调函数。<code>parseInt</code> 函数接受两个参数：要转换的值和进制数。但是，<code>map</code> 方法传递的第二个参数是当前元素的索引，而不是进制数。这导致了 <code>parseInt</code> 函数的行为不同于预期。</p><p>让我们来详细解释一下每次迭代的情况：</p><ol><li>第一次迭代：<code>parseInt(&#39;1&#39;, 0)</code>，将 <code>&#39;1&#39;</code> 转换为十进制，返回 <code>1</code>。</li><li>第二次迭代：<code>parseInt(&#39;2&#39;, 1)</code>，将 <code>&#39;2&#39;</code> 转换为一进制，但是一进制无法表示 <code>&#39;2&#39;</code>，所以返回 <code>NaN</code>。</li><li>第三次迭代：<code>parseInt(&#39;3&#39;, 2)</code>，将 <code>&#39;3&#39;</code> 转换为二进制，但是二进制无法表示 <code>&#39;3&#39;</code>，所以返回 <code>NaN</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>最终的返回值是 <code>[1, NaN, NaN]</code></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>返回期望的结果 <code>[1, 2, 3]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：this指向（2）输出结果"><a href="#Q6：this指向（2）输出结果" class="headerlink" title="Q6：this指向（2）输出结果"></a>Q6：this指向（2）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">sayMyName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = obj.<span class="property">sayName</span></span><br><span class="line"><span class="keyword">const</span> fn2 = obj.<span class="property">sayMyName</span></span><br><span class="line"><span class="title function_">fn1</span>() </span><br><span class="line">obj.<span class="title function_">sayName</span>() </span><br><span class="line"><span class="title function_">fn2</span>() </span><br><span class="line">obj.<span class="title function_">sayMyName</span>() </span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，你定义了一个全局变量 <code>name</code> 并赋值为 <code>&#39;window&#39;</code>，然后创建了一个名为 <code>obj</code> 的对象，其中包含了两个方法 <code>sayName</code> 和 <code>sayMyName</code>。然后你将 <code>sayName</code> 方法赋值给了 <code>fn1</code> 变量，将 <code>sayMyName</code> 方法赋值给了 <code>fn2</code> 变量。</p><p>接下来，你调用了这些方法并打印出它们的执行结果。我们逐一分析：</p><ol><li><code>fn1()</code> 这里 <code>fn1</code> 是通过将 <code>obj.sayName</code> 方法赋值给变量得到的。由于函数调用时 <code>this</code> 的指向取决于调用方式，而不是定义方式，因此在这种情况下，<code>this</code> 指向全局对象（浏览器环境下是 <code>window</code>），所以打印的结果是 <code>&#39;window&#39;</code>。</li><li><code>obj.sayName()</code> 这是在 <code>obj</code> 上直接调用 <code>sayName</code> 方法，此时 <code>this</code> 指向的是 <code>obj</code> 对象，因此打印的结果是 <code>&#39;obj&#39;</code>。</li><li><code>fn2()</code> 这里 <code>fn2</code> 是通过将 <code>obj.sayMyName</code> 方法赋值给变量得到的。而箭头函数的 <code>this</code> 始终指向定义时所在的作用域，即全局作用域，在这个作用域中，<code>name</code> 变量被赋值为 <code>&#39;window&#39;</code>，因此打印的结果是 <code>&#39;window&#39;</code>。</li><li><code>obj.sayMyName()</code> 这是在 <code>obj</code> 上直接调用 <code>sayMyName</code> 方法，但是由于箭头函数的 <code>this</code> 绑定在定义时的作用域，因此此时的 <code>this</code> 也是指向的全局作用域，因此打印的结果也是 <code>&#39;window&#39;</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span></span><br><span class="line">obj</span><br><span class="line"><span class="variable language_">window</span></span><br><span class="line"><span class="variable language_">window</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：变量提升（2）运行题"><a href="#Q7：变量提升（2）运行题" class="headerlink" title="Q7：变量提升（2）运行题"></a>Q7：变量提升（2）运行题</h3><p>难度：⭐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">var foo;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">foo = function()&#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，虽然函数 <code>foo()</code> 被声明了两次，但是 JavaScript 中的函数声明会被提升到作用域的顶部，因此函数声明会优先于变量声明。这种行为被称为“函数提升”。</p><p>下面是代码的执行过程：</p><ol><li>JavaScript 引擎首先会进行变量和函数声明的提升，将它们移动到作用域的顶部。所以，函数声明 <code>function foo()</code> 会被提升到作用域的顶部，而变量声明 <code>var foo</code> 也会被提升，但由于存在函数声明，它将被忽略。</li><li>因此，实际上代码的执行顺序会变成这样：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 此时输出 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接着，<code>foo()</code> 函数被调用，输出 1。</li><li>然后，<code>foo</code> 变量被赋值为一个新的函数，即匿名函数 <code>function() { console.log(2); }</code>。</li></ol><p>因此，最终的输出是 <code>1</code>，而不是 <code>2</code>。这是因为函数声明会在变量声明之前被处理，所以在执行时会使用函数声明定义的函数。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>输出 1</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Promise-2-输出结果"><a href="#Q8：Promise-2-输出结果" class="headerlink" title="Q8：Promise(2)输出结果"></a>Q8：Promise(2)输出结果</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个 Promise 对象 <code>promise1</code>，然后输出了字符串 <code>&#39;1&#39;</code> 以及 <code>promise1</code> 的值。但是要注意，Promise 的构造函数中并没有调用 <code>resolve</code> 或 <code>reject</code>，所以 <code>promise1</code> 处于 pending（待定）状态。因此，即使 <code>promise1</code> 已经被创建，但其状态仍然是 pending，直到调用 <code>resolve</code> 或 <code>reject</code> 方法，Promise 的状态才会发生变化。</p><p>因此，虽然在创建 Promise 对象后立即输出 <code>promise1</code>，但它的状态仍然是 pending，因此输出的 <code>promise1</code> 可能并不包含实际的结果，而是一个 pending 状态的 Promise 对象。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：Promise-3-输出结果"><a href="#Q9-：Promise-3-输出结果" class="headerlink" title="Q9 ：Promise(3)输出结果"></a>Q9 ：Promise(3)输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码的执行过程如下：</p><ol><li>首先，定义了一个箭头函数 <code>fn</code>，该箭头函数返回一个 Promise 对象。</li><li>在箭头函数内部，立即执行了一个 Promise 构造函数，这个构造函数内部打印了 <code>1</code>，然后通过 <code>resolve</code> 方法将 Promise 的状态设置为 resolved，同时传递了 <code>&#39;success&#39;</code> 作为成功的返回值。</li><li>调用 <code>fn()</code>，这会立即执行箭头函数，而箭头函数中的 Promise 构造函数也会立即执行，因此会在控制台打印出 <code>1</code>。此时，Promise 对象被成功解决，但 <code>.then()</code> 方法尚未执行。</li><li>继续执行下一行代码，即 <code>console.log(&#39;start&#39;)</code>，打印出 <code>&#39;start&#39;</code>。</li><li>此时，整个脚本的主线程任务已经执行完毕，事件循环开始检查任务队列中是否有待执行的微任务。发现 Promise 对象的状态已经改变，并且有 <code>.then()</code> 方法注册了对应的处理函数，因此将这个微任务加入到微任务队列中。</li><li>事件循环开始处理微任务队列中的任务，执行 <code>.then()</code> 方法中的回调函数，即打印出 <code>&#39;success&#39;</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码的执行顺序是：</p><ol><li>首先打印出 <code>1</code>。</li><li>然后打印出 <code>&#39;start&#39;</code>。</li><li>最后打印出 <code>&#39;success&#39;</code>。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：Promise-4-输出结果"><a href="#Q10：Promise-4-输出结果" class="headerlink" title="Q10：Promise(4)输出结果"></a>Q10：Promise(4)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在给定的代码中，<code>runAsync</code> 函数会创建一个 Promise，在一秒后 resolve 该 Promise，并打印传入的参数 <code>x</code>，然后返回该 Promise。<code>Promise.all</code> 接受一个由 Promises 组成的数组作为参数，返回一个新的 Promise，当数组中所有的 Promise 都被解决时，该 Promise 也会被解决，解决值是一个数组，包含了每个 Promise 的解决值。</p><p>在这段代码中，<code>Promise.all</code> 会同时执行三个 <code>runAsync</code> 函数，每个函数都会在一秒后 resolve。然后，<code>then</code> 方法中的回调函数会在所有的 Promise 都被 resolve 后执行，并且传入的 <code>res</code> 参数是一个数组，包含了每个 Promise 的 resolve 值。</p><p>由于 <code>runAsync</code> 函数会在 resolve 时打印传入的参数 <code>x</code>，所以在输出结果中，我们会先看到 1、2、3 分别被打印出来，然后是整个数组 [1, 2, 3] 被打印出来，因为 <code>Promise.all</code> 返回的是一个包含所有 resolve 值的数组</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="meta">1, 2, 3</span>]</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：Promise-5-输出结果"><a href="#Q11：Promise-5-输出结果" class="headerlink" title="Q11：Promise(5)输出结果"></a>Q11：Promise(5)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个 Promise，Promise 的执行器函数会立即执行。在执行器函数中，首先输出 1，然后调用了 <code>resolve(&#39;success&#39;)</code>，接着输出 2。注意，调用 <code>resolve</code> 并不会立即结束 Promise 的执行器函数，后面的代码仍然会执行。</p><p>接着，创建的 Promise 对象 <code>promise</code> 会立即进入 resolved（解决）状态，并且传递了 ‘success’ 给后续的 <code>then</code> 方法。</p><p>然后，下面的 <code>then</code> 方法注册了一个回调函数，在 Promise 对象 <code>promise</code> 被 resolved 时执行。由于 Promise 已经在创建时立即 resolved，所以这个回调函数会被添加到微任务队列中，等待当前的执行栈清空后执行。在这个回调函数中，输出了 3。</p><p>最后，输出了 4。因为 JavaScript 是单线程的，代码是同步执行的，所以在执行 <code>console.log(4)</code> 之前，Promise 相关的微任务已经被添加到微任务队列中，等待执行栈清空后执行。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：Promise-6-输出结果"><a href="#Q12：Promise-6-输出结果" class="headerlink" title="Q12：Promise(6)输出结果"></a>Q12：Promise(6)输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，虽然创建了一个 Promise，但在 Promise 的执行器函数中并没有调用 <code>resolve</code> 或 <code>reject</code>，因此这个 Promise 不会进入 resolved 或 rejected 状态。因此，与该 Promise 关联的 <code>then</code> 方法中注册的回调函数也不会被执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：代码结果（1）运行题"><a href="#Q13：代码结果（1）运行题" class="headerlink" title="Q13：代码结果（1）运行题"></a>Q13：代码结果（1）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong>函数声明提升</strong>：<ul><li>JavaScript 中的函数声明会被提升到所在作用域的顶部，因此在函数声明之前调用函数是合法的。</li><li>因此，在执行 <code>foo(typeof a)</code> 之前，函数 <code>foo()</code> 已经被声明。</li></ul></li><li><strong>变量声明提升</strong>：<ul><li>与函数声明不同，变量声明会提升至作用域顶部，但不会被初始化，直到执行到定义的语句才会被赋值。</li><li>在函数 <code>foo()</code> 中，变量 <code>b</code> 的声明被提升到函数体的顶部，但在声明之前访问 <code>typeof b</code> 会得到 <code>undefined</code>。</li></ul></li></ol><p>因此，当执行 <code>foo(typeof a)</code> 时，会按照以下步骤执行：</p><ol><li>输出 <code>this</code>：由于 <code>foo()</code> 函数在全局作用域中调用，因此 <code>this</code> 指向全局对象（浏览器中是 <code>window</code> 对象）。</li><li>输出 <code>p</code>：<code>p</code> 的值为 <code>typeof a</code>，即字符串 <code>&quot;undefined&quot;</code>，因为在调用时变量 <code>a</code> 未定义，因此 <code>typeof a</code> 返回 <code>&quot;undefined&quot;</code>。</li><li>输出 <code>typeof b</code>：在声明 <code>let b = 0;</code> 之前访问变量 <code>b</code>，此时变量 <code>b</code> 已经被声明但尚未初始化，因此输出 <code>undefined</code>。</li><li>因为变量 <code>b</code> 是在声明之前使用，会导致 ReferenceError 错误。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">undefined</span><br><span class="line">ReferenceError 错误</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：代码结果（2）运行题"><a href="#Q14：代码结果（2）运行题" class="headerlink" title="Q14：代码结果（2）运行题"></a>Q14：代码结果（2）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">obj.<span class="title function_">a</span>();</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>Foo.a = function(){ console.log(4); }</code><br>这一行在函数 <code>Foo</code> 自身定义了一个静态方法 <code>a</code>。当调用 <code>Foo.a()</code> 时，它会打印 <code>4</code>。</li><li><code>Foo.a();</code><br>这行代码调用了刚刚定义的静态方法 <code>a</code>，所以它会打印 <code>4</code>。</li><li><code>let obj = new Foo();</code><br>这行代码创建了 <code>Foo</code> 的一个新实例。当使用 <code>new</code> 调用 <code>Foo</code> 函数时，它创建了一个新对象。构造函数运行，为实例设置了属性 <code>a</code>，这个属性是一个函数，当被调用时会打印 <code>2</code>。但是，<code>Foo</code> 自身的静态属性 <code>a</code> 保持不变。</li><li><code>obj.a();</code><br>这行代码调用了新对象 <code>obj</code> 上的实例方法 <code>a</code>。由于我们在构造函数中定义了 <code>this.a</code>，它会打印 <code>2</code>。</li><li><code>Foo.a();</code><br>这行代码再次调用 <code>Foo</code> 上的静态方法 <code>a</code>。由于自上次被调用以来它没有改变，它仍然会打印 <code>4</code>。</li></ol><p>在这个序列中没有使用 <code>Foo.prototype.a = function(){ console.log(3); }</code> 这个赋值，因为我们从未调用过没有自己的 <code>a</code> 属性的实例的 <code>a</code> 方法。如果我们在删除了 <code>obj</code> 自己的 <code>a</code> 属性（<code>delete obj.a;</code>）后调用 <code>obj.a()</code>，那么它会使用原型的 <code>a</code> 方法并打印 <code>3</code>。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：代码结果（3）运行题"><a href="#Q15：代码结果（3）运行题" class="headerlink" title="Q15：代码结果（3）运行题"></a>Q15：代码结果（3）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line"> <span class="title function_">c</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，变量<code>a</code>被声明在全局作用域，并赋值为<code>3</code>。</li><li>然后，函数<code>c</code>被声明在全局作用域。当调用<code>c</code>函数时，它会弹出当前作用域链中可访问的变量<code>a</code>的值。</li><li>紧接着，一个立即执行函数表达式（IIFE）被创建并执行。在这个函数内部，又声明了一个局部变量<code>a</code>，并赋值为<code>4</code>。但是这个变量只在立即执行函数的局部作用域内有效。</li><li>在IIFE内部，我们调用了函数<code>c</code>。因为函数<code>c</code>是在全局作用域中定义的，所以当它查找变量<code>a</code>时，会沿作用域链向上查找直到全局作用域，找到全局变量<code>a</code>的值，即<code>3</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：this指向（3）输出结果"><a href="#Q16：this指向（3）输出结果" class="headerlink" title="Q16：this指向（3）输出结果"></a>Q16：this指向（3）输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.<span class="title function_">bind</span>(foo).<span class="title function_">bind</span>(sed);</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.<span class="title function_">bind</span>(foo).<span class="title function_">bind</span>(sed).<span class="title function_">bind</span>(fiv);</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>bind</code> 方法创建了一个新的函数，该函数的 <code>this</code> 关键字被绑定到传递给 <code>bind</code> 方法的第一个参数，并返回一个新的函数</p><p><code>bind</code> 方法还可以携带参数，这些参数将被应用到绑定函数的调用</p><p>在这个问题中，主要涉及到了 <code>bind</code> 方法的嵌套调用</p><p>需要注意的是，当你多次调用 <code>bind</code> 方法时，每次 <code>bind</code> 都会返回一个新的函数，并且绑定了第一次传递给 <code>bind</code> 的 <code>this</code> 值</p><p>后续的 <code>bind</code> 调用不会更改之前绑定的 <code>this</code> 值，因此后续传递的 <code>this</code> 值将被忽略</p><p><strong>示例分析：</strong></p><ul><li>在第一个示例中：<ul><li>首先，<code>bar.bind(foo)</code> 会创建一个新的函数，该函数的 <code>this</code> 值被绑定到 <code>foo</code></li><li>然后，再次调用 <code>bar.bind(foo).bind(sed)</code> 时，由于第一个 <code>bind</code> 已经绑定了 <code>foo</code>，第二个 <code>bind</code> 试图将 <code>this</code> 绑定到 <code>sed</code> 将被忽略，函数的 <code>this</code> 仍然保持绑定到 <code>foo</code></li><li>当 <code>func()</code> 被调用时，函数中的 <code>this.x</code> 仍然是 <code>foo.x</code>，即 <code>3</code></li></ul></li><li>在第二个示例中：<ul><li>首先，<code>bar.bind(foo)</code> 会创建一个新的函数，该函数的 <code>this</code> 值被绑定到 <code>foo</code></li><li>接着，再次调用 <code>bar.bind(foo).bind(sed)</code> 时，<code>this</code> 仍然绑定到 <code>foo</code>，而第二个 <code>bind</code> 的 <code>sed</code> 作为 <code>this</code> 参数会被忽略</li><li>再次调用 <code>bar.bind(foo).bind(sed).bind(fiv)</code> 时，<code>this</code> 仍然保持绑定到 <code>foo</code>，第三个 <code>bind</code> 的 <code>fiv</code> 作为 <code>this</code> 参数也被忽略</li><li>因此，当 <code>func()</code> 被调用时，函数中的 <code>this.x</code> 仍然是 <code>foo.x</code>，即 <code>3</code></li></ul></li></ul><p><strong>总结：</strong></p><p>在这两个示例中，由于多次 <code>bind</code> 的 <code>this</code> 值已经被绑定到最初传递的 <code>foo</code>，后续 <code>bind</code> 的 <code>this</code> 参数将被忽略</p><p>因此，无论在 <code>bar.bind(foo).bind(sed)</code> 还是 <code>bar.bind(foo).bind(sed).bind(fiv)</code> 中调用 <code>func()</code>，函数中的 <code>this</code> 值都将保持绑定到 <code>foo</code>，并且 <code>func()</code> 调用的结果将始终是输出 <code>3</code></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：Promise-7-输出结果"><a href="#Q17：Promise-7-输出结果" class="headerlink" title="Q17：Promise(7)输出结果"></a>Q17：Promise(7)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>JavaScript运行时包括一个包含消息队列的事件循环和一个微任务队列</p><p><code>async/await</code>和<code>Promise</code>相关的回调会进入微任务队列，而像<code>setTimeout</code>这样的函数设置的回调会进入消息队列</p><p>微任务队列在每次事件循环迭代的末尾执行，而消息队列中的事件则需要等到下一个迭代</p><p>根据这个信息，我们可以确定代码的输出顺序：</p><ol><li>首先，<code>async1</code>函数被调用，打印 <code>&quot;async1 start&quot;</code></li><li>然后，<code>async1</code>函数中调用<code>await async2()</code>。<code>async2</code>函数被调用</li><li>在<code>async2</code>函数中，<code>setTimeout</code>将<code>console.log(&#39;timer2&#39;)</code>回调排入消息队列</li><li>然后，<code>async2</code>继续执行，打印 <code>&quot;async2&quot;</code></li><li><code>async2</code>执行完毕，控制权返回到<code>async1</code>，但是<code>async1</code>中<code>await</code>之后的代码需要等待微任务队列中的所有任务完成后才能执行</li><li><code>async1</code>函数暂停执行，事件循环继续，执行全局的<code>setTimeout</code>，将<code>console.log(&#39;timer3&#39;)</code>排入消息队列</li><li>然后，全局上下文中的最后一条语句<code>console.log(&quot;start&quot;)</code>被执行</li><li>此时，主线程代码执行完毕，事件循环开始处理微任务队列。<code>async1</code>中<code>await</code>之后的代码<code>console.log(&quot;async1 end&quot;)</code>被执行</li><li><code>async1</code>中的<code>setTimeout</code>将<code>console.log(&#39;timer1&#39;)</code>排入消息队列</li><li>主线程代码和微任务队列都清空后，事件循环开始处理消息队列中的宏任务，按照它们被添加到队列的顺序执行。首先是<code>timer2</code>的回调，打印 <code>&quot;timer2&quot;</code></li><li>接下来是<code>timer3</code>的回调，打印 <code>&quot;timer3&quot;</code></li><li>最后是<code>timer1</code>的回调，打印 <code>&quot;timer1&quot;</code></li></ol><p>所以，输出的顺序将是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure><p>请注意，虽然<code>setTimeout</code>的延时被设置为0，它仍然会在当前执行堆栈清空后的下一个事件循环迭代中执行</p><p>这意味着<code>async/await</code>和其他同步代码总是先于<code>setTimeout</code>回调执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：Promise-8-输出结果"><a href="#Q18：Promise-8-输出结果" class="headerlink" title="Q18：Promise(8)输出结果"></a>Q18：Promise(8)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">runReject</span>(<span class="number">0</span>), <span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runAsync</span>(<span class="number">2</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>)])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result: &quot;</span>, res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是一个 JavaScript 的 Promise 相关的示例，它创建了两个异步函数 <code>runAsync</code> 和 <code>runReject</code>，然后使用 <code>Promise.race()</code> 方法来竞争它们的执行</p><p>逐步拆解这段代码，并解释其输出顺序：</p><ol><li><code>runAsync</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 resolve 这个 Promise，并打印参数 <code>x</code> 的值</li><li><code>runReject</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 reject 这个 Promise，并打印一个错误信息以及参数 <code>x</code> 的值</li><li><code>Promise.race()</code> 方法：接受一个 Promise 数组，并返回一个新的 Promise 对象，该 Promise 对象会在数组中的任意一个 Promise 状态发生改变时立即改变</li></ol><p>现在，让我们来解释输出顺序：</p><ul><li>首先，<code>runReject(0)</code> 会立即执行，并在 0 秒后 reject，但因为 <code>setTimeout()</code> 的延迟设定为 0，所以在这个阶段并不会立即输出任何内容</li><li>然后，<code>runAsync(1)</code>、<code>runAsync(2)</code> 和 <code>runAsync(3)</code> 会同时执行，并在 1 秒、2 秒和 3 秒后分别 resolve，同时输出它们的参数值</li><li>由于 <code>Promise.race()</code> 返回的 Promise 对象会在最先解决或拒绝的 Promise 状态发生改变时立即改变，因此最终的输出将会是第一个解决的 Promise 对象的结果</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="title class_">Error</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时输出的值不是Promise.race返回的</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.race()</code> 是 JavaScript 中的一个静态方法，用于创建一个新的 Promise</p><p>该 Promise 在传入的可迭代对象中的任何一个 Promise 解决或拒绝时解决或拒绝，而不管其他 Promise 的状态如何</p><p>具体来说，<code>Promise.race()</code> 接受一个可迭代对象（通常是一个数组），并返回一个新的 Promise 对象</p><p>这个新的 Promise 对象将会在可迭代对象中的第一个 Promise 状态改变时采用该 Promise 的状态和值。如果可迭代对象为空，则返回的 Promise 将永远保持挂起状态</p><p>例如，在一个包含多个 Promise 的数组中，如果其中一个 Promise 解决或拒绝了，<code>Promise.race()</code> 返回的 Promise 将立即采用该解决或拒绝的状态和值，而不会等待其他 Promise 的解决或拒绝</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19：Promise-9-输出结果"><a href="#Q19：Promise-9-输出结果" class="headerlink" title="Q19：Promise(9)输出结果"></a>Q19：Promise(9)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span> (x) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span> (x) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runReject</span>(<span class="number">4</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>), <span class="title function_">runReject</span>(<span class="number">2</span>)])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码使用了 <code>Promise.all()</code> 方法来等待所有的 Promise 都解决（resolve）或有一个被拒绝（reject），然后返回一个包含所有 Promise 解决值的数组</p><p>现在，让我们来拆解这段代码，并解释其输出顺序：</p><ol><li><code>runAsync</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 resolve 这个 Promise，并打印参数 <code>x</code> 的值</li><li><code>runReject</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 reject 这个 Promise，并打印一个错误信息以及参数 <code>x</code> 的值</li><li><code>Promise.all()</code> 方法：接受一个 Promise 数组，并返回一个新的 Promise 对象，该 Promise 对象会在数组中所有的 Promise 都解决时 resolve，或者其中任意一个被拒绝时 reject</li></ol><p>逐步详细地解释代码在浏览器中的执行过程：</p><ol><li><strong>开始执行代码</strong>：<ul><li>调用 <code>Promise.all()</code>，传入一个包含了四个 Promise 的数组：<code>[runAsync(1), runReject(4), runAsync(3), runReject(2)]</code></li><li>每个 Promise 开始执行，并且计划在一定时间后解决或拒绝</li></ul></li><li><strong>1 秒后</strong>：<ul><li><code>runAsync(1)</code> 解决并输出 1。</li><li><code>runReject(2)</code> 被拒绝并输出错误信息 “Error: 2”</li><li><code>runAsync(3)</code> 继续执行但尚未解决</li></ul></li><li><strong>2 秒后</strong>：<ul><li><code>runAsync(3)</code> 解决并输出 3</li><li><code>runReject(4)</code> 继续执行但尚未拒绝</li></ul></li><li><strong>4 秒后</strong>：<ul><li><code>runReject(4)</code> 被拒绝并输出错误信息 “4”</li></ul></li></ol><p>因此，整个执行过程如下：</p><ul><li>1 秒后输出：1（来自 <code>runAsync(1)</code>）、3（来自 <code>runAsync(3)</code>）</li><li>2 秒后输出：2（来自 <code>runReject(2)</code> 的错误信息）</li><li>4 秒后输出：4（来自 <code>runReject(4)</code> 的错误信息）</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1s后输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.all()</code> 是 JavaScript 中的一个静态方法，用于创建一个新的 Promise，该 Promise 在传入的可迭代对象中的所有 Promise 都解决（resolve）时才会解决，如果任何一个 Promise 被拒绝（reject）了，则该 Promise 也会被拒绝</p><p>具体来说，<code>Promise.all()</code> 接受一个可迭代对象（通常是一个数组），并返回一个新的 Promise 对象</p><p>这个新的 Promise 对象将会在传入的所有 Promise 都解决时才会解决，并且它的解决值是一个包含了所有 Promise 解决值的数组。如果传入的任何一个 Promise 被拒绝，则返回的 Promise 将立即被拒绝，其拒绝原因是第一个被拒绝的 Promise 的拒绝原因</p><p><code>Promise.all()</code> 在处理多个异步操作时非常有用，特别是当你需要等待多个异步操作都完成后才能继续执行下一步操作时</p><p>例如，你可以用它来等待多个网络请求都返回后再更新页面，或者等待多个文件的读取完成后再进行处理等</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：Promise-10-输出结果"><a href="#Q20：Promise-10-输出结果" class="headerlink" title="Q20：Promise(10)输出结果"></a>Q20：Promise(10)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  &#125;, function fail1 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail1&#x27;, err)</span><br><span class="line">  &#125;).catch(function fail2 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail2&#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>Promise.resolve()</code> 创建一个立即解决的 Promise，并进入微任务队列</li><li>由于 Promise 是立即解决的，进入微任务队列中的任务会立即执行。因此，<code>.then()</code> 方法中的回调函数会被添加到微任务队列中，等待执行</li><li>微任务队列中的任务开始执行。由于 Promise 是成功状态，所以成功的回调函数 <code>function success(res)</code> 被调用，传入的参数 <code>res</code> 是 Promise 解决的值（在这个例子中是 <code>undefined</code>）</li><li>在成功的回调函数中，<code>throw new Error(&#39;error!!!&#39;)</code> 抛出了一个错误</li><li>由于在成功的回调函数中抛出了错误，Promise 状态被改变为拒绝（rejected）。错误会被传递给下一个可用的拒绝回调函数</li><li>因为在 <code>.then()</code> 方法中提供了失败（reject）的回调函数 <code>function fail1(err)</code>，所以这个失败的回调函数被调用，并接收到抛出的错误作为参数</li><li><code>console.log(&#39;fail1&#39;, err)</code> 打印了错误信息</li><li>由于没有错误处理链继续执行，这个错误会被传递到 <code>.catch()</code> 方法中</li><li><code>.catch()</code> 方法中的回调函数 <code>function fail2(err)</code> 被调用，并接收到抛出的错误作为参数</li><li><code>console.log(&#39;fail2&#39;, err)</code> 打印了错误信息</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fail2 <span class="title class_">Error</span>: error!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：Promise-11-输出结果"><a href="#Q21：Promise-11-输出结果" class="headerlink" title="Q21：Promise(11)输出结果"></a>Q21：Promise(11)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timerStart&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timerEnd&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>new Promise(...)</code> 的代码块立即执行，创建了一个 Promise 实例。传入的函数中包含了一个异步操作，即 <code>setTimeout</code></li><li><code>console.log(1)</code> 打印了数字 1</li><li><code>setTimeout</code> 被调用，设置了一个定时器，该定时器会在 0 毫秒后执行回调函数</li><li><code>console.log(2)</code> 打印了数字 2</li><li>控制流程离开了 Promise 构造函数，继续执行下一行代码</li><li><code>console.log(4)</code> 打印了数字 4</li><li>这个时候，JavaScript 主线程中的同步代码执行完毕，事件循环开始检查是否有微任务需要执行</li><li>由于 Promise 的状态是异步确定的，它的回调函数不会立即执行，而是会被放入微任务队列中等待执行</li><li>在微任务队列中，<code>promise.then(...)</code> 中的回调函数被添加，等待执行</li><li>控制流程返回到微任务队列，开始执行微任务</li><li>执行 <code>promise.then(...)</code> 中的回调函数，传入的参数 <code>res</code> 是 Promise 解决的值（在这里是字符串 “success”）</li><li><code>console.log(res)</code> 打印了解决值 “success”</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">timerStart</span><br><span class="line">timerEnd</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：Promise-12-输出结果"><a href="#Q22：Promise-12-输出结果" class="headerlink" title="Q22：Promise(12)输出结果"></a>Q22：Promise(12)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>console.log(&#39;start&#39;)</code> 打印了字符串 <code>&#39;start&#39;</code></li><li><code>setTimeout(() =&gt; { console.log(&#39;time&#39;) })</code> 被调用，设置了一个定时器，该定时器会在默认时间后执行回调函数</li><li><code>Promise.resolve()</code> 创建了一个立即解决的 Promise，并进入微任务队列</li><li><code>console.log(&#39;end&#39;)</code> 打印了字符串 <code>&#39;end&#39;</code></li><li>控制流程离开了当前同步代码块，开始执行微任务</li><li>微任务队列中的任务开始执行，<code>.then()</code> 方法中的回调函数被添加到微任务队列中</li><li>控制流程再次回到微任务队列，开始执行微任务</li><li><code>.then()</code> 方法中的回调函数被执行，打印了字符串 <code>&#39;resolve&#39;</code></li><li>执行到这里，所有的同步代码执行完毕，事件循环开始检查是否有宏任务需要执行</li><li>定时器的回调函数被触发执行，打印了字符串 <code>&#39;time&#39;</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">resolve</span><br><span class="line">time</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：Promise-13-输出结果"><a href="#Q23：Promise-13-输出结果" class="headerlink" title="Q23：Promise(13)输出结果"></a>Q23：Promise(13)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>定义了一个名为 <code>fn</code> 的箭头函数，该函数返回一个 Promise 实例</p><p>在 Promise 构造函数中，会立即执行传入的函数，这里会打印数字 1，然后解决（resolve）Promise 并传递字符串 “success”</p></li><li><p><code>console.log(&quot;start&quot;)</code> 打印了字符串 <code>&quot;start&quot;</code></p></li><li><p>调用 <code>fn()</code>，执行函数体。这时候会执行 Promise 构造函数中的内容，打印了数字 1，并立即解决 Promise，并传递字符串 “success”</p></li><li><p><code>fn()</code> 返回的 Promise 实例进入微任务队列</p></li><li><p>控制流程离开了当前同步代码块，开始执行微任务</p></li><li><p>微任务队列中的任务开始执行，<code>.then()</code> 方法中的回调函数被添加到微任务队列中</p></li><li><p>控制流程再次回到微任务队列，开始执行微任务</p></li><li><p><code>.then()</code> 方法中的回调函数被执行，接收到解决值 <code>&quot;success&quot;</code>，然后打印了 <code>&quot;success&quot;</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：Promise-14-输出结果"><a href="#Q24：Promise-14-输出结果" class="headerlink" title="Q24：Promise(14)输出结果"></a>Q24：Promise(14)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>, promise1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>, promise2);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>promise1</code> 是通过 <code>new Promise()</code> 创建的，立即执行 Promise 构造函数中的函数体<ul><li><code>console.log(&#39;promise1&#39;)</code> 打印了字符串 <code>&#39;promise1&#39;</code></li></ul></li><li>在 <code>promise1</code> 的执行过程中，<code>resolve(&#39;resolve1&#39;)</code> 被调用，将 Promise 状态设置为 resolved，并传递了解决值 <code>&#39;resolve1&#39;</code></li><li><code>promise2</code> 是通过 <code>promise1.then()</code> 方法创建的，它绑定在 <code>promise1</code> 上。这时候，<code>promise2</code> 并不会立即执行，它会在 <code>promise1</code> 被解决后才会执行</li><li><code>console.log(&#39;1&#39;, promise1)</code> 打印了 <code>&#39;1&#39;</code> 和 <code>promise1</code>。由于 <code>promise1</code> 已经被解决，所以输出时会显示 <code>promise1</code> 的状态和解决值（状态为 resolved，解决值为 <code>&#39;resolve1&#39;</code>）</li><li><code>console.log(&#39;2&#39;, promise2)</code> 打印了 <code>&#39;2&#39;</code> 和 <code>promise2</code>。此时，<code>promise2</code> 还未被解决，因为它是由 <code>promise1.then()</code> 创建的，而 <code>promise1</code> 的状态是 resolved，但 <code>promise2</code> 的回调函数还未执行，所以 <code>promise2</code> 的状态为 pending（待定）</li><li>在微任务队列中，<code>promise1.then()</code> 中的回调函数被添加，等待执行</li><li>控制流程离开了当前同步代码块，开始执行微任务</li><li>微任务队列中的任务开始执行，<code>promise1.then()</code> 中的回调函数被执行，打印了解决值 <code>&#39;resolve1&#39;</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;promise1&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> <span class="title class_">Promise</span>&#123;&lt;resolved&gt;: <span class="string">&#x27;resolve1&#x27;</span>&#125;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="title class_">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">&#x27;resolve1&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：代码结果（4）运行题"><a href="#Q25：代码结果（4）运行题" class="headerlink" title="Q25：代码结果（4）运行题"></a>Q25：代码结果（4）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，<code>map</code>函数的回调函数可以接受三个参数：当前元素、当前元素的索引和整个数组</p><p>而<code>parseInt</code>函数可以接受两个参数：一个是要解析的字符串，另一个是解析时使用的基数（进制）</p><p>当你执行<code>[&#39;10&#39;, &#39;10&#39;, &#39;10&#39;, &#39;10&#39;, &#39;10&#39;].map(parseInt)</code>时，实际上你对每个元素调用了<code>parseInt</code>函数，并传入了两个参数：元素本身和它的索引</p><p>因此，实际调用是这样的：</p><ol><li><code>parseInt(&#39;10&#39;, 0)</code> // 第一个元素，基数为0，返回10（0被当作10进制来解析）</li><li><code>parseInt(&#39;10&#39;, 1)</code> // 第二个元素，基数为1，但1不是有效基数，返回NaN</li><li><code>parseInt(&#39;10&#39;, 2)</code> // 第三个元素，基数为2，返回2（因为’10’在二进制表示为2）</li><li><code>parseInt(&#39;10&#39;, 3)</code> // 第四个元素，基数为3，返回3（因为’10’在三进制中表示为3）</li><li><code>parseInt(&#39;10&#39;, 4)</code> // 第五个元素，基数为4，返回4（因为’10’在四进制中表示为4）</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="title class_">NaN</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：代码结果（5）运行题"><a href="#Q26：代码结果（5）运行题" class="headerlink" title="Q26：代码结果（5）运行题"></a>Q26：代码结果（5）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> +<span class="number">123</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，当你看到 <code>123[&quot;toString&quot;]</code> 这样的表达式时，实际上是在访问数字123的 <code>toString</code> 方法</p><p>数字字面量123被自动装箱成一个临时的 <code>Number</code> 对象，并访问其 <code>toString</code> 方法</p><p><code>123[&quot;toString&quot;].length</code> 这部分表达式求的是 <code>toString</code> 方法的 <code>length</code> 属性</p><p>在JavaScript中，函数的 <code>length</code> 属性表示该函数期望接收的参数个数</p><p><code>Number</code> 的 <code>toString</code> 方法可以接受一个可选参数，该参数指定要转换的基数，因此 <code>toString</code> 方法的 <code>length</code> 值为1</p><p>所以，<code>123[&quot;toString&quot;].length</code> 的值为1</p><p>接下来，你将这个值1与123进行加法操作</p><p>在JavaScript中，加法操作符可以用于数字的算术加法或字符串的连接。当其中一个操作数是数字而另一个是数字时，JavaScript会执行算术加法</p><p>因此，<code>123[&quot;toString&quot;].length + 123</code> 的计算过程是 <code>1 + 123</code>，结果为 <code>124</code></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">124</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：代码结果（6）运行题"><a href="#Q27：代码结果（6）运行题" class="headerlink" title="Q27：代码结果（6）运行题"></a>Q27：代码结果（6）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码创建了一个<code>for</code>循环，用于设置5个<code>setTimeout</code></p><p>每个<code>setTimeout</code>都有一个回调函数<code>timer</code>，在推迟0毫秒（实际会受到浏览器最小延时的限制）之后执行</p><p>由于<code>setTimeout</code>是异步执行的，因此所有的<code>setTimeout</code>回调都会在当前执行栈清空之后才会执行</p><p>关键点在于这里使用了<code>var</code>来声明变量<code>i</code>，而<code>var</code>声明的变量具有函数作用域，而不是块级作用域</p><p>这意味着在for循环结束时，变量<code>i</code>的值将是6（因为最后一次循环在执行<code>i++</code>后，<code>i</code>变为6且不满足<code>i &lt;= 5</code>的条件而终止循环）</p><p>当事件循环执行这些<code>setTimeout</code>回调时，它们都会访问到同一个变量<code>i</code>，而此时<code>i</code>已经是6了</p><p>因为所有的<code>setTimeout</code>都在一个事件循环队列中，因此它们并不会彼此间有任何延迟</p><p>因此，输出不会按照1到5的顺序打印，而是会打印5次6</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>解决这个问题</p><ol><li><p>闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>let</code>来声明<code>i</code>（ES6）, <code>let</code>会在每次迭代的循环块中创建一个新的<code>i</code>绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：代码结果（8）运行题"><a href="#Q28：代码结果（8）运行题" class="headerlink" title="Q28：代码结果（8）运行题"></a>Q28：代码结果（8）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![]的结果是什么</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>取反操作</p><p><code>![]</code> 首先计算右边的表达式</p><p><code>!</code> 操作符将对 <code>[]</code>（空数组）进行布尔取反操作</p><p>在JavaScript中，一个空数组是一个真值（truthy）</p><p>因此对它取反后，将得到布尔值 <code>false</code></p></li><li><p>等于操作</p><p>现在原始的比较已经变成了 <code>[] == false</code></p><p>在这个比较中，因为一边是对象（空数组）而另一边是布尔值</p><p>根据抽象相等性比较（Abstract Equality Comparison）的规则，JavaScript将尝试将这两边转换成一个共同的类型</p></li><li><p>类型转换<br><code>false</code> 需要转换为数值型以便跟数组进行比较</p><p>布尔值 <code>false</code> 转换为数字时值是 <code>0</code></p><p>这样，现在的比较变成了 <code>[] == 0</code></p></li><li><p>数组到字符串的转换</p><p>接下来，JavaScript会尝试将对象（本例中的空数组 <code>[]</code>）转换为原始值</p><p>数组对象转换为原始值时，会先转换为字符串</p><p>由于空数组转换为字符串是一个空字符串（<code>&quot;&quot;</code>），现在的比较就变成了 <code>&quot;&quot; == 0</code></p></li><li><p>字符串到数字的转换</p><p>因为另一边是数字，JavaScript会进一步将字符串转换为数字，空字符串转换为数字是 <code>0</code></p><p>最后，比较就变成了 <code>0 == 0</code></p></li><li><p>比较结果</p><p><code>0</code> 等于 <code>0</code>，这个比较的结果为 <code>true</code></p></li></ol><p>因此，最终 <code>[] == ![]</code> 的结果就是 <code>true</code>，这是由于JavaScript内部类型转换规则的结果</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：Promise-15-输出结果"><a href="#Q29：Promise-15-输出结果" class="headerlink" title="Q29：Promise(15)输出结果"></a>Q29：Promise(15)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;promise resolve&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 success&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt start&#x27;</span>)</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，执行全局代码，<code>console.log(&#39;script start&#39;)</code> 是第一个被执行的，所以首先输出 <code>script start</code></li><li>然后，遇到了异步函数 <code>async1()</code>。这是一个异步调用，但在内部 <code>console.log(&#39;async1 start&#39;)</code> 会首先同步执行，所以第二个输出 <code>async1 start</code></li><li>之后，遇到了 <code>await</code> 关键字，它会返回一个新的 Promise 对象。在这个 Promise 的执行器函数中，有一个 console.log(‘promise1’) 的同步操作，因此第三个输出 <code>promise1</code></li><li>Promise 对象在状态变更（这里是调用了 <code>resolve</code> 方法）前的代码属于微任务，在当前宏任务内执行。但由于 <code>async/await</code> 的特殊性，<code>await</code> 后面的代码 (<code>console.log(&#39;async1 success&#39;)</code>) 会被打包为一个微任务，等待当前的 Promise 状态变为 resolved 后进入微任务队列等待执行，至此当前的异步函数 <code>async1</code> 执行完毕</li><li>接着，继续执行全局代码，遇到另一处 Promise 构造，此时执行器函数内的 console.log(‘promise2’) 同步执行，所以第四个输出 <code>promise2</code></li><li>再下来遇到setTimeout，这是一个宏任务，会被派发到宏任务事件队列中，由于Javascript是单线程执行，所以需要等待前面的任务处理完毕，此处就先不输出 ‘timer’</li><li>此时，全局的同步代码执行完毕，开始执行微任务队列中的任务。第一个待执行的微任务是 <code>async1()</code> 中 <code>await</code> 后面的代码，所以第五个输出 <code>async1 success</code></li><li><code>async1()</code> 代码执行完毕后，它的 <code>.then()</code> 方法被调用，返回的结果是 <code>async1 end</code>，所以第六个输出 <code>async1 end</code></li><li>这时，微任务队列已经为空，开始执行宏任务队列中的任务，输出 <code>timer</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;srcipt start&quot;</span></span><br><span class="line"><span class="string">&quot;async1 start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;promise2&quot;</span></span><br><span class="line"><span class="string">&quot;async1 success&quot;</span></span><br><span class="line"><span class="string">&quot;async1 end&quot;</span></span><br><span class="line"><span class="string">&quot;timer&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：Promise-16-输出结果"><a href="#Q30：Promise-16-输出结果" class="headerlink" title="Q30：Promise(16)输出结果"></a>Q30：Promise(16)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 success&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt start&#x27;</span>)</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，<code>console.log(&#39;script start&#39;)</code> 这行代码在全局脚本中，它将首先执行，所以输出 <code>script start</code></p></li><li><p>接着，遇到 <code>async1()</code> 函数调用</p><p>由于 <code>async1</code> 是一个异步函数，它将被立即调用，但里面的代码可能不会立即完成</p></li><li><p>进入 <code>async1()</code> 函数内部，<code>console.log(&#39;async1 start&#39;)</code> 首先被同步执行，所以会输出 <code>async1 start</code></p></li><li><p>然后，代码遇到 <code>await</code> 关键词和一个新的 Promise</p><p><code>await</code> 将暂停 <code>async1</code> 函数后面的代码执行，在这个例子中就是 <code>console.log(&#39;async1 success&#39;)</code>，直到 Promise 被解决（resolve）</p><p>此时，Promise 内部调用了 <code>console.log(&#39;promise1&#39;)</code>，所以输出 <code>promise1</code></p><p>但是这个Promise从未被解决，因为它内部没有调用resolve函数，这将影响程序的后续行为，此部分的代码输出结束在此</p></li><li><p>跳出 <code>async1()</code> 函数，回到全局执行环境，紧接着执行 <code>console.log(&#39;script end&#39;)</code>，所以接下来输出 <code>script end</code></p></li><li><p>此时，全局的同步代码已经执行完毕，但是 <code>async1()</code> 中 <code>await</code> 后面的 <code>console.log(&#39;async1 success&#39;)</code> 依赖于之前的 Promise 解决</p><p>由于该 Promise 没有解决（因为没有调用 <code>resolve</code> 或者 <code>reject</code>），它将永远挂起在那里，导致紧随其后的 <code>console.log(&#39;async1 success&#39;)</code> 和 <code>.then(res =&gt; console.log(res))</code> 都不会执行</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;srcipt start&quot;</span></span><br><span class="line"><span class="string">&quot;async1 start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;srcipt end&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：Promise-17-输出结果"><a href="#Q31：Promise-17-输出结果" class="headerlink" title="Q31：Promise(17)输出结果"></a>Q31：Promise(17)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>一个用async关键字声明的异步函数<code>fn</code>，它的功能是返回一个数值</p><p>尽管函数内有两行被注释的代码，但我们只关注未被注释的那行</p><p>这段代码在执行时的行为如下：</p><ol><li><p>函数<code>fn</code>是异步的，也就是说它返回的始终是一个<code>Promise</code>对象</p><p>由于<code>async</code>函数允许你直接返回一个值（如这里的数字123），它会自动将这个值包裹在<code>Promise.resolve</code>中，即相当于返回了<code>Promise.resolve(123)</code></p></li><li><p>当<code>fn</code>被调用时，由于其返回的是一个Promise，可以链式调用<code>.then()</code>方法处理当这个Promise被解决（resolved）时的值</p></li><li><p><code>.then()</code>中的回调函数将接收到<code>fn</code>函数返回的结果作为参数，这里是数字123</p></li><li><p><code>.then()</code>回调函数调用<code>console.log(res)</code>会将这个结果输出到控制台</p></li></ol><p>因此，整个过程结束后，控制台上会输出<code>123</code></p><p>这是因为<code>fn()</code>函数返回的Promise立即被解决了，并且有值123</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：Promise-18-输出结果"><a href="#Q32：Promise-18-输出结果" class="headerlink" title="Q32：Promise(18)输出结果"></a>Q32：Promise(18)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;我是finally2返回的值&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2后面的then函数&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>代码使用了<code>Promise.resolve</code>来创建已经解决的Promise，并使用<code>.then()</code>和<code>.finally()</code>来处理这些Promise</p><p>以下是这段代码执行时的顺序和输出分析：</p><ol><li><code>Promise.resolve(&#39;1&#39;)</code>：创建一个已经解析（resolved）的Promise对象，其解析值为字符串’1’</li><li><code>.then(res =&gt; console.log(res))</code>：<code>.then</code>方法返回一个新的Promise对象，并接受resolved值为参数的调用函数。该调用函数（匿名函数<code>res =&gt; console.log(res)</code>）会在Promise完成（resolved）时被调用，并打印出res的值，也就是打印’1’</li><li><code>.finally(() =&gt; console.log(&#39;finally&#39;))</code>：不论Promise是fulfilled还是rejected，都会执行控制台打印’finally’的操作。不过，需要注意的是，<code>finally</code>的回调函数是不接受任何参数的，不影响原有的Promise的值</li></ol><p>接下来，关于第二个Promise的执行步骤如下：</p><ol><li><code>Promise.resolve(&#39;2&#39;)</code>：创建一个已经解析（resolved）的Promise对象，其解析值为字符串’2’</li><li><code>.finally(() =&gt; console.log(&#39;finally2&#39;))</code>：同样的，不论Promise是fulfilled还是rejected，都会执行打印’finally2’的操作。并且返回了一个字符串，但这个返回值会被忽略，不会传递到下一个Promise</li><li><code>.then(res =&gt; console.log(&#39;finally2后面的then函数&#39;, res))</code>：这时，因为<code>finally</code>并没有改变值，所以这里的<code>res</code>会继承前一个Promise的解析值’2’，也就是打印出’finally2后面的then函数’后面输出的是’2’</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;finally2&quot;</span></span><br><span class="line"><span class="string">&quot;finally&quot;</span></span><br><span class="line"><span class="string">&quot;finally2后面的then函数&quot;</span> <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：Promise-19-输出结果"><a href="#Q33：Promise-19-输出结果" class="headerlink" title="Q33：Promise(19)输出结果"></a>Q33：Promise(19)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then2: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then3: &quot;</span>, res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>创建了一个新的<code>Promise</code>实例，其中传递的执行器（executor）函数是立即执行的。<ul><li>在执行器内部，首先调用<code>reject(&quot;error&quot;)</code>，这将导致Promise变为拒绝（rejected）状态，并将其理由设置为字符串<code>&quot;error&quot;</code></li><li>紧接着有一个<code>resolve(&quot;success2&quot;)</code>调用。但是，一旦Promise被拒绝或解决，它的状态就不能再改变了。因此，这行调用是没有任何效果的，所以<code>resolve</code>不会执行，Promise的拒绝理由保持为<code>&quot;error&quot;</code></li></ul></li><li>跟随这个<code>Promise</code>实例的是一个<code>.then()</code>方法的调用链，其中包含两个<code>.then()</code>和一个<code>.catch()</code><ul><li>第一个<code>.then(res =&gt; console.log(&quot;then1: &quot;, res))</code>：通常情况下，<code>.then()</code>会接收到Promise的解析值，但是由于Promise是被拒绝的，所以这个<code>.then()</code>是被跳过的</li></ul></li><li><code>.then()</code>的跳过直接导致<code>.catch(err =&gt; console.log(&quot;catch: &quot;, err))</code>的执行<ul><li><code>.catch()</code>方法是用来捕获前面<code>Promise</code>链上的错误的，由于之前的Promise已经被拒绝，并带有理由<code>&quot;error&quot;</code>，所以<code>.catch()</code>会捕获到这个拒绝，并输出<code>catch: error</code></li></ul></li><li><code>.catch()</code>后面跟着另一个<code>.then(res =&gt; console.log(&quot;then3: &quot;, res))</code><ul><li><code>.catch()</code>可以处理错误，并且也返回一个新的Promise，这个Promise默认情况下是解决状态（resolved）的，除非你在<code>.catch()</code>里再抛出错误。因为在这个场景中<code>.catch()</code>里没有抛出新的错误，所以<code>.catch()</code>之后的<code>.then()</code>得到的Promise是解决状态的</li><li>这个<code>.then()</code>没有被显式给定解析值，因为它是跟在<code>.catch()</code>后面的，所以它接收的解析值是<code>undefined</code>，因此输出<code>then3: undefined</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;catch: &quot;</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="string">&quot;then3: &quot;</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：Promise-20-输出结果"><a href="#Q34：Promise-20-输出结果" class="headerlink" title="Q34：Promise(20)输出结果"></a>Q34：Promise(20)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>Promise.resolve().then...</code> 这是一个立即解决的 Promise，其 <code>.then()</code> 方法中的回调加入到微任务队列</p></li><li><p><code>const timer1 = setTimeout(...)</code> 定义了一个宏任务，将它放入宏任务队列中等待执行</p></li><li><p><code>console.log(&#39;start&#39;);</code> 直接执行，打印 <code>start</code></p><p>执行结果到目前为止：<code>start</code></p></li><li><p>此时，主线程的同步代码执行完成，事件循环首先检查微任务队列，遇到 <code>Promise.resolve().then...</code> 中的回调，执行它：</p><ul><li>打印 <code>promise1</code></li><li>定义并启动另一个宏任务 <code>timer2</code><br>执行结果累计：<code>start</code> → <code>promise1</code></li></ul></li><li><p>现在，微任务队列已为空，事件循环移向宏任务队列。第一个遇到的宏任务是 <code>timer1</code> 的回调：</p><ul><li>打印 <code>timer1</code></li><li>然后，<code>Promise.resolve().then...</code> 再次创建一个新的微任务，加入到微任务队列<br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code></li></ul></li><li><p><code>timer1</code> 执行结束后，再次检查微任务队列，发现刚刚添加的 <code>Promise.resolve().then...</code> 中的回调，执行它：</p><ul><li>打印 <code>promise2</code><br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code> → <code>promise2</code></li></ul></li><li><p>最后，执行 <code>timer2</code> 的回调（前面<code>timer1</code>和<code>timer2</code>由于几乎同时设定，执行顺序在某些环境下可能会有细微差别，但基于大多数实现，<code>timer1</code> 因为在代码中先出现，通常会先执行）：</p><ul><li>打印 <code>timer2</code><br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code> → <code>promise2</code> → <code>timer2</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;timer1&quot;</span></span><br><span class="line"><span class="string">&quot;promise2&quot;</span></span><br><span class="line"><span class="string">&quot;timer2&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：Promise-21-输出结果"><a href="#Q35：Promise-21-输出结果" class="headerlink" title="Q35：Promise(21)输出结果"></a>Q35：Promise(21)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>首先，两个 <code>Promise.resolve()</code> 几乎同时执行</p><p>因为它们都是微任务，JavaScript 会在当前执行栈清空后，立即执行这些微任务</p><p>执行顺序如下：</p><ol><li>第一个 <code>.then()</code> 回调执行，打印出 <code>0</code></li><li>同时，第二个 <code>Promise.resolve().then(() =&gt; { console.log(1) })</code> 开始执行其链中的第一个 <code>.then()</code>，打印出 <code>1</code></li><li>第一个 <code>.then()</code> 回调返回了 <code>Promise.resolve(4)</code>，这个返回值会被传递给链中的下一个 <code>.then()</code>，所以接下来的 <code>.then((res) =&gt; { console.log(res) })</code> 会在微任务队列中等待执行，这里的 <code>res</code> 将是 <code>4</code></li><li>回到第二个 Promise 链，它的第二个 <code>.then()</code> 执行，打印出 <code>2</code></li><li>第二个 Promise 链的第三个 <code>.then()</code> 执行，打印出 <code>3</code></li><li>现在回到第一个 Promise 的第二个 <code>.then()</code>，它打印出之前等待的 <code>4</code></li><li>第二个 Promise 链的剩下的 <code>.then()</code> 依次执行，打印出 <code>5</code> 和 <code>6</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：this指向（4）输出结果"><a href="#Q36：this指向（4）输出结果" class="headerlink" title="Q36：this指向（4）输出结果"></a>Q36：this指向（4）输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">fn1</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),</span><br><span class="line"> <span class="attr">fn2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn1</span>();</span><br><span class="line">obj.<span class="title function_">fn2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> obj.<span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> obj.<span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>先了解箭头函数和普通函数（在此示例中用作方法）之间的区别，尤其是在它们如何处理<code>this</code>关键字方面</p><ul><li>箭头函数<strong>不</strong>绑定<code>this</code>，它们会捕获其所在上下文的<code>this</code>值作为自己的<code>this</code>值，无论是否被new调用</li><li>普通函数（使用<code>function</code>关键字定义的函数）的<code>this</code>指向调用它时的对象，或者在使用<code>new</code>构造函数时，指向新创建的对象</li></ul><p>首先，定义一个对象<code>obj1</code>，该对象有两个函数作为属性，一个是以函数表达式方式定义，一个是以箭头函数方式定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line"> <span class="attr">fn1</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),  <span class="comment">// 这是一个箭头函数，它不会绑定自身的this</span></span><br><span class="line"> <span class="attr">fn2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;  <span class="comment">// 这是一个普通函数，它会绑定自身的this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>obj1.fn1();</code></p><p>当你在控制台调用<code>obj1.fn1()</code>时，将会执行<code>fn1</code></p><p>由于<code>fn1</code>是一个箭头函数，它不绑定自身的<code>this</code>，<code>this</code>的值取决于定义<code>fn1</code>时的上下文</p><p>又因为<code>fn1</code>在全局作用域定义，所以在非严格模式下，<code>this</code>将指向全局对象，也就是浏览器环境下的<code>window</code>对象（严格模式下，<code>this</code>将是<code>undefined</code>）</p><p>所以第一个<code>console.log</code>将打印全局对象<code>window</code></p></li><li><p><code>obj1.fn2();</code></p><p>然后你调用<code>obj1.fn2()</code>，将会执行<code>fn2</code></p><p><code>fn2</code>是一个普通方法，当它作为对象的方法被调用时，<code>this</code>会指向调用它的对象，也就是<code>obj1</code></p><p>所以第二个<code>console.log</code>将打印出<code>obj1</code></p></li><li><p><code>const x = new obj1.fn1();</code></p><p>接下来你尝试存储一个新的<code>fn1</code>实例到<code>x</code>变量</p><p>这里会产生一个问题，因为箭头函数不能用作构造函数</p><p><code>new</code>关键字需要用在包含<code>this</code>和<code>prototype</code>的普通函数上，而箭头函数不具备这二者</p><p>所以这里会抛出一个类型错误，表明<code>obj1.fn1</code>不是构造函数</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span></span><br><span class="line">&#123;<span class="attr">fn1</span>: ƒ, <span class="attr">fn2</span>: ƒ&#125;</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: obj.<span class="property">fn1</span> is not a constructor</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：Promise-22-输出结果"><a href="#Q37：Promise-22-输出结果" class="headerlink" title="Q37：Promise(22)输出结果"></a>Q37：Promise(22)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;async1 success&#x27;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先定义了一个异步函数<code>async1</code>，它包含一个错误处理的<code>try...catch</code>块和一些控制台日志输出</p><p>然后执行这个异步函数并在其返回的<code>Promise</code>上附加了一个<code>.then</code>处理程序</p><p>最后，代码执行一个<code>console.log</code></p><p>现在，让我们详细了解代码的执行流程：</p><ol><li>调用<code>async1()</code>函数</li><li>控制台输出<code>&#39;script start&#39;</code></li><li>在<code>async1</code>中，异步等待(<code>await</code>)一个被拒绝(<code>reject</code>)的<code>Promise</code></li><li><code>Promise</code>被拒绝，因此错误被抛出，接着<code>catch</code>块捕获这个错误</li><li>控制台输出捕获的错误<code>&#39;error!!!&#39;</code></li><li><code>catch</code>块完成执行后，控制台输出<code>&#39;async1&#39;</code></li><li><code>async1</code>返回一个解决(<code>resolve</code>)的<code>Promise</code></li><li>最后，<code>.then</code>处理程序接收到返回的<code>Promise</code>中的值，控制台输出<code>&#39;async1 success&#39;</code></li></ol><p>这个顺序描述了异步操作的副作用和<code>.then</code>处理程序的调用顺序</p><p>由于<code>async</code>函数使得异步代码看起来像是同步的，它可以在<code>await</code>表达式上暂停执行，直到<code>Promise</code>解决或拒绝</p><p>这也是为什么即使有错误发生，<code>async1</code>之后的代码还是会执行的原因，因为错误被<code>catch</code>块捕获处理了</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">error!!!</span><br><span class="line">async1</span><br><span class="line">async1 success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：Promise-23-输出结果"><a href="#Q38：Promise-23-输出结果" class="headerlink" title="Q38：Promise(23)输出结果"></a>Q38：Promise(23)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这里有两个异步函数：<code>async1</code>和<code>async2</code></p><p>在函数<code>async1</code>中，有一个暂停点`await async2()``</p><p><code>`await</code>关键字使得JavaScript运行时等待直到<code>Promise settles</code>，并返回其结果</p><p>现在，让我们理解一下这段代码：</p><ol><li>调用<code>async1()</code>函数</li><li>在<code>async1</code>函数内部，执行到<code>await async2()</code>，调用<code>async2()</code>函数</li><li><code>async2</code>函数开始执行，输出 <code>async2</code> ，然后返回一个Promise对象，并且这个Promise是以错误状态结束(rejected)</li><li><code>await</code>操作在碰到rejected状态的Promise时，会抛出一场错误，并立即结束当前函数的执行</li></ol><p>在这段代码中，我们没有在<code>async1</code>函数中捕获可能发生的错误(<code>async2</code>函数返回的Promise被拒绝)，所以当<code>async2</code>返回的Promise被拒绝时，它会在<code>async1</code>函数中抛出一个错误，导致<code>async1</code>函数立即结束，而且不会输出’async1’，也不会返回’async1 success’</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async2</span><br><span class="line"><span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="string">&#x27;error&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：Promise-24-输出结果"><a href="#Q39：Promise-24-输出结果" class="headerlink" title="Q39：Promise(24)输出结果"></a>Q39：Promise(24)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testSometing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行testSometing&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;testSometing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行testAsync&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test start...&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> <span class="title function_">testSometing</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> <span class="title function_">testAsync</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v2);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise start...&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test end...&quot;</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>首先执行</strong> <code>test()</code> 函数，在控制台上打印 <code>&quot;test start...&quot;</code></p></li><li><p>然后进入 <code>testSomething()</code> 函数，在控制台上打印 <code>&quot;执行testSometing&quot;</code></p><p>这个函数返回一个字符串 <code>&quot;testSometing&quot;</code>，但因为是异步函数，这个返回值会被包装在一个解析的 <code>Promise</code> 对象中</p></li><li><p><strong>然后执行</strong> <code>Promise</code> 构造函数的回调，打印 <code>&quot;promise start...&quot;</code></p><p>这个 <code>Promise</code> 立即被解析为 <code>&quot;promise&quot;</code>，此时 <code>Promise</code> 的解析在任务队列中等待执行</p></li><li><p>在所有同步代码执行完成后（此时包括在 <code>test()</code> 函数外部立即执行的 <code>console.log(&quot;test end...&quot;)</code>），打印 <code>&quot;test end...&quot;</code></p></li><li><p>之后，异步函数 <code>test()</code> 再次回到执行的控制下，<code>testSomething()</code> 函数返回的结果，也就是 <code>&quot;testSometing&quot;</code> 已经准备好，打印出来</p></li><li><p>接着，<code>testAsync()</code> 函数被调用，在控制台上打印 <code>&quot;执行testAsync&quot;</code></p><p>它返回 <code>&quot;hello async&quot;</code>，这个值封装在一个Promise中，由于已经是resolve的状态，会在后面的事件循环中输出</p></li><li><p>由于我们先前的 <code>Promise</code> 已经处于解析状态，在 <code>testAsync()</code> 完成之前，任务队列中的 <code>Promise</code> 解析输出 <code>&quot;promise&quot;</code> 实际先于 <code>hello async</code> 执行</p></li><li><p>紧接着，<code>testAsync()</code> 函数返回的 <code>&quot;hello async&quot;</code> 输出到控制台</p></li><li><p>最后，打印出包含 <code>v1</code>(<code>testSometing</code>) 和 <code>v2</code>(<code>hello async</code>) 的结果</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test start...</span><br><span class="line">执行testSometing</span><br><span class="line">promise start...</span><br><span class="line">test end...</span><br><span class="line">testSometing</span><br><span class="line">执行testAsync</span><br><span class="line">promise</span><br><span class="line">hello <span class="keyword">async</span></span><br><span class="line">testSometing hello <span class="keyword">async</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：Promise-25-输出结果"><a href="#Q40：Promise-25-输出结果" class="headerlink" title="Q40：Promise(25)输出结果"></a>Q40：Promise(25)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>调用<code>async1()</code>，这个异步函数开始执行</li><li><code>&quot;async1 start&quot;</code>被打印到控制台</li><li>在<code>async1()</code>内部，<code>await async2()</code>暂停了<code>async1()</code>的进一步执行，直到<code>async2()</code>完成。接下来，<code>async2()</code>被调用</li><li><code>async2()</code>执行并立即将一个<code>setTimeout</code>计划为0毫秒后执行。这会将回调函数（打印<code>&#39;timer&#39;</code>）加入到宏任务队列中，但实际的调用会在当前执行栈清空以及当前宏任务完成之后才发生</li><li><code>&quot;async2&quot;</code>被打印到控制台，这是<code>async2()</code>内直接执行的代码</li><li><code>async2()</code>执行完成，执行权返回到<code>async1()</code>，因为<code>async1()</code>在等待<code>async2()</code></li><li>现在回到全局上下文，执行最后的<code>console.log(&quot;start&quot;)</code>，打印 <code>&quot;start&quot;</code> 到控制台</li><li>此时，当前的调用栈和宏任务队列（当前宏任务是调用<code>async1()</code>与之后的全局上下文中的代码）都已清空。JS引擎现在会从宏任务队列中取出下一个任务，也就是<code>setTimeout</code>的回调函数</li><li><code>setTimeout</code>的回调函数执行并在控制台打印出<code>&#39;timer&#39;</code></li><li><code>&quot;async1 end&quot;</code>是在<code>async2()</code>之后在<code>async1()</code>中打印的，但由于<code>async1()</code>函数内部是由<code>await async2()</code>暂停的，所以会在<code>&quot;start&quot;</code>和<code>&#39;timer&#39;</code>之间打印</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q41：Promise-26-输出结果"><a href="#Q41：Promise-26-输出结果" class="headerlink" title="Q41：Promise(26)输出结果"></a>Q41：Promise(26)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;err!!!&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, res)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, err)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，你正在创建一个被拒绝的Promise，然后使用 <code>then</code> 方法来处理它的结果</p><p>这个 <code>then</code> 方法有两个参数：一个成功回调和一个失败回调</p><p>因为你的Promise是被拒绝的，所以失败的回调会被触发并接收到你传递的值 ‘err!!!’</p><p>注意，<code>catch</code> 并不会被执行</p><p>因为当你提供了 <code>then</code> 的失败回调后，这个回调就接管了错误处理，所以 <code>catch</code> 不会再被调用</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error err!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：Promise-27-输出结果"><a href="#Q42：Promise-27-输出结果" class="headerlink" title="Q42：Promise(27)输出结果"></a>Q42：Promise(27)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">err</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码中，首先，你创建了一个已解决的 Promise 对象，然后你在 <code>then</code> 函数中返回了相同的 Promise 对象</p><p>这会导致 Promise 陷入一个循环状态，因为它在等待自己完成</p><p>因此，这样的写法会抛出一个类型错误，表示 Promise 不能返回自身</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TypeError</span>: <span class="title class_">Chaining</span> cycle detected <span class="keyword">for</span> promise #</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：Promise-28-输出结果"><a href="#Q43：Promise-28-输出结果" class="headerlink" title="Q43：Promise(28)输出结果"></a>Q43：Promise(28)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then: &quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码中，你创建了一个已解决的 Promise 对象，在它的 <code>then</code> 方法中返回了一个新的错误对象 <code>new Error(&#39;error!!!&#39;)</code></p><p>但这样并不会导致 promise 被拒绝</p><p>如你所见，<code>then</code> 代码块中返回一个错误对象，它并不会自动地把 promise 状态变为 rejected，这就是为什么错误信息会被传递给下一个 <code>then</code> 而非 <code>catch</code></p><p>这意味着即使你创建了一个 Error 对象，并把它作为结果返回，Promise 也仍然会保持其解析状态（Resolved，也就是说状态是完成的而不是被拒绝的）</p><p>然后代码进入下一个 <code>then</code>，打印出结果 “then: Error: error!!!”</p><p>如果你想抛出错误并让其被 <code>catch</code> 捕捉，有两种方法：</p><ol><li>你可以抛出一个错误 <code>throw new Error(&#39;error!!!&#39;)</code>，而不是返回它</li><li>或者你可以返回一个被拒绝（rejected）的 Promise，比如 <code>return Promise.reject(new Error(&#39;error!!!&#39;))</code></li></ol><p>在这两种情况下，错误都会被 <code>catch</code> 块捕获并处理</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">then</span>:  <span class="title class_">Error</span>: error!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q44：Promise-29-输出结果"><a href="#Q44：Promise-29-输出结果" class="headerlink" title="Q44：Promise(29)输出结果"></a>Q44：Promise(29)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个新的 Promise 对象 <code>promise</code></p><p>在 Promise 的执行器函数中，通过 <code>setTimeout()</code> 方法设置了一个定时器，1秒（1000毫秒）后，打印 <code>&#39;timer&#39;</code> 到控制台，并且将 Promise 的状态改为已解决（resolved），解决值为字符串 <code>&#39;success&#39;</code></p><p>随后，有两个 <code>then</code> 方法被链式调用在 <code>promise</code> 上</p><p>每个 <code>then</code> 方法都注册了一个回调函数，用于处理 Promise 解决时的情形</p><p>在这个回调函数中，你打印出了 Promise 的解决值 <code>&#39;success&#39;</code> 以及从变量 <code>start</code> 至当前的时间差</p><p>由于 <code>start</code> 是在 Promise 被创建之前就记录的，这个时间差大致上代表了从 Promise 创建到它解决时经过的时间</p><p>因为设置了一个1秒的延迟，打印出的时间应该大约是1000毫秒（可能会稍微多一点，取决于执行环境和其他延迟）</p><p>两个 <code>then</code> 方法几乎会同时接收到解决值 <code>&#39;success&#39;</code>，所以它们打印出的时间差应该也会非常接近</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer</span><br><span class="line">success <span class="number">1004</span></span><br><span class="line">success <span class="number">1004</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q45：Promise-30-输出结果"><a href="#Q45：Promise-30-输出结果" class="headerlink" title="Q45：Promise(30)输出结果"></a>Q45：Promise(30)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码展示了 Promise 的处理流程，包括了拒绝（reject），捕获错误（catch），以及成功解析（resolve）的处理</p><ol><li><code>Promise.reject(1)</code> 创建了一个被拒绝的 Promise，其拒绝理由是数字 <code>1</code></li><li>随后，<code>.then(res =&gt; { console.log(res); return 2; })</code> 是一个处理解析（resolve）的 <code>then</code> 方法。但由于 Promise 已经被拒绝，这个 <code>then</code> 方法中的回调函数将不会被调用</li><li>接着，<code>.catch(err =&gt; { console.log(err); return 3 })</code> 是用于捕获错误的 <code>catch</code> 方法。由于前面的 Promise 被拒绝且没有被任何 <code>then</code> 的第二个回调参数（用于处理拒绝）捕获，所以这个 <code>catch</code> 方法将会被调用，打印出拒绝理由 <code>1</code>，并返回一个新的值 <code>3</code></li><li>最后，<code>.then(res =&gt; { console.log(res); })</code> 会处理上一个 <code>.catch</code> 返回的结果。由于 <code>.catch</code> 返回了 <code>3</code>，这个 <code>then</code> 方法将被调用，结果 <code>3</code> 会被打印出来</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q46：Promise-31-输出结果"><a href="#Q46：Promise-31-输出结果" class="headerlink" title="Q46：Promise(31)输出结果"></a>Q46：Promise(31)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码呈现了一个典型的 <code>Promise</code> 链式调用流程</p><ol><li>首先是通过 <code>Promise.resolve(1)</code> 创建了一个立即解决的 <code>Promise</code>，其解决值为数字 <code>1</code></li><li><code>.then(res =&gt; { console.log(res); return 2; })</code> 链接到了这个 <code>Promise</code>，并提供了一个回调函数。这个回调被调用时，会打印出解决值 <code>1</code>，然后返回数字 <code>2</code></li><li><code>.catch(err =&gt; { return 3; })</code> 是一个错误处理函数，但由于前面的 <code>Promise</code> 被成功解决，而不是拒绝，这个回调不会被调用</li><li>最后是另一个 <code>.then(res =&gt; { console.log(res); })</code>，它处理了前一个 <code>.then</code> 方法返回的 <code>2</code>。它的回调会打印出 <code>2</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q47：Promise-32-输出结果"><a href="#Q47：Promise-32-输出结果" class="headerlink" title="Q47：Promise(32)输出结果"></a>Q47：Promise(32)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，<code>promise</code> 被初始化为一个新的 <code>Promise</code> 对象</p><p>在其执行器函数中，依次调用了 <code>resolve</code> 和 <code>reject</code> 方法，最后又尝试调用了 <code>resolve</code></p><p>然而，<code>Promise</code> 的状态一旦改变（从“pending”变为“fulfilled”或“rejected”）就会固定下来，后续的 <code>resolve</code> 或 <code>reject</code> 调用将不会有任何效果</p><p>因此，第一次调用 <code>resolve(&quot;success1&quot;)</code> 会将 <code>promise</code> 的状态从“pending”更改为“fulfilled”，并设置其结果值为 <code>&quot;success1&quot;</code></p><p>紧接着的 <code>reject(&quot;error&quot;)</code> 和再次的 <code>resolve(&quot;success2&quot;)</code> 调用将被忽略，因为 Promise 的状态已经确定，且为“fulfilled”</p><p>接下来的 <code>.then(res =&gt; { console.log(&quot;then: &quot;, res); })</code> 用于处理 Promise 解决时的情形</p><p>因为 Promise 已经成功解决，故此回调将被调用，并打印出 <code>then: success1</code></p><p><code>.catch(err =&gt; { console.log(&quot;catch: &quot;, err); })</code> 用于捕获任何可能的拒绝情况，但由于 <code>promise</code> 成功解决而无需调用</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">then</span>:  success1</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q48：Promise-33-输出结果"><a href="#Q48：Promise-33-输出结果" class="headerlink" title="Q48：Promise(33)输出结果"></a>Q48：Promise(33)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1里的内容&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，<code>promise1</code> 被初始化为一个新的 <code>Promise</code> 对象，其内部包含一个异步操作（<code>setTimeout</code>），该操作在 1000 毫秒（1秒）后执行，将 <code>promise1</code> 的状态从“pending”更改为“fulfilled”，且解决值为 <code>&quot;success&quot;</code></p><p>在这之前，会立即打印出 <code>&quot;promise1里的内容&quot;</code></p></li><li><p>然后，几乎同时（由于事件循环，这些都是在初始化阶段同步完成的），由控制台输出 <code>&quot;promise1&quot;, promise1</code> 和 <code>&quot;promise2&quot;, promise2</code></p><p>由于JS的异步特性，这两个 <code>Promise</code> 对象此时都处于“pending”状态</p></li><li><p>接下来，第一个 <code>setTimeout</code> 的回调函数（延迟了 1 秒）执行，打印 <code>&quot;timer1&quot;</code> 并解决 <code>promise1</code></p><p>因为 <code>promise2</code> 是通过 <code>promise1.then()</code> 产生的，并在其回调中抛出了一个错误，所以 <code>promise2</code> 将会被拒绝</p></li><li><p>最后，第二个 <code>setTimeout</code>（延迟了 2 秒）的回调函数执行，打印出 <code>&quot;timer2&quot;</code> 和此时 <code>promise1</code> 和 <code>promise2</code> 的状态</p><p>此时，<code>promise1</code> 已经解决（fulfilled）且其值为 <code>&quot;success&quot;</code>，而 <code>promise2</code> 由于之前的错误抛出已经被拒绝（rejected）</p></li></ol><p>根据这个流程，控制台的输出顺序和内容应该如下：</p><ul><li><code>&quot;promise1里的内容&quot;</code>：同步打印，表示 <code>Promise</code> 初始化</li><li><code>&quot;promise1&quot;, Promise {&lt;pending&gt;}</code>：初始化时 <code>promise1</code> 的状态</li><li><code>&quot;promise2&quot;, Promise {&lt;pending&gt;}</code>：初始化时 <code>promise2</code> 的状态</li><li><code>&quot;timer1&quot;</code>：1秒后的异步打印</li><li><code>&quot;timer2&quot;</code>：2秒后的异步打印</li><li><code>&quot;promise1&quot;, Promise {&lt;fulfilled&gt;: &quot;success&quot;}</code>：2秒时 <code>promise1</code> 的状态和解决值</li><li><code>&quot;promise2&quot;, Promise {&lt;rejected&gt;: Error: error!!!}</code>：2秒时 <code>promise2</code> 的状态和拒绝原因</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise1里的内容</span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="string">&#x27;success&#x27;</span>&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="title class_">Error</span>: error!!!</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">9</span>:<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q49：Promise-34-输出结果"><a href="#Q49：Promise-34-输出结果" class="headerlink" title="Q49：Promise(34)输出结果"></a>Q49：Promise(34)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，创建了一个名为<code>promise1</code>的新 Promise</p><p>这个 Promise 在1秒后解决(‘success’)</p></li><li><p>然后，通过调用<code>promise1.then()</code>创建了另一个名为 <code>promise2</code> 的 Promise</p><p><code>promise2</code> 的回调函数在 <code>promise1</code> 解决时立即抛出一个错误，导致 <code>promise2</code> 被立即拒绝</p></li><li><p>同时，在创建 Promise 后，立即打印 <code>promise1</code> 和 <code>promise2</code></p><p>由于此时两个 Promise 都处于 pending 状态，所以看到的是两个 pending 的 Promise：<code>Promise {&lt;pending&gt;}</code></p></li><li><p>在2秒后，通过 setTimeout 打印了 <code>promise1</code> 和 <code>promise2</code> 的状态</p><p>此时，<code>promise1</code> 应该已经完成并解决 (‘success’)，而 <code>promise2</code> 由于在其 then 方法中抛出了错误，应该已经被拒绝</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 无输出，但是已经抛出错误</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="title class_">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q50：Promise-35-输出结果"><a href="#Q50：Promise-35-输出结果" class="headerlink" title="Q50：Promise(35)输出结果"></a>Q50：Promise(35)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，两个 <code>setTimeout</code> 函数作为异步操作被添加到任务队列中</p><p>它们都设定为延迟为0毫秒，但其实并不意味着它们会立即执行，相反地，它们会等到当前的同步代码全部执行完毕后，才会执行</p></li><li><p>然后，<code>console.log(&#39;start&#39;);</code>作为同步代码首先被执行并打印出<code>start</code></p></li><li><p>同步代码执行完毕后，开始执行队列中的异步任务，首先执行的是第一个添加到队列的 <code>setTimeout</code>，它会打印出<code>timer1</code>，并且在其回调函数中添加了另一个 <code>setTimeout</code></p></li><li><p>然后，继续执行下一个 <code>setTimeout</code>，打印出<code>timer2</code></p></li><li><p>最后，执行最后添加到队列中的 <code>setTimeout</code>，打印出<code>timer3</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer1&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer2&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer3&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q51：Promise-36-输出结果"><a href="#Q51：Promise-36-输出结果" class="headerlink" title="Q51：Promise(36)输出结果"></a>Q51：Promise(36)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>两个<code>setTimeout</code>调用被排定为宏任务，它们将在当前执行栈清空后的下一个事件循环迭代中执行</p></li><li><p><code>console.log(&#39;start&#39;)</code>是同步代码，会立刻执行，打印<code>start</code>到控制台</p></li><li><p>当当前的执行栈清空时，即同步代码执行完毕后，事件循环将检查微任务队列</p><p>此时，微任务队列是空的，因此事件循环进入下一步，开始执行宏任务队列中的任务</p></li><li><p>第一个<code>setTimeout</code>回调执行，打印<code>timer1</code></p><p>它内部的<code>Promise.resolve().then()</code>会创建一个微任务，该微任务会在当前宏任务完成后、下个宏任务开始前执行</p></li><li><p>第一个宏任务的微任务（<code>console.log(&#39;promise&#39;)</code>）现在执行，打印<code>promise</code></p></li><li><p>第一个<code>setTimeout</code>的宏任务及其微任务执行完毕后，事件循环继续执行下一个宏任务，即第二个<code>setTimeout</code>回调，打印<code>timer2</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer1&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer2&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q52：Promise-37-输出结果"><a href="#Q52：Promise-37-输出结果" class="headerlink" title="Q52：Promise(37)输出结果"></a>Q52：Promise(37)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这里 <code>.then(2)</code> 并不会改变 Promise 链中的值，因为 2 不是一个函数</p><p>.then()` 接受一个函数作为参数，如果你传递一个非函数的值，它将会被忽略，Promise 链中的值将不会变</p><p>然后，<code>.then(Promise.resolve(3))</code> 也同样不会改变 Promise 链中的值</p><p>这是因为 <code>.then</code> 期望一个函数作为参数，即使你给出的是一个已决的 Promise，它也不会改变当前 Promise 链中的值</p><p>你只能通过一个返回 Promise 或返回一个新值的函数来改变 Promise 链中的值</p><p>再接下来的 <code>.then(console.log)</code> 则会在控制台打印出来Promise链中的值，也就是 <code>1</code></p><p>这段代码的执行过程可以描述为：</p><ol><li><p><code>Promise.resolve(1)</code> 创建并立即解析了一个含有值 <code>1</code> 的 Promise</p><p>这个 Promise 中的值现在可以在其后的链中的 <code>.then()</code> 调用中被访问到</p></li><li><p><code>.then(2)</code> 试图将链中的值改变为 <code>2</code>，但由于 <code>2</code> 不是一个函数，所以这一步并未改变链中的值，链中的值仍为 <code>1</code></p></li><li><p><code>.then(Promise.resolve(3))</code> 试图将链中的值改变为从 <code>Promise.resolve(3)</code> 得到的 Promise 的解析值，即 <code>3</code></p><p>但同样因为 <code>Promise.resolve(3)</code> 不是一个函数，所以这一步也并未改变链中的值，链中的值仍然为 <code>1</code></p></li><li><p><code>.then(console.log)</code> 打印出当前链中的值，即 <code>1</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q53：Promise-38-输出结果"><a href="#Q53：Promise-38-输出结果" class="headerlink" title="Q53：Promise(38)输出结果"></a>Q53：Promise(38)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;resolve3&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resovle1&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resolve2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>p1</code>是一个<code>Promise</code>实例，其构造函数中包含一个异步操作（<code>setTimeout</code>）和两次立即的<code>resolve</code>调用</p></li><li><p>在<code>Promise</code>的执行器（executor）函数中，首先通过<code>setTimeout</code>设置了一个宏任务，延迟0ms后执行。然后立即执行了两次<code>resolve</code></p></li><li><p>根据<code>Promise</code>的特性，一个<code>Promise</code>对象的状态只能从<code>pending</code>变为<code>fulfilled</code>或<code>rejected</code>，且状态变化后不会再改变</p><p>因此，第一次调用<code>resolve(&#39;resovle1&#39;)</code>将会决定<code>p1</code>的状态和结果，后续的<code>resolve(&#39;resolve2&#39;)</code>和<code>setTimeout</code>中的<code>resolve(&#39;resolve3&#39;)</code>不会改变<code>p1</code>的状态或结果</p></li><li><p>第一个<code>then</code>注册的回调函数取得的<code>res</code>值是<code>&#39;resovle1&#39;</code>（由于上面提到的<code>Promise</code>的状态变化特性），所以控制台会先打印出”resovle1”</p></li><li><p>在这个<code>then</code>的回调函数中，又设置了一个<code>setTimeout</code>，延迟1000ms后执行</p><p>因为<code>setTimeout</code>会创建一个宏任务，所以这里的<code>console.log(p1)</code>会在延迟1000ms之后执行，打印出<code>p1</code>的当前状态</p><p>此时<code>p1</code>已经完成，所以会显示<code>Promise</code>完成态的相关信息</p></li><li><p>在<code>Promise</code>链的最后有一个<code>finally</code>调用</p><p>finally<code>注册的回调函数是在</code>Promise<code>完成（不管是fulfilled还是rejected）后调用的，</code>finally`不接受任何参数，所以这里打印出的是”finally undefined”</p></li><li><p><code>setTimeout</code>中设置的打印<code>&#39;timer1&#39;</code>会在所有同步代码执行完毕、事件循环到达对应的宏任务队列时执行，因此<code>&#39;timer1&#39;</code>会在<code>&#39;resovle1&#39;</code>之后、<code>&#39;finally undefined&#39;</code>之后打印</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;resolve1&#x27;</span><br><span class="line">&#x27;finally&#x27; undefined</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q54：Promise-39-输出结果"><a href="#Q54：Promise-39-输出结果" class="headerlink" title="Q54：Promise(39)输出结果"></a>Q54：Promise(39)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">async1</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 success&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="number">4</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>&quot;script start&quot;</code>首先被同步输出</p></li><li><p>调用<code>async1</code>函数，该函数首先同步输出<code>&quot;async1&quot;</code></p></li><li><p>接着设置一个定时器（<code>timer1</code>），延迟2000ms后打印<code>&quot;timer1&quot;</code>，此定时器会被放入宏任务队列中等待执行</p></li><li><p>接下来，<code>async1</code>里执行到<code>await new Promise(...)</code>，在这个Promise中<code>&quot;promise1&quot;</code>被同步输出</p><p>然而，这个Promise从未被<code>resolve</code>，导致<code>await</code>后面的代码（包括<code>&quot;async1 end&quot;</code>及函数返回值<code>&quot;async1 success&quot;</code>）不会立即执行，<code>async1</code>函数会在这里暂停执行</p></li><li><p>主线程继续执行，同步输出<code>&quot;script end&quot;</code></p></li><li><p>然后执行<code>Promise.resolve(1)</code>链</p><p>但是<code>.then(2)</code>是错误的用法，因为<code>.then</code>里应该传入函数。由于不是函数，这个<code>.then</code>不会对结果产生影响，直接传递给下一个<code>.then</code></p><p><code>Promise.resolve(3)</code>也是一个Promise，但由于它不是在<code>.then</code>的回调函数中返回，因此它也不会对链上的流程产生影响，<code>1</code>直接传递给最后一个<code>.then</code>的回调函数，导致输出<code>1</code></p></li><li><p>设置第二个定时器（<code>timer2</code>），延迟1000ms执行，也被加入宏任务队列</p></li></ol><p>需要注意的是，由于<code>async1</code>中的Promise没有<code>resolve</code>，<code>&quot;async1 end&quot;</code>和<code>&quot;async1 success&quot;</code>不会被输出，因为<code>async1</code>函数在遇到<code>await</code>操作符时暂停了执行，等待Promise解决，但这个Promise实际上永远不会被解决</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br><span class="line">1</span><br><span class="line">&#x27;timer2&#x27;</span><br><span class="line">&#x27;timer1&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q55：Promise-40-输出结果"><a href="#Q55：Promise-40-输出结果" class="headerlink" title="Q55：Promise(40)输出结果"></a>Q55：Promise(40)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">6</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="title function_">first</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>first</code> 函数被调用：<ul><li>首先，在 <code>first</code> 函数的 Promise 中打印 <code>3</code></li><li>然后，创建 <code>p</code> Promise，在 <code>p</code> 的执行器函数中首先打印 <code>7</code></li><li>在 <code>p</code> 的执行器中，<code>setTimeout</code> 被设置，预计在下一轮事件循环的宏任务中打印 <code>5</code> 并且解决该 Promise</li><li><code>p</code> 的 Promise 立即被解决，其解决值为 <code>1</code></li><li><code>first</code> 函数中的 Promise 被解决，解决值为 <code>2</code></li><li>接着，将 <code>p.then</code> 放置在微任务队列中，预计在当前执行栈清空后打印已解决的 <code>p</code> 的值 <code>1</code></li></ul></li><li>然后，同步打印 <code>4</code></li></ol><p>到这里，同步任务已经完成。接下来，事件循环检查微任务队列：</p><ol><li>它找到 <code>p.then</code>，并且打印 <code>1</code></li><li>然后找到 <code>first().then</code> 并且打印 <code>2</code></li></ol><p>这样，微任务队列清空后，事件循环继续检查宏任务队列：</p><ol><li><p>第一个宏任务是 <code>setTimeout</code> 中的回调，它打印 <code>5</code></p></li><li><p><code>setTimeout</code>的回调执行时，控制台打印出 <code>p</code> 的状态</p><p>由于此时 <code>p</code> 的状态已经解决了，它应该是一个带有解决值 <code>1</code> 的 <code>Promise {&lt;fulfilled&gt;: 1}</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">Promise&#123;&lt;fulfilled&gt;: 1&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q56：Promise-41-输出结果"><a href="#Q56：Promise-41-输出结果" class="headerlink" title="Q56：Promise(41)输出结果"></a>Q56：Promise(41)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，打印”script start”</li><li>然后，设置一个0ms后执行的setTimeout回调，这是一个宏任务被加入到宏任务队列中，等待后续的事件循环执行</li><li>调用<code>async1()</code>函数<ul><li>“async1 start”被打印</li><li>执行<code>async1()</code>中的<code>await async2()</code></li><li>调用<code>async2()</code>，”async2”被打印</li><li>然后,await操作会将<code>async1</code>函数后续的操作包装成一个微任务（这个微任务包含打印”async1 end”的操作），并将其加入微任务队列</li></ul></li><li>创建一个新的Promise，执行器中打印”promise1”</li><li>使用<code>.then</code>方法注册Promise的成功回调，在Promise状态变为fulfilled时打印”promise2”。这个回调被加入到微任务队列中</li><li>打印”script end”</li></ol><p>到这里，程序的同步部分已经完成，开始进行事件循环，处理任务队列中的微任务和宏任务</p><ol><li>由于微任务队列优先于宏任务队列执行，因此会先执行两个微任务：<ul><li>首先是<code>async1</code>函数中的微任务，打印”async1 end”</li><li>然后执行Promise的成功回调，打印”promise2”</li></ul></li><li>所有微任务执行完后，执行宏任务队列中的setTimeout回调，打印”setTimeout”</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1 start&#x27;</span><br><span class="line">&#x27;async2&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br><span class="line">&#x27;async1 end&#x27;</span><br><span class="line">&#x27;promise2&#x27;</span><br><span class="line">&#x27;setTimeout&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q57：Promise-42-输出结果"><a href="#Q57：Promise-42-输出结果" class="headerlink" title="Q57：Promise(42)输出结果"></a>Q57：Promise(42)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">promise1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally1&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="title function_">promise2</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>第一个Promise链 —— <code>promise1()</code>:</p><ol><li><code>promise1</code> 函数被调用，创建并返回一个新的<code>Promise</code>对象<code>p</code></li><li>在<code>p</code>的executor函数内部，”promise1”被打印到控制台</li><li>紧接着，<code>resolve(&#39;1&#39;)</code>调用使得Promise<code>p</code>的状态变为fulfilled</li><li><code>then</code> 方法被调用，在其中会打印出来自<code>promise1</code>的结果<code>&quot;1&quot;</code></li><li>由于<code>then</code>已经处理了Promise的fulfilled状态，<code>catch</code>块将被跳过</li><li><code>finally</code> 块始终会执行，打印”finally1”</li></ol><p>第二个Promise链 —— <code>promise2()</code>:</p><ol><li><code>promise2</code> 函数被调用，创建并返回一个新的<code>Promise</code>对象</li><li>这个新的Promise立即走向reject状态，并带有值”error”</li><li>由于没有设置<code>then</code>方法的第二个参数（为rejected状态的处理函数），所以Promise的rejected状态会被后续的<code>catch</code>块捕获</li><li><code>catch</code>块执行并打印出”error”</li><li><code>finally</code>块始终会执行，打印”finally2”</li></ol><p>以上两个Promise链是独立的，它们的输出也会独立地显示到控制台</p><p>由于JavaScript事件循环和浏览器的微任务队列的执行顺序，这些Promises的回调（<code>then</code>, <code>catch</code>, <code>finally</code>）会在同步代码执行完毕后，按照它们被添加到队列中的顺序执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;error&#x27;</span><br><span class="line">&#x27;finally1&#x27;</span><br><span class="line">&#x27;finally2&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io">Nanami Kento</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io/posts/e82d9764/">https://wutiaowu5t5.github.io/posts/e82d9764/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wutiaowu5t5.github.io" target="_blank">Nanami Kento</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/07/DZHXR21erdnGQb4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/179be34f/" title="《Css 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/ulgHOCdRZz2QP4B.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Css 面试题》</div></div></a></div><div class="next-post pull-right"><a href="/posts/376fa3ef/" title="《Vue 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Z42qJc7bzuGo9Bp.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Vue 面试题》</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/2b323cc0/" title="《Http 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/LMjgSltydQzxOm1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="title">《Http 面试题》</div></div></a></div><div><a href="/posts/556519a1/" title="《Html 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/qvzTE9WGspLbhtO.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-11</div><div class="title">《Html 面试题》</div></div></a></div><div><a href="/posts/f967bad7/" title="《React 面试题》"><img class="cover" src="https://s2.loli.net/2024/04/08/cY28rAiwQCkZDBW.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">《React 面试题》</div></div></a></div><div><a href="/posts/179be34f/" title="《Css 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/ulgHOCdRZz2QP4B.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-12</div><div class="title">《Css 面试题》</div></div></a></div><div><a href="/posts/376fa3ef/" title="《Vue 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Z42qJc7bzuGo9Bp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="title">《Vue 面试题》</div></div></a></div><div><a href="/posts/75cf67a1/" title="《前端工程化 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/9UW3r8qCnNYgXAz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">《前端工程化 面试题》</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nanami Kento</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/wutiaowu5t5"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:Gojo5t5Satoru@outlook.com" target="_blank" title="Gojo5t5Satoru@outlook.com"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="wxid-ws0099"><i class="fab fa-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="1987053649"><i class="fab fa-qq" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The blog is still under construction, stay tuned!</div></div><div class="card-widget card-visitor"><div class="item-headline"><i class="fas fa-location-arrow"></i><span>来访者</span></div><div class="item-content"><div id="welcome-info"></div><script data-pjax>var longitude="114.03028607368469";var Latitude="22.610554348016493";var txkey="NAOBZ-ETV3Z-U6FXM-ZJOMI-62Q7K-I6B4H";var ipLoacation;window.onload = () => {welcometxmap()};</script></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFDOM%E8%B7%9FBOM"><span class="toc-text">Q1：什么是DOM跟BOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q2：说说你对轮询的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E7%BB%99%E4%B8%80%E4%B8%AAdom%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%8D%95%E8%8E%B7%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E5%86%92%E6%B3%A1%EF%BC%8C%E8%AF%B4%E4%B8%8B%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%87%A0%E6%AC%A1%E4%BA%8B%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BC%9A%E5%85%88%E6%89%A7%E8%A1%8C%E5%86%92%E6%B3%A1%E8%BF%98%E6%98%AF%E6%8D%95%E8%8E%B7"><span class="toc-text">Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%9C%A8script%E6%A0%87%E7%AD%BE%E4%B8%AD%E5%86%99-export-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-text">Q4：直接在script标签中写 export 为什么会报错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9Amouseover-%E5%88%A9-mouseenter-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q5：mouseover 利 mouseenter 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6-%EF%BC%9AoffsetWidth-offsetHeight-clientWidth-clientHeight-%E4%B8%8E"><span class="toc-text">Q6 ：offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9AJS%E4%B8%AD%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">Q7：JS中怎么阻止事件冒泡和默认事件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9A"><span class="toc-text">Q8：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q9：谈谈你对事件冒泡和捕获的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9AES6%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Q10：ES6有什么新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9Axml%E5%92%8Cjson%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q11：xml和json什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88JavaScript%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">Q12：为什么JavaScript是单线程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9A%E2%80%9D%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E2%80%9D%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q13：”严格模式”是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9ANode%E8%B7%9FElement%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">Q14：Node跟Element是什么关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9DOM%E6%A0%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q15：说说你对DOM树的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q16%EF%BC%9AJavascript%E8%B7%9FCss%E6%98%AF%E6%80%8E%E4%B9%88%E9%98%BB%E5%A1%9EDOM%E6%A0%91%E6%9E%84%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="toc-text">Q16：Javascript跟Css是怎么阻塞DOM树构建的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q17%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-text">Q17：什么是变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q18%EF%BC%9AJavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Q18：JavaScript中的事件模型有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q19%EF%BC%9A-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">Q19： 什么是同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q20%EF%BC%9ACSS%E5%8A%A8%E7%94%BB%E5%92%8CJS%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E7%94%BB%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">Q20：CSS动画和JS实现的动画分别有哪些优缺点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q21%EF%BC%9A%E5%A0%86%E4%B8%8E%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q21：堆与栈有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q22%EF%BC%9AService-worker%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q22：Service worker是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q23%EF%BC%9AJSBridge%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q23：JSBridge是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q24%EF%BC%9A-JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">Q24： JavaScript 中内存泄漏有哪几种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q25%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">Q25：什么是事件代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q26%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">Q26：什么是作用域、作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q27%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AF%B9%E4%BA%8ESPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q27：说一下对于SPA的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q28%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q28：原型、原型链是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q29%EF%BC%9A%E5%AF%B9JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q29：对JS模块化方案的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q30%EF%BC%9AJavaScript%E5%AF%B9%E8%B1%A1%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q30：JavaScript对象里面的可枚举性是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q31%EF%BC%9A%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q31：对函数式编程的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q32%EF%BC%9A%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q32：对闭包的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q33%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%B7%9F%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">Q33：深拷贝跟浅拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9Atypeof-NaN%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q1：typeof NaN的结果是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">Q2：如何区分数组和对象?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Ajs%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Q3：js中如何判断一个值是否是数组类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9Anull%E5%92%8C-undefined-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q4：null和 undefined 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E2%80%991%E2%80%99-toString-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-text">Q5：’1’.toString()为什么不会报错?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9Atypeof-%E4%B8%8Einstanceof-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q6：typeof 与instanceof 有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9AJavaScript%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">Q7：JavaScript中的错误有哪几种类型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9Ajs%E4%B8%AD%E7%9A%84undefined%E5%92%8C-ReferenceError-xxx-is-not-defined-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q8：js中的undefined和 ReferenceError: xxx is not defined 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9%EF%BC%9Anull%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">Q9：null是对象吗？为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Q10：数据类型检测的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9AisNaN-%E5%92%8C-NumberisNaN-%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q11：isNaN 和 NumberisNaN 函数有什么区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E5%88%B0%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">Q1：怎么获取到一个实例对象的原型对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Q2：改变this指向的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E5%AF%B9ToPrimitive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q3：对ToPrimitive的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9AObject%E4%B8%8EMap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q4：Object与Map有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9Acookie-%E7%9A%84%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E4%B8%BA-0%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-text">Q5：cookie 的有效时间设置为 0会怎么样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9ADom%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Q6：Dom操作有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9AES6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-text">Q7：ES6中对象新增了哪些扩展?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9AProxy-%E8%83%BD%E5%A4%9F%E7%9B%91%E5%90%AC%E5%88%B0%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%90%97"><span class="toc-text">Q8：Proxy 能够监听到对象中的对象的引用吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9-%EF%BC%9A%E5%AF%BC%E8%87%B4-JavaScript-%E4%B8%AD-this-%E6%8C%87%E5%90%91%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q9 ：导致 JavaScript 中 this 指向混乱的原因是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9Ae-target%E8%B7%9Fe-currentTarget%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Q10：e.target跟e.currentTarget有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-new-target-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q11：说说你对 new.target 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">Q12：如何判断一个对象是不是空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q13：正则表达式是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9AJavascript%E9%87%8C%E9%9D%A2%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Q14：Javascript里面的继承方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9Abase64%E7%BC%96%E7%A0%81%E5%9B%BE%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E9%87%8F%E5%8F%98%E5%A4%A7"><span class="toc-text">Q15：base64编码图片，为什么会让数据量变大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E5%B0%86%E6%95%B0%E7%BB%84%E7%9A%84length%E8%AE%BE%E7%BD%AE%E4%B8%BA0%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%AE%83%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88"><span class="toc-text">Q1：将数组的length设置为0，获取它的第一个元素会返回什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">Q2：什么是类数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E7%A9%BA%E6%95%B0%E7%BB%84%E8%B0%83%E7%94%A8reduce%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">Q3：空数组调用reduce会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84reduce%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%B3%95"><span class="toc-text">Q4：数组的reduce有什么用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9Aarguments-%E8%BF%99%E7%A7%8D%E7%B1%BB%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E7%B1%BB%E6%95%B0%E7%BB%84"><span class="toc-text">Q5：arguments 这种类数组，如何遍历类数组?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9AJavscript%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Q6：Javscript数组的常用方法有哪些?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9Ajs%E7%9A%84%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Q1：js的函数声明有几种方式？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E5%AF%B9%E2%80%9C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q2：对“立即执行函数”的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Anew-fn%E4%B8%8Enew-fn%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">Q3：new fn与new fn（）有什么区别吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9AES6%E4%B8%AD%E5%87%BD%E6%95%B0%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-text">Q4：ES6中函数新增了哪些扩展?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-text">Q5：什么是尾调用优化和尾递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%BB%A5%E4%B8%8B%E7%AD%89%E5%BC%8F%E6%98%AF%E6%88%90%E7%AB%8B%E7%9A%84%E5%90%97%EF%BC%9F1-000-000-1000000"><span class="toc-text">Q1：以下等式是成立的吗？1_000_000 &#x3D;&#x3D;&#x3D; 1000000</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Q2：空值合并运算符是什么？有什么使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E8%AF%B7%E7%AE%80%E8%BF%B0-%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">Q3：请简述 &#x3D;&#x3D; 的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A-%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8"><span class="toc-text">Q4：&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;有什么区别，分别在什么情况使用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E5%A6%82%E6%9E%9Cnew%E4%B8%80%E4%B8%AA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-text">Q5：如果new一个箭头函数会怎么样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9AObject-is%EF%BC%88%EF%BC%89%E4%B8%8E%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Q6：Object.is（）与比较操作符“&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;”的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A0-1-0-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E0-3"><span class="toc-text">Q7：0.1+0.2为什么不等于0.3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9AES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84Set%E8%B7%9FMap%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A5%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9AMath-ceil%E8%B7%9FMeth-floor%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q2：Math.ceil跟Meth.floor有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9Adocument-write%E5%92%8CinnerHTML%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q3：document.write和innerHTML有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9AMath-max%E8%B7%9FMath-min%E6%80%8E%E4%B9%88%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E9%87%8C%E9%9D%A2%E5%8F%96%E6%9C%80%E5%80%BC"><span class="toc-text">Q4：Math.max跟Math.min怎么用于数组里面取最值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E5%AF%B9requestIdleCallback%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q5：对requestIdleCallback的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9Amap%E5%92%8C%E5%92%8C-filter-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q6：map和和 filter 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9Amap-%E5%92%8C-forEach-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q7：map 和 forEach 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9Aconst%E5%A3%B0%E6%98%8E%E4%BA%86%E6%95%B0%E7%BB%84%EF%BC%8C%E8%BF%98%E8%83%BDpush%E5%85%83%E7%B4%A0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">Q8：const声明了数组，还能push元素吗，为什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9-%EF%BC%9AMath-ceil-%E3%80%81Math-round-%E3%80%81Math-floor-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q9 ：Math.ceil()、Math.round()、Math.floor()三者的区别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9AtoPrecision-%E5%92%8C-toFixed-%E5%92%8C-Math-round-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q10：toPrecision 和 toFixed 和 Math.round 有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-Polyfil"><span class="toc-text">Q11：什么是 Polyfil ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9AsetTimeout-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%83%BD%E5%A4%9F%E5%8F%8A%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-text">Q12：setTimeout 为什么不能保证能够及时执行?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9AJavascript%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">Q13：Javascript字符串的常用方法有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9AaddEventListener-%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-text">Q14：addEventListener 第三个参数是干什么的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9AJavascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q16%EF%BC%9Avar%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q16：var、let、const之间有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q17%EF%BC%9APromise-then-%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E5%92%8Ccatch%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q17：Promise then 第二个参数和catch的区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q18%EF%BC%9ApostMessage-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Q18：postMessage 有哪些使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q19-%EF%BC%9Aasync-await-%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">Q19 ：async&#x2F;await 怎么进行错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q20%EF%BC%9Ascript%E6%A0%87%E7%AD%BE%E5%86%85%E7%9A%84async%E8%B7%9Fdefer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E8%B7%9F%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">Q20：script标签内的async跟defer有什么区别跟作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q21%EF%BC%9AsetTimeout%E7%9A%84%E5%BB%B6%E6%97%B6%E5%86%99%E6%88%900%EF%BC%8C%E4%B8%80%E8%88%AC%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">Q21：setTimeout的延时写成0，一般在什么场景下使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q22%EF%BC%9AwebSocket%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">Q22：webSocket如何兼容低浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q23%EF%BC%9Aajax%E3%80%81axios%E3%80%81fetch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q23：ajax、axios、fetch有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q24%EF%BC%9Afor%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q24：for…in和for…of有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q25%EF%BC%9AMap%E8%B7%9FWeakMap%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q25：Map跟WeakMap什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q26%EF%BC%9A%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E4%BD%A0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%A2%ABnew%E8%B0%83%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8"><span class="toc-text">Q26：如何确保你的构造函数只能被new调用，而不能被普通调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q27%EF%BC%9A%E6%80%8E%E4%B9%88%E4%B8%AD%E6%96%ADforEach%E5%BE%AA%E7%8E%AF"><span class="toc-text">Q27：怎么中断forEach循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q28%EF%BC%9Atry%E2%80%A6catch-%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E5%88%B0%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%90%97"><span class="toc-text">Q28：try…catch 可以捕获到异步代码中的错误吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q29%EF%BC%9AGenerator%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E4%B8%AD%E6%96%AD%E5%92%8C%E6%81%A2%E5%A4%8D%E7%9A%84"><span class="toc-text">Q29：Generator是怎么做到中断和恢复的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q30%EF%BC%9Aasync-await%E3%80%81generator%E3%80%81promise-%E8%BF%99%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E8%81%94%E5%92%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q30：async&#x2F;await、generator、promise 这三者的关联和区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q31%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9Promise-all%E5%9C%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E4%BE%9D%E7%84%B6%E6%9C%89%E6%95%88"><span class="toc-text">Q31：如何让Promise.all在抛出异常后依然有效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q32%EF%BC%9Aobject-assign%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q32：object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q33%EF%BC%9A%E5%AF%B9window-requestAnimationFrame-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">Q33：对window.requestAnimationFrame 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q34%EF%BC%9AObject-defineProperty%E4%B8%8E-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Q34：Object.defineProperty与 Proxy 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q35%EF%BC%9AES6%E4%B8%AD%E7%9A%84-Reflect-%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">Q35：ES6中的 Reflect 对象有什么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q36%EF%BC%9A%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BES6%E9%87%8C%E9%9D%A2%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">Q36：详细的介绍一下ES6里面的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q37%EF%BC%9AforEach%E8%83%BD%E4%B8%8D%E8%83%BD%E7%94%A8await"><span class="toc-text">Q37：forEach能不能用await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q38%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%A8%E5%88%86%E8%AF%B7%E6%B1%82%E4%B8%AD%EF%BC%8C%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8encodeURlComponent-%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A0%81"><span class="toc-text">Q38：为什么部分请求中，参数需要使用encodeURlComponent 进行转码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q39%EF%BC%9AObject-create%E8%B7%9Fnew%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Q39：Object.create跟new什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q40%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%B7%9F%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Q40：箭头函数跟普通函数之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q41%EF%BC%9AWebsocket%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%B3%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">Q41：Websocket中的心跳是为了解决什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q42%EF%BC%9AAxios%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Q42：Axios的原理是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q43%EF%BC%9Atry%E2%80%A6catch%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E6%9C%89%E9%97%AE%E9%A2%98"><span class="toc-text">Q43：try…catch代码是否有问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">代码运行题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9APromise-1-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q1：Promise(1)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9Athis%E6%8C%87%E5%90%91%EF%BC%881%EF%BC%89%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q2：this指向（1）输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%EF%BC%881%EF%BC%89%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q3：类型判断（1）输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%881%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q4：变量提升（1）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%887%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q5：代码结果（7）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9Athis%E6%8C%87%E5%90%91%EF%BC%882%EF%BC%89%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q6：this指向（2）输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%882%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q7：变量提升（2）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9APromise-2-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q8：Promise(2)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9-%EF%BC%9APromise-3-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q9 ：Promise(3)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9APromise-4-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q10：Promise(4)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9APromise-5-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q11：Promise(5)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9APromise-6-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q12：Promise(6)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%881%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q13：代码结果（1）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%882%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q14：代码结果（2）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%883%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q15：代码结果（3）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q16%EF%BC%9Athis%E6%8C%87%E5%90%91%EF%BC%883%EF%BC%89%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q16：this指向（3）输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q17%EF%BC%9APromise-7-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q17：Promise(7)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q18%EF%BC%9APromise-8-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q18：Promise(8)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q19%EF%BC%9APromise-9-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q19：Promise(9)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q20%EF%BC%9APromise-10-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q20：Promise(10)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q21%EF%BC%9APromise-11-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q21：Promise(11)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q22%EF%BC%9APromise-12-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q22：Promise(12)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q23%EF%BC%9APromise-13-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q23：Promise(13)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q24%EF%BC%9APromise-14-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q24：Promise(14)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q25%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%884%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q25：代码结果（4）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q26%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%885%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q26：代码结果（5）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q27%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%886%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q27：代码结果（6）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q28%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C%EF%BC%888%EF%BC%89%E8%BF%90%E8%A1%8C%E9%A2%98"><span class="toc-text">Q28：代码结果（8）运行题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q29%EF%BC%9APromise-15-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q29：Promise(15)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q30%EF%BC%9APromise-16-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q30：Promise(16)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q31%EF%BC%9APromise-17-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q31：Promise(17)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q32%EF%BC%9APromise-18-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q32：Promise(18)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q33%EF%BC%9APromise-19-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q33：Promise(19)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q34%EF%BC%9APromise-20-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q34：Promise(20)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q35%EF%BC%9APromise-21-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q35：Promise(21)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q36%EF%BC%9Athis%E6%8C%87%E5%90%91%EF%BC%884%EF%BC%89%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q36：this指向（4）输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q37%EF%BC%9APromise-22-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q37：Promise(22)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q38%EF%BC%9APromise-23-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q38：Promise(23)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q39%EF%BC%9APromise-24-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q39：Promise(24)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q40%EF%BC%9APromise-25-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q40：Promise(25)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q41%EF%BC%9APromise-26-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q41：Promise(26)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q42%EF%BC%9APromise-27-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q42：Promise(27)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q43%EF%BC%9APromise-28-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q43：Promise(28)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q44%EF%BC%9APromise-29-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q44：Promise(29)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q45%EF%BC%9APromise-30-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q45：Promise(30)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q46%EF%BC%9APromise-31-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q46：Promise(31)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q47%EF%BC%9APromise-32-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q47：Promise(32)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q48%EF%BC%9APromise-33-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q48：Promise(33)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q49%EF%BC%9APromise-34-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q49：Promise(34)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q50%EF%BC%9APromise-35-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q50：Promise(35)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q51%EF%BC%9APromise-36-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q51：Promise(36)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q52%EF%BC%9APromise-37-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q52：Promise(37)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q53%EF%BC%9APromise-38-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q53：Promise(38)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q54%EF%BC%9APromise-39-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q54：Promise(39)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q55%EF%BC%9APromise-40-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q55：Promise(40)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q56%EF%BC%9APromise-41-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q56：Promise(41)输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q57%EF%BC%9APromise-42-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">Q57：Promise(42)输出结果</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》"><img src="https://s2.loli.net/2024/05/09/DzJNVjYfem3M8wX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习ThreeJS-《Camera（官网案例）》"/></a><div class="content"><a class="title" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》">学习ThreeJS-《Camera（官网案例）》</a><time datetime="2024-04-18T07:24:24.000Z" title="发表于 2024-04-18 15:24:24">2024-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1d0a14b2/" title="学习ThreeJS-基础环境搭建"><img src="https://s2.loli.net/2024/05/09/GK9ruP7wU6qlCZn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习ThreeJS-基础环境搭建"/></a><div class="content"><a class="title" href="/posts/1d0a14b2/" title="学习ThreeJS-基础环境搭建">学习ThreeJS-基础环境搭建</a><time datetime="2024-04-17T07:24:24.000Z" title="发表于 2024-04-17 15:24:24">2024-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/54d94922/" title="Webapck创建Vue3项目"><img src="https://s2.loli.net/2024/05/09/K7VxfLSw1E6eDvR.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webapck创建Vue3项目"/></a><div class="content"><a class="title" href="/posts/54d94922/" title="Webapck创建Vue3项目">Webapck创建Vue3项目</a><time datetime="2024-04-16T07:24:24.000Z" title="发表于 2024-04-16 15:24:24">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/11f6c0d3/" title="Webpack创建React项目"><img src="https://s2.loli.net/2024/05/09/AlgtPEVUNqkTd2i.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Webpack创建React项目"/></a><div class="content"><a class="title" href="/posts/11f6c0d3/" title="Webpack创建React项目">Webpack创建React项目</a><time datetime="2024-04-15T07:24:24.000Z" title="发表于 2024-04-15 15:24:24">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8dce8b29/" title="Vite创建Vue3项目"><img src="https://s2.loli.net/2024/05/09/uCvF9qlxXWUL8mb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vite创建Vue3项目"/></a><div class="content"><a class="title" href="/posts/8dce8b29/" title="Vite创建Vue3项目">Vite创建Vue3项目</a><time datetime="2024-04-14T07:24:24.000Z" title="发表于 2024-04-14 15:24:24">2024-04-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/12/07/DZHXR21erdnGQb4.jpg')"><div id="footer-wrap"><div class="copyright">&copy;Fri Nov 12 1999 08:00:00 GMT+0800 (中国标准时间) - 2024 By Nanami Kento</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" id="change_dark_mode" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))--><!--  i.fas.fa-adjust--><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh fa-spin"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0%</span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><!--a.rightMenu-item(href="javascript:rmf.searchinThisPage();")--><!--  i.fas.fa-search--><!--  span='站内搜索'--><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><!--a.rightMenu-item(href="javascript:toggleWinbox();")--><!--  i.fas.fa-cog--><!--  span='博客设置'--><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span id="fullScreenText">进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '7b5408da757d7ca1909e',
      clientSecret: 'a34138bdde985783ed984fc84cec5538a0fe931d',
      repo: 'wutiaowu5t5.github.io',
      owner: 'wutiaowu5t5',
      admin: ['wutiaowu5t5'],
      id: 'd07c11971bd21bc740e7d87cd2cc4d69',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async src="/js/debounceInit.js"></script><script async src="/js/console.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script async src="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.js"></script><script async src="/js/share.js"></script><script async src="/js/grayscale.js"></script><script async src="/js/randomPost.js"></script><script async src="/js/positionWelcome.js"></script><script async src="/js/rightMenu.js"></script><script async src="/js/showFPS.js"></script><div id="fps"></div><script async src="/js/refresh.js"></script><script data-pjax defer src="/js/hideAsideOnMobile.js"></script><script src="/js/nightModeSwitchAnimation.js" async></script><script src="/js/readPercent.js" async></script><script src="/js/mobileReadingModeHideSidebar.js" async></script><script async src="/js/articleEchartsDarkMode.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="五条悟,六眼,咒术「苍」,反转「赫」,虚式「茈」,无量空处,狗卷,鲑鱼,金枪鱼,木鱼花,鲣鱼干,蛋黄酱,大芥,明太子,腌高菜,海带,情绪,宿傩,束缚,「契阔」,「弥虚葛笼」,鹿紫云一,「幻兽琥珀」,「龙鳞」,「反发」,「黑闪」,里梅,冰凝咒法,九十九,星之怒,凰轮,冥冥,神风,涉谷,百鬼夜行,涉谷,乙骨,模仿,钉崎,夏油,伏黑惠,虎杖,「迳庭拳」,娜娜明,「瓦落」,猪肚包,小肚叽,小葵" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="fixedcard-dashboard"><button class="fixedcard-activebtn" type="button" title="用户信息" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-info&quot;,&quot;0&quot;)"><i class="fas fa-address-book"></i></button><button class="fixedcard-activebtn" type="button" title="最新文章" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-recent-post&quot;,&quot;0&quot;)"><i class="fas fa-history"></i></button><button class="fixedcard-activebtn" type="button" title="来访者" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-visitor&quot;,&quot;0&quot;)"><i class="fas fa-earth-americas"></i></button><div class="fixedcard-user-avatar fixedcard-activebtn" onclick="RemoveFixedCardWidget()"><img class="fixedcard-user-avatar-img" src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" title="Nanami Kento"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://hexo-circle-of-friends-api-jade.vercel.app/api?user=wutiaowu5t5";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="user=wutiaowu5t5";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                //console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:260px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                //console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    //console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '0bfa3e0417864a0cb4a14ccdd2517046';
  var gaud_map_key = '7ff01b85d8ea8f50c2e71a46c46e444d';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279, 28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>