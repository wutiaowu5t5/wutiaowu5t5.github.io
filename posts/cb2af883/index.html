<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《手写JavaScript 面试题》 | Nanami Kento</title><meta name="author" content="Nanami Kento"><meta name="copyright" content="Nanami Kento"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实现目标功能Q1：二分查找难度：⭐⭐  解析                               在 JavaScript 中，可以使用几种不同的方法来实现二分查找算法，具体取决于个人的编程偏好和问题的特性。以下是几种常见的实现方式：迭代法使用 while 循环来不断缩小搜索范围，直到找到目标值或确定目标值不存在于数组中。递归法通过递归调用来实现二分查找算法，将数组分割成更小的部分无论使用">
<meta property="og:type" content="article">
<meta property="og:title" content="《手写JavaScript 面试题》">
<meta property="og:url" content="https://wutiaowu5t5.github.io/posts/cb2af883/index.html">
<meta property="og:site_name" content="Nanami Kento">
<meta property="og:description" content="实现目标功能Q1：二分查找难度：⭐⭐  解析                               在 JavaScript 中，可以使用几种不同的方法来实现二分查找算法，具体取决于个人的编程偏好和问题的特性。以下是几种常见的实现方式：迭代法使用 while 循环来不断缩小搜索范围，直到找到目标值或确定目标值不存在于数组中。递归法通过递归调用来实现二分查找算法，将数组分割成更小的部分无论使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png">
<meta property="article:published_time" content="2024-01-19T07:24:24.000Z">
<meta property="article:modified_time" content="2024-01-19T07:24:24.000Z">
<meta property="article:author" content="Nanami Kento">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png"><link rel="shortcut icon" href="/img/header.jpg"><link rel="canonical" href="https://wutiaowu5t5.github.io/posts/cb2af883/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Nanami Kento","link":"链接: ","source":"来源: Nanami Kento","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《手写JavaScript 面试题》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-19 15:24:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 17
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/all.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Nanami Kento" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div id="loading-box-me"><div id="wrapper"><div id="mouse"></div><div class="loader"></div><div class="loading-bar-me"><div class="progress-bar"></div></div><div class="status"><div class="state"></div><div class="percentage"></div></div></div></div></div><script>const preloader = {
  endLoading: () => {
    var loadingBox = document.getElementById('loading-box');
    var loadingBoxme = document.getElementById('loading-box-me');
    loadingBoxme.addEventListener('animationend', () => {setTimeout(function() {loadingBox.classList.add("loaded");}, 2000) })
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  },
  otherendLoading: () => {
    document.getElementById('loading-box').classList.add("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.otherendLoading();},10000)

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.otherendLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Nanami Kento"><span class="site-name">Nanami Kento</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-bijijilu"></i><span> 记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-fabuwenzhang"></i><span> 文章</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gl-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-grouping"></i><span> 分类</span></a></li><li><a class="site-page child" href="/articleCount/"><i class="fa-fw iconfont icon-tongji"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-suiji"></i><span> 随机跳转</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 收藏网站</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyu"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《手写JavaScript 面试题》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-19T07:24:24.000Z" title="发表于 2024-01-19 15:24:24">2024-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-19T07:24:24.000Z" title="更新于 2024-01-19 15:24:24">2024-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web/">web</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>140分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《手写JavaScript 面试题》"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="实现目标功能"><a href="#实现目标功能" class="headerlink" title="实现目标功能"></a>实现目标功能</h2><h3 id="Q1：二分查找"><a href="#Q1：二分查找" class="headerlink" title="Q1：二分查找"></a>Q1：二分查找</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 JavaScript 中，可以使用几种不同的方法来实现二分查找算法，具体取决于个人的编程偏好和问题的特性。以下是几种常见的实现方式：</p><ol><li><p>迭代法</p><p>使用 while 循环来不断缩小搜索范围，直到找到目标值或确定目标值不存在于数组中。</p></li><li><p>递归法</p><p>通过递归调用来实现二分查找算法，将数组分割成更小的部分</p></li></ol><p>无论使用哪种方法，二分查找的核心思想都是将搜索范围一分为二，通过比较中间元素和目标值的大小关系来决定继续搜索的方向，从而达到快速查找的目的</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; arr[left] || target &gt; arr[right]) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 避免数值溢出</span></span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> guess = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (guess === target) &#123;</span><br><span class="line">            <span class="comment">// 继续向左扫描，找到第一个等于目标值的索引</span></span><br><span class="line">            <span class="keyword">while</span> (arr[mid - <span class="number">1</span>] === target) &#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 返回第一个等于目标值的索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标值不存在于数组中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法：</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">binarySearch</span>(arr, target);</span><br><span class="line"><span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 的第一个索引为：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 不存在于数组中。`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>递归法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearchRecursive</span>(<span class="params">arr, target, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right || left &lt; <span class="number">0</span> || right &gt;= arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标值不存在于数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间索引</span></span><br><span class="line">    <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> guess = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (guess === target) &#123;</span><br><span class="line">        <span class="comment">// 继续向左扫描，找到第一个等于目标值的索引</span></span><br><span class="line">        <span class="keyword">while</span> (arr[mid - <span class="number">1</span>] === target) &#123;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 返回第一个等于目标值的索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearchRecursive</span>(arr, target, mid + <span class="number">1</span>, right); <span class="comment">// 在右半部分继续查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearchRecursive</span>(arr, target, left, mid - <span class="number">1</span>); <span class="comment">// 在左半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法：</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">binarySearchRecursive</span>(arr, target);</span><br><span class="line"><span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 的第一个索引为：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 不存在于数组中。`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：怎么预防用户连续快速点击，造成数据多次提交？"><a href="#Q2：怎么预防用户连续快速点击，造成数据多次提交？" class="headerlink" title="Q2：怎么预防用户连续快速点击，造成数据多次提交？"></a>Q2：怎么预防用户连续快速点击，造成数据多次提交？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>为了防止用户连续快速点击造成数据多次提交，你可以考虑以下几种方法：</p><ol><li><p><strong>防抖（Debouncing）</strong>：</p><ul><li><p>防抖是一种控制函数调用频率的技术，通过延迟执行函数来确保在一定时间内只触发一次。当用户连续快速点击时，只有最后一次点击会触发实际的操作。</p></li><li><p>在前端中，你可以使用 JavaScript 中的 <code>setTimeout</code>和 clearTimeout</p><p>来实现防抖。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在点击事件中使用防抖</span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">debounce</span>(submitData, <span class="number">1000</span>); <span class="comment">// 1000 毫秒内只会触发一次 submitData 函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>禁用按钮</strong>：</p><ul><li><p>在用户点击后，禁用提交按钮，防止连续点击。可以在提交后添加一个 loading 状态，完成后再启用按钮。</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  button.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">submitData</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>点击间隔判断</strong>：</p><ul><li><p>记录上一次点击的时间戳，在点击时判断与上一次点击的时间间隔，只有在时间间隔足够长时才执行实际的提交操作。</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastClickTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">if</span> (currentTime - lastClickTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 限定间隔为 1000 毫秒</span></span><br><span class="line">    <span class="title function_">submitData</span>();</span><br><span class="line">    lastClickTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数"><a href="#Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数" class="headerlink" title="Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数"></a>Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong>公式：(摄氏度 * 9/5) + 32</strong></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将摄氏度转换为华氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">celsiusToFahrenheit</span>(<span class="params">celsius</span>) &#123;</span><br><span class="line">  <span class="comment">// 公式：(摄氏度 * 9/5) + 32</span></span><br><span class="line">  <span class="keyword">const</span> fahrenheit = (celsius * <span class="number">9</span>/<span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(fahrenheit.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 保留两位小数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将华氏度转换为摄氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fahrenheitToCelsius</span>(<span class="params">fahrenheit</span>) &#123;</span><br><span class="line">  <span class="comment">// 公式：(华氏度 - 32) * 5/9</span></span><br><span class="line">  <span class="keyword">const</span> celsius = (fahrenheit - <span class="number">32</span>) * <span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(celsius.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 保留两位小数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> celsiusValue = <span class="number">25</span>; <span class="comment">// 25摄氏度</span></span><br><span class="line"><span class="keyword">const</span> fahrenheitValue = <span class="number">77</span>; <span class="comment">// 77华氏度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> convertedToFahrenheit = <span class="title function_">celsiusToFahrenheit</span>(celsiusValue);</span><br><span class="line"><span class="keyword">const</span> convertedToCelsius = <span class="title function_">fahrenheitToCelsius</span>(fahrenheitValue);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;celsiusValue&#125;</span>摄氏度 = <span class="subst">$&#123;convertedToFahrenheit&#125;</span>华氏度`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;fahrenheitValue&#125;</span>华氏度 = <span class="subst">$&#123;convertedToCelsius&#125;</span>摄氏度`</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：使用原生js给一个按钮绑定两个onclick事件"><a href="#Q4：使用原生js给一个按钮绑定两个onclick事件" class="headerlink" title="Q4：使用原生js给一个按钮绑定两个onclick事件"></a>Q4：使用原生js给一个按钮绑定两个onclick事件</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Multiple Click Events<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 获取按钮元素</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> myButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 第一个click事件处理函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">handleClick1</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;First click event!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 第二个click事件处理函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">handleClick2</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;Second click event!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 给按钮添加第一个click事件</span></span></span><br><span class="line"><span class="language-javascript">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick1);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 给按钮添加第二个click事件</span></span></span><br><span class="line"><span class="language-javascript">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick2);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：给某个资源的链接，如-https-www-baidu-com-index-html请实现一个方法，获取该资源的后缀，如-html"><a href="#Q5：给某个资源的链接，如-https-www-baidu-com-index-html请实现一个方法，获取该资源的后缀，如-html" class="headerlink" title="Q5：给某个资源的链接，如 https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如 html"></a>Q5：给某个资源的链接，如 <a href="https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如">https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如</a> html</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>切割</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取最后一个斜杠后面的内容</span></span><br><span class="line">    <span class="keyword">const</span> filename = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 获取最后一个点后面的内容作为后缀</span></span><br><span class="line">    <span class="keyword">const</span> extension = filename.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> extension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法首先通过拆分URL来获取文件名，然后再从文件名中获取后缀。需要注意的是，这个方法假设文件名中只有一个点作为后缀名的分隔符，并且后缀名在点后面。如果URL中包含查询参数或片段标识符，可能需要进行额外的处理以避免错误。</p></li><li><p>正则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用正则表达式匹配最后一个点后面的内容作为后缀</span></span><br><span class="line">    <span class="keyword">const</span> extension = url.<span class="title function_">match</span>(<span class="regexp">/\.([^.]+)$/</span>);</span><br><span class="line">    <span class="keyword">if</span> (extension) &#123;</span><br><span class="line">        <span class="keyword">return</span> extension[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果没有后缀，则返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法使用正则表达式 <code>\.[^.]+$</code> 来匹配最后一个点后面的内容作为后缀，然后返回匹配到的结果。如果没有找到后缀，则返回空字符串。与之前的方法相比，这种方法更加灵活，可以处理更多可能的情况。</p></li><li><p>获取索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到最后一个点的索引</span></span><br><span class="line">    <span class="keyword">const</span> lastDotIndex = url.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastDotIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 切片并获取后缀</span></span><br><span class="line">        <span class="keyword">const</span> extension = url.<span class="title function_">slice</span>(lastDotIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果没有后缀，则返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法首先使用 <code>lastIndexOf()</code> 方法找到最后一个点的索引，然后通过切片获取后缀。如果没有找到后缀，则返回空字符串。这种方法比较简洁，并且与正则表达式相比，可能具有更好的性能。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放"><a href="#Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放" class="headerlink" title="Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放?"></a>Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>要实现这样的滚动公告组件，你可以使用 JavaScript 来控制滑入和滑出事件，并结合定时器来暂停和恢复播放。下面是一个基本的实现示例：</p><p>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;announcement&quot;</span>&gt;</span>这是滚动公告内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取公告元素</span></span><br><span class="line"><span class="keyword">const</span> announcementElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;announcement&quot;</span>);</span><br><span class="line"><span class="comment">// 设置滚动公告的内容和滚动速度</span></span><br><span class="line"><span class="keyword">const</span> announcementContent = <span class="string">&quot;这是滚动公告内容，这是滚动公告内容，这是滚动公告内容&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> scrollSpeed = <span class="number">50</span>; <span class="comment">// 滚动速度（单位：毫秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义滚动公告函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollAnnouncement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    announcementElement.<span class="property">innerText</span> += <span class="string">&quot; &quot;</span> + announcementContent; <span class="comment">// 添加滚动内容</span></span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要停止滚动</span></span><br><span class="line">        <span class="keyword">if</span> (!announcementElement.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-paused&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 滚动内容</span></span><br><span class="line">            announcementElement.<span class="property">scrollLeft</span> += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果内容滚动到末尾，则重置滚动位置</span></span><br><span class="line">            <span class="keyword">if</span> (announcementElement.<span class="property">scrollLeft</span> &gt;= announcementElement.<span class="property">scrollWidth</span> - announcementElement.<span class="property">clientWidth</span>) &#123;</span><br><span class="line">                announcementElement.<span class="property">scrollLeft</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, scrollSpeed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将定时器ID存储在元素的自定义属性中</span></span><br><span class="line">    announcementElement.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-interval-id&quot;</span>, intervalId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始滚动</span></span><br><span class="line"><span class="title function_">scrollAnnouncement</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移入时暂停滚动</span></span><br><span class="line">announcementElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseenter&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取剩余等待时间</span></span><br><span class="line">    <span class="keyword">const</span> remainingTime = scrollSpeed - (announcementElement.<span class="property">scrollWidth</span> - announcementElement.<span class="property">scrollLeft</span>) % scrollSpeed;</span><br><span class="line">    <span class="comment">// 停止滚动</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(announcementElement.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-interval-id&quot;</span>));</span><br><span class="line">    announcementElement.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-paused&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 等待剩余时间后继续滚动</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        announcementElement.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-paused&quot;</span>);</span><br><span class="line">        <span class="title function_">scrollAnnouncement</span>();</span><br><span class="line">    &#125;, remainingTime);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移出时继续滚动</span></span><br><span class="line">announcementElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseleave&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继续滚动</span></span><br><span class="line">    announcementElement.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-paused&quot;</span>);</span><br><span class="line">    <span class="title function_">scrollAnnouncement</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个代码片段首先定义了一个滚动公告的容器，然后设置了滚动的速度和内容。接着定义了一个函数 <code>scrollAnnouncement()</code> 来执行滚动公告的动作，并设置了一个定时器来控制滚动的频率。在鼠标移入和移出事件中，暂停和恢复滚动的操作通过设置一个自定义属性 <code>data-paused</code> 来实现。当鼠标移入时，先暂停滚动，然后等待剩余的滚动时间后再继续滚动。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：怎么把十进制的-0-2-转换成二进制"><a href="#Q7：怎么把十进制的-0-2-转换成二进制" class="headerlink" title="Q7：怎么把十进制的 0.2 转换成二进制?"></a>Q7：怎么把十进制的 0.2 转换成二进制?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decimalToBinary</span>(<span class="params">decimal, precision</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> binary = <span class="string">&quot;0.&quot;</span>; <span class="comment">// 二进制结果的初始部分</span></span><br><span class="line">    <span class="keyword">let</span> remainder = decimal; <span class="comment">// 初始余数为十进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环指定的精度，进行乘以 2 取整操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; precision; i++) &#123;</span><br><span class="line">        <span class="comment">// 将余数乘以 2</span></span><br><span class="line">        remainder *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果结果大于等于 1，则整数部分为 1，否则为 0</span></span><br><span class="line">        <span class="keyword">if</span> (remainder &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            binary += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            remainder -= <span class="number">1</span>; <span class="comment">// 更新余数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            binary += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数进行转换，精度为 16 位</span></span><br><span class="line"><span class="keyword">const</span> binaryRepresentation = <span class="title function_">decimalToBinary</span>(<span class="number">0.2</span>, <span class="number">16</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binaryRepresentation); <span class="comment">// 输出 &quot;0.0011001100110011&quot;</span></span><br></pre></td></tr></table></figure><p>这个函数 <code>decimalToBinary()</code> 接受两个参数：要转换的十进制数和转换后二进制的精度（即位数）。然后通过循环将小数不断乘以 2，并根据结果的整数部分确定二进制的相应位数。最终返回的二进制字符串即为所需的结果。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>乘以 2 取整法和除以 2 取余法</strong></p><ol><li><strong>乘以 2 取整法</strong>：<ul><li>优点：<ul><li>不涉及除法运算，乘法运算通常比除法运算更高效，因此在某些情况下可能更快。</li><li>适用于不需要精确表示小数的情况，例如计算机中的浮点数表示。</li></ul></li><li>计算方式：<ul><li>首先将十进制数乘以 2，然后取整部分作为二进制的下一位数。</li><li>如果乘以 2 的结果大于等于 1，则记录为 1，并将结果减去 1；否则记录为 0。</li><li>然后将结果乘以 2，继续重复以上步骤，直到得到所需的位数或者小数部分为 0。</li></ul></li><li>适用场景：<ul><li>在计算机程序中，特别是涉及到浮点数转换为二进制表示时，可能更常用乘以 2 取整法。</li></ul></li></ul></li><li><strong>除以 2 取余法</strong>：<ul><li>优点：<ul><li>更直观易懂，与人们对十进制到二进制的转换过程更为熟悉。</li><li>对于需要精确表示小数的情况，除以 2 取余法可以提供更准确的结果。</li></ul></li><li>计算方式：<ul><li>首先将十进制数除以 2，然后取余数作为二进制的下一位数。</li><li>将商作为新的要除以 2 的十进制数。</li><li>继续重复以上步骤，直到得到的商为 0。</li></ul></li><li>适用场景：<ul><li>在需要精确表示小数的情况下，例如数学计算、金融领域等，除以 2 取余法可能更为适用。</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：请对以下数组，根据born”的值降序排列"><a href="#Q8：请对以下数组，根据born”的值降序排列" class="headerlink" title="Q8：请对以下数组，根据born”的值降序排列"></a>Q8：请对以下数组，根据born”的值降序排列</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singers = [  </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Steven Tyler&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Aerosmith&#x27;</span>, <span class="attr">born</span>: <span class="number">1948</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Karen Carpenter&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;The Carpenters&#x27;</span>, <span class="attr">born</span>: <span class="number">1950</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Kurt Cobain&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Nirvana&#x27;</span>, <span class="attr">born</span>: <span class="number">1967</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Stevie Nicks&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Fleetwood Mac&#x27;</span>, <span class="attr">born</span>: <span class="number">1948</span> &#125;, </span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>使用 <code>sort()</code> 方法和箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singers.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.<span class="property">born</span> - a.<span class="property">born</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>使用 reduce() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = singers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> insertIndex = acc.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; cur.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (insertIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        acc.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acc.<span class="title function_">splice</span>(insertIndex, <span class="number">0</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>这种方法使用了 reduce() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.concat() 和 for…of 循环</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> singer <span class="keyword">of</span> singers) &#123;</span><br><span class="line">    <span class="keyword">let</span> inserted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sortedSingers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singer.<span class="property">born</span> &gt; sortedSingers[i].<span class="property">born</span>) &#123;</span><br><span class="line">            sortedSingers.<span class="title function_">splice</span>(i, <span class="number">0</span>, singer);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inserted) &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">push</span>(singer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用了 for…of 循环遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.unshift() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sortedSingers[i] &amp;&amp; singer.<span class="property">born</span> &lt; sortedSingers[i].<span class="property">born</span>) i++;</span><br><span class="line">    sortedSingers.<span class="title function_">splice</span>(i, <span class="number">0</span>, singer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.push() 和 Array.prototype.pop() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = sortedSingers.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; singer.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">push</span>(singer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">splice</span>(index, <span class="number">0</span>, singer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.push() 和 Math.max() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">max</span>(...sortedSingers.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; singer.<span class="property">born</span> ? sortedSingers.<span class="title function_">indexOf</span>(item) : -<span class="number">1</span>));</span><br><span class="line">    sortedSingers.<span class="title function_">splice</span>(index + <span class="number">1</span>, <span class="number">0</span>, singer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.reduceRight() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = singers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> insertIndex = acc.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; cur.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (insertIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        acc.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acc.<span class="title function_">splice</span>(insertIndex, <span class="number">0</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>这种方法使用了 reduceRight() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果"><a href="#Q9-：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果" class="headerlink" title="Q9 ：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果?"></a>Q9 ：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作，例如请求数据或其他耗时任务</span></span><br><span class="line">        <span class="comment">// 假设这里是一个异步任务，返回处理结果</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">`Processed item: <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">        &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> promises = myList.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">asyncTask</span>(item));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise.all()：</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All tasks completed successfully:&quot;</span>, results);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error processing tasks:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 Promise.allSettled()：</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> successfulResults = results.<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">const</span> failedResults = results.<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">reason</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Successful tasks:&quot;</span>, successfulResults);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Failed tasks:&quot;</span>, failedResults);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.all()</code> 和 <code>Promise.allSettled()</code> 是两种不同的 Promise 组合方法，它们之间有一些关键的区别：</p><ol><li><strong>Promise.all()</strong>：<ul><li>当所有 Promise 都成功解决时，返回一个包含所有 Promise 结果的数组。</li><li>如果其中任何一个 Promise 被拒绝（rejected），则立即将返回的 Promise 对象标记为拒绝，并且会传递第一个被拒绝的 Promise 的拒因（rejection reason）。</li><li>如果有一个 Promise 被拒绝，那么其他 Promise 的执行依然会继续，但 <code>Promise.all()</code> 返回的 Promise 对象将被标记为拒绝，无法获取其他 Promise 的结果。</li></ul></li><li><strong>Promise.allSettled()</strong>：<ul><li>等待所有 Promise 执行完成，不管是成功还是失败，都会返回一个包含所有 Promise 执行结果的数组。</li><li>返回的 Promise 对象状态总是成功的，不会因为其中的某个 Promise 被拒绝而导致整个组合 Promise 被拒绝。</li><li>返回的数组中的每个元素都是一个对象，代表对应的 Promise 执行结果，包括状态（fulfilled 或 rejected）和对应的值或拒因。</li></ul></li></ol><p>简而言之，<code>Promise.all()</code> 等待所有 Promise 解决，如果有一个被拒绝则整个组合 Promise 被拒绝；而 <code>Promise.allSettled()</code> 等待所有 Promise 执行完成，无论成功或失败，返回的 Promise 总是成功的，并提供每个 Promise 的执行结果。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：怎么把函数中的-arguments-转成数组"><a href="#Q10：怎么把函数中的-arguments-转成数组" class="headerlink" title="Q10：怎么把函数中的 arguments 转成数组?"></a>Q10：怎么把函数中的 arguments 转成数组?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Array.from() 方法</strong>：</p><ul><li>使用 <code>Array.from()</code> 方法可以将类数组对象转换为数组。</li><li>实现原理：<code>Array.from()</code> 方法从一个类数组或可迭代对象中创建一个新的数组实例。它会遍历类数组对象的每个元素，并将其添加到新数组中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Array.prototype.slice.call() 方法</strong>：</p><ul><li>使用 <code>Array.prototype.slice.call()</code> 方法通过调用数组的 <code>slice()</code> 方法，将一个类数组对象转换为数组。</li><li>实现原理：<code>slice()</code> 方法可以接受两个参数，第一个参数是开始截取的索引，第二个参数是结束截取的索引。如果省略第二个参数，则从开始索引截取到数组末尾。因为我们没有传入任何参数，所以它会将整个类数组对象转换为数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扩展运算符 <code>...</code></strong>：</p><ul><li>使用扩展运算符 <code>...</code> 可以将一个可迭代对象展开为多个元素，并创建一个包含所有参数的数组。</li><li>实现原理：扩展运算符 <code>...</code> 可以将一个可迭代对象展开为多个元素。在这种情况下，<code>arguments</code> 对象是一个可迭代对象，因此使用 <code>...arguments</code> 可以将其展开为多个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>arguments</code> 是一个特殊的对象，用于在函数内部访问传递给函数的参数列表。它类似于数组，但并不是一个真正的数组，而是一个类数组对象（Array-like Object）。<code>arguments</code> 对象包含了所有传递给函数的参数，可以通过索引来访问每个参数。</p><p><code>arguments</code> 对象有以下特点：</p><ol><li><strong>类数组对象</strong>：<code>arguments</code> 对象类似于数组，但不是一个真正的数组，因为它没有数组的方法和属性。</li><li><strong>自动创建</strong>：<code>arguments</code> 对象在函数内部自动创建，无需显式声明或定义。</li><li><strong>包含所有参数</strong>：<code>arguments</code> 对象包含了所有传递给函数的参数，包括函数定义时声明的参数以及调用函数时传递的参数。</li><li><strong>索引访问</strong>：可以通过索引来访问 <code>arguments</code> 对象中的每个参数，索引从 0 开始。</li><li><strong>length 属性</strong>：<code>arguments</code> 对象具有 <code>length</code> 属性，表示传递给函数的参数数量。</li></ol><p>使用 <code>arguments</code> 对象可以使函数更加灵活，因为它允许函数接受任意数量的参数，而不需要提前定义函数参数的个数。然而，由于 <code>arguments</code> 对象不是一个真正的数组，因此不能直接使用数组的方法，例如 <code>push()</code> 和 <code>pop()</code>。 若要在 <code>arguments</code> 对象上使用数组方法，需要先将其转换为真正的数组。</p><p><strong>数组和类数组之间的主要区别：</strong></p><div class="table-container"><table><thead><tr><th>特点</th><th>数组（Array）</th><th>类数组对象（Array-like Object）</th></tr></thead><tbody><tr><td>数据类型</td><td>存储任意类型的数据，可以是基本类型和对象等</td><td>只能存储元素，通常是单一类型的</td></tr><tr><td>长度（Length）属性</td><td>有长度属性 <code>length</code></td><td>通常没有 <code>length</code> 属性，除非明确添加</td></tr><tr><td>可迭代性（Iterable）</td><td>可以使用迭代器方法（如 <code>forEach</code>, <code>map</code>）</td><td>通常不能直接使用数组方法，但可以通过其他方式进行遍历，如 <code>for...of</code> 或 <code>Array.from()</code></td></tr><tr><td>方法和属性</td><td>拥有数组方法和属性，如 <code>push</code>, <code>pop</code>, <code>slice</code></td><td>通常没有数组方法和属性</td></tr></tbody></table></div><p>总的来说，数组是 JavaScript 中的一种特殊对象，拥有一系列方法和属性，可以轻松地操作其元素。而类数组对象通常只能存储元素，缺乏数组的方法和属性，但有时可以通过一些技巧或转换方法来模拟数组的行为。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：写一个repeat-方法，实现字符串的复制拼接"><a href="#Q11：写一个repeat-方法，实现字符串的复制拼接" class="headerlink" title="Q11：写一个repeat 方法，实现字符串的复制拼接"></a>Q11：写一个repeat 方法，实现字符串的复制拼接</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>String.prototype.repeat() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">repeat</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.fill() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(str).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.join() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">join</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.map() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;, <span class="function">() =&gt;</span> str).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>String.prototype.padStart() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">padStart</span>(str.<span class="property">length</span> * n, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while 循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result += str;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="title function_">repeatString</span>(str, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>reduce 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc</span>) =&gt;</span> acc + str, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Polyfill 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">repeat</span>) &#123;</span><br><span class="line">    <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">repeat</span> = <span class="keyword">function</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;can\&#x27;t convert &#x27;</span> + <span class="variable language_">this</span> + <span class="string">&#x27; to object&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span> + <span class="variable language_">this</span>;</span><br><span class="line">        <span class="comment">// To convert string to integer.</span></span><br><span class="line">        count = +count;</span><br><span class="line">        <span class="comment">// Check NaN</span></span><br><span class="line">        <span class="keyword">if</span> (count != count)</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must be non-negative&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="title class_">Infinity</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must be less than infinity&#x27;</span>);</span><br><span class="line">        count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(count);</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="property">length</span> == <span class="number">0</span> || count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// Ensuring count is a 31-bit integer allows us to heavily optimize the</span></span><br><span class="line">        <span class="comment">// main part. But anyway, most current (August 2014) browsers can&#x27;t handle</span></span><br><span class="line">        <span class="comment">// strings 1 &lt;&lt; 28 chars or longer, so:</span></span><br><span class="line">        <span class="keyword">if</span> (str.<span class="property">length</span> * count &gt;= <span class="number">1</span> &lt;&lt; <span class="number">28</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must not overflow maximum string size&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> maxCount = str.<span class="property">length</span> * count;</span><br><span class="line">        count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">log</span>(count) / <span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">while</span> (count) &#123;</span><br><span class="line">            str += str;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        str += str.<span class="title function_">substring</span>(<span class="number">0</span>, maxCount - str.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><strong>String.prototype.repeat() 方法</strong>：<ul><li>API：<code>String.prototype.repeat(count)</code></li><li>参数：<code>count</code>，一个非负整数，表示要重复字符串的次数。</li><li>返回值：返回一个新的字符串，该字符串包含指定次数的原始字符串拼接在一起的结果。</li></ul></li><li><strong>Array.prototype.fill() 方法</strong>：<ul><li>API：<code>Array.prototype.fill(value, start, end)</code></li><li>参数：<code>value</code>，要填充到数组中的值；<code>start</code>，填充的起始索引（可选，默认为0）；<code>end</code>，填充的结束索引（可选，默认为数组末尾）。</li><li>返回值：修改后的数组。</li></ul></li><li><strong>Array.prototype.join() 方法</strong>：<ul><li>API：<code>Array.prototype.join(separator)</code></li><li>参数：<code>separator</code>，一个可选的字符串，用作分隔符，将数组中的每个元素连接在一起。如果省略，则默认使用逗号作为分隔符。</li><li>返回值：返回一个由数组元素组成的字符串，每个元素之间由分隔符分隔。</li></ul></li><li><strong>Array.prototype.map() 方法</strong>：<ul><li>API：<code>Array.prototype.map(callback, thisArg)</code></li><li>参数：<code>callback</code>，一个用于处理数组元素的函数，该函数接收三个参数：当前值（currentValue）、当前索引（index）、原数组（array）；<code>thisArg</code>，可选参数，用作执行回调时的 this 值。</li><li>返回值：返回一个新数组，数组中的每个元素都是回调函数的结果。</li></ul></li><li><strong>String.prototype.padStart() 方法</strong>：<ul><li>API：<code>String.prototype.padStart(targetLength, padString)</code></li><li>参数：<code>targetLength</code>，目标字符串的长度；<code>padString</code>，一个可选的填充字符串，默认为空格。</li><li>返回值：返回一个新的字符串，该字符串由原始字符串重复填充至目标长度后返回。</li></ul></li><li><strong>Polyfill 方法</strong>：<ul><li>这是一个用于解决在不支持 <code>String.prototype.repeat()</code> 方法的环境中提供兼容性的方法。</li><li>它检查是否存在 <code>String.prototype.repeat()</code> 方法，如果不存在则定义一个 Polyfill 方法，否则不做任何操作。</li><li>该 Polyfill 方法实现了重复字符串的功能，与原生的 <code>String.prototype.repeat()</code> 方法功能相同。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：使用is生成1-10000的数组"><a href="#Q12：使用is生成1-10000的数组" class="headerlink" title="Q12：使用is生成1-10000的数组"></a>Q12：使用is生成1-10000的数组</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10000</span> &#125;, <span class="function">(<span class="params">_, index</span>) =&gt;</span> index + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这段代码将创建一个长度为 10000 的数组，并使用箭头函数来填充数组的每个元素，使其从 1 到 10000。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：移动端的点击事件的有延迟，时间是多久，为什么会有-怎么解决这个延时"><a href="#Q13：移动端的点击事件的有延迟，时间是多久，为什么会有-怎么解决这个延时" class="headerlink" title="Q13：移动端的点击事件的有延迟，时间是多久，为什么会有?怎么解决这个延时?"></a>Q13：移动端的点击事件的有延迟，时间是多久，为什么会有?怎么解决这个延时?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>移动端点击事件的延迟通常称为”点击延迟”（Click Delay），在某些移动设备和浏览器中会存在这个问题。这种延迟的主要原因是浏览器为了等待可能的双击事件（double tap），以便在用户进行双击时执行相应的操作。</p><p>这个点击延迟的时间通常在 300 毫秒左右，具体时间可能因浏览器和设备而异。</p><p>解决这个延时的常见方法包括：</p><ol><li><p><strong>使用 <code>touchstart</code> 事件</strong></p><p><code>touchstart</code> 事件触发的速度更快，可以替代 <code>click</code> 事件</p><p>但需要注意的是，<code>touchstart</code> 事件与 <code>click</code> 事件有一些区别，如在移动设备上长按屏幕时不会触发 <code>click</code> 事件，但会触发 <code>touchstart</code> 事件</p></li><li><p><strong>使用 CSS 属性 <code>touch-action: none</code></strong></p><p>通过在元素上设置 <code>touch-action: none</code> CSS 属性来禁用浏览器的默认行为，从而避免点击延迟</p><p>这个方法可能会影响到页面的默认滚动行为，需要根据具体情况来决定是否使用</p></li><li><p><strong>使用第三方库或框架</strong></p><p>一些 JavaScript 库或框架（如 FastClick、TapJS 等）专门用于解决移动端点击延迟的问题</p><p>这些库通常会在内部优化事件处理逻辑，以提供更快的响应速度</p></li><li><p><strong>meta 标签设置</strong></p><p>可以使用 <code>&lt;meta&gt;</code> 标签中的 <code>viewport</code> 属性来控制页面的缩放行为，通过设置 <code>user-scalable=no</code> 来禁止用户缩放页面，可以减少点击延迟</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，禁止用户缩放页面可能会影响用户体验，因此需要谨慎使用</p></li><li><p><strong>优化页面性能</strong></p><p>优化页面的性能和加载速度，减少资源的请求和加载时间，可以间接地减少点击延迟</p><p>特别是减少 JavaScript 和 CSS 文件的大小和数量，以及优化图片资源的加载方式</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：如何判断当前脚本运行在浏览器还是-node-环境中"><a href="#Q14：如何判断当前脚本运行在浏览器还是-node-环境中" class="headerlink" title="Q14：如何判断当前脚本运行在浏览器还是 node 环境中?"></a>Q14：如何判断当前脚本运行在浏览器还是 node 环境中?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在浏览器环境中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前环境是浏览器&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在 Node.js 环境中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前环境是 Node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未知环境</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未知环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，可以通过检查全局对象来判断当前脚本是在浏览器环境还是 Node.js 环境中运行。在浏览器环境中，全局对象是 <code>window</code>，而在 Node.js 环境中，全局对象是 <code>global</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：前端路由’a-gt-b-gt-c-这样前进，也可以返回c-gt-b-gt-a，用什么数据结构来存比较高效"><a href="#Q15：前端路由’a-gt-b-gt-c-这样前进，也可以返回c-gt-b-gt-a，用什么数据结构来存比较高效" class="headerlink" title="Q15：前端路由’a -&gt;b-&gt;c`这样前进，也可以返回c-&gt;b-&gt;a，用什么数据结构来存比较高效"></a>Q15：前端路由’a -&gt;b-&gt;c`这样前进，也可以返回c-&gt;b-&gt;a，用什么数据结构来存比较高效</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">backStack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">forwardStack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="params">page</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = page;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// 清空前进栈，因为导航到新页面后不能再前进</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 用户导航到a</span></span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 用户从a导航到b</span></span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 用户从b导航到c</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">back</span>();    <span class="comment">// 用户点击后退，从c回到b</span></span><br><span class="line">router.<span class="title function_">back</span>();    <span class="comment">// 用户再次点击后退，从b回到a</span></span><br><span class="line">router.<span class="title function_">forward</span>(); <span class="comment">// 用户点击前进，从a前进到b</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>navigate</code>方法用于模拟用户导航到新页面的行为，<code>back</code>方法和<code>forward</code>方法分别用于后退和前进。使用栈结构允许我们保持一个清晰的历史记录，并且能够以逆序访问这些记录，这正是我们在浏览器历史中所期望的行为。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>前进栈（Forward Stack）</strong>: 当用户从一个页面导航到另一个页面时，将当前页面推入前进栈。</li><li><strong>后退栈（Back Stack）</strong>: 当用户点击后退时，将当前页面推入后退栈，并从前进栈中弹出顶部页面来显示。</li><li><strong>前进</strong>: 当用户点击前进按钮时，将当前页面推入后退栈，并从前进栈中弹出顶部页面来显示。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在计算机科学中，管理这种前进和后退（前进和后退导航）的一种有效方法是使用两个栈（堆栈）——一个用于前进历史，另一个用于后退历史。这种方法在许多浏览器的历史功能的实现中被采用</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：怎么预防用户快速连续点击，造成数据多次提交"><a href="#Q16：怎么预防用户快速连续点击，造成数据多次提交" class="headerlink" title="Q16：怎么预防用户快速连续点击，造成数据多次提交"></a>Q16：怎么预防用户快速连续点击，造成数据多次提交</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>为了防止重复提交，前端一般会在第一次提交的结果返回前，将提交按钮禁用</p><ol><li><p><strong>禁用按钮</strong>：</p><ul><li><p>在提交操作后立即禁用按钮，防止用户再次点击，直到操作完成或过一段时间后重新启用按钮。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#submitButton&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    button.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> button.<span class="property">disabled</span> = <span class="literal">false</span>)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> button.<span class="property">disabled</span> = <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>节流（Throttle）或防抖（Debounce）</strong>：</p><ul><li><p>使用节流或防抖函数控制点击事件的频率，限制在特定时间内只允许触发一次。</p></li><li><p>示例代码（防抖）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> submitDataDebounced = <span class="title function_">debounce</span>(submitData, <span class="number">3000</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, submitDataDebounced);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>状态管理</strong>：</p><ul><li><p>使用状态管理追踪提交的状态，如果某次提交尚未完成，则拒绝新的提交。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isSubmitting = <span class="literal">false</span>;</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSubmitting) <span class="keyword">return</span>;</span><br><span class="line">    isSubmitting = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> isSubmitting = <span class="literal">false</span>)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> isSubmitting = <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全屏遮罩</strong>：</p><ul><li><p>显示一个全屏遮罩元素阻止用户在关键操作期间与页面交互。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mask = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">mask.<span class="property">style</span> = <span class="string">&#x27;position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; display: none;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mask);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">showMask</span> = (<span class="params"></span>) =&gt; mask.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hideMask</span> = (<span class="params"></span>) =&gt; mask.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">showMask</span>();</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">hideMask</span>())</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="title function_">hideMask</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：实现以下转换，合并连续的数字"><a href="#Q17：实现以下转换，合并连续的数字" class="headerlink" title="Q17：实现以下转换，合并连续的数字"></a>Q17：实现以下转换，合并连续的数字</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">15</span>]=&gt;[<span class="string">&#x27;1-&gt;4&#x27;</span>,<span class="string">&#x27;6-&gt;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="string">&#x27;15&#x27;</span>]</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>mergeConsecutiveNumbers</code> 函数的思路是将输入数组中的连续数字范围合并成字符串形式，然后返回这些合并后的字符串列表。具体的思路如下：</p><ol><li><strong>参数验证</strong>：<ul><li>首先，函数会验证输入是否为非空数组，以避免空数组或非数组的输入导致的潜在错误</li><li>如果输入不是数组或者数组为空，则函数直接返回空数组</li></ul></li><li><strong>初始化</strong>：<ul><li>初始化一个结果数组 <code>result</code>，用于存储最终的合并结果</li><li>定义变量 <code>start</code> 和 <code>end</code>，表示当前连续数字范围的开始和结束。初始值均为输入数组的第一个元素</li></ul></li><li><strong>帮助函数</strong>：<ul><li>定义一个名为 <code>addRangeToResult</code> 的帮助函数，用于将连续数字范围添加到结果数组 <code>result</code> 中</li><li>如果开始和结束是相同的，则表示这是一个单独的数字；否则表示这是一个连续的数字范围</li></ul></li><li><strong>遍历输入数组</strong>：<ul><li>遍历输入数组，从索引 1 开始（因为初始值已经处理了第一个元素）</li><li>对于每一个元素 <code>current</code>，检查其是否与 <code>end + 1</code> 相等。如果是，说明 <code>current</code> 是连续的数字，更新 <code>end</code> 变量</li><li>如果 <code>current</code> 不等于 <code>end + 1</code>，则表示当前元素不是连续数字的一部分。在这种情况下，调用 <code>addRangeToResult</code> 函数将当前范围添加到结果数组中，然后重置 <code>start</code> 和 <code>end</code> 为当前元素</li></ul></li><li><strong>处理最后一个范围</strong>：<ul><li>在循环结束后，函数调用 <code>addRangeToResult</code> 函数来处理最后一个范围（因为在遍历结束后，可能还有未处理的范围）</li></ul></li><li><strong>返回结果</strong>：<ul><li>最后，函数返回结果数组 <code>result</code>，其中包含了输入数组中的合并后的连续数字范围</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeConsecutiveNumbers</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(input) || input.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化范围的开始和结束</span></span><br><span class="line">    <span class="keyword">let</span> start = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> end = start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 帮助函数来添加范围到结果数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addRangeToResult</span> = (<span class="params">start, end</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (start === end) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(start.<span class="title function_">toString</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;start&#125;</span>-&gt;<span class="subst">$&#123;end&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输入数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; input.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> current = input[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前数字与前一个数字连续</span></span><br><span class="line">        <span class="keyword">if</span> (current === end + <span class="number">1</span>) &#123;</span><br><span class="line">            end = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将当前范围添加到结果数组</span></span><br><span class="line">            <span class="title function_">addRangeToResult</span>(start, end);</span><br><span class="line">            <span class="comment">// 开始一个新的范围</span></span><br><span class="line">            start = current;</span><br><span class="line">            end = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后一个范围</span></span><br><span class="line">    <span class="title function_">addRangeToResult</span>(start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例输入</span></span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并输出结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mergeConsecutiveNumbers</span>(input));  <span class="comment">// 输出 [&#x27;1-&gt;4&#x27;, &#x27;6-&gt;7&#x27;, &#x27;9&#x27;, &#x27;13&#x27;, &#x27;15&#x27;]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：非递归遍历二叉树"><a href="#Q18：非递归遍历二叉树" class="headerlink" title="Q18：非递归遍历二叉树"></a>Q18：非递归遍历二叉树</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在数据结构和算法中，非递归遍历二叉树是指通过迭代的方式来遍历二叉树，而不是使用递归的方法。二叉树的遍历方式主要有三种：前序遍历、中序遍历和后序遍历。接下来，我将分别介绍这些遍历方式的非递归实现。</p><p><strong>前序遍历（Pre-order Traversal）：</strong></p><p>在前序遍历中，遍历顺序是根节点 -&gt; 左子树 -&gt; 右子树。非递归实现通常使用栈来模拟递归过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentNode = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNode.<span class="property">value</span>); <span class="comment">// 处理当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将右子节点入栈，因为栈是后进先出</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">right</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再将左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">left</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历（In-order Traversal）：</strong></p><p>在中序遍历中，遍历顺序是左子树 -&gt; 根节点 -&gt; 右子树。非递归实现通常使用栈来辅助遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> currentNode = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (currentNode || stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 向左走到底，将所有左子节点入栈</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode);</span><br><span class="line">            currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 弹出一个节点并处理</span></span><br><span class="line">        currentNode = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNode.<span class="property">value</span>); <span class="comment">// 处理当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续遍历右子树</span></span><br><span class="line">        currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历（Post-order Traversal）：</strong></p><p>在后序遍历中，遍历顺序是左子树 -&gt; 右子树 -&gt; 根节点。非递归实现有几种方法，通常使用栈进行辅助。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stack1 = [];</span><br><span class="line">    <span class="keyword">const</span> stack2 = [];</span><br><span class="line">    stack1.<span class="title function_">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两个栈来处理</span></span><br><span class="line">    <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentNode = stack1.<span class="title function_">pop</span>();</span><br><span class="line">        stack2.<span class="title function_">push</span>(currentNode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将左子树和右子树依次入栈</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">left</span>) &#123;</span><br><span class="line">            stack1.<span class="title function_">push</span>(currentNode.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">right</span>) &#123;</span><br><span class="line">            stack1.<span class="title function_">push</span>(currentNode.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 stack2 中弹出所有节点即为后序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (stack2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack2.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>); <span class="comment">// 处理节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的非递归遍历实现，你可以在不使用递归的情况下对二叉树进行前序遍历、中序遍历和后序遍历。这些实现都使用了栈来模拟递归过程，以达到非递归遍历的目的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19-：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"><a href="#Q19-：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名" class="headerlink" title="Q19 ：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"></a>Q19 ：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回数据类型的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTypeOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查参数是否为 null 或 undefined</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;null or undefined&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Object.prototype.toString.call(obj) 获取对象的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理自定义类的类名</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="property">constructor</span> &amp;&amp; obj.<span class="property">constructor</span>.<span class="property">name</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.<span class="property">constructor</span>.<span class="property">name</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果无法获取类名，返回 &#x27;Object&#x27; 作为兜底类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型直接返回类型信息</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> myObject = <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="string">&#x27;Example&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myString = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> myNumber = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myObject)); <span class="comment">// 输出: MyClass</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myArray));  <span class="comment">// 输出: [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myString)); <span class="comment">// 输出: [object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myNumber)); <span class="comment">// 输出: [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myFunction)); <span class="comment">// 输出: [object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(<span class="literal">null</span>)); <span class="comment">// 输出: null or undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(<span class="literal">undefined</span>)); <span class="comment">// 输出: null or undefined</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>谢谢你提醒我可以详细一些。下面是对比 JavaScript 中几种判断数据类型的方法的表格形式，包括它们的优点和缺点：</p><div class="table-container"><table><thead><tr><th>判断类型方法</th><th>优点</th><th>缺点</th><th>示例代码</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>- 简单易用，代码简洁。<br>- 对于基本数据类型（如字符串、数字、布尔值、函数、未定义）判断准确。</td><td>- 对于对象、数组和 <code>null</code>，返回的结果不准确。<br>- <code>null</code> 的判断结果是 <code>&quot;object&quot;</code>，这可能导致混淆。<br>- 无法区分复杂数据类型（如数组和对象）。</td><td><img src="https://s2.loli.net/2024/04/18/1HAIVxder26quki.png" alt="image-20240418185016079"></td></tr><tr><td><code>instanceof</code></td><td>- 判断对象是否属于某个类（包括内置的类，如 <code>Array</code>、<code>Date</code>）。<br>- 适用于对象的类继承关系判断。</td><td>- 对于原始数据类型（如字符串、数字等）无效。<br>- 无法区分原始数据类型和其包装对象（例如 <code>String</code> 对象和字符串）。</td><td><img src="https://s2.loli.net/2024/04/18/nVsqZrO1i7PTXko.png" alt="image-20240418185032946"></td></tr><tr><td><code>Object.prototype.toString.call()</code></td><td>- 对各种类型（包括 <code>null</code> 和 <code>undefined</code>）返回明确的类型信息。<br>- 可以准确判断复杂数据类型（如数组、日期、正则表达式等）。</td><td>- 代码较长，不如 <code>typeof</code> 简洁。</td><td><img src="https://s2.loli.net/2024/04/18/q1TWJsSnPHO369X.png" alt="image-20240418185041665"></td></tr><tr><td><code>Array.isArray()</code></td><td>- 专门用于判断数组，判断准确。</td><td>- 只能判断数组类型，无法判断其他类型。</td><td><img src="https://s2.loli.net/2024/04/18/ZuJPcS4lAkLzpDq.png" alt="image-20240418185052865"></td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：JQuery的链式调用怎么实现的"><a href="#Q20：JQuery的链式调用怎么实现的" class="headerlink" title="Q20：JQuery的链式调用怎么实现的"></a>Q20：JQuery的链式调用怎么实现的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 jQuery 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jQuery</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟选择器操作</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">elements</span> = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟设置 CSS 样式的方法</span></span><br><span class="line">    <span class="title function_">css</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">style</span>[property] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟添加 CSS 类的方法</span></span><br><span class="line">    <span class="title function_">addClass</span>(<span class="params">className</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">classList</span>.<span class="title function_">add</span>(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟设置元素内容的方法</span></span><br><span class="line">    <span class="title function_">html</span>(<span class="params">content</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">innerHTML</span> = content;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 jQuery 对象并进行链式调用</span></span><br><span class="line"><span class="keyword">const</span> $div = <span class="keyword">new</span> <span class="title function_">jQuery</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    .<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)    <span class="comment">// 设置字体颜色为红色</span></span><br><span class="line">    .<span class="title function_">addClass</span>(<span class="string">&#x27;highlight&#x27;</span>)   <span class="comment">// 添加 CSS 类名</span></span><br><span class="line">    .<span class="title function_">html</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);  <span class="comment">// 设置元素内容为 &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($div); <span class="comment">// 输出 jQuery 对象，包含了设置后的元素</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>jQuery 的链式调用是通过在每个 jQuery 方法中返回 jQuery 对象的引用来实现的</p><p>当你调用一个 jQuery 方法时，该方法会修改 jQuery 对象的状态，并返回修改后的 jQuery 对象，从而使得可以连续调用其他 jQuery 方法</p><p>这种链式调用的实现方式可以使得 jQuery 代码更加清晰和易于编写，同时也能够提高代码的可读性和可维护性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：怎么检测浏览器的版本"><a href="#Q21：怎么检测浏览器的版本" class="headerlink" title="Q21：怎么检测浏览器的版本"></a>Q21：怎么检测浏览器的版本</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>监测浏览器版本是通过获取用户浏览器的 User Agent 字符串，并解析该字符串来获取浏览器的名称和版本信息</p><p>通常情况下，User Agent 字符串会包含浏览器的相关信息，包括名称、版本号和操作系统等</p><p>以下是一种常见的检测浏览器版本的方法：</p><ol><li>使用 <code>navigator.userAgent</code> 获取用户浏览器的 User Agent 字符串</li><li>根据 User Agent 字符串中是否包含特定浏览器的标识来确定浏览器的类型。常见的浏览器标识包括 <code>&quot;Chrome&quot;</code>、<code>&quot;Firefox&quot;</code>、<code>&quot;Safari&quot;</code>、<code>&quot;Edge&quot;</code>、<code>&quot;MSIE&quot;</code> 等</li><li>通过正则表达式匹配来提取出浏览器的版本信息。通常情况下，浏览器的版本号会跟在浏览器名称后面，并且以斜杠 <code>/</code> 分隔，例如 <code>&quot;Chrome/92.0.4515.159&quot;</code></li><li>根据不同的浏览器类型和版本信息，进行相应的处理或输出</li></ol><p>这种方法是一种基于 User Agent 字符串的检测浏览器版本的常用方法。然而，需要注意的是，User Agent 字符串可以被篡改，因此在实际应用中可能会存在一定的不准确性</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取浏览器的 user agent 字符串</span></span><br><span class="line"><span class="keyword">var</span> userAgent = navigator.<span class="property">userAgent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义浏览器名称与对应版本匹配的正则表达式</span></span><br><span class="line"><span class="keyword">var</span> browserRegex = &#123;</span><br><span class="line">    <span class="string">&quot;Chrome&quot;</span>: <span class="regexp">/Chrome\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Firefox&quot;</span>: <span class="regexp">/Firefox\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Edge&quot;</span>: <span class="regexp">/Edge\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Safari&quot;</span>: <span class="regexp">/Version\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;IE&quot;</span>: <span class="regexp">/(?:MSIE |rv:)(\d+)/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测浏览器的版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> browser <span class="keyword">in</span> browserRegex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userAgent.<span class="title function_">indexOf</span>(browser) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> version = userAgent.<span class="title function_">match</span>(browserRegex[browser])[<span class="number">1</span>];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(browser + <span class="string">&quot; 版本：&quot;</span> + version);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 找到匹配的浏览器后立即跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有找到匹配的浏览器，输出提示信息</span></span><br><span class="line"><span class="keyword">if</span> (!version) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法检测浏览器版本。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>Feature Detection（特性检测）</strong></p><p>通过检测浏览器是否支持某些特定的 JavaScript 特性或 API 来判断浏览器版本</p><p>不同版本的浏览器可能会实现不同的特性或 API，因此可以根据特性的支持情况来推断浏览器版本</p><p>这种方法不依赖于 User Agent 字符串，更加可靠，但需要了解不同浏览器版本对特性的支持情况</p></li><li><p><strong>嗅探技术（Sniffing）</strong></p><p>通过检测浏览器的行为、属性或功能来确定其类型和版本</p><p>例如，可以检测浏览器的渲染引擎、JavaScript 引擎、CSS 属性支持情况等</p><p>嗅探技术相对复杂，需要针对不同浏览器进行详细的测试和分析，但可以提供更准确的浏览器识别结果</p></li><li><p><strong>服务端检测</strong></p><p>在服务器端进行浏览器检测</p><p>当浏览器向服务器发送请求时，服务器可以通过解析请求的 User Agent 字符串来确定浏览器类型和版本，并返回相应的内容或页面</p><p>这种方法相对可靠，但需要在服务器端进行处理，可能会增加服务器的负载和复杂度</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：什么是单点登录，以及如何进行实现"><a href="#Q22：什么是单点登录，以及如何进行实现" class="headerlink" title="Q22：什么是单点登录，以及如何进行实现"></a>Q22：什么是单点登录，以及如何进行实现</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>一、单点登录是什么</strong></p><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p><p>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p><p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p><p><img src="https://s2.loli.net/2024/05/10/chsjAqRGB3Vba4X.png" alt="image-20240510155436715"></p><p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p><p><strong>举个例子</strong></p><p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p><p><strong>二、如何实现</strong></p><p><strong>同域名下的单点登录</strong></p><p><code>cookie</code>的<code>domin</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p><p>利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com</code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p><p><strong>不同域名下的单点登录(一)</strong></p><p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p><p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p><p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p><p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p><p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p><p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p><p><strong>不同域名下的单点登录(二)</strong></p><p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p><p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端</p><p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p><p>关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token </span></span><br><span class="line"><span class="keyword">var</span> hl-= result.<span class="property">data</span>.<span class="property">token</span>; </span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML </span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe); </span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&quot;http://app1.com&quot;</span>)</span><br><span class="line"> &#125;, <span class="number">4000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    iframe.<span class="title function_">remove</span>()</span><br><span class="line">&#125;, <span class="number">6000</span>); </span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, event.<span class="property">data</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code> 被多个域所共享</p><p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p><p><strong>三、流程</strong></p><p>单点登录的流程图如下所示：</p><p><img src="https://s2.loli.net/2024/05/10/Bpr7kJf6dl9azPQ.png" alt="image-20240510155953411"></p><ul><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统2的受保护资源</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li></ul><p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p><p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p><p>全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><p><a href="https://zhuanlan.zhihu.com/p/334720992">单点登录参考文章</a></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：如何判断一个元素是否在可视区域中"><a href="#Q23：如何判断一个元素是否在可视区域中" class="headerlink" title="Q23：如何判断一个元素是否在可视区域中"></a>Q23：如何判断一个元素是否在可视区域中</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>element.getBoundingClientRect()</code></p><p>使用<code>element.getBoundingClientRect()</code>方法，它会返回元素的大小及其相对于视口的位置</p><p>这个方法返回一个DOMRect对象，包含了<code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>, <code>width</code>, <code>height</code>这些值，其中<code>top</code>和<code>left</code>表示元素左上角相对于视口的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewport</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.<span class="property">left</span> &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.<span class="property">bottom</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>) &amp;&amp;</span><br><span class="line">    rect.<span class="property">right</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会返回一个布尔值，如果元素完全在视口内部则为<code>true</code>，否则为<code>false</code></p></li><li><p><code>Intersection Observer</code> API</p><p><code>Intersection Observer</code> API提供了一种异步检测目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态变化的方式</p><p>这种方法非常适合用来实现懒加载、无限滚动等功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过IntersectionObserver构造函数创建一个观察者对象</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果entry.isIntersecting为true，表示元素进入可视区</span></span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素已进入可视区域&#x27;</span>);</span><br><span class="line">      <span class="comment">// 做一些操作，比如加载图片等</span></span><br><span class="line">      <span class="comment">// 完成操作后，可以取消观察</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用observe方法来观察一个元素</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#yourElementId&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：什么是防抖和节流，以及如何编码实现"><a href="#Q24：什么是防抖和节流，以及如何编码实现" class="headerlink" title="Q24：什么是防抖和节流，以及如何编码实现"></a>Q24：什么是防抖和节流，以及如何编码实现</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>是什么</strong></p><p>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用<code>throttle</code>（节流）和<code>debounce</code>（防抖）的方式来减少调用频率</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性/技术</th><th style="text-align:left">防抖 (Debouncing)</th><th style="text-align:left">节流 (Throttling)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义</strong></td><td style="text-align:left">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</td><td style="text-align:left">在固定时间间隔内只执行一次事件回调。</td></tr><tr><td style="text-align:left"><strong>相同点</strong></td><td style="text-align:left">两者都是性能优化的技术，用于减少事件处理器执行的频率。</td><td style="text-align:left">同左。</td></tr><tr><td style="text-align:left"><strong>不同点</strong></td><td style="text-align:left">防抖关注于延迟执行。一段时间内的多次操作只会执行最后一次。</td><td style="text-align:left">节流关注于定时执行。一段时间内的操作，无论触发多少次，只会定期执行一次。</td></tr><tr><td style="text-align:left"><strong>应用场景</strong></td><td style="text-align:left">- 搜索框搜索输入。（减少请求次数）<br/> - 窗口大小调整（resize）。（避免重绘和重流）<br/> - 表单验证。（停止输入一段时间后进行验证）</td><td style="text-align:left">- 滚动加载，滚动事件的无限加载。（比如滚动到页面底部自动加载内容）<br/> - 轮播图用户快速多次点击箭头按钮。（限制用户点击频率）<br/> - 测量滚动位置。（例如固定时间内只计算一次滚动距离）</td></tr></tbody></table></div><p><img src="https://s2.loli.net/2024/05/10/zolVey45Hrcuh96.png" alt="image-20240510161540382"></p><p><strong>举例：</strong></p><p>每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p><p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p><p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p><p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p><p><strong>代码实现</strong></p><ol><li><p>防抖</p><ul><li><p>立即执行</p><p>事件触发后立即执行，然后n秒内不再执行</p><p>这种实现方式的效果是，事件触发后立即执行，然后在等待的n秒内如果事件又被触发则重新等待n秒</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非立即执行</p><p>事件触发后不立即执行，等待n秒后执行，如果在这n秒内又触发了事件，则重新开始等待</p><p>这种实现方式的效果是，当事件在n秒内没有再次被触发，才会执行回调函数。即当你滚动滚动条时，滚动结束后n秒再执行，如果滚动过程中又滚动了，那么重新等待n秒</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>节流</p><ul><li><p>时间戳方式</p><p>时间戳方式的节流函数会立即执行第一次触发的事件，然后如果在设定的时间间隔内再次触发事件，这次触发的事件不会被执行</p><p>只有当过了设定的时间间隔后，才会再次执行事件处理函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定时器方式</p><p>定时器方式的节流函数会在第一次触发事件时不立即执行事件处理函数，而是设置一个延时，等待指定的时间间隔后执行。如果在这个延时期间内再次触发了事件，这次触发的事件不会被执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两者结合方式</p><p>有时候，为了同时满足立即执行第一次触发的事件和结束触发时还能执行一次事件处理函数的需求，可以将时间戳方式和定时器方式结合起来使用</p><p>这种方式结合了两者的优点，第一次触发事件会立即执行，之后如果在设定的时间间隔内再次触发事件，则会延迟执行，确保在结束触发后还能再执行一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout, context, args, previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> later = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        previous = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：Javascript中如何实现函数缓存-函数缓存有哪些应用场景"><a href="#Q25：Javascript中如何实现函数缓存-函数缓存有哪些应用场景" class="headerlink" title="Q25：Javascript中如何实现函数缓存?函数缓存有哪些应用场景"></a>Q25：Javascript中如何实现函数缓存?函数缓存有哪些应用场景</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数缓存，也被称为记忆化（Memoization），是一种优化技术，主要用于存储昂贵函数调用的结果，然后在再次调用同样的输入时直接返回缓存的结果</p><ol><li><p><strong>闭包（Closures）</strong></p><p>使用闭包可以缓存函数的计算结果</p><p>闭包可以访问函数外部的变量，因此可以将函数结果存储在一个变量中，并在下次执行时首先检查该变量</p></li><li><p><strong>映射对象（Map Object）</strong></p><p> <code>Map</code>对象可以存储键值对，并且能记住原始插入顺序</p><p>你可以用传递给函数的参数作为键，把函数返回的结果作为值来进行存储</p></li><li><p><strong>高阶函数（Higher Order Functions）</strong></p><p>可以创建一个高阶函数，它接受一个函数并返回一个新的函数</p><p>这个新函数会检查是否已经缓存了传递给原函数的特定参数的结果</p></li></ol><p><strong>实现代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用args作为键创建一个唯一的表示，这里简单地将参数连接为字符串</span></span><br><span class="line">    <span class="keyword">const</span> key = args.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    cache.<span class="title function_">set</span>(key, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的加法函数，后面将使用memoize进行缓存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用memoize创建一个缓存版本的add函数</span></span><br><span class="line"><span class="keyword">const</span> memoizedAdd = <span class="title function_">memoize</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用会执行计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoizedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3，进行计算，并存入缓存</span></span><br><span class="line"><span class="comment">// 第二次调用时，同样的参数会直接从缓存中获取结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoizedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3，直接从缓存中获取，不再执行计算</span></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ol><li><p><strong>重复计算</strong></p><p>当函数需要多次重复计算相同参数的结果时，函数缓存可以避免重复工作，只需计算一次然后存储结果即可。</p></li><li><p><strong>昂贵的函数调用</strong></p><p>对于计算成本很高的函数，如涉及复杂算法的函数，使用缓存可以减少执行时间。</p></li><li><p><strong>递归函数</strong></p><p>特别是在处理递归函数时，如计算斐波纳契数列等，缓存结果可以大幅度减少计算量。</p></li><li><p><strong>数据库查询</strong></p><p>在需要频繁进行相同查询的数据库操作中，函数缓存可以存储之前的查询结果，减少数据库的压力。</p></li><li><p><strong>API调用</strong></p><p>如果一个API的数据不会频繁更新，通过缓存API调用结果可以节省网络带宽并提高响应速度。</p></li><li><p><strong>DOM操作的优化</strong></p><p>如果有一个函数根据相同参数总是生成相同的DOM结构，可以通过缓存来优化，避免重复的DOM操作。</p></li><li><p><strong>数据转换</strong></p><p>对于数据格式化或转换操作，如日期格式化，如果转换规则复杂且转换对象重复性高，可以用缓存来提高效率。</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">闭包</th><th style="text-align:left">高阶函数</th><th style="text-align:left">函数柯里化</th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义</strong></td><td style="text-align:left">函数嵌套函数，内部函数访问外部变量</td><td style="text-align:left">一个至少满足以下一个条件的函数：接受一个或多个函数作为参数，或者返回一个函数</td><td style="text-align:left">一个将多参数函数转换为一系列使用一个参数的函数的技术</td></tr><tr><td style="text-align:left"><strong>作用</strong></td><td style="text-align:left">使函数可以访问其定义时的作用域中的变量，即使它在其定义环境外执行</td><td style="text-align:left">抽象或封装行为，可以用函数作为参数或返回新的函数来构建更加模块化的代码</td><td style="text-align:left">分解复杂的函数参数，使得函数变得易于处理，易于复用，并且能够逐步应用函数</td></tr><tr><td style="text-align:left"><strong>状态保持</strong></td><td style="text-align:left">可以记住和访问创建它的函数的局部变量，参数和其他闭包</td><td style="text-align:left">不一定保持任何状态，可以是无状态的，仅用于抽象计算步骤或创建新的函数</td><td style="text-align:left">不直接关注状态，而是关注参数的重组和分配</td></tr><tr><td style="text-align:left"><strong>返回值</strong></td><td style="text-align:left">会返回一个函数，这个函数可以访问创建它时的环境</td><td style="text-align:left">可以返回函数，也可以返回其他任何类型的值</td><td style="text-align:left">返回接收下一个参数的新函数，直到所有参数被”消耗”</td></tr><tr><td style="text-align:left"><strong>参数处理</strong></td><td style="text-align:left">参数在闭包创建时确定，并在闭包的上下文中保持不变</td><td style="text-align:left">参数的处理取决于具体的高阶函数实现，并非固定模式</td><td style="text-align:left">每次调用仅接受一个参数，并返回接受下一个参数的新函数</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">用于创建私有变量和方法，保存状态，实现模块化</td><td style="text-align:left">用于函数抽象和复用，函数组合，以及处理不确定数量的参数</td><td style="text-align:left">用于固定某些参数，简化多参数函数的逆复，以及函数的偏应用</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：如何有顺序的执行10个异步任务"><a href="#Q26：如何有顺序的执行10个异步任务" class="headerlink" title="Q26：如何有顺序的执行10个异步任务"></a>Q26：如何有顺序的执行10个异步任务</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Async/Await</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">asyncTask</span>(i); <span class="comment">// 等待当前任务完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runTasks</span>(); <span class="comment">// 启动任务</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>await</code> 关键字使得 JavaScript 引擎等待每个 <code>asyncTask</code> 完成之后再继续循环</p></li><li><p><code>Promise 链</code></p><p>通过在每个异步操作上调用 <code>.then()</code> 方法，可以确保它们按顺序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  promise = promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">asyncTask</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，每个任务都将在前一个任务解决后启动</p></li><li><p>使用递归</p><p>通过递归函数顺序执行异步任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runTasks</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">asyncTask</span>(i).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">runTasks</span>(i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runTasks</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当一个任务完成，它会调用<code>runTasks</code>来启动下一个任务</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：javascript里面怎么取消请求"><a href="#Q27：javascript里面怎么取消请求" class="headerlink" title="Q27：javascript里面怎么取消请求"></a>Q27：javascript里面怎么取消请求</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>取消 <code>XMLHttpRequest</code> 请求</p><p>对于 <code>XMLHttpRequest</code> 对象，我们可以使用 <code>abort</code> 方法来取消请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.example.com/api&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求失败的处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要取消请求的时候调用</span></span><br><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>在这个例子中，调用 <code>xhr.abort()</code> 会立即终止请求，然后触发 <code>onabort</code> 事件</p><p>加上对 <code>onerror</code> 的监听可以确保所有的异常情况都有对应的处理</p></li><li><p>取消 <code>Fetch</code> 请求</p><p>通过使用 <code>AbortController</code> 和它的 <code>signal</code> 属性，可以取消一个 <code>fetch</code> 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://www.example.com/api&#x27;</span>, &#123; signal &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Fetch operation was aborted&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其它错误的处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要取消请求的地方调用</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>在此示例中，创建了一个 <code>AbortController</code> ，并将其 <code>signal</code> 属性传递给 <code>fetch</code> </p><p>要取消请求，在合适的时机调用 <code>controller.abort()</code></p></li><li><p>取消 <code>Axios</code> 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://www.example.com/api&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误的处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要取消请求时执行</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>我们创建了一个 <code>AbortController</code> 的实例，并将它的 <code>signal</code> 属性作为配置选项传递给 Axios 的请求方法</p><p>当调用 <code>controller.abort()</code> 方法时，如果请求仍在进行中，它将被取消，并且 <code>catch</code> 块将捕获到一个异常，其中 <code>axios.isCancel(error)</code> 可以检测这个异常是否是因为请求被取消造成的</p><p>您应该确保使用的 Axios 版本支持 <code>AbortController</code></p><p>这个特性自 Axios v0.19.0 起被引入</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：如何让-var-a-b-a-1-b-2-解构赋值成功"><a href="#Q28：如何让-var-a-b-a-1-b-2-解构赋值成功" class="headerlink" title="Q28：如何让 var [a, b]={a: 1,b: 2}解构赋值成功"></a>Q28：如何让 var [a, b]={a: 1,b: 2}解构赋值成功</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在浏览器运行的时候，报错如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a,b] = obj</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/11/D4dKLRzSjyrnNio.png" alt="image-20240511174905915"></p><p>它告诉我们obj这个对象是不可迭代的，只要改成可迭代的，就可以解决这个问题</p><p>要想满足迭代协议需要对象身上有一个名为<code>[Symbol.iterator]</code>的方法</p><p>再使用for..of或者解构赋值的时候会隐式的调用这个方法，得到一个迭代对象，通过迭代对象的next方法判断当前是否完成迭代和具体迭代的值</p><p>也就是说我们要在obj上添加<code>[Symbol.iterator]</code>方法并且完成next方法的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">value</span>: obj[keys[index++]]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>可迭代协议的概念（</strong> <strong>MDN</strong> <strong>）</strong></p><p>可迭代协议是JavaScript中规定的一套标准，它允许对象通过特定的方法定义它们的迭代行为，即规定了对象如何被<code>for...of</code>这样的迭代语句遍历。这个协议主要涉及到两个部分：</p><ol><li><p><strong>迭代器方法 (<code>@@iterator</code>)</strong>:</p><p>对象或其原型链中的某个对象必须有一个名为<code>Symbol.iterator</code>的属性，该属性是一个无参数函数，它返回一个迭代器对象。当对象需要被迭代时，例如在<code>for...of</code>循环中，这个方法会被调用</p></li><li><p><strong>迭代器对象</strong>:</p><p>该对象必须遵守<strong>迭代器协议</strong>，具体来说，需要有一个<code>next()</code>方法，该方法在每次迭代时被调用。每次调用<code>next()</code>方法时，迭代器对象返回另一个称为迭代结果的对象。迭代结果对象必须具有两个属性：</p><ul><li><code>value</code>：迭代的当前值</li><li><code>done</code>：布尔值，如果迭代器已经遍历了迭代对象所有值，则为<code>true</code>；如果迭代还未结束，则为<code>false</code></li></ul></li></ol><p>通过实现这个协议，任何对象都可定制它在迭代时产生值的序列，成为可迭代的</p><p>例如，数组和字符串是可迭代的，因为它们的原型链上都有<code>Symbol.iterator</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>在此示例中，数组<code>arr</code>是内建可迭代对象，它的<code>Symbol.iterator</code>方法返回一个迭代器对象<code>it</code>，我们可以手动调用<code>next()</code>方法来迭代数组</p><p>如果需要让一个自定义对象满足可迭代协议，可以定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="variable language_">this</span>[keys[index++]], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出：1, 然后 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个普通对象，并给它添加了一个<code>[Symbol.iterator]</code>属性，从而使对象变成可迭代的</p><p>通过这种方式，对象就可以用在任何期待可迭代值的JavaScript语言结构中</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：前端的页面截图怎么实现"><a href="#Q29：前端的页面截图怎么实现" class="headerlink" title="Q29：前端的页面截图怎么实现"></a>Q29：前端的页面截图怎么实现</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>Canvas</p><p>最常见的方式是将需要截图的内容绘制到一个<code>&lt;canvas&gt;</code>元素上，然后使用<code>canvas.toDataURL()</code>方法获取图像的DataURL，这是一个Base64编码的字符串表示的图片</p><p>基于此字符串，可以显示图片或者转换成Blob进行下载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">screenshotDOMElement</span>(<span class="params">element, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 将DOM元素渲染到canvas上的函数</span></span><br><span class="line">  <span class="title function_">html2canvas</span>(element).<span class="title function_">then</span>(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 转换canvas为DataURL</span></span><br><span class="line">    <span class="keyword">var</span> dataURL = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">    <span class="title function_">callback</span>(dataURL);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">screenshotDOMElement</span>(<span class="variable language_">document</span>.<span class="property">body</span>, <span class="keyword">function</span>(<span class="params">dataURL</span>)&#123;</span><br><span class="line">  <span class="comment">// 创建一个Image元素</span></span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = dataURL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将Image元素添加到页面中以显示截图</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者创建下载链接以下载截图</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  a.<span class="property">href</span> = dataURL;</span><br><span class="line">  a.<span class="property">download</span> = <span class="string">&#x27;screenshot.png&#x27;</span>;</span><br><span class="line">  a.<span class="title function_">click</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要提醒的是，上面的代码使用了<code>html2canvas</code>库，它是一个非常流行的库，可以将HTML转换成Canvas图片</p><p>你需要在你的项目中包含这个库才能使用上述功能</p></li><li><p>浏览器拓展API</p><p>如果你正在开发一个浏览器扩展，你可以利用浏览器提供的API来捕捉当前页面或者页面的部分区域</p><p>例如，在Chrome扩展程序中，可以使用<code>chrome.tabs.captureVisibleTab</code>方法实现截屏</p><p>这通常用于浏览器插件开发，对于普通的前端网页开发并不适用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">captureVisibleTab</span>(<span class="literal">null</span>, &#123;&#125;, <span class="keyword">function</span> (<span class="params">image</span>) &#123;</span><br><span class="line">  <span class="comment">// image是一个base64编码的DataURL</span></span><br><span class="line">  <span class="keyword">var</span> screenshotUrl = image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面你可以将截图DataURL用于不同的目的，例如显示或下载</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用这个API，用户的浏览器必须安装相应的扩展，并且在扩展的权限设置中允许这种截图行为</p></li></ol><p><strong>注意</strong></p><ul><li>如果页面中有跨域内容，使用Canvas进行截图可能会遇到安全限制</li><li>上述方法仅适合静态内容的截图。如果页面有复杂的动态效果或者视频等流媒体内容，可能无法准确捕获</li><li>对于特权环境（如浏览器扩展），可能有额外的API用于截图</li><li>用户隐私应予以考虑，不应在用户不知情或未经允许的情况下进行截图</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：怎么实现虚拟列表"><a href="#Q30：怎么实现虚拟列表" class="headerlink" title="Q30：怎么实现虚拟列表"></a>Q30：怎么实现虚拟列表</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>虚拟列表（Virtual List）或虚拟滚动（Virtual Scrolling）是一种极其有效的前端性能优化技术，专门用于优化长列表数据的渲染性能</p><p>当面对需要渲染成千上万条数据项的列表时，虚拟列表技术通过只渲染当前视口（viewport）内以及少量缓冲区内的列表项，而不是整个列表的数据项，来显著提高页面的渲染效率及性能</p><ol><li><p>核心概念</p><ul><li><p><strong>渲染优化</strong></p><p>虚拟列表通过减少实际渲染的DOM节点数量来降低浏览器的负担，使得即使是数据量极大的列表页也能实现流畅的滚动和交互体验</p></li><li><p><strong>动态渲染</strong></p><p>随着用户滚动，应用程序会根据视口的变化动态地添加或移除列表项，确保在任何时候，DOM中的节点数量保持恒定</p></li></ul></li><li><p>优点与缺点</p><ul><li><p><strong>优点</strong></p><ul><li><p><strong>性能提升</strong></p><p>显著减少了待渲染的DOM元素数量，提高页面渲染性能</p></li><li><p><strong>用户体验增强</strong></p><p>页面滚动流畅，减少了内存的占用，提高了页面响应速度</p></li></ul></li><li><p><strong>缺点</strong></p><ul><li><p><strong>实现复杂度</strong></p><p>动态计算可见项、处理滚动事件等，实现相对较为复杂</p></li><li><p><strong>滚动位置误差</strong></p><p>尤其在列表项高度不一致时，可能会导致滚动位置的计算误差</p></li></ul></li></ul></li><li><p>应用场景</p><ul><li><p><strong>电商网站的商品列表</strong></p><p>展示成千上万的商品信息</p></li><li><p><strong>后台系统的数据表格</strong></p><p>处理大量的数据展示</p></li><li><p><strong>社交媒体信息流</strong></p><p>如新闻、文章列表或社交动态的无限滚动加载</p></li></ul></li></ol><p>虽然可以手动实现虚拟列表，但大多数开发者倾向于使用现成的库来简化开发流程，例如<code>react-window</code>和<code>react-virtualized</code>等库，它们提供了开箱即用的虚拟列表实现方案，大大降低了复杂度</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>实现虚拟列表涉及以下关键步骤与技术：</p><ol><li><p><strong>计算可见区域</strong></p><p>根据视口大小和滚动位置来计算当前应该渲染哪些列表项</p></li><li><p><strong>渲染策略</strong></p><p>仅渲染视口内的数据项，对于非可见区域的数据，通过占位符或者估算高度来确保滚动条正常</p></li><li><p><strong>动态调整</strong></p><p>根据滚动位置动态加载新的列表项并回收离开视口的旧数据项</p></li><li><p><strong>优化技术</strong></p><ul><li><p><strong>虚拟DOM</strong></p><p>降低重绘与回流，提升性能</p></li><li><p><strong>懒加载</strong></p><p>延迟渲染非可见区域的数据，减少网络和资源消耗</p></li><li><p><strong>缓存机制</strong></p><p>缓存已渲染的列表项，提高滚动性能</p></li><li><p><strong>预测加载</strong></p><p>根据用户的滚动行为预测接下来的数据需求，提前加载数据</p></li></ul></li></ol><p><strong>具体实现</strong></p><p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/VirtualList"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=VirtualList&show_owner=true"/></a></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：如何判断某个字符串长度-要求支持表情"><a href="#Q31：如何判断某个字符串长度-要求支持表情" class="headerlink" title="Q31：如何判断某个字符串长度(要求支持表情)"></a>Q31：如何判断某个字符串长度(要求支持表情)</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 的 <code>length</code> 属性在处理包含四字节 Unicode 字符（例如表情符号）的字符串时可能不会返回预期的结果，原因是 <code>length</code> 属性会将四字节的 Unicode 字符计算为 2 个字符</p><p>所以如果需要准确获得包含表情符号的字符串长度，我们要用到“展开”操作符 (<code>...</code>) 和 <code>Array</code> 对象的 <code>length</code> 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, World! 😊&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStringLength</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查输入是否为字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;getStringLength error: The input must be a string.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者根据你的需要，返回其他方案</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [...str].<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getStringLength</span>(str); <span class="comment">// 返回正确的字符数量，包括表情符号</span></span><br></pre></td></tr></table></figure><p>这段代码会将字符串里的每个字符（包括四字节 Unicode 字符）都单独展开成独立的数组元素，然后使用 <code>length</code> 属性统计元素的数量，避免了四字节字符被错误地计为2个字符的问题</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：如何判断页面是通过PC端还是移动端访问"><a href="#Q32：如何判断页面是通过PC端还是移动端访问" class="headerlink" title="Q32：如何判断页面是通过PC端还是移动端访问"></a>Q32：如何判断页面是通过PC端还是移动端访问</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>navigator.userAgent</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectDevice</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> userAgent = navigator.<span class="property">userAgent</span>;</span><br><span class="line">  <span class="keyword">if</span> (userAgent.<span class="title function_">match</span>(<span class="regexp">/Android/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/webOS/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPhone/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPad/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPod/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/BlackBerry/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/Windows Phone/i</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Mobile Device&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Desktop Device&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">detectDevice</span>());</span><br></pre></td></tr></table></figure><p>这个 <code>detectDevice()</code> 函数在执行时会检查<code>navigator.userAgent</code>是否包含特定的移动设备标识符</p><p>如果匹配到这些设备标识符中的任何一个，该函数将返回 <code>&#39;Mobile Device&#39;</code></p><p>否则，该函数将返回 <code>&#39;Desktop Device&#39;</code></p><p>这个方法并不是<code>100%</code>准确的，因为用户代理字符串可以被浏览器设置项或恶意用户修改</p><p>然而，这仍然是一个大多数情况下有效的方法，用于判断访问者使用的是桌面还是移动设备</p></li><li><p><strong>使用CSS媒体查询</strong></p><p>通过CSS媒体查询判断窗口的大小，从而对移动设备和桌面设备采取不同的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line"> <span class="comment">/* 在这里放置移动端的CSS */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查屏幕宽度</strong></p><p>移动设备通常支持触摸事件，而桌面则依赖于鼠标事件，所以你可以侦测页面是否可以进行触摸事件来判定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt;= <span class="number">768</span>) &#123;</span><br><span class="line"> <span class="comment">// 移动端执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 桌面端执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>触摸事件检测</strong></p><p>移动设备通常支持触摸事件，而桌面则依赖于鼠标事件，所以可以侦测页面是否可以进行触摸事件来判定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isTouchDevice</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         (<span class="string">&#x27;ontouchstart&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) </span><br><span class="line">         || (navigator.<span class="property">MaxTouchPoints</span> &gt; <span class="number">0</span>)</span><br><span class="line">         || (navigator.<span class="property">msMaxTouchPoints</span> &gt; <span class="number">0</span>)</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用库或框架</strong></p><p>现成的库，如Modernizr、WURFL.js等，可以帮助你检测设备的类型</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：实现一个数字转中文的方法"><a href="#Q33：实现一个数字转中文的方法" class="headerlink" title="Q33：实现一个数字转中文的方法"></a>Q33：实现一个数字转中文的方法</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数目标与输入检验</p><p>这个函数的主要目标是将数字转换为汉字表示的形式</p><p>它不仅包括正负整数的转换，也支持处理小数部分以及检查输入数字是否在特定的区间内</p><p>最开始的几行代码用于验证输入是否为合法的数字，并确定输入数字是否在函数处理的范围内（本例中为-1亿到1亿）</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="string">&#x27;输入不是一个有效的数字&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MIN_NUM</span> = -<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_NUM</span> = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="variable constant_">MIN_NUM</span> || num &gt; <span class="variable constant_">MAX_NUM</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`数字必须在<span class="subst">$&#123;MIN_NUM&#125;</span>到<span class="subst">$&#123;MAX_NUM&#125;</span>之间`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负数处理</strong></p><p>接下来，函数检查数字是否为负</p><p>如果是负数，它会标记一个负数标志为<code>true</code>并将数字转换为正数以便后续处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> negative = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    negative = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整数部分转换</strong></p><p>函数中的<code>getIntegerChn</code>辅助函数负责将数字的整数部分转换成汉字</p><p>这一过程通过递归地处理数字的每四位（即在中文中的“万”与“亿”单位间的分割点）来完成</p><p>它首先将数字分解成小于10000的块，并为每个块生成对应的中文表示，然后根据其在原数中的位置添加适当的单位（如“万”、“亿”等）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getIntegerChn</span> = (<span class="params">intNum</span>) =&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>小数部分转换</strong></p><p>如果数字有小数点，<code>getDecimalChn</code>函数负责将小数点后的每位数字转换为相应的汉字，并在前面加上“点”字以区分整数和小数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getDecimalChn</span> = (<span class="params">str</span>) =&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>负数的最终表示</strong></p><p>在整数和小数部分都转换完成后，如果最初标记的负数标志为<code>true</code>，则在最终的中文字符串前加上“负”字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertToChinese</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="string">&#x27;输入不是一个有效的数字&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义转换的区间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MIN_NUM</span> = -<span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MAX_NUM</span> = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数字是否在允许的区间内</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="variable constant_">MIN_NUM</span> || num &gt; <span class="variable constant_">MAX_NUM</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`数字必须在<span class="subst">$&#123;MIN_NUM&#125;</span>到<span class="subst">$&#123;MAX_NUM&#125;</span>之间`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> numMap = [<span class="string">&#x27;零&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;七&#x27;</span>, <span class="string">&#x27;八&#x27;</span>, <span class="string">&#x27;九&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> unitMap = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;万&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;亿&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;万亿&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> negative = <span class="literal">false</span>; <span class="comment">// 标记是否为负数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        negative = <span class="literal">true</span>;</span><br><span class="line">        num = -num; <span class="comment">// 将负数转为正数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换整数部分</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getIntegerChn</span> = (<span class="params">intNum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(intNum === <span class="number">0</span>) <span class="keyword">return</span> numMap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> chnStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> zero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (intNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> section = intNum % <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">if</span> (zero) chnStr = numMap[<span class="number">0</span>] + chnStr;</span><br><span class="line">            <span class="keyword">let</span> strIns = <span class="title function_">sectionToChinese</span>(section);</span><br><span class="line">            strIns += (section !== <span class="number">0</span>) ? unitMap[count] : unitMap[<span class="number">0</span>];</span><br><span class="line">            chnStr = strIns + chnStr;</span><br><span class="line">            zero = section &lt; <span class="number">1000</span> &amp;&amp; section &gt; <span class="number">0</span>;</span><br><span class="line">            intNum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(intNum / <span class="number">10000</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chnStr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换小数部分</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getDecimalChn</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> decimalStr = <span class="string">&#x27;点&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            decimalStr += numMap[+char];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> decimalStr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> [integerPart, decimalPart] = num.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> chineseStr = <span class="title function_">getIntegerChn</span>(<span class="built_in">parseInt</span>(integerPart));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decimalPart) &#123;</span><br><span class="line">        chineseStr += <span class="title function_">getDecimalChn</span>(decimalPart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">        chineseStr = <span class="string">&#x27;负&#x27;</span> + chineseStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chineseStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convertToChinese</span>(-<span class="number">12345.678</span>)); <span class="comment">// 返回 &quot;负一万二千三百四十五点六七八&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convertToChinese</span>(<span class="number">1000000000</span>)); <span class="comment">// 返回 &quot;数字必须在-100000000到100000000之间&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：用js实现二叉树的定义和基本操作（待完善）"><a href="#Q34：用js实现二叉树的定义和基本操作（待完善）" class="headerlink" title="Q34：用js实现二叉树的定义和基本操作（待完善）"></a>Q34：用js实现二叉树的定义和基本操作（待完善）</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>二叉树是一种特殊的树形数据结构，其中每个节点最多有两个子节点，通常被称为左子节点和右子节点</p><p>按定义，二叉树是空的（即，没有节点）或者由一个根节点和两棵互不相交的、被分别称为左子树和右子树的二叉树组成</p><p>详细地说，二叉树的每个节点包含以下部分：</p><ul><li>数据元素：包含节点值或者其他相关信息的部分</li><li>左指针：指向左子节点的指针。如果没有左子节点，该指针指向空或者NULL</li><li>右指针：指向右子节点的指针。如果没有右子节点，该指针指向空或者NULL</li></ul><p>二叉树有许多变体，如二叉搜索树、AVL树（自平衡二叉搜索树）、堆（一种特殊的完全二叉树）和红黑树等</p><p>其中，二叉搜索树是最常用的一种，它的特点是任意节点的值都大于或等于其左子树中存储的值，并且小于或等于其右子树中存储的值</p><p>二叉树的优势在于其查找、插入、删除的平均和最佳时间复杂度可以达到O(log n)（其中n代表树中节点的数量），这归功于二叉树数据结构的特性使查找路径大大缩短</p><p>但是，为了保持树的平衡（即保持左右两边节点数量均衡，避免退化为链），可能需要进行一些额外操作</p><p>二叉树可被用来实现二叉搜索树、表达式解析树、堆和B+树（一种用于数据库和文件系统的数据结构）等等</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：查找岛屿数量"><a href="#Q35：查找岛屿数量" class="headerlink" title="Q35：查找岛屿数量"></a>Q35：查找岛屿数量</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span></span><br><span class="line"><span class="comment">// 2、岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span></span><br><span class="line"><span class="comment">// 3、此外，你可以假设该网格的四条边均被水包围。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 返回结果 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示</span></span><br><span class="line">m == grid.<span class="property">length</span></span><br><span class="line">n == grid[i].<span class="property">length</span></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">300</span></span><br><span class="line">grid[i][j] 的值为 <span class="string">&#x27;0&#x27;</span> 或 <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在计算二维网格中岛屿的数量问题中，主要有两种搜索方法来遍历岛屿：</p><ol><li><p><strong>深度优先搜索（DFS, Depth-First Search）</strong><br>深度优先搜索是以垂直的方式进行探索。它从一个节点开始，尽可能深地搜索每一个分支，直到到达底部，然后回溯并探索下一条分支</p><p>在岛屿数量的问题中，DFS可以从任一未访问过的陆地出发，尽可能探索与之相连的所有陆地，然后将其标记为已访问</p><p>DFS通过递归或栈实现</p></li><li><p><strong>广度优先搜索（BFS, Breadth-First Search）</strong><br>广度优先搜索是以水平的方式进行探索</p><p>它从一个节点开始，首先访问所有邻近的节点，即先宽后深地探索每一层</p><p>在岛屿数量的问题中，BFS可以从任一未访问过的陆地出发，一层一层地探索所有相邻的陆地，并将其标记为已访问</p><p>BFS通常用队列来实现</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>使用递归的方式进行<strong>深度优先搜索</strong></p><p>每当我们遇到”1”（即陆地）时，我们将尝试访问它的所有相邻的”1”（即未访问过的陆地），并将它们标记为已访问，以此来识别一个完整的岛屿</p><p>完成对一个岛屿的探索后，我们继续搜索下一个未被访问的”1”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="comment">// 辅助函数用于执行深度优先搜索</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查越界情况以及是否是水域或已访问过的陆地</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">length</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前位置标记为已访问</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 通过将1修改为0来标记已访问</span></span><br><span class="line">        <span class="comment">// 访问四个方向的相邻陆地</span></span><br><span class="line">        <span class="title function_">dfs</span>(i+<span class="number">1</span>, j); <span class="comment">// 下</span></span><br><span class="line">        <span class="title function_">dfs</span>(i-<span class="number">1</span>, j); <span class="comment">// 上</span></span><br><span class="line">        <span class="title function_">dfs</span>(i, j+<span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="title function_">dfs</span>(i, j-<span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!grid || !grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 计数器，用于统计岛屿数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 发现未访问的陆地，启动深度优先搜索</span></span><br><span class="line">                <span class="title function_">dfs</span>(i, j);</span><br><span class="line">                count++; <span class="comment">// 完成一个岛屿的搜索，岛屿数量加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid1)); <span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid2)); <span class="comment">// 返回结果 3</span></span><br></pre></td></tr></table></figure><p>这段代码首先定义了一个<code>dfs</code>函数，用于实现深度优先搜索并标记已访问的陆地</p><p>然后，我们遍历整个网格，每次遇到”1”（未访问过的陆地）时，使用<code>dfs</code>函数搜索整个岛屿，并通过将”1”标记为”0”来标记已访问的陆地</p><p>遍历过程中每完成对一个岛屿的探索，就将岛屿数量加一</p></li><li><p>使用<strong>广度优先搜索（BFS）</strong></p><p>我们通常会用队列来追踪需要探索的陆地</p><p>从遇到初始的一个“1”开始，我们将其添加到队列中，然后按层序遍历相邻的格子，将遇到的所有“1”都置为“0”以防重复计数，直到队列为空</p><p>这样，每完成一轮循环，就能识别并计数一个岛屿</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!grid || !grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dirs = [[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]; <span class="comment">// 上下左右移动的方向</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++; <span class="comment">// 找到一个岛屿，岛屿数量加1</span></span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">                <span class="keyword">const</span> queue = [[i, j]]; <span class="comment">// 使用数组模拟队列，存储岛屿中的陆地坐标</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> [x, y] = queue.<span class="title function_">shift</span>(); <span class="comment">// 从队列中取出一个陆地坐标</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检查此陆地的所有相邻陆地</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> [dx, dy] <span class="keyword">of</span> dirs) &#123;</span><br><span class="line">                        <span class="keyword">const</span> nx = x + dx, ny = y + dy;</span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; cols &amp;&amp; grid[nx][ny] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            grid[nx][ny] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">                            queue.<span class="title function_">push</span>([nx, ny]); <span class="comment">// 相邻的陆地入队</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid1)); <span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid2)); <span class="comment">// 返回结果 3</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>dirs</code>数组定义了可以移动的方向，即上下左右</p><p>每次发现一个“1”后，都开始一个新的BFS过程：首先将其标记为“0”，然后将它的坐标加入队列中</p><p>在队列不为空的情况下循环，每次从队列中取出一个坐标，再将其相邻的未标记的陆地坐标入队，同时将这些陆地标记为“0”以表示已访问</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>时间复杂度和空间复杂度是用来评估算法效率的两个标准。想象一下，你在厨房做饭：</p><ol><li><p><strong>时间复杂度</strong></p><p>就像是完成菜肴所需要的总时间</p><p>简单的菜，比如煮鸡蛋，可能只需要几分钟</p><p>但如果是做一个复杂的烤鸡大餐，可能需要几个小时</p><p>在计算机的世界里，时间复杂度帮助我们了解一个程序运行完成需要多长时间</p><p><strong>评估标准</strong></p><ul><li><p><strong>确定算法的基本操作</strong></p><p>识别算法中执行最频繁的操作</p><p>比如在排序算法中，基本操作可能是比较或交换元素</p></li><li><p><strong>分析操作的数量</strong></p><p>计算输入数据大小为n时，基本操作执行了多少次</p><p>假设操作数量为<code>f(n)</code></p></li><li><p><strong>考虑最坏情况</strong></p><p>通常我们评估算法的时间复杂度时，考虑的是最坏的情况</p><p>即对于给定大小的输入，算法所需时间的最大值</p></li><li><p><strong>简化表达式</strong></p><p>在<code>f(n)</code>中去掉常数项和低阶项，保留最高阶项，并注意它前面的系数也不重要</p><p>因为时间复杂度关注的是随着输入规模n的增长，算法所需时间的变化趋势</p></li><li><p><strong>使用大O符号</strong></p><p>得到简化后的表达式并采用大O符号来描述算法的时间复杂度</p><p>例如，如果操作数量<code>f(n)</code>可被简化为<code>2n^2 + 3n + 5</code>，则算法的时间复杂度是<code>O(n^2)</code></p></li></ul></li><li><p><strong>空间复杂度</strong></p><p>则像是你在做饭时占用的厨房空间大小</p><p>如果你只是煮个鸡蛋，可能只需要一个小锅</p><p>但如果是准备一个大餐，你可能需要整个厨房的空间</p><p>在计算机中，空间复杂度告诉我们运行一个程序需要多少内存空间</p><p><strong>评估标准</strong></p><ul><li><p><strong>考虑所有内存使用</strong></p><p>算法可能使用内存来存储各种变量、数组、来自外部输入的数据和递归栈</p></li><li><p><strong>区分临时和持久空间使用</strong></p><p>有些内存使用在算法执行完后就不再需要了，这是临时内存使用</p><p>有些可能是算法的输出，或者是算法运行过程中必须长期保留的，这是持久内存使用</p></li><li><p><strong>计算所有部件的总空间</strong></p><p>评估由输入大小n导致的总内存使用情况</p><p>这通常包括输入数据结构的大小，加上算法内部额外创建的数据结构大小</p></li><li><p><strong>简化表达式</strong></p><p>和时间复杂度一样，去掉表达式中的常量项和低阶项，只保留最高阶项</p></li><li><p><strong>使用大O符号</strong></p><p>最后，使用大O符号来描述空间复杂度</p><p>例如，如果一个算法只需要一个大小与输入大小n成比例的数组，那么空间复杂度就是<code>O(n)</code></p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：计算背包"><a href="#Q36：计算背包" class="headerlink" title="Q36：计算背包"></a>Q36：计算背包</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有 N 件物品和一个容量是 V 的背包。每件物品有且只有一件。</span></span><br><span class="line"><span class="comment">// 第 i 件物品的体积是 v[i] ，价值是 w[i] 。</span></span><br><span class="line"><span class="comment">// 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1：</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], w = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 输出: 4</span></span><br><span class="line"><span class="comment">// 解释: 只选第一件物品，可使价值最大。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], w = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 输出: 5</span></span><br><span class="line"><span class="comment">// 解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>解决这类背包问题，有几种不同的方法，通常包括动态规划、回溯、贪心算法等。下面我将概述几种常用的解决方法：</p><ol><li><p><strong>动态规划（DP）</strong></p><p>动态规划是解决背包问题最经典也是最有效的方法之一</p><p>它主要有两种方式：<strong>0-1背包</strong>和<strong>完全背包</strong></p><p>对于你的问题，我们使用0-1背包的思路，因为每件物品只能选择一次</p><ul><li><p><strong>0-1背包问题</strong></p><p>可以用二维数组<code>dp</code>表示，其中<code>dp[i][j]</code>表示从前<code>i</code>个物品中挑选，总体积不超过<code>j</code>的条件下的最大价值</p><p>状态转移方程为：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</code></p></li></ul><p>这种方法的时间复杂度和空间复杂度均为O(NV)，N是物品数量，V是背包容量</p></li><li><p><strong>动态规划（空间优化）</strong></p><p>基于上面的动态规划方法，可以对其进行空间优化，将二维数组压缩为一维数组。优化后，使用单个数组<code>dp[j]</code>表示总体积不超过<code>j</code>的条件下的最大价值，状态转移方程变为：<code>dp[j] = max(dp[j], dp[j-v[i]] + w[i])</code>。</p><p>空间复杂度降低为O(V)。</p></li><li><p><strong>贪心算法</strong></p><p>贪心算法是另一种思路，它不总能得到最优解，但在某些情况下计算效率较高</p><p>对于物品选择问题，一个简单的贪心策略可能是按价值密度（价值除以体积）降序排列物品，然后尽量选择价值密度高的物品装入背包，直到装不下为止</p></li><li><p><strong>分支限界法</strong></p><p>分支限界法是基于队列的宽度优先搜索，它使用“分支”来探索可行的解空间，并使用“限界”来剪枝，不继续探索那些无法得到最优解的分支</p><p>这种方法适用于更复杂的背包问题或需要精确解的场景</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>0-1背包写法</strong></p><p>实现0-1背包问题的动态规划算法，你需要构建一个二维数组用来保存每个状态下的最大价值</p><p>在实现过程中，我们创建了一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>代表考虑前<code>i</code>个物品，当背包容量限制为<code>j</code>时我们能够装进背包的最大价值</p><p>通过填充这个二维数组，我们可以找到最后的解</p><p>在结束时，<code>dp[N][V]</code>就代表了所有物品在不超过背包容量<code>V</code>的条件下能达到的最大总价值</p><p>注意在真实应用中，为了节省空间，你也可以将这个二维数组压缩到一维数组</p><p>这样的优化需要你在更新<code>dp[j]</code>的时候从后往前更新，这样可以保证状态转移使用的是上个物品的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">  <span class="comment">// dp是一个二维数组，dp[i][j]表示前i个物品，在不超过j的体积下的最大价值</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: N + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前物品体积大于当前背包容量，不能加入当前物品</span></span><br><span class="line">      <span class="keyword">if</span> (v[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - v[i - <span class="number">1</span>]] + w[i - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大价值在dp[N][V]中</span></span><br><span class="line">  <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">knapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">knapsack</span>(N, V, v, w)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完全背包</strong></p><p>完全背包问题的关键区别在于每种物品可以选取无限次</p><p>在JavaScript中，这种问题的动态规划解法与0-1背包问题类似，但是在更新<code>dp</code>数组的时候，内部循环会有所不同，因为你需要考虑重复选择某一物品的情况</p><p>这段代码的处理方式与0-1背包问题的主要差异在于内层循环<code>j</code>的方向</p><p>在完全背包问题中，当你在计算<code>dp[j]</code>时，因为每种类型的物品可以使用多次，所以可以从左到右遍历，并且用自身的先前计算的值来更新后面的值</p><p>这种处理方式意味着在计算<code>dp[j]</code>时，可以重复考虑物品<code>i</code>，而这在0-1背包问题中不被允许</p><p>注意，这里的代码为了简洁明了，省略了物品数量的限制，也就是说，默认情况下每种物品可以无限使用。如果物品有数量限制，解法将不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeKnapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化dp数组，dp[j]代表容量为j的背包能达到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="comment">// 注意：此循环与0-1背包问题相反，我们从小到大遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = v[i]; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="comment">// 更新dp[j]，选择当前物品i或者不选择，取二者的最大值</span></span><br><span class="line">      dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回容量为V的背包的最大价值</span></span><br><span class="line">  <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="comment">// 解释: 选择第二件物品两次</span></span><br></pre></td></tr></table></figure></li><li><p><strong>空间优化写法</strong></p><p>空间优化版本的完全背包问题可以将二维的dp数组压缩为一维数组</p><p>空间复杂度从O(NV)降为O(V)</p><p>空间优化的关键在于对dp数组定义的更改</p><p>在原始方法中，dp是一个二维数组，表示考虑前i个物品在不超过j的体积上的最大价值</p><p>优化后，我们在更新dp[j]时，不再需要考虑“前i个物品”这个维度，只需要考虑“不超过j的体积上的最大价值”，因为我们已经在内层循环中涵盖了所有的物品</p><p>这种优化极大地节省了空间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeKnapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化状态数组，dp[v]代表容量为v的背包能装载物品的最大总价值</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 从小到大遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = v[i]; j &lt;= V; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程，取最大值</span></span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大背包价值存储在dp[V]</span></span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 6，解释：选择第二件物品两次</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：全排列"><a href="#Q37：全排列" class="headerlink" title="Q37：全排列"></a>Q37：全排列</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1：</span></span><br><span class="line"><span class="comment">// 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：</span></span><br><span class="line"><span class="comment">// 输入：nums = [0,1]</span></span><br><span class="line"><span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3：</span></span><br><span class="line"><span class="comment">// 输入：nums = [1]</span></span><br><span class="line"><span class="comment">// 输出：[[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示：</span></span><br><span class="line"><span class="comment">// 1 &lt;= nums.length &lt;= 6</span></span><br><span class="line"><span class="comment">// -10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line"><span class="comment">// nums 中的所有整数 互不相同</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>解决这个问题的关键是采用回溯法</p><p>回溯法是一个通过探索所有可能的候选解来找出所有解的策略</p><p>如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃它，并且递归地尝试另一个候选解</p><p>对于全排列问题，我们可以将问题视为一个树形结构，每一层选择一个不在当前排列中的数字</p><p>当我们达到树的底部时，就找到了一个排列，并且回退到上一步，尝试下一个数字</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码通过递归函数<code>backtrack</code>遍历所有可能的排列情况</p><p>对于每个位置，它都会尝试数组<code>nums</code>中的每一个数字，如果这个数字还没有被使用过（也就是说，它还没有在<code>path</code>中），就将它添加到当前排列(<code>path</code>)中，并继续递归处理下一个位置</p><p>当达到一个完整排列时（也就是<code>path</code>的长度与<code>nums</code>的长度相等），就将其加入到结果<code>result</code>中</p><p>在处理完一个位置所有可能的数字之后，需要进行回溯（通过<code>path.pop()</code>），也就是撤销上一步的选择，尝试其他选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// 结果列表</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">// 路径列表，用来保存当前的排列组合</span></span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">nums, path</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前排列长度等于原始数组长度时，记录当前排列</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 跳过已经选择的数字</span></span><br><span class="line">      <span class="keyword">if</span> (path.<span class="title function_">includes</span>(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 选择当前数字</span></span><br><span class="line">      path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">      <span class="comment">// 进入下一层决策树</span></span><br><span class="line">      <span class="title function_">backtrack</span>(nums, path);</span><br><span class="line">      <span class="comment">// 取消选择当前数字，回退到之前的状态</span></span><br><span class="line">      path.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从空路径开始进行回溯</span></span><br><span class="line">  <span class="title function_">backtrack</span>(nums, path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">0</span>, <span class="number">1</span>]));    <span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>]));       <span class="comment">// 输出：[[1]]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：写一个LRU缓存函数"><a href="#Q38：写一个LRU缓存函数" class="headerlink" title="Q38：写一个LRU缓存函数"></a>Q38：写一个LRU缓存函数</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>LRU缓存，即最近最少使用（Least Recently Used）缓存算法，是一种常用的页面置换算法，选择最近最久未使用的数据进行淘汰</p><p>这个算法的主要目的是为了保持最常用的数据在缓存中，而不经常使用的数据会被移出缓存</p><p>实现LRU缓存机制的分析过程通常包括以下步骤：</p><ol><li><p><strong>确定数据结构</strong></p><p>一个高效的LRU缓存通常需要使用两种数据结构，一种是用于保持插入顺序的链表（比如双向链表），另一种是用于O(1)时间复杂度查找的哈希表</p></li><li><p><strong>实现插入操作</strong></p><p>插入新元素时，我们需要将元素插入到链表的头部</p><p>如果缓存已经达到最大容量，我们则移除链表尾部的元素，因为尾部元素是最近最少使用的</p><p>同时，需要在哈希表中添加该元素的键和指向链表中元素的指针</p></li><li><p><strong>实现访问操作</strong></p><p>访问元素时，如果元素在缓存中，则需要将其移动到链表的头部，表示它最近被使用过</p><p>这也意味着链表的尾部始终表示最久未使用的元素</p></li><li><p><strong>同步操作</strong></p><p>插入和访问操作都需要及时在哈希表和链表之间进行同步，确保两者的数据是一致的</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    #map;</span><br><span class="line">    #capacity;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#capacity = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.#map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.#map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.#map.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 如果key存在，首先删除旧的位置，然后将其重新设置到Map的末尾，代表最近使用过</span></span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">set</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.#map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.#map.<span class="property">size</span> === <span class="variable language_">this</span>.#capacity) &#123;</span><br><span class="line">            <span class="comment">// 当缓存达到上限时，删除最近最少使用的元素</span></span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.#map.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">set</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个方法来修改缓存的容量</span></span><br><span class="line">    <span class="title function_">setCapacity</span>(<span class="params">newCapacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#capacity = newCapacity;</span><br><span class="line">        <span class="comment">// 如果新容量小于当前map的大小，需要删除最久未使用的项直到大小符合新容量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.#map.<span class="property">size</span> &gt; <span class="variable language_">this</span>.#capacity) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.#map.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以提供一些其他的方法来满足不同的需求，例如获取当前缓存容量</span></span><br><span class="line">    <span class="title function_">getCapacity</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前缓存中元素的数量</span></span><br><span class="line">    <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#map.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例:</span></span><br><span class="line"><span class="keyword">const</span> lruCache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">1</span>));   <span class="comment">// 返回  1</span></span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 移除 key 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">2</span>));   <span class="comment">// 返回  -1 (未找到)</span></span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 移除 key 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">1</span>));   <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">3</span>));   <span class="comment">// 返回  3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">4</span>));   <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：大文件怎么实现断点续传"><a href="#Q39：大文件怎么实现断点续传" class="headerlink" title="Q39：大文件怎么实现断点续传"></a>Q39：大文件怎么实现断点续传</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Step 1: 切割文件</strong></p><p>利用JavaScript中的<code>Blob</code>对象的<code>slice</code>方法来切割大文件成为多个小块（即文件片段或file chunks）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file, chunkSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> chunks = [];</span><br><span class="line">  <span class="keyword">const</span> size = file.<span class="property">size</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> start = <span class="number">0</span>; start &lt; size; start += chunkSize) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(start, <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, size));</span><br><span class="line">    chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 2: 上传文件切片</strong></p><p>上传每个文件切片之前，需要检查服务器上已经上传了哪些切片</p><p>通过<code>fetch</code>或<code>axios</code>等HTTP客户端进行异步上传，并在请求中发送额外信息，如切片序号、文件唯一标识符等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadChunks</span>(<span class="params">chunks, fileId</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;chunk&#x27;</span>, chunks[i]);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;fileId&#x27;</span>, fileId);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;index&#x27;</span>, i);</span><br><span class="line">    <span class="comment">// 发送请求到后端</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/upload&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: formData &#125;);</span><br><span class="line">    <span class="comment">// 保存上传进度，用于续传</span></span><br><span class="line">    <span class="title function_">saveProgress</span>(fileId, i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 3: 保存上传进度</strong></p><p>利用<code>localStorage</code>或其他持久化方法来记录上传的进度，这样在网络断开后可以从中断点继续上传</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">saveProgress</span>(<span class="params">fileId, chunkIndex</span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(fileId, chunkIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 4: 断点续传</strong></p><p>在上传之前，先向服务器查询文件上传的进度或已上传的切片，从而决定从哪个切片开始上传</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">continueUploading</span>(<span class="params">file, fileId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="comment">/* 您设置的切片大小 */</span>;</span><br><span class="line">  <span class="keyword">const</span> chunks = <span class="title function_">sliceFile</span>(file, chunkSize);</span><br><span class="line">  <span class="keyword">const</span> uploadedChunks = <span class="keyword">await</span> <span class="title function_">fetchUploadedChunks</span>(fileId);</span><br><span class="line">  <span class="keyword">const</span> remainingChunks = chunks.<span class="title function_">slice</span>(uploadedChunks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">uploadChunks</span>(remainingChunks, fileId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 5: 后端合并切片</strong></p><p>在服务器端，当所有切片上传完成后，需要将这些切片合并成原始的文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 示例</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeChunks</span>(<span class="params">chunks, dest</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wStream = fs.<span class="title function_">createWriteStream</span>(dest);</span><br><span class="line"></span><br><span class="line">  chunks.<span class="title function_">forEach</span>(<span class="function"><span class="params">chunkPath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(chunkPath);</span><br><span class="line">    wStream.<span class="title function_">write</span>(data);</span><br><span class="line">    fs.<span class="title function_">unlinkSync</span>(chunkPath); <span class="comment">// 删除已合并的切片</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  wStream.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些是客户端实现大文件断点续传的基本步骤</p><p>实际实现时，你还需要处理异常情况，比如网络错误重试、权限校验、加密等安全措施、以及后端接收切片的API设计等</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>大文件断点续传是网络传输中的一个术语，指的是在上传或下载大文件时，如果传输中断，则下次可以从中断的地方继续传输，而不是重新开始</p><p>底层实现通常依靠的是HTTP协议的范围请求（Range Requests）</p><p><strong>工作原理简述：</strong></p><ol><li><p><strong>切片</strong></p><p>将整个文件切分成多个小块，每一小块可以单独传输</p></li><li><p><strong>传输记录</strong></p><p>记录每个小块的传输进度，成功或失败</p></li><li><p><strong>中断和恢复</strong></p><p>如果传输中断（比如网络问题、程序关闭等），下次传输可以根据已有的记录，直接从上次中断的小块开始传输</p></li><li><p><strong>文件重组</strong></p><p>当所有的小块都传输完成后，将这些小块重组成原始的大文件</p></li></ol><p><strong>为什么需要断点续传？</strong></p><ul><li><p><strong>节省带宽</strong></p><p>如果网络连接不稳定，避免多次上传下载同一个文件的相同部分</p></li><li><p><strong>提高效率</strong></p><p>对于特别大的文件，重新传输全部内容代价很高</p></li><li><p><strong>用户体验</strong></p><p>提供更为流畅和友好的用户体验，特别是移动设备用户在不稳定网络下</p></li></ul><p>断点续传对于提高大文件传输的可靠性和效率至关重要，特别是在容错、网络条件差、数据传输成本高的情况下</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：版本号排序"><a href="#Q40：版本号排序" class="headerlink" title="Q40：版本号排序"></a>Q40：版本号排序</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一组版本号如下</span></span><br><span class="line">[<span class="string">&#x27;0.1.1&#x27;</span>, <span class="string">&#x27;2.3.3&#x27;</span>, <span class="string">&#x27;0.302.1&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>, <span class="string">&#x27;4.3.5&#x27;</span>, <span class="string">&#x27;4.3.4.5&#x27;</span>]。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需要对其进行排序，排序的结果为 [&#x27;4.3.5&#x27;,&#x27;4.3.4.5&#x27;,&#x27;2.3.3&#x27;,&#x27;0.302.1&#x27;,&#x27;0.1.1&#x27;]</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这是一个关于版本号排序问题的javascript解决办法</p><p>把每一个版本号分解，并使用’.’做成一个数组，这样你具有一个一维数组，其中每个元素是一个数组</p><p>然后根据这个数组，你可以使用数组的<code>sort()</code>方法进行排序</p><p>在排序函数中，你需要进行一些定制，以确保排序行为符合你的期望</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">versionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aArr = a.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    <span class="keyword">let</span> bArr = b.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">max</span>(aArr.<span class="property">length</span>, bArr.<span class="property">length</span>); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((aArr[i] || <span class="number">0</span>) &lt; (bArr[i] || <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((aArr[i] || <span class="number">0</span>) &gt; (bArr[i] || <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> versions = [<span class="string">&#x27;0.1.1&#x27;</span>, <span class="string">&#x27;2.3.3&#x27;</span>, <span class="string">&#x27;0.302.1&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>, <span class="string">&#x27;4.3.5&#x27;</span>, <span class="string">&#x27;4.3.4.5&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">versionSort</span>(versions));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [ &#x27;4.3.5&#x27;, &#x27;4.3.4.5&#x27;, &#x27;4.2&#x27;, &#x27;2.3.3&#x27;, &#x27;0.302.1&#x27;, &#x27;0.1.1&#x27; ]</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们首先定义了一个函数<code>versionSort()</code>，它接收一个版本号数组</p><p>在这个函数中我们使用了数组的<code>sort()</code>方法，定制排序函数来对数组排序</p><p>在排序函数中，我们首先把版本号分解成多个部分，然后我们对版本号的每一部分进行比较，如果发现某一部分的版本号更大，我们就认定此版本号整体更大，并结束循环和比较</p><p>如果所有部分的版本号都相等，我们认定此版本号等于比较的版本号</p>
              </div>
            </details>
<p><br/></p>
<h3 id="排序算法拓展Q41-Q42"><a href="#排序算法拓展Q41-Q42" class="headerlink" title="排序算法拓展Q41-Q42"></a>排序算法拓展Q41-Q42</h3><details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>冒泡排序（Bubble Sort）</strong></p><p>通过重复遍历要排序的数列，比较每对相邻元素，如果他们的顺序错误就把他们交换过来</p><p>过程类似在水中的气泡逐渐上升</p></li><li><p><strong>选择排序（Selection Sort）</strong></p><p>首先在未排序的数列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾</p></li><li><p><strong>希尔排序（Shell Sort）</strong></p><p>是插入排序的一种更高效的改进版本</p><p>希尔排序会先将数列进行分组，然后对每组数据进行插入排序，逐渐缩小分组的间隔进行排序，最终当整个数列基本有序时，再对全体元素进行一次直接插入排序</p></li><li><p><strong>插入排序（Insertion Sort）</strong></p><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p></li><li><p><strong>归并排序（Merge Sort）</strong></p><p>归并排序是建立在归并操作上的一种有效的排序算法</p><p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p></li><li><p><strong>快速排序（Quick Sort）</strong></p><p>通过选取一个元素作为基准，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面，此时基准元素在其排好序后的正确位置</p></li><li><p><strong>堆排序（Heap Sort）</strong></p><p>利用堆这种数据结构所设计的，视为一种树形选择排序</p></li><li><p><strong>计数排序（Counting Sort）</strong></p><p>是一个非比较排序，利用数组下标来确定元素的正确位置</p></li><li><p><strong>桶排序（Bucket Sort）</strong></p><p>数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p></li><li><p><strong>基数排序（Radix Sort）</strong></p><p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位</p><p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序</p></li></ol>
              </div>
            </details>
<h3 id="Q41：实现冒泡排序"><a href="#Q41：实现冒泡排序" class="headerlink" title="Q41：实现冒泡排序"></a>Q41：实现冒泡排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历待排序的数组，比较两个相邻的项目，并且在必要时交换它们</p><p>每遍历一次都会确保至少有一个元素被移动到其最终位置</p><p>实现冒泡排序的步骤解析：</p><ol><li><p><strong>检查输入是否为数组 (<code>Array.isArray(arr)</code>)</strong> </p><p>这个条件判定确保了输入的数据类型是数组</p><p>冒泡排序是针对数组设计的，所以这个检查是必要的</p></li><li><p><strong>空数组或单个元素数组的检查 (<code>arr.length &lt;= 1</code>)</strong></p><p> 如果数组为空或者仅包含一个元素，则不需要排序，因为它已经是有序的</p><p>直接返回原数组</p></li><li><p><strong>设置<code>n</code>为数组的长度 (<code>n = arr.length</code>)</strong></p><p> 这个变量后面会被用来确定当前未排序部分的范围</p></li><li><p><strong>定义<code>newN</code>变量</strong> </p><p>这个变量用来记录在某一趟遍历中最后一次发生元素交换的位置，表示数组从<code>newN</code>之后的位置已经是排序好的，下一轮排序时不需要再考虑</p></li><li><p><strong>执行排序的外部循环 (<code>do...while</code>)</strong></p><p> 外部循环确保排序会持续进行直到没有再需要交换的项，这表示数组已经完全排序</p></li><li><p><strong>内部循环 (<code>for</code>循环)</strong></p><p> 在数组的未排序部分进行遍历</p><ul><li><p><strong>类型检查 (<code>typeof arr[i - 1] !== typeof arr[i]</code>)</strong></p><p> 在比较之前确认元素类型相同，以确保排序的有效性和防止JavaScript的强制类型转换可能导致的问题</p></li><li><p><strong>相邻元素比较 (<code>arr[i - 1] &gt; arr[i]</code>)</strong></p><p> 对当前元素和它之前的元素进行比较。如果前面的元素比当前元素大，它们的位置需要交换</p></li><li><p><strong>交换元素</strong></p><p> 使用临时变量<code>temp</code>来交换两个元素的位置</p></li><li><p><strong>更新<code>newN</code></strong></p><p> 设置<code>newN</code>为这次内部循环中最后一次发生交换的索引</p></li></ul></li><li><p><strong>更新<code>n</code></strong></p><p> 将<code>n</code>设置为最后一次发生交换的位置<code>newN</code>，这样下一次外部循环时，只需要检查到<code>newN</code>为止，因为后面的部分已经排序好了</p></li><li><p><strong>循环结束条件 (<code>newN != 0</code>)</strong></p><p> 如果在一轮完整的遍历中没有发生任何交换，<code>newN</code>会保持为0，这表明数组已经完全排序，循环可以结束</p></li></ol><p>通过以上步骤，冒泡排序利用交换元素的方式实现了数组的排序</p><p>冒泡的“名字”来源于较大元素的“冒泡”效应，因为在每轮遍历中，它们会如气泡一般逐渐“浮”到数组的一端</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查输入是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The provided input is not an array.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查数组长度，对于空数组或只有一个元素的数组直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> newN; <span class="comment">// 用于记录一轮遍历中最后一次交换的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      newN = <span class="number">0</span>; <span class="comment">// 每轮开始前将newN重置为0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// 添加了一个检查用以确保元素能够比较</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> arr[i - <span class="number">1</span>] !== <span class="keyword">typeof</span> arr[i]) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Elements are not of the same type for comparison.&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">              <span class="keyword">let</span> temp = arr[i - <span class="number">1</span>];</span><br><span class="line">              arr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">              arr[i] = temp;</span><br><span class="line">              newN = i; <span class="comment">// 更新为最新的交换位置</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      n = newN; <span class="comment">// 将n更新为最后一次交换的位置，下一轮遍历只到这里为止</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (newN != <span class="number">0</span>); <span class="comment">// 如果一轮中没有任何交换发生，那么数组已经是排序好的，循环结束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数组</span></span><br><span class="line"><span class="keyword">let</span> testArray = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行冒泡排序</span></span><br><span class="line"><span class="title function_">bubbleSort</span>(testArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出排序后的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testArray);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：实现选择排序"><a href="#Q42：实现选择排序" class="headerlink" title="Q42：实现选择排序"></a>Q42：实现选择排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是选择排序算法的一个 JavaScript 实现</p><p>以下是每个主要部分的详细解析:</p><ol><li><p><code>if (!Array.isArray(arr))</code> 这个部分检查输入的参数是否为数组</p><p>如果不是，就抛出一个 <code>TypeError</code></p></li><li><p><code>if(arr.length &lt;= 1) return arr;</code> 对于空数组或只有一个元素的数组，它们已经被认为是排序过的，所以直接返回就可以了</p></li><li><p><code>arr.forEach((ele, index) =&gt; {...}</code> 这个循环检查数组的每个元素是否为数字，并且不是 <code>NaN</code></p><p>如果元素不是数字或者是 <code>NaN</code>，那么会抛出一个 <code>TypeError</code></p></li><li><p><code>for (let i = 0; i &lt; n - 1; i++) {...}</code> 这个外层循环遍历数组的每个元素，将当前元素设为最小元素</p></li><li><p><code>for (let j = i + 1; j &lt; n; j++) {...}</code> 内层循环遍历当前元素之后的所有元素，如果找到比当前最小元素还小的元素，就更新最小元素的索引</p></li><li><p><code>if (i !== minIndex) {...}</code> 当一次内层循环结束后，如果最小元素不是当前元素（that is, 索引 <code>i</code> 和 <code>minIndex</code> 不等），就交换这两个元素的位置</p><p>这样，第 <code>i</code> 个位置上的元素就会是前 <code>i+1</code> 个元素中的最小元素</p></li><li><p>最后，返回排序后的数组</p></li></ol><p>这个算法的时间复杂度是 O(n^2)，其中 n 是数组的长度</p><p>尽管选择排序在大多数情况下没有快速排序或归并排序高效，但是它的代码简洁，而且不需要使用额外的内存空间，这使得它在某些情况下仍然是一个很好的选择</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查输入是否为数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The provided input is not an array.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于非常小的数组，排序是不必要的，可以早点返回</span></span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在开始排序之前，检查数组元素是否可比较</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> ele !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(ele)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`The provided input array contains non-comparable elements at index <span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;ele&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到了一个较小的元素，与当前位置的元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：实现希尔排序"><a href="#Q43：实现希尔排序" class="headerlink" title="Q43：实现希尔排序"></a>Q43：实现希尔排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是希尔排序算法的实现，我会详细地逐步解析这个过程。</p><ol><li><p>输入验证</p><p><strong>首先</strong>, 它验证传入的参数是不是一个数组，如果不是数组则抛出错误“<code>Input must be an array</code>”</p><p><strong>然后</strong>, 它通过一个for循环遍历数组中的每一个元素来验证每个元素是否为数字或字符串</p><p>如果数组中存在既不是数字也不是字符串的元素，则抛出错误“<code>Array elements must be numbers or strings</code></p></li><li><p>初始化变量</p><p><strong>接下来</strong>, 定义了数组的长度<code>len</code>和初始间隔<code>gap</code></p><p>间隔的初始值设为1，这个值将用于确定排序时比较元素之间的间隔</p></li><li><p>动态定义间隔序列</p><p>使用一个while循环计算初始的<code>gap</code>值</p><p>这个循环基于希尔排序的增量序列计算方法（<code>gap = gap * 3 + 1</code>），直到<code>gap</code>值不小于数组长度的三分之一</p><p>这样做是为了从较宽的间隔开始排序，并逐步缩短间隔，最终达到1</p></li><li><p>进行希尔排序</p><p><strong>在外层for循环中</strong>, <code>gap</code>值从初始值开始不断地通过<code>Math.floor(gap / 3)</code>缩小，直到<code>gap</code>值为1</p><p>这是希尔排序中减小间隔的过程</p><p><strong>内层for循环</strong>从<code>i = gap</code>开始迭代数组，这确保了每次比较都是在间隔<code>gap</code>之间进行的</p><p><strong>最内层for循环</strong>将当前元素<code>arr[j]</code>与距离<code>gap</code>位置之前的对应元素<code>arr[j - gap]</code>进行比较</p><p>如果<code>arr[j] &lt; arr[j - gap]</code>，则将它们位置互换</p><p>这个比较和交换过程一直进行，直到当前元素正确地“插入”（实际上是交换到正确位置）或是已经比较到数组的开始位置</p></li><li><p>结束和返回</p><p>当所有的间隔遍历完成，数组将完成排序，并通过<code>return arr;</code>返回排序后的数组</p></li></ol><p>这就是希尔排序的整个过程，从较大的间隔开始，逐渐缩小间隔进行比较和交换，直至间隔为1，相当于进行了一次插入排序，这时数组已经是排序好的了</p><p>这种方法相比于直接插入排序，在同样是基于插入的排序算法中，大大提升了效率</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 输入验证</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element !== <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> element !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Array elements must be numbers or strings&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>,</span><br><span class="line">    gap = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt;= gap &amp;&amp; arr[j] &lt; arr[j - gap]; j -= gap) &#123;</span><br><span class="line">        <span class="comment">// 交换元素位置</span></span><br><span class="line">        [arr[j], arr[j - gap]] = [arr[j - gap], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shellSort</span>([<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q44：实现插入排序"><a href="#Q44：实现插入排序" class="headerlink" title="Q44：实现插入排序"></a>Q44：实现插入排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是插入排序算法的一个实现，适用于JavaScript数组</p><p>下面我会逐步解析代码的各个部分：</p><ol><li><p><strong>数组输入验证</strong></p><ul><li>函数首先检查传入的参数<code>arr</code>是否为数组类型。如果不是，抛出一个错误</li></ul></li><li><p><strong>元素类型验证与NaN排除</strong></p><ul><li><p>检查数组中的每个元素是否都是数字类型，并且不是<code>NaN</code>（Not a Number）</p><p>如果某个元素不是数字或者是<code>NaN</code>，抛出一个错误</p></li></ul></li><li><p><strong>排序逻辑</strong></p><ul><li><p>函数通过两层循环来实现插入排序</p><ul><li><p>外层循环从<code>arr</code>的第二个元素开始，即索引<code>1</code>，遍历到数组的末尾</p><p>这个外层循环表示我们从未排序部分取出的待插入元素</p></li><li><p>内层循环用于找到这个待插入元素在已排序部分的正确位置，并将其插入</p><p>在这个过程中，我们把当前元素<code>current</code>保存在一个变量中，并逐一将已排序的元素向后移动，直到找到一个比<code>current</code>小的元素</p></li></ul></li><li><p>一旦找到合适的位置，我们退出内层循环，并将<code>current</code>放到正确的位置上</p></li></ul></li><li><p><strong>插入动作</strong></p><ul><li>当内层循环完成后，已找到<code>current</code>元素的插入位置，此时<code>j</code>变量代表<code>current</code>元素应该插入的位置索引</li><li>最后一步是将<code>current</code>变量赋值给<code>arr[j+1]</code>，这样我们就将元素插入到了数组的正确位置</li></ul></li></ol><p>代码执行后会返回已经排序的数组</p><p>插入排序算法利用了事实，即数组的一个子序列（在当前索引之前的元素）已经是排序过的</p><p>它在每次迭代中都会将一个新元素插入到已排序的子序列中，直到整个数组排序完成</p><p>插入排序的时间复杂度通常是O(n^2)，对于较小的或部分排序的数组来说效率是可接受的</p><p>对于较大的数组，可能会需要更高效的算法，如快速排序、堆排序或归并排序</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 验证输入是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证数组元素类型并排除 NaN</span></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(item)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;All array elements must be valid numbers&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找插入位置的同时进行元素移动</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; current) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = current; <span class="comment">// 完成插入动作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q45：实现归并排序"><a href="#Q45：实现归并排序" class="headerlink" title="Q45：实现归并排序"></a>Q45：实现归并排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是一个实现归并排序的JavaScript函数，它包括两个部分：<code>mergeSort</code>主函数和<code>merge</code>辅助函数</p><p>让我们逐步来解析一下这段代码</p><ol><li><p><strong>mergeSort函数</strong></p><p>这是一个调用归并排序算法的函数，输入参数为一个待排序的数组<code>arr</code></p><ul><li>首先，函数通过<code>Array.isArray(arr)</code>来检查输入是否为数组，然后使用<code>every</code>方法检查数组内的每个元素是否都是有限的数字，对于非数组或者数组中含有无效数字的情况，会抛出一个错误信息</li><li>如果数组长度小于等于1（表示数组为空或只有一个元素），那就没有必要排序，直接返回原数组</li><li>然后，函数将待排序的数组从中间拆分为两个子数组，一个包含前半部分的元素，另一个包含后半部分的元素</li><li>最后，函数递归地对这两个子数组进行排序，然后通过<code>merge</code>函数将排序后的结果合并在一起</li></ul></li><li><p><strong>merge函数</strong></p><p>这是一个辅助函数，使用两个已经排序的数组作为输入参数，在这个例子中就是<code>left</code>和<code>right</code></p><ul><li>函数首先初始化一个空的结果数组<code>resultArray</code>和两个从0开始的索引<code>leftIndex</code>和<code>rightIndex</code></li><li>在接下来的循环中，函数将<code>left</code>数组中索引为<code>leftIndex</code>的元素和<code>right</code>数组中索引为<code>rightIndex</code>的元素进行比较，较小的那一个将被推入<code>resultArray</code>，并将相应的索引加1，用于追踪两个数组中的比较进度</li><li>最后，当<code>left</code>数组和<code>right</code>数组中的元素都被比较过后，剩下的未被比较的元素（其一定会全部在其中一个数组的末尾并且比已经比较过的元素要大）会被加入到结果数组的尾部</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 验证输入是否为数组, 并确保每个元素都是有效的数字</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="title function_">every</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="keyword">typeof</span> num === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isFinite</span>(num))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array of numbers.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(middle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> resultArray = [], leftIndex = <span class="number">0</span>, rightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.<span class="property">length</span> &amp;&amp; rightIndex &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      resultArray.<span class="title function_">push</span>(left[leftIndex]);</span><br><span class="line">      leftIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resultArray.<span class="title function_">push</span>(right[rightIndex]);</span><br><span class="line">      rightIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultArray</span><br><span class="line">    .<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(leftIndex))</span><br><span class="line">    .<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(rightIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q46：实现快速排序"><a href="#Q46：实现快速排序" class="headerlink" title="Q46：实现快速排序"></a>Q46：实现快速排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>isNumeric(value)</code> </p><p> 这是一个辅助函数，接收一个参数并返回一个布尔值表示该参数是否是finite number（即不是NaN, Infinity或-Infinity）</p></li><li><p><code>swap(array, i, j)</code> </p><p>它是用于交换数组两个索引下的元素的位置</p><p>这个函数在排序算法中非常关键</p></li><li><p><code>partition(array, left, right)</code> 在快速排序中也是一个核心的函数</p><p>所谓”partition operation”，就是将数组分成两半，使得左边子数组的所有元素都小于右边子数组的所有元素</p><p>同时，该函数还会返回一个“pivot index”</p><p>这个索引是计算后得到，使得所有比它小的元素都在它的左边，所有比它大的元素都在它的右边</p><p>这个pivot就是我们之后进行递归操作的基础</p></li><li><p><code>quickSort(array, left, right)</code> 是主要的排序函数</p><p>它首先检查传入的参数是否满足所需的要求，例如数组中的元素是否全为数字等</p><p>然后，它使用了划分(partition)操作并得到了一个“pivot index”</p><p>在得到这个pivot index后，quickSort函数进行自我调用，对pivot index的左边和右边的子数组分别进行排序</p><p>这个过程中的自我调用，就是quickSort中的“递归”部分</p></li></ol><p>快速排序算法是一种非常高效的排序算法</p><p>它的基本思想是：通过一次排序将待排序数据分割成独立的两部分，其中一部分数据都比另外一部分的数据小，然后再按此方法对这两部分数据分别进行快速排序，整个过程可以递归进行，以此达到整个数据变成有序序列</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumeric</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; !<span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isFinite</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, left = <span class="number">0</span>, right = array.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 参数验证</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The first argument must be an array&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> right !== <span class="string">&#x27;number&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Left and right must be numbers&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回已经排序好的小数组</span></span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查元素是否全部为数字</span></span><br><span class="line">  <span class="keyword">if</span> (!array.<span class="title function_">slice</span>(left, right + <span class="number">1</span>).<span class="title function_">every</span>(isNumeric)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array should contain only numbers&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始排序</span></span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title function_">partition</span>(array, left, right); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">quickSort</span>(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pivotIndex &lt; right) &#123;</span><br><span class="line">    <span class="title function_">quickSort</span>(array, pivotIndex, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, i, j</span>) &#123;</span><br><span class="line">  [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = array[<span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (array[j] &gt; pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(array, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q47：实现堆排序"><a href="#Q47：实现堆排序" class="headerlink" title="Q47：实现堆排序"></a>Q47：实现堆排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>heapSort</code> 函数</p><p>这是排序的主函数，接收一个数组 <code>arr</code> 作为参数</p><ol><li><strong>输入验证</strong>: 首先，进行检查以确保 <code>arr</code> 参数是一个数组</li><li><strong>长度验证</strong>: 如果数组长度 <code>&lt;= 1</code>，那就不需要排序，直接返回原数组</li><li><strong>类型验证</strong>: 接下来检查数组中的每个元素都是有限数值</li><li><strong>构建最大堆</strong>: 使用 <code>buildMaxHeap</code> 函数把输入数组 <code>arr</code> 转换为最大堆</li><li>排序逻辑<ul><li>循环从数组的末尾开始到索引1处结束</li><li>使用 <code>swap</code> 函数将堆顶的最大元素与当前考察位置的元素交换</li><li>调用 <code>maxHeapify</code> 函数将堆顶至考察位置上的部分调整为最大堆</li></ul></li></ol><p>这个函数将按升序排列数组 <code>arr</code></p></li><li><p><code>buildMaxHeap</code> 函数</p><p>这个辅助函数将数组转换成一个最大堆结构</p><ul><li>从最后一个非叶子节点开始向前（这是由 <code>start = Math.floor(length / 2) - 1</code> 决定的），每个节点都进行下沉操作，以保证子节点的值小于这个节点的值</li></ul></li><li><p><code>maxHeapify</code> 函数</p><p><code>maxHeapify</code> 是堆排序核心步骤，它确保堆的属性被维护</p><ul><li>该函数接收一个索引 <code>index</code> 和堆的大小 <code>heapSize</code>，使用左儿子和右儿子的索引与当前节点的值进行比较</li><li>如果子节点的值大于父节点，<code>largest</code> 将记录最大值的索引</li><li>如果发现最大值的索引不是当前考察的父节点，则通过 <code>swap</code> 交换当前节点和最大值的节点</li><li>由于交换后影响了子堆的结构，所以递归调用 <code>maxHeapify</code> 来调整变动后的子堆，确保它仍然是最大堆</li></ul></li><li><p><code>swap</code> 函数</p><p>这个简单的函数通过解构赋值交换数组中两个元素的位置</p><ul><li>实现数组 <code>arr</code> 中索引 <code>i</code> 和 <code>j</code> 上的两个元素的交换。这种写法是ES6语法糖，是交换元素的快捷方式</li></ul></li></ol><p>这整个堆排序的过程：</p><p>首先，通过 <code>buildMaxHeap</code> 将数组重新排序成最大堆</p><p>然后，堆顶（也是整个数组中的最大值）和数组的最后一个元素交换位置，然后缩小考察的数组范围（即 减少 <code>heapSize</code>），由于交换破坏了最大堆的属性，需要重新调用 <code>maxHeapify</code> 来恢复最大堆</p><p>重复这个过程，直到整个数组完全排序</p><p>最终，原数组 <code>arr</code> 变成已排序的数组，并返回</p><p>由于堆排序的方法，我们每次都能确定最大的元素被放置在最终的位置，因此不需要额外的存储空间之外的数组来进行排序</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Expected an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!arr.<span class="title function_">every</span>(<span class="title class_">Number</span>.<span class="property">isFinite</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array must contain only numbers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建最大堆</span></span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(arr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换首尾元素并重新调整最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 从最后一个非叶子节点开始向前遍历，进行下沉操作</span></span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, i, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">arr, index, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>, largest = index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (largest !== index) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(arr, index, largest);</span><br><span class="line">    <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, largest, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>) &#123;</span><br><span class="line">  [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q48：怎么实现一个二维码登录pc网站"><a href="#Q48：怎么实现一个二维码登录pc网站" class="headerlink" title="Q48：怎么实现一个二维码登录pc网站"></a>Q48：怎么实现一个二维码登录pc网站</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>二维码登录是现代Web开发中常见的一种身份验证方式，尤其在移动设备广泛使用的背景下</p><p>它提供了一个便捷的方法，允许用户通过扫描二维码来登录PC网站，避免了手动输入账号密码的麻烦</p><p>接下来，我将详细解释二维码的本质及如何实现二维码登录PC网站</p><p><strong>二维码的本质</strong></p><p>二维码（Quick Response Code, QR Code）是一种矩阵二维码或二维条码，它由黑白色块组成</p><p>与传统的一维条码相比，二维码可以存储更多信息，包括网址、文本或其他数据</p><p>二维码可以通过相机扫描进行读取，这一点在二维码登录中尤为重要</p><p><strong>实现二维码登录的流程</strong></p><p>实现二维码登录通常涉及后端服务器、PC网站（通常是网站的登录页面）和用户的移动设备</p><p>基本流程大致如下：</p><ol><li><p>生成登录二维码</p><p><strong>在PC网站登录页面生成二维码</strong> </p><p>当用户打开PC网站的登录页面时，网站后台会生成一个唯一标识（通常是一个随机生成的字符串或UUID），并将这个唯一标识与一个登录请求的URL合并</p><p>然后，使用这个URL生成二维码显示在登录页面上</p></li><li><p>移动设备扫描二维码</p><p><strong>用户使用移动设备扫描二维码</strong> </p><p>这一步通常需要用户已经在移动设备上登录了相应的移动应用（比如微信、支付宝等），应用可以识别并处理扫描到的URL</p></li><li><p>移动设备请求登录授权</p><p><strong>移动应用处理二维码中的URL，向服务器发起登录授权请求</strong></p><p>在这一步，移动应用通常会向服务器发送包含用户凭据（如令牌）和二维码中的唯一标识的请求</p></li><li><p>服务器验证并授权登录</p><p><strong>服务器验证请求</strong></p><p>服务器接收到登录授权请求后，验证用户凭据和唯一标识</p><p>如果验证成功，服务器则认为PC端的登录请求是合法的</p></li><li><p>通知PC端登录成功</p><p><strong>服务器通过WebSocket或轮询机制通知PC端</strong></p><p>一旦服务器验证用户成功，并且授权了PC端的登录请求，它需要一个方式来通知PC端</p><p>这通常通过WebSocket连接实现，如果PC端在生成二维码时就建立了WebSocket连接</p><p>或者通过PC端定期轮询服务器来检查登录状态</p></li><li><p>PC端完成登录</p><p><strong>PC端接收到登录成功的通知后，完成登录过程</strong> </p><p>这可能涉及到设置用户的登录状态、储存令牌和跳转到登录后的页面等</p></li></ol><p><strong>关键技术实现</strong></p><ol><li><p><strong>二维码生成</strong> </p><p>可以使用各种前端库来在网页上生成二维码，例如<code>qrcode.js</code></p></li><li><p><strong>WebSocket或轮询</strong> </p><p>WebSocket提供了一个实时双向通信方案，使得服务器可以实时通知PC网站</p><p>如果不使用WebSocket，可以采用定时轮询的方式，让PC端定时向服务器发起请求查询登录状态</p></li><li><p><strong>唯一标识处理</strong> </p><p>在服务器端生成并处理唯一标识（比如UUID），将它与用户的登录状态关联起来</p></li><li><p><strong>安全性</strong> </p><p>确保所有通信都通过HTTPS进行，保护用户数据安全</p><p>另外，二维码的有效期应该设定得短些，避免被滥用</p></li></ol><p>通过上述流程和关键技术实现点，你可以在自己的PC网站上实现二维码登录功能</p><p>这种登录方式为用户提供了便利的同时，也要确保整个过程的安全性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q49：Javascript里面的倒计时怎么纠正偏差"><a href="#Q49：Javascript里面的倒计时怎么纠正偏差" class="headerlink" title="Q49：Javascript里面的倒计时怎么纠正偏差"></a>Q49：Javascript里面的倒计时怎么纠正偏差</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>使用服务器时间作为基准</strong></p><p>因为用户的设备时间可能不准确，所以最好在倒计时开始时同步一次服务器时间，并据此进行后续的倒计时计算</p><ul><li><p><strong>AJAX请求</strong></p><p>通过一个异步请求获取服务器时间，并存储这个时间用于后续计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getServerTime</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api/server-time&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(data.<span class="property">serverTime</span>); <span class="comment">// 服务器的UNIX时间戳</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>WebSocket连接</strong></p><p>维持一个WebSocket连接，动态同步服务器时间用于精确计时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已经打开了一个WebSocket连接ws</span></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> serverTime = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>).<span class="property">serverTime</span>;</span><br><span class="line">  <span class="title function_">startCountdown</span>(serverTime);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>校正时间间隔</strong></p><p>使用<code>setTimeout</code>或<code>setInterval</code>的周期性调用可以不断校正时间，避免累计误差</p><p>每次回调时应该重新计算剩余时间，而不是简单依赖固定的间隔</p><ul><li><p><strong>递归<code>setTimeout</code>调用</strong>：使用<code>setTimeout</code>代替<code>setInterval</code>，并在每次回调执行时递归地调用它，实现自调正的特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">remaining</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(remaining + <span class="string">&#x27; ms remaining&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(remaining - <span class="number">1000</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">countdown</span>(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>动态延迟</strong>：在<code>setTimeout</code>中动态计算下一次回调的延迟时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adaptiveCountdown</span>(<span class="params">endTime</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scheduleNextTick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">var</span> remaining = endTime - now;</span><br><span class="line">    <span class="keyword">var</span> nextTick = remaining % <span class="number">1000</span> || <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(scheduleNextTick, nextTick);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">scheduleNextTick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>避免长时间间隔</strong></p><p>尽量不要设置很长的单次倒计时（如几分钟以上），因为更长的时间间隔意味着更大的潜在偏差</p><p>如果需要长时间倒计时，应该分成多个较短的间隔</p><ul><li><p><strong>分段计时</strong></p><p>将长时间间隔分成多个短时间间隔，逐段计时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">segmentCountdown</span>(<span class="params">duration, segment</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> segmentsLeft = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(duration / segment);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    segmentsLeft--;</span><br><span class="line">    <span class="keyword">if</span> (segmentsLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(tick, segment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(tick, segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用性能优化</strong></p><p>确保倒计时函数的执行尽可能快和轻量，减少其他JavaScript任务对倒计时精度的影响</p><ul><li><p><strong>降低页面复杂度</strong></p><p>确保倒计时期间页面尽可能简洁，减少DOM操作和CPU密集型任务</p></li><li><p><strong>使用<code>requestAnimationFrame</code></strong></p><p>这通常用于动画，但可以确保计时器的代码在浏览器绘图前执行，从而保持同步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">frameCountdown</span>(<span class="params">targetTime</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">frame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (targetTime &gt; now) &#123;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用Web Workers</strong></p><p>如果需要高精度计时器，可以使用Web Workers，因为它们运行在后台线程，不受主线程任务的干扰</p><ul><li><p><strong>Dedicated Worker</strong></p><p>创建一个独立的脚本文件，该文件作为Web Worker运行，用于倒计时</p><p>这个Dedicated Worker脚本接收来自主线程的倒计时开始指令，然后每秒通过<code>postMessage</code>方法更新剩余时间，直至倒计时结束</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收主线程消息，开始倒计时</span></span><br><span class="line">onmessage = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> seconds = event.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> countdown = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">postMessage</span>(seconds);</span><br><span class="line">    <span class="keyword">if</span>(seconds-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(countdown, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">countdown</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在主线程处理倒计时逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Dedicated Worker</span></span><br><span class="line"><span class="keyword">var</span> countdownWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;countdownWorker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收Worker发来的倒计时数据</span></span><br><span class="line">countdownWorker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;剩余时间: &quot;</span> + event.<span class="property">data</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(event.<span class="property">data</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;倒计时结束!&quot;</span>);</span><br><span class="line">    countdownWorker.<span class="title function_">terminate</span>(); <span class="comment">// 停止Worker</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动倒计时，比如60秒</span></span><br><span class="line">countdownWorker.<span class="title function_">postMessage</span>(<span class="number">60</span>);</span><br></pre></td></tr></table></figure></li><li><p>Shared Worker</p><p>如果需要在多个标签页或者iframe中共享同一个倒计时，可以使用Shared Worker来实现</p><p>主线程代码</p><p>只需要一处（例如，用户打开的第一个标签页）通过<code>postMessage</code>启动倒计时，其他所有连接了这个Shared Worker的标签页都会收到倒计时更新的消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;sharedCountdownWorker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mySharedWorker.<span class="property">port</span>.<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line">mySharedWorker.<span class="property">port</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;剩余时间: &quot;</span> + e.<span class="property">data</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">data</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;倒计时结束！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在一个标签页中启动倒计时即可</span></span><br><span class="line"><span class="comment">// mySharedWorker.port.postMessage(60);</span></span><br></pre></td></tr></table></figure><p>这个Shared Worker脚本接收来自任一连接它的页面的倒计时开始指令，然后每秒通过<code>postMessage</code>给所有连接的端口更新剩余时间，实现多标签页或iframe间的倒计时共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ports = [];</span><br><span class="line">onconnect = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">  ports.<span class="title function_">push</span>(port);</span><br><span class="line"></span><br><span class="line">  port.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> seconds = event.<span class="property">data</span>;</span><br><span class="line">    <span class="title function_">countdown</span>(seconds);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">seconds</span>) &#123;</span><br><span class="line">  ports.<span class="title function_">forEach</span>(<span class="function"><span class="params">port</span> =&gt;</span> &#123;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(seconds);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(seconds-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(seconds), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>前端JavaScript获取的时间实际上是来自用户设备的系统时间，这意味着如果用户修改了设备的时间，那么JavaScript获取的时间也会受到影响，倒计时和其他依赖时间的功能会因此而不准确</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q50：实现合并Promise函数"><a href="#Q50：实现合并Promise函数" class="headerlink" title="Q50：实现合并Promise函数"></a>Q50：实现合并Promise函数</h3><p>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中</p>
<p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">time</span> = (<span class="params">timer</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax1</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax2</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax3</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span> () &#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>promise方式</strong></p><p>为了实现<code>mergePromise</code>函数，我们需要按照传入数组的顺序依次执行这些异步操作，并收集每个异步操作的结果</p><p>这可以通过链式调用Promise的<code>.then()</code>方法来完成</p><p>在这个实现中，<code>mergePromise</code>函数接受一个包含ajax函数的数组<code>ajaxArray</code></p><p>我们定义了<code>data</code>数组来保存每个ajax调用后resolve的结果</p><p>我们开始时有一个“空”的已经resolved的Promise对象，我们把这个Promise对象赋值给<code>sequence</code>变量</p><p>然后我们利用<code>Array.prototype.forEach</code>遍历<code>ajaxArray</code>数组，将数组中的每个函数加到<code>sequence</code>的调用链中，并通过连续调用<code>.then()</code>保证顺序执行</p><p>在每一次迭代中，我们都将上一个Promise通过<code>.then()</code>链接到当前的ajax调用，然后在另一个<code>.then()</code>中将结果<code>res</code>推入<code>data</code>数组，并返回<code>data</code>数组，这样下一个Promise的<code>.then()</code>可以接收到上一个<code>.then()</code>返回的数据数组</p><p>这样遍历之后，<code>data</code>数组就按顺序积累了所有ajax调用的结果</p><p>最后返回的<code>sequence</code> Promise在所有的ajax函数都顺序执行并且它们的结果都被推入<code>data</code>数组之后，就会被resolve</p><p>这个最后的Promise resolve了<code>data</code>数组作为结果，然后我们在<code>.then()</code>回调函数中打印出”data”数组和”done”</p><p>利用这种方式，我们实现了函数依次执行，并按序收集它们resolve的值</p></li><li><p><strong>await方式</strong></p><p>也可以使用<code>async/await</code>来实现</p><p>使用<code>async/await</code>可以让我们的代码看起来更像同步代码，降低了复杂性</p><p>在此实现中，我们使用<code>async</code>关键字声明了一个异步函数<code>mergePromise</code>，此函数接受一个包含ajax函数的数组<code>ajaxArray</code></p><p>在异步函数内部，我们可以使用<code>await</code>关键字来等待每个ajax函数的完成，并将结果push进<code>data</code>数组</p><p>这种方式的优点是，代码更简洁，更易于阅读</p><p>我们没有必要手动创建一个Promise链，可以直接在for循环中循环等待每个Promise的resolve，一旦全部完成，我们便得到了所有值放在<code>data</code>数组中</p><p>然后返回这个数组，当所有ajax调用都结束后，将会resolve整个<code>mergePromise</code>函数的Promise</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>promise方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">  <span class="comment">// 存储每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始值是一个已解决的Promise</span></span><br><span class="line">  <span class="keyword">let</span> sequence = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  ajaxArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 上一个Promise的.then()的结果是新的Promise</span></span><br><span class="line">    sequence = sequence.<span class="title function_">then</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把每次得到的结果放入data</span></span><br><span class="line">      data.<span class="title function_">push</span>(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 传递data到下一个.then</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sequence的最终值是最后一个被处理的Promise</span></span><br><span class="line">  <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>await方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> ajaxArray) &#123;</span><br><span class="line">        data.<span class="title function_">push</span>(<span class="keyword">await</span> <span class="title function_">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q51：使用Promise实现，限制异步并发个数，并尽快完成"><a href="#Q51：使用Promise实现，限制异步并发个数，并尽快完成" class="headerlink" title="Q51：使用Promise实现，限制异步并发个数，并尽快完成"></a>Q51：使用Promise实现，限制异步并发个数，并尽快完成</h3><p>有8个图片资源的url，已经存储在数组urls中</p>
<p>urls类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code> 而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。</p>
<p>但有一个要求，任何时刻同时下载的链接数量不可以超过3个</p>
<p>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成</p>
<p>难度：⭐⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一张图片加载完成&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at&#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>可以考虑使用”并发控制”的模式，即每次并发请求的数量为3，当有请求完成后再发起新的请求，直到全部图片都加载完成</p><p>这样可以确保任何时刻最多只有3个请求在同时进行</p><p>这段代码实现了一个名为 <code>limitLoad</code> 的函数，其目的是管理对图片资源的异步加载，限制在任何时刻同时进行的加载数量不超过给定的限制值（<code>limit</code>）</p><p>下面是对这个函数如何工作的逐步解析：</p><ol><li><p>输入参数</p><ul><li><p><code>urls</code></p><p>一个包含图片资源URLs的数组</p></li><li><p><code>loadImg</code></p><p>一个接受单个URL为参数并返回一个<code>Promise</code>的函数，该<code>Promise</code>会在相应的图片加载完成时解决，如果加载失败，则拒绝</p></li><li><p><code>limit</code></p><p>同时进行图片加载的最大数量</p></li></ul></li><li><p>函数执行流程</p><ol><li><strong>初始化变量</strong><ul><li><code>sequence</code>: 通过复制<code>urls</code>数组创建，以避免修改原始数组</li><li><code>promises</code>: 存储正在进行的、数量不超过<code>limit</code>的加载操作的<code>Promise</code>对象数组</li></ul></li><li><strong>启动初始的并发请求</strong><ul><li>使用<code>map</code>函数从<code>sequence</code>中提取前<code>limit</code>个URL，并对每个URL调用<code>loadImg</code>函数，开始加载对应的图片</li><li>对<code>loadImg</code>返回的每个<code>Promise</code>，通过<code>then</code>和<code>catch</code>确保无论成功还是失败都将返回resolving的Promise，其中包含了该次加载操作在<code>promises</code>数组中的索引</li></ul></li><li><strong>利用<code>reduce</code>顺序处理剩余的<code>urls</code></strong><ul><li><code>reduce</code>通过一个初始的<code>Promise</code>开始执行，并且为序列中的每个URL顺序安排加载操作</li><li>在每次迭代中，使用<code>Promise.race</code>等待<code>promises</code>数组中任意一个<code>Promise</code>完成（无论是解决还是拒绝）</li><li>一旦有<code>Promise</code>完成，就用新的加载操作的<code>Promise</code>替换<code>promises</code>数组中对应的位置，这样可以确保<code>promises</code>数组始终在维护最多<code>limit</code>个正在进行的加载操作</li></ul></li><li><strong>处理所有加载操作完成后的情况</strong><ul><li>使用<code>promiseChain.then()</code>等待所有通过<code>reduce</code>安排的加载操作完成</li><li>再通过<code>Promise.all(promises)</code>等待当前正在进行的所有加载操作的完成</li><li>之后，通过<code>then()</code>可以执行一些所有图片加载尝试完成（无论成功或失败）后的最终处理</li></ul></li><li><strong>错误处理</strong><ul><li>在最后，通过<code>catch</code>捕获整个加载过程中遇到的任何错误，并打印错误信息</li></ul></li></ol></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">limitLoad</span>(<span class="params">urls, loadImg, limit</span>) &#123;</span><br><span class="line">    <span class="comment">// 拷贝urls</span></span><br><span class="line">    <span class="keyword">let</span> sequence = [].<span class="title function_">concat</span>(urls);</span><br><span class="line">    <span class="comment">// 存储正在加载的图片Promise数组</span></span><br><span class="line">    <span class="keyword">let</span> promises = [];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 启动初始的并发请求</span></span><br><span class="line">    promises = sequence.<span class="title function_">splice</span>(<span class="number">0</span>, limit).<span class="title function_">map</span>(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里加载图片，然后返回图片索引</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">loadImg</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> index).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> index);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用reduce依次加载剩余的图片</span></span><br><span class="line">    <span class="keyword">let</span> promiseChain = sequence.<span class="title function_">reduce</span>(<span class="function">(<span class="params">lastPromiseChain, url, currentIndex</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastPromiseChain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 等待到promises数组中任何一个Promise被解决（或被拒绝）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(promises);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">fastestIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 一旦图片加载完成，用新的Promise替换掉promises数组中已完成的Promise</span></span><br><span class="line">            promises[fastestIndex] = <span class="title function_">loadImg</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> fastestIndex).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> fastestIndex);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当所有图片加载完成（或失败）后，返回一个新的Promise</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 最后等待剩余的图片加载完成（或失败）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在所有图片加载（或失败）后，可能需要做一些最终的处理</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片都已尝试加载&#x27;</span>);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理整个图片加载过程中遇到的任何错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;在加载所有图片的过程中发生了一个错误: &quot;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">limitLoad</span>(urls, loadImg, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h2 id="实现API"><a href="#实现API" class="headerlink" title="实现API"></a>实现API</h2><h3 id="Q1：使用-setTimeout-实现-setlnterval"><a href="#Q1：使用-setTimeout-实现-setlnterval" class="headerlink" title="Q1：使用 setTimeout 实现 setlnterval"></a>Q1：使用 setTimeout 实现 setlnterval</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在使用<code>setTimeout</code>实现<code>setInterval</code>（即模拟周期性执行某个函数的行为）的时候，核心思想是通过递归调用<code>setTimeout</code>来达到<code>setInterval</code>的效果</p><p>这么做有几个关键的注意点和技巧：</p><ol><li><p><strong>精确的时间控制</strong></p><p>使用<code>setTimeout</code>递归调用的方式可以比<code>setInterval</code>提供更精确的时间控制</p><p>因为<code>setInterval</code>在某些情况下可能会受到多个待执行的回调函数堆积的影响，导致实际执行间隔不准确</p><p>在递归调用<code>setTimeout</code>时，每次都是在上一个调用完成后才设置下一个调用，从一定程度上避免了这个问题</p></li><li><p><strong>避免堆积</strong></p><p>在高负载或者执行时间较长的情况下，避免回调函数的堆积。如果回调函数执行时间过长，超过了设置的间隔时间，<code>setTimeout</code>会等待回调函数执行完毕后立即执行，不会像<code>setInterval</code>那样导致回调函数堆积。</p></li><li><p><strong>错误处理</strong></p><p>递归调用时，可以在每一次的回调函数中添加错误处理逻辑</p><p>这是利用<code>setTimeout</code>模拟<code>setInterval</code>可以做到而直接使用<code>setInterval</code>较难实现的</p></li><li><p><strong>提供停止机制</strong></p><p>在直接使用<code>setInterval</code>时，可以通过<code>clearInterval</code>停止执行</p><p>在用<code>setTimeout</code>模拟时，需要手动提供一个机制来停止循环（比如，通过一个标志变量控制）</p></li><li><p><strong>性能考虑</strong></p><p>虽然使用<code>setTimeout</code>递归可以提供更灵活的控制，但在某些极端情况下（比如，非常短的时间间隔和复杂的业务逻辑），它可能会导致性能问题</p><p>因此，设计时应考虑到具体的业务需求和环境</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于停止定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">      timerId = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归函数用来模拟 setInterval 的行为</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">intervalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerId !== <span class="literal">null</span>) &#123; <span class="comment">// 检查定时器是否已经被停止</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>(); <span class="comment">// 尝试执行用户提供的回调函数</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error during interval execution:&quot;</span>, error);</span><br><span class="line">        <span class="title function_">stop</span>(); <span class="comment">// 出错时停止定时器</span></span><br><span class="line">        <span class="keyword">throw</span> error; <span class="comment">// 可选，根据需要决定是否需要重新抛出错误</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 安排下一次执行</span></span><br><span class="line">      timerId = <span class="built_in">setTimeout</span>(intervalFunction, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  timerId = <span class="built_in">setTimeout</span>(intervalFunction, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个对象，包含 stop 方法，以便外部可以停止定时器</span></span><br><span class="line">  <span class="keyword">return</span> &#123; stop &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="title function_">mySetInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要停止定时器时，可以调用 stop 方法</span></span><br><span class="line"><span class="comment">// 例如，5秒后停止</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  interval.<span class="title function_">stop</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Interval stopped&quot;</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：实现js里面的sort排序"><a href="#Q5：实现js里面的sort排序" class="headerlink" title="Q5：实现js里面的sort排序"></a>Q5：实现js里面的sort排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr, compareFn = defaultCompare</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> pivot = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> lesser = [];</span><br><span class="line">    <span class="keyword">const</span> greater = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compareFn</span>(arr[i], pivot) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            lesser.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            greater.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(lesser, compareFn), pivot, ...<span class="title function_">quickSort</span>(greater, compareFn)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defaultCompare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io">Nanami Kento</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wutiaowu5t5.github.io/posts/cb2af883/">https://wutiaowu5t5.github.io/posts/cb2af883/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wutiaowu5t5.github.io" target="_blank">Nanami Kento</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4d830755/" title="《浏览器 &amp;&amp; 计算机网络 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/kF7StdjaNfKTlHL.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《浏览器 &amp;&amp; 计算机网络 面试题》</div></div></a></div><div class="next-post pull-right"><a href="/posts/79175f37/" title="魔改-《文章标签外挂》"><img class="cover" src="https://s2.loli.net/2024/01/26/MZrUiFg5VboODyS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">魔改-《文章标签外挂》</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/556519a1/" title="《Html 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/qvzTE9WGspLbhtO.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-11</div><div class="title">《Html 面试题》</div></div></a></div><div><a href="/posts/376fa3ef/" title="《Vue 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/Z42qJc7bzuGo9Bp.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="title">《Vue 面试题》</div></div></a></div><div><a href="/posts/179be34f/" title="《Css 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/ulgHOCdRZz2QP4B.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-12</div><div class="title">《Css 面试题》</div></div></a></div><div><a href="/posts/75cf67a1/" title="《前端工程化 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/9UW3r8qCnNYgXAz.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">《前端工程化 面试题》</div></div></a></div><div><a href="/posts/4d830755/" title="《浏览器 &amp;&amp; 计算机网络 面试题》"><img class="cover" src="https://s2.loli.net/2023/12/07/kF7StdjaNfKTlHL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">《浏览器 &amp;&amp; 计算机网络 面试题》</div></div></a></div><div><a href="/posts/ed392c85/" title="面经汇总"><img class="cover" src="https://s2.loli.net/2024/04/09/jF8lya3XT7uJMsD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">面经汇总</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nanami Kento</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://github.com/wutiaowu5t5"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:Gojo5t5Satoru@outlook.com" target="_blank" title="Gojo5t5Satoru@outlook.com"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="wxid-ws0099"><i class="fab fa-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/wutiaowu5t5" target="_blank" title="1987053649"><i class="fab fa-qq" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The blog is still under construction, stay tuned!</div></div><div class="card-widget card-visitor"><div class="item-headline"><i class="fas fa-location-arrow"></i><span>来访者</span></div><div class="item-content"><div id="welcome-info"></div><script data-pjax>var longitude="114.03028607368469";var Latitude="22.610554348016493";var txkey="NAOBZ-ETV3Z-U6FXM-ZJOMI-62Q7K-I6B4H";var ipLoacation;window.onload = () => {welcometxmap()};</script></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87%E5%8A%9F%E8%83%BD"><span class="toc-text">实现目标功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">Q1：二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E6%80%8E%E4%B9%88%E9%A2%84%E9%98%B2%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E5%BF%AB%E9%80%9F%E7%82%B9%E5%87%BB%EF%BC%8C%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%EF%BC%9F"><span class="toc-text">Q2：怎么预防用户连续快速点击，造成数据多次提交？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A9%E5%8D%8E%E6%B0%8F%E5%BA%A6%E8%B7%9F%E6%91%84%E6%B0%8F%E5%BA%A6%E5%8F%AF%E4%BB%A5%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0"><span class="toc-text">Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AAonclick%E4%BA%8B%E4%BB%B6"><span class="toc-text">Q4：使用原生js给一个按钮绑定两个onclick事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E7%BB%99%E6%9F%90%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%A6%82-https-www-baidu-com-index-html%E8%AF%B7%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%AF%A5%E8%B5%84%E6%BA%90%E7%9A%84%E5%90%8E%E7%BC%80%EF%BC%8C%E5%A6%82-html"><span class="toc-text">Q5：给某个资源的链接，如 https:&#x2F;&#x2F;www.baidu.com&#x2F;index.html请实现一个方法，获取该资源的后缀，如 html</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q6%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%BB%9A%E5%8A%A8%E5%85%AC%E5%91%8A%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8%E9%BC%A0%E6%A0%87%E6%BB%91%E5%85%A5%E6%97%B6%E5%81%9C%E6%AD%A2%E6%92%AD%E6%94%BE%EF%BC%8C%E5%9C%A8%E9%BC%A0%E6%A0%87%E7%A6%BB%E5%BC%80%E6%97%B6%E7%BB%A7%E7%BB%AD%E7%AD%89%E5%BE%85%E6%BB%91%E5%85%A5%E6%97%B6%E7%9A%84%E5%89%A9%E4%BD%99%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E5%90%8E%E6%92%AD%E6%94%BE"><span class="toc-text">Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q7%EF%BC%9A%E6%80%8E%E4%B9%88%E6%8A%8A%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84-0-2-%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-text">Q7：怎么把十进制的 0.2 转换成二进制?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q8%EF%BC%9A%E8%AF%B7%E5%AF%B9%E4%BB%A5%E4%B8%8B%E6%95%B0%E7%BB%84%EF%BC%8C%E6%A0%B9%E6%8D%AEborn%E2%80%9D%E7%9A%84%E5%80%BC%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-text">Q8：请对以下数组，根据born”的值降序排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q9-%EF%BC%9A%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E7%9A%84list%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%B9%B6%E4%BE%9D%E6%AC%A1%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">Q9 ：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q10%EF%BC%9A%E6%80%8E%E4%B9%88%E6%8A%8A%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-arguments-%E8%BD%AC%E6%88%90%E6%95%B0%E7%BB%84"><span class="toc-text">Q10：怎么把函数中的 arguments 转成数组?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q11%EF%BC%9A%E5%86%99%E4%B8%80%E4%B8%AArepeat-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%8D%E5%88%B6%E6%8B%BC%E6%8E%A5"><span class="toc-text">Q11：写一个repeat 方法，实现字符串的复制拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q12%EF%BC%9A%E4%BD%BF%E7%94%A8is%E7%94%9F%E6%88%901-10000%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">Q12：使用is生成1-10000的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q13%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6"><span class="toc-text">Q13：移动端的点击事件的有延迟，时间是多久，为什么会有?怎么解决这个延时?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q14%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD"><span class="toc-text">Q14：如何判断当前脚本运行在浏览器还是 node 环境中?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q15%EF%BC%9A%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E2%80%99a-gt-b-gt-c-%E8%BF%99%E6%A0%B7%E5%89%8D%E8%BF%9B%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9Ec-gt-b-gt-a%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AD%98%E6%AF%94%E8%BE%83%E9%AB%98%E6%95%88"><span class="toc-text">Q15：前端路由’a -&gt;b-&gt;c&#96;这样前进，也可以返回c-&gt;b-&gt;a，用什么数据结构来存比较高效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q16%EF%BC%9A%E6%80%8E%E4%B9%88%E9%A2%84%E9%98%B2%E7%94%A8%E6%88%B7%E5%BF%AB%E9%80%9F%E8%BF%9E%E7%BB%AD%E7%82%B9%E5%87%BB%EF%BC%8C%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">Q16：怎么预防用户快速连续点击，造成数据多次提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q17%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%BB%A5%E4%B8%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">Q17：实现以下转换，合并连续的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q18%EF%BC%9A%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">Q18：非递归遍历二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q19-%EF%BC%9A%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E8%A6%81%E6%B1%82%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%94%E5%9B%9E%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%90%8D"><span class="toc-text">Q19 ：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q20%EF%BC%9AJQuery%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">Q20：JQuery的链式调用怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q21%EF%BC%9A%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">Q21：怎么检测浏览器的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q22%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">Q22：什么是单点登录，以及如何进行实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q23%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E4%B8%AD"><span class="toc-text">Q23：如何判断一个元素是否在可视区域中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q24%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">Q24：什么是防抖和节流，以及如何编码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q25%EF%BC%9AJavascript%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98-%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Q25：Javascript中如何实现函数缓存?函数缓存有哪些应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q26%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C10%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">Q26：如何有顺序的执行10个异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q27%EF%BC%9Ajavascript%E9%87%8C%E9%9D%A2%E6%80%8E%E4%B9%88%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82"><span class="toc-text">Q27：javascript里面怎么取消请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q28%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9-var-a-b-a-1-b-2-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E6%88%90%E5%8A%9F"><span class="toc-text">Q28：如何让 var [a, b]&#x3D;{a: 1,b: 2}解构赋值成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q29%EF%BC%9A%E5%89%8D%E7%AB%AF%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%88%AA%E5%9B%BE%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">Q29：前端的页面截图怎么实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q30%EF%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">Q30：怎么实现虚拟列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q31%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6-%E8%A6%81%E6%B1%82%E6%94%AF%E6%8C%81%E8%A1%A8%E6%83%85"><span class="toc-text">Q31：如何判断某个字符串长度(要求支持表情)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q32%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E6%98%AF%E9%80%9A%E8%BF%87PC%E7%AB%AF%E8%BF%98%E6%98%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BF%E9%97%AE"><span class="toc-text">Q32：如何判断页面是通过PC端还是移动端访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q33%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B8%AD%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Q33：实现一个数字转中文的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q34%EF%BC%9A%E7%94%A8js%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89"><span class="toc-text">Q34：用js实现二叉树的定义和基本操作（待完善）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q35%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-text">Q35：查找岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q36%EF%BC%9A%E8%AE%A1%E7%AE%97%E8%83%8C%E5%8C%85"><span class="toc-text">Q36：计算背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q37%EF%BC%9A%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">Q37：全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q38%EF%BC%9A%E5%86%99%E4%B8%80%E4%B8%AALRU%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-text">Q38：写一个LRU缓存函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q39%EF%BC%9A%E5%A4%A7%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-text">Q39：大文件怎么实现断点续传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q40%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%92%E5%BA%8F"><span class="toc-text">Q40：版本号排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%8B%93%E5%B1%95Q41-Q42"><span class="toc-text">排序算法拓展Q41-Q42</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q41%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">Q41：实现冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q42%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">Q42：实现选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q43%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">Q43：实现希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q44%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">Q44：实现插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q45%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">Q45：实现归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q46%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">Q46：实现快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q47%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">Q47：实现堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q48%EF%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95pc%E7%BD%91%E7%AB%99"><span class="toc-text">Q48：怎么实现一个二维码登录pc网站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q49%EF%BC%9AJavascript%E9%87%8C%E9%9D%A2%E7%9A%84%E5%80%92%E8%AE%A1%E6%97%B6%E6%80%8E%E4%B9%88%E7%BA%A0%E6%AD%A3%E5%81%8F%E5%B7%AE"><span class="toc-text">Q49：Javascript里面的倒计时怎么纠正偏差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q50%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%90%88%E5%B9%B6Promise%E5%87%BD%E6%95%B0"><span class="toc-text">Q50：实现合并Promise函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q51%EF%BC%9A%E4%BD%BF%E7%94%A8Promise%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%99%90%E5%88%B6%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%B9%B6%E5%B0%BD%E5%BF%AB%E5%AE%8C%E6%88%90"><span class="toc-text">Q51：使用Promise实现，限制异步并发个数，并尽快完成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0API"><span class="toc-text">实现API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9A%E4%BD%BF%E7%94%A8-setTimeout-%E5%AE%9E%E7%8E%B0-setlnterval"><span class="toc-text">Q1：使用 setTimeout 实现 setlnterval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5%EF%BC%9A%E5%AE%9E%E7%8E%B0js%E9%87%8C%E9%9D%A2%E7%9A%84sort%E6%8E%92%E5%BA%8F"><span class="toc-text">Q5：实现js里面的sort排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e9e23f4f/" title="Proxy代理对象"><img src="https://s2.loli.net/2024/06/04/GhbQgVJkiO56Alw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Proxy代理对象"/></a><div class="content"><a class="title" href="/posts/e9e23f4f/" title="Proxy代理对象">Proxy代理对象</a><time datetime="2024-06-06T07:24:24.000Z" title="发表于 2024-06-06 15:24:24">2024-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7cdb9308/" title="纯前端Vue3项目PDF导出"><img src="https://s2.loli.net/2024/06/04/C5xMpYPGXui8gQW.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="纯前端Vue3项目PDF导出"/></a><div class="content"><a class="title" href="/posts/7cdb9308/" title="纯前端Vue3项目PDF导出">纯前端Vue3项目PDF导出</a><time datetime="2024-06-05T07:24:24.000Z" title="发表于 2024-06-05 15:24:24">2024-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/922c3fd/" title="Vue权限设计"><img src="https://s2.loli.net/2024/06/04/yQLdc29nJKePStz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue权限设计"/></a><div class="content"><a class="title" href="/posts/922c3fd/" title="Vue权限设计">Vue权限设计</a><time datetime="2024-06-04T07:24:24.000Z" title="发表于 2024-06-04 15:24:24">2024-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d7d36a8f/" title="Javascript工具函数抽取"><img src="https://s2.loli.net/2024/05/27/WjYo3UX62ynwsM7.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Javascript工具函数抽取"/></a><div class="content"><a class="title" href="/posts/d7d36a8f/" title="Javascript工具函数抽取">Javascript工具函数抽取</a><time datetime="2024-05-27T03:10:24.000Z" title="发表于 2024-05-27 11:10:24">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》"><img src="https://s2.loli.net/2024/05/09/DzJNVjYfem3M8wX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习ThreeJS-《Camera（官网案例）》"/></a><div class="content"><a class="title" href="/posts/9462a334/" title="学习ThreeJS-《Camera（官网案例）》">学习ThreeJS-《Camera（官网案例）》</a><time datetime="2024-04-18T07:24:24.000Z" title="发表于 2024-04-18 15:24:24">2024-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/12/07/Cflpa2eIDwFUtEG.png')"><div id="footer-wrap"><div class="copyright">&copy;Fri Nov 12 1999 08:00:00 GMT+0800 (中国标准时间) - 2024 By Nanami Kento</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" id="change_dark_mode" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><!--button#darkmode(type="button" title=_p('rightside.night_mode_title'))--><!--  i.fas.fa-adjust--><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="refresh-cache" type="button" title="刷新缓存" onclick="refreshCache()"><i class="fas fa-refresh fa-spin"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0%</span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="iconfont icon-baidu"></i><span>百度搜索</span></a><!--a.rightMenu-item(href="javascript:rmf.searchinThisPage();")--><!--  i.fas.fa-search--><!--  span='站内搜索'--><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><!--a.rightMenu-item(href="javascript:toggleWinbox();")--><!--  i.fas.fa-cog--><!--  span='博客设置'--><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span id="fullScreenText">进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '7b5408da757d7ca1909e',
      clientSecret: 'a34138bdde985783ed984fc84cec5538a0fe931d',
      repo: 'wutiaowu5t5.github.io',
      owner: 'wutiaowu5t5',
      admin: ['wutiaowu5t5'],
      id: '908219221474ac3410aadf7104f7b936',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async src="/js/debounceInit.js"></script><script async src="/js/console.js"></script><script type="text/javascript" src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script async src="//at.alicdn.com/t/c/font_4427279_s445g4lsqz.js"></script><script async src="/js/share.js"></script><script async src="/js/grayscale.js"></script><script async src="/js/randomPost.js"></script><script async src="/js/positionWelcome.js"></script><script async src="/js/rightMenu.js"></script><script async src="/js/showFPS.js"></script><div id="fps"></div><script async src="/js/refresh.js"></script><script data-pjax defer src="/js/hideAsideOnMobile.js"></script><script src="/js/nightModeSwitchAnimation.js" async></script><script src="/js/readPercent.js" async></script><script src="/js/mobileReadingModeHideSidebar.js" async></script><script async src="/js/articleEchartsDarkMode.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="五条悟,六眼,咒术「苍」,反转「赫」,虚式「茈」,无量空处,狗卷,鲑鱼,金枪鱼,木鱼花,鲣鱼干,蛋黄酱,大芥,明太子,腌高菜,海带,情绪,宿傩,束缚,「契阔」,「弥虚葛笼」,鹿紫云一,「幻兽琥珀」,「龙鳞」,「反发」,「黑闪」,里梅,冰凝咒法,九十九,星之怒,凰轮,冥冥,神风,涉谷,百鬼夜行,涉谷,乙骨,模仿,钉崎,夏油,伏黑惠,虎杖,「迳庭拳」,娜娜明,「瓦落」,猪肚包,小肚叽,小葵" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="fixedcard-dashboard"><button class="fixedcard-activebtn" type="button" title="用户信息" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-info&quot;,&quot;0&quot;)"><i class="fas fa-address-book"></i></button><button class="fixedcard-activebtn" type="button" title="最新文章" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-recent-post&quot;,&quot;0&quot;)"><i class="fas fa-history"></i></button><button class="fixedcard-activebtn" type="button" title="来访者" onclick="FixedCardWidget(&quot;class&quot;,&quot;card-visitor&quot;,&quot;0&quot;)"><i class="fas fa-earth-americas"></i></button><div class="fixedcard-user-avatar fixedcard-activebtn" onclick="RemoveFixedCardWidget()"><img class="fixedcard-user-avatar-img" src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg" title="Nanami Kento"></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://hexo-circle-of-friends-api-jade.vercel.app/api?user=wutiaowu5t5";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="user=wutiaowu5t5";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                //console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:260px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                //console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    //console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '0bfa3e0417864a0cb4a14ccdd2517046';
  var gaud_map_key = '7ff01b85d8ea8f50c2e71a46c46e444d';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279, 28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>