<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog结合GitHub Page部署</title>
    <url>/posts/7c0d938c/</url>
    <content><![CDATA[<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>这一步的作用主要是让自己的博客有一个远程仓库可以推送代码</p>
<ol>
<li><p>打开<code>github</code>，登录自己的账号，并新建一个代码仓库</p>
<p><img src="https://s2.loli.net/2023/12/26/G7whFz6BXATlIij.png" alt="image-20231226155101500"></p>
</li>
<li><p>填写仓库名并创建，一定要勾选<code>Add README</code></p>
<p>仓库名有严格的格式，一定要按照格式来，否则无法生成自己的页面，格式：<code>&lt;username&gt;.github.io</code></p>
<p><img src="https://s2.loli.net/2023/12/26/8Va65TQjrxyd9NF.png" alt="image-20231226155654294"></p>
</li>
</ol>
<p><br/></p>
<h2 id="设置部署仓库"><a href="#设置部署仓库" class="headerlink" title="设置部署仓库"></a>设置部署仓库</h2><ol>
<li><p>进入代码内，打开<code>_config.yml</code></p>
<p>在最后一行内设置自己的<code>deploy</code>，<code>repo</code>的设置根据自己仓库里面的<code>SSH</code>来，<code>branch</code>根据你的仓库默认分支来</p>
<p><img src="https://s2.loli.net/2023/12/26/6F5BPyDg1xsrYMv.png" alt="image-20231226162840853"></p>
<p><img src="https://s2.loli.net/2023/12/26/YXAJjBS8WCpRQZM.png" alt="image-20231226162743654"></p>
</li>
<li><p>配置SSH</p>
<p>因为是用ssh连接，所以需要配置一下<code>ssh key</code></p>
<ol>
<li><p>打开<code>Git Bash</code></p>
</li>
<li><p>输入  <code>cd ~/.ssh</code>检测一下本地有没有<code>ssh</code>文件，如果有的话可以直接跳到第4步</p>
</li>
<li><p>没有的话需要创建<code>ssh key</code></p>
<p>运行<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>，后面的邮箱是你的<code>github</code>绑定的邮箱</p>
<p>运行完一直回车就可以</p>
</li>
<li><p>将创建好的<code>key</code>添加到<code>github</code></p>
<ul>
<li><p>拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Window 使用 clip 命令复制，Mac 则使用 pbcopy 命令</p>
</li>
<li><p>打开你的<code>github</code>账户的设置，找到里面的<code>ssh and GPG keys</code>选项，点击<code>NEW  SSH Key</code>，粘贴并保存</p>
</li>
</ul>
</li>
<li><p>测试是否添加成功并可连接</p>
<p>在<code>bash</code>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现以下内容就是成功</p>
<p><img src="https://s2.loli.net/2023/12/26/YGa5nVdmcIBgzhA.png" alt="image-20231226165627123"></p>
</li>
</ol>
</li>
</ol>
<p><br/></p>
<h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><ol>
<li><p>清理之前生成的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建build过的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现如图所示即为成功</p>
<p><img src="https://s2.loli.net/2023/12/26/DLgpK8n5QyFhdjI.png" alt="image-20231226172454122"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>Git提交规范记录</title>
    <url>/posts/a70ec0c6/</url>
    <content><![CDATA[<h2 id="Commit-Message作用"><a href="#Commit-Message作用" class="headerlink" title="Commit Message作用"></a>Commit Message作用</h2><ol>
<li><p>提供更多的历史信息，方便快速浏览</p>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以过滤某些commit（比如文档改动），便于快速查找信息</p>
<p>比如，下面的命令仅仅显示本次发布新增加的功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接从commit生成Change log</p>
<p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档</p>
</li>
</ol>
<p><br/></p>
<h2 id="Commit-Message-的格式"><a href="#Commit-Message-的格式" class="headerlink" title="Commit Message 的格式"></a>Commit Message 的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<p>其中，Header 是必需的，Body 和 Footer 可以省略</p>
<p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观</p>
<ol>
<li><p>Header</p>
<p>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</p>
<ul>
<li><p>type</p>
<p>type用于说明 commit 的类别，只允许使用下面7个标识</p>
<p>feat：新功能（feature）</p>
<p>fix：修补bug</p>
<p>docs：文档（documentation）</p>
<p>style： 格式（不影响代码运行的变动）</p>
<p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p>
<p>test：增加测试</p>
<p>chore：构建过程或辅助工具的变动</p>
</li>
<li><p>scope</p>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</p>
</li>
<li><p>subject</p>
<p>subject是 commit 目的的简短描述，不超过50个字符</p>
<p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p>
<p>第一个字母小写</p>
<p>结尾不加句号（.）</p>
</li>
</ul>
</li>
<li><p>Body</p>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent</span><br></pre></td></tr></table></figure>
<p>说明代码变动的动机，以及与以前行为的对比</p>
</li>
<li><p>Footer</p>
<ol>
<li><p>Footer 部分只用于两种情况</p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">&#x27;attribute&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn<span class="string">&#x27;t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 Issue</p>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure>
<p>也可以一次关闭多个 issue </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>Revert</p>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">&#x27;graphiteWidth&#x27;</span> option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<p>Body部分的格式是固定的，必须写成This reverts commit <hash>.，其中的hash是被撤销 commit 的 SHA 标识符</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面</p>
</li>
</ol>
<p><br/></p>
<h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><p>Commitizen是一个撰写合格 Commit message 的工具。</p>
<p>安装命令如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<p>以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<p><img src="https://s2.loli.net/2024/04/23/fuyUO5tDjYRo3Pv.png" alt="429b439c9f9f422039f8c2afbb4886bd034e5b3f.png"></p>
<p><br/></p>
<h2 id="validate-commit-msg"><a href="#validate-commit-msg" class="headerlink" title="validate-commit-msg"></a>validate-commit-msg</h2><p>validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式</p>
<p>它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js</p>
<p>接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;ghooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;./validate-commit-msg.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A </span><br><span class="line">$ git commit -m <span class="string">&quot;edit markdown&quot;</span> INVALID COMMIT MSG: does not match <span class="string">&quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</span> ! was: edit markdown</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="生成-Change-log"><a href="#生成-Change-log" class="headerlink" title="生成 Change log"></a>生成 Change log</h2><p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2，例3）</p>
<p>生成的文档包括以下三个部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">New features</span><br><span class="line"></span><br><span class="line">Bug fixes</span><br><span class="line"></span><br><span class="line">Breaking changes.</span><br></pre></td></tr></table></figure>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容</p>
<p>conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g conventional-changelog</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure>
<p>上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure>
<p>为了方便使用，可以将其写入package.json的scripts字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>以后，直接运行下面的命令即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run changelog</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《中介者模式（行为型）》</title>
    <url>/posts/957fddbf/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列对象之间的交互，从而降低对象之间的耦合度</p>
<p><br/></p>
<p>中介者模式通常涉及三个核心角色：中介者（Mediator）、同事对象（Colleague）和具体中介者（Concrete Mediator）</p>
<ul>
<li><p><strong>中介者（Mediator）</strong></p>
<p>定义了一个接口用于与各个同事对象通信，并负责协调各个同事对象之间的交互</p>
<p>中介者对象通常包含一个或多个方法，用于处理不同类型的交互事件</p>
</li>
<li><p><strong>同事对象（Colleague）</strong></p>
<p>各个参与交互的对象。同事对象可以向中介者发送消息，也可以接收来自中介者的消息</p>
</li>
<li><p><strong>具体中介者（Concrete Mediator）</strong></p>
<p>实现了中介者接口，负责实际的协调和控制各个同事对象之间的交互</p>
<p>具体中介者对象通常包含了各个同事对象的引用，并根据收到的消息来进行相应的处理</p>
</li>
</ul>
<p><br/></p>
<p>中介者模式的核心思想是将系统中各个对象之间的交互行为集中到一个中介者对象中，从而降低对象之间的耦合度</p>
<p>这种模式的优点在于，可以减少对象之间的直接依赖关系，提高系统的灵活性和可维护性</p>
<p>中介者模式适用于以下情况：</p>
<ul>
<li>当系统中各个对象之间存在复杂的交互关系，并且希望将这些交互关系集中到一个对象中进行管理时，可以使用中介者模式</li>
<li>当系统中的对象之间的交互关系随着系统的演化而变得复杂时，中介者模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个聊天室系统</p>
<p>聊天室中的用户可以发送消息给其他用户，而消息发送过程中需要对消息进行广播和接收等操作</p>
<p>中介者模式可以将聊天室对象视为一个中介者对象，负责管理用户之间的消息发送和接收</p>
<p>当用户发送消息时，可以将消息发送给聊天室对象，由聊天室对象负责将消息广播给所有在线用户</p>
<p>这样，可以实现用户之间的交互行为集中到一个中介者对象中进行管理，从而降低系统的复杂度</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在多个对象之间的复杂交互</strong></p>
<p>中介者模式适用于存在多个对象之间的复杂交互，并且这些对象之间存在相互依赖的情况</p>
</li>
<li><p><strong>需要解耦对象之间的关系</strong></p>
<p>中介者模式适用于需要解耦对象之间的关系，避免对象之间的直接通信，从而降低对象之间的耦合度</p>
</li>
<li><p><strong>对象之间存在多对多的关系</strong></p>
<p>中介者模式适用于对象之间存在多对多的关系，并且对象之间的交互比较复杂的情况，通过引入中介者来统一管理对象之间的交互</p>
</li>
<li><p><strong>需要集中化控制对象之间的交互</strong></p>
<p>中介者模式适用于需要集中化控制对象之间的交互，通过引入中介者来协调对象之间的交互，避免交互逻辑分散在多个对象中</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>减少类之间的依赖关系</strong></p>
<p>中介者模式可以减少类之间的直接依赖关系，将对象之间的交互逻辑集中到中介者对象中，从而降低了类之间的耦合度</p>
</li>
<li><p><strong>简化对象的交互</strong></p>
<p>中介者模式可以简化对象之间的交互逻辑，将复杂的交互逻辑封装到中介者对象中，使得对象之间只需要与中介者进行通信，而无需直接相互交互</p>
</li>
<li><p><strong>提高系统的可维护性</strong></p>
<p>中介者模式将对象之间的交互逻辑集中到中介者对象中，使得系统的交互逻辑更加清晰和易于理解，从而提高了系统的可维护性</p>
</li>
<li><p><strong>提高系统的灵活性</strong></p>
<p>中介者模式可以通过引入新的中介者对象来扩展系统的功能，而无需修改已有的对象，从而提高了系统的灵活性</p>
</li>
<li><p><strong>降低了对象之间的直接耦合</strong></p>
<p>中介者模式可以避免对象之间的直接相互引用，降低了对象之间的耦合度，使得系统更加灵活和易于扩展</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>中介者对象可能变得复杂</strong></p>
<p>随着系统的演化，中介者对象可能会变得复杂，包含大量的交互逻辑，导致中介者对象变得难以维护和理解</p>
</li>
<li><p><strong>可能导致单点故障</strong></p>
<p>如果中介者对象出现故障，可能会导致系统的其他部分无法正常工作，特别是系统的依赖性较高时</p>
</li>
<li><p><strong>可能导致性能问题</strong></p>
<p>由于中介者对象负责管理对象之间的交互逻辑，可能会导致中介者对象成为系统的瓶颈，特别是在处理大量请求时可能会出现性能问题</p>
</li>
<li><p><strong>增加了系统的复杂度</strong></p>
<p>中介者模式引入了一个额外的中介者对象，可能会增加系统的复杂度，特别是当系统中存在多个中介者对象时</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>用户类与聊天室类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示聊天系统的用户。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个User实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">id</span> - 用户的唯一标识符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span> - 用户的名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id, name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">chatRoom</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向当前聊天室发送消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">message</span> - 要发送的消息内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sendMessage</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">chatRoom</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">chatRoom</span>.<span class="title function_">sendMessage</span>(<span class="variable language_">this</span>, message)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;您还没有加入聊天室！&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收来自其他用户的消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">message</span> - 接收到的消息内容。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">senderName</span> - 发送者的名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">receive</span>(<span class="params">message, senderName</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 收到了来自 <span class="subst">$&#123;senderName&#125;</span> 的消息：<span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天室。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">ChatRoom</span>&#125; <span class="variable">chatRoom</span> - 要加入的聊天室对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">joinChatRoom</span>(<span class="params">chatRoom</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chatRoom <span class="keyword">instanceof</span> <span class="title class_">ChatRoom</span>) &#123; <span class="comment">// 检查传入的是否是有效的ChatRoom实例</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">chatRoom</span> = chatRoom</span><br><span class="line">            chatRoom.<span class="title function_">addUser</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;提供的聊天室无效。&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出聊天室。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">leaveChatRoom</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">chatRoom</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">chatRoom</span>.<span class="title function_">removeUser</span>(<span class="variable language_">this</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">chatRoom</span> = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; - 用户的名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个聊天室，包含多个用户和消息传递功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个ChatRoom实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">users</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户到聊天室。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">User</span>&#125; <span class="variable">user</span> - 要添加的用户对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">addUser</span>(<span class="params">user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">has</span>(user.<span class="property">id</span>)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">set</span>(user.<span class="property">id</span>, user)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;user.getName()&#125;</span> 已加入聊天室。`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`ID为 <span class="subst">$&#123;user.id&#125;</span> 的用户已在聊天室中。`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从聊天室中移除用户。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">User</span>&#125; <span class="variable">user</span> - 要移除的用户对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">removeUser</span>(<span class="params">user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">has</span>(user.<span class="property">id</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> userName = user.<span class="title function_">getName</span>()</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">delete</span>(user.<span class="property">id</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;userName&#125;</span> 已离开聊天室。`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`ID为 <span class="subst">$&#123;user.id&#125;</span> 的用户不在聊天室中。`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将消息广播给聊天室中的其他用户。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">User</span>&#125; <span class="variable">sender</span> - 发送消息的用户对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">message</span> - 要发送的消息内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sendMessage</span>(<span class="params">sender, message</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> senderName = sender.<span class="title function_">getName</span>()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [userId, user] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">users</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId !== sender.<span class="property">id</span>) &#123;</span><br><span class="line">                user.<span class="title function_">receive</span>(message, senderName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出User和ChatRoom类</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">User</span>,</span><br><span class="line">    <span class="title class_">ChatRoom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入ChatRoom和User类</span></span><br><span class="line"><span class="comment"> * 从&#x27;../MediatorPattern&#x27;路径导入ChatRoom和User类，用于创建聊天室和用户实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChatRoom</span>, <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../MediatorPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个聊天室实例</span></span><br><span class="line"><span class="comment"> * 创建一个名为chatRoom的ChatRoom实例，作为用户交流的平台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> chatRoom = <span class="keyword">new</span> <span class="title class_">ChatRoom</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建用户实例</span></span><br><span class="line"><span class="comment"> * 创建三个不同的User实例，分别代表用户1、用户2和用户3。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;User 1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;User 2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> user3 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;User 3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户加入聊天室</span></span><br><span class="line"><span class="comment"> * 将三个用户实例加入到chatRoom聊天室中，使他们能够进行通信。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">user1.<span class="title function_">joinChatRoom</span>(chatRoom)</span><br><span class="line">user2.<span class="title function_">joinChatRoom</span>(chatRoom)</span><br><span class="line">user3.<span class="title function_">joinChatRoom</span>(chatRoom)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户发送消息</span></span><br><span class="line"><span class="comment"> * 用户1和用户2分别向聊天室发送消息，演示了消息的发送过程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">user1.<span class="title function_">sendMessage</span>(<span class="string">&#x27;Hello, everyone!&#x27;</span>)</span><br><span class="line">user2.<span class="title function_">sendMessage</span>(<span class="string">&#x27;Hi, there!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>聊天应用程序</strong></p>
<p>聊天室就是一个很好的中介者模式的应用场景</p>
<p>用户通过聊天室发送和接收消息，而不需要直接与其他用户通信</p>
</li>
<li><p><strong>GUI 应用程序</strong></p>
<p>在复杂的 GUI 应用程序中，不同的组件可能需要相互通信，例如窗口、面板、按钮等</p>
<p>中介者模式可以用来管理这些组件之间的通信，以减少耦合度</p>
</li>
<li><p><strong>游戏开发</strong></p>
<p>在多人在线游戏中，玩家之间可能需要进行交互，例如发送消息、交易物品等</p>
<p>中介者模式可以用来管理玩家之间的交互，以及处理游戏中的事件</p>
</li>
<li><p><strong>交通系统</strong></p>
<p>在城市交通系统中，交通信号灯可以被视为中介者，管理交通流量并协调不同方向上的车辆行驶</p>
<p>通过中介者模式，交通信号灯可以控制交通流量，避免交通拥堵和事故发生</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/MediatorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript工具函数抽取</title>
    <url>/posts/d7d36a8f/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《享元模式（结构型）》</title>
    <url>/posts/469c39d8/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式（Flyweight Pattern）是一种结构型设计模式，它旨在通过共享对象来最小化内存使用和提高性能</p>
<p><br/></p>
<p>享元模式通常涉及两个核心角色：享元（Flyweight）和享元工厂（Flyweight Factory）</p>
<ul>
<li><p><strong>享元（Flyweight）</strong></p>
<p>表示一个可共享的对象，包含了内部状态和外部状态</p>
<p>内部状态是对象共享的部分，它存储在享元对象内部，而外部状态是对象特有的部分，它存储在享元对象外部，并在需要时通过参数传递给享元对象</p>
</li>
<li><p><strong>享元工厂（Flyweight Factory）</strong></p>
<p>用于创建和管理享元对象</p>
<p>享元工厂通常包含一个享元对象的池子（或者缓存），用于存储和复用已创建的享元对象，并在需要时返回给客户端</p>
</li>
</ul>
<p><br/></p>
<p>享元模式的核心思想是通过共享对象来最小化内存使用和提高性能</p>
<p>当有多个相似的对象需要创建时，享元模式可以将其中的一部分共享出来，从而节省内存空间</p>
<p>这种模式的优点在于，可以减少对象的创建数量，提高系统的性能和可扩展性</p>
<p>享元模式适用于以下情况：</p>
<ul>
<li>当需要创建大量相似对象，并且这些对象之间有一些共同的部分时，可以使用享元模式</li>
<li>当希望减少对象的创建数量，提高系统性能和可扩展性时，享元模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个文本编辑器中的字符对象</p>
<p>文本编辑器可能需要创建大量的字符对象来表示文本内容，而很多字符对象可能是相同的（如空格、换行符等）</p>
<p>享元模式可以将其中的一些字符对象共享出来，从而节省内存空间，提高系统性能</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在大量相似对象</strong></p>
<p>享元模式适用于存在大量相似对象，并且这些对象之间有一些共享的状态或者行为的情况</p>
</li>
<li><p><strong>需要节省内存空间</strong></p>
<p>享元模式适用于需要节省内存空间的情况，因为享元模式可以将对象的内部状态和外部状态分离，从而避免了创建大量相似对象所带来的内存浪费</p>
</li>
<li><p><strong>外部状态相对固定</strong></p>
<p>享元模式适用于外部状态相对固定的情况，因为享元模式将对象的内部状态和外部状态分离，因此外部状态需要相对稳定</p>
</li>
<li><p><strong>需要对对象进行复用</strong></p>
<p>享元模式适用于需要对对象进行复用的情况，因为享元模式通过共享已有的对象来避免创建新的对象，从而提高了对象的复用性</p>
</li>
<li><p><strong>需要降低系统的复杂度</strong></p>
<p>享元模式适用于需要降低系统的复杂度的情况，因为享元模式可以将对象的内部状态和外部状态分离，从而降低了对象的复杂度</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>减少内存使用</strong></p>
<p>享元模式可以有效减少相似对象的内存使用，通过共享相同的对象实例来节省内存空间</p>
</li>
<li><p><strong>提高性能</strong></p>
<p>由于减少了对象的数量，享元模式可以提高系统的性能，减少了对象的创建和销毁次数，从而提高了系统的响应速度。</p>
</li>
<li><p><strong>对象复用</strong></p>
<p>享元模式可以实现对象的复用，通过共享已有的对象实例来避免创建新的对象，从而提高了对象的复用性</p>
</li>
<li><p><strong>简化对象管理</strong></p>
<p>享元模式可以简化对象的管理，因为所有共享的对象实例都由工厂类来管理，减少了对象的创建和销毁的逻辑</p>
</li>
<li><p><strong>分离内部状态和外部状态</strong></p>
<p>享元模式将对象的内部状态和外部状态分离，使得可以共享内部状态，而外部状态可以独立变化，提高了系统的灵活性</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能引起线程安全问题</strong></p>
<p>如果多个线程同时访问享元对象，并且对外部状态进行修改，可能会引起线程安全问题，需要额外的同步措施来保证线程安全</p>
</li>
<li><p><strong>增加系统复杂度</strong></p>
<p>享元模式需要对对象的内部状态和外部状态进行分离，并且需要维护一个共享池，可能会增加系统的复杂度</p>
</li>
<li><p><strong>可能导致代码混乱</strong></p>
<p>如果对象的内部状态和外部状态没有良好地分离，可能会导致代码混乱，降低了系统的可维护性</p>
</li>
<li><p><strong>不适用于所有情况</strong></p>
<p>享元模式适用于存在大量相似对象，并且需要节省内存空间的情况，但并不适用于所有情况，特别是对象的外部状态变化频繁的情况</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>创建基础的类跟工厂类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个字符及其相关操作的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个字符对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; char 一个长度为1的字符串。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果输入不是一个长度为1的字符串，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> char !== <span class="string">&#x27;string&#x27;</span> || char.<span class="property">length</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Character must be a single character string.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">char</span> = char</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定位置显示字符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; position 一个包含两个数字的数组，表示位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果位置不是一个包含两个数字的数组，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">display</span>(<span class="params">position</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(position) || position.<span class="property">length</span> !== <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Position must be an array of two numbers.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Character &#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.char&#125;</span>&#x27; displayed at position (<span class="subst">$&#123;position[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;position[<span class="number">1</span>]&#125;</span>)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建和管理字符对象的工厂类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    #characters = &#123;&#125; <span class="comment">// 用于存储已创建的字符对象的私有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个字符对象，如果不存在则创建。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; char 一个长度为1的字符串，表示要获取的字符。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">Character</span>&#125; 返回对应的字符对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果输入不是一个长度为1的字符串，抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getCharacter</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> char !== <span class="string">&#x27;string&#x27;</span> || char.<span class="property">length</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Character must be a single character string.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(char <span class="keyword">in</span> <span class="variable language_">this</span>.#characters)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#characters[char] = <span class="keyword">new</span> <span class="title class_">Character</span>(char)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#characters[char]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个CharacterFactory的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">CharacterFactory</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">CharacterFactory</span> <span class="keyword">from</span> <span class="string">&#x27;../FlyweightPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试创建并显示字符对象</span></span><br><span class="line">    <span class="comment">// 首次请求字符&#x27;A&#x27;的实例</span></span><br><span class="line">    <span class="keyword">const</span> charA = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    charA.<span class="title function_">display</span>([<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首次请求字符&#x27;B&#x27;的实例</span></span><br><span class="line">    <span class="keyword">const</span> charB = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    charB.<span class="title function_">display</span>([<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次请求字符&#x27;A&#x27;的实例，预期将复用之前的实例而不是创建新实例</span></span><br><span class="line">    <span class="keyword">const</span> anotherCharA = <span class="title class_">CharacterFactory</span>.<span class="title function_">getCharacter</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    anotherCharA.<span class="title function_">display</span>([<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证两个字符&#x27;A&#x27;的实例是否相同</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(charA === anotherCharA) <span class="comment">// 预期输出 true，表明两个&#x27;A&#x27;字符引用了同一实例</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 捕获并输出可能发生的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>游戏开发</strong></p>
<p>在游戏中，可能存在大量相同类型的对象，比如敌人、子弹、粒子等。这些对象的外部状态（位置、速度等）可能不同，但内部状态（外观、行为等）是相同的</p>
<p>通过使用享元模式，游戏可以共享相同类型的对象，从而提高性能和降低内存占用</p>
</li>
<li><p><strong>Web 开发</strong></p>
<p>在 Web 应用程序中，可能存在大量重复的数据，比如页面元素、样式、图标等。通过使用享元模式，可以共享这些数据，并减少加载时间和网络带宽的消耗</p>
</li>
<li><p><strong>图形编辑器</strong></p>
<p>在图形编辑器中，用户可以创建和编辑大量的图形对象，比如线条、圆形、矩形等</p>
<p>通过使用享元模式，可以共享相同类型的图形对象，从而减少内存消耗，并提高绘图性能</p>
</li>
<li><p><strong>操作系统</strong></p>
<p>在操作系统中，可能存在大量相同类型的资源，比如文件、进程、线程等</p>
<p>通过使用享元模式，可以共享这些资源，并提高系统的整体性能和响应速度</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/FlyweightPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《原型模式（创建型）》</title>
    <url>/posts/14ddad5d/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而无需通过标准的构造函数来创建</p>
<p>原型模式通过引入一个原型接口和具体原型实现类来实现这一点</p>
<p><br/></p>
<p>在原型模式中，通常存在两个核心角色：原型接口（Prototype）和具体原型类（Concrete Prototype）</p>
<p>原型接口定义了用于复制自身的方法，而具体原型类实现了原型接口，负责实际进行对象的复制操作</p>
<p><br/></p>
<p>原型模式的核心思想是通过复制现有对象来创建新对象，而无需知道具体对象的类型或者构造方法</p>
<p>这种模式的优点在于，可以避免对象的构造过程，提高对象的创建效率，同时也可以减少代码重复</p>
<p>原型模式适用于以下情况：</p>
<ol>
<li>当一个系统需要创建大量相似对象时，使用原型模式可以提高对象创建的效率</li>
<li>当对象的构造过程比较复杂，或者需要从数据库或者网络中获取对象的数据时，使用原型模式可以避免这些复杂的构造过程</li>
</ol>
<p><br/></p>
<p>举个简单的例子，考虑一个图形编辑器</p>
<p>用户可以创建不同类型的图形对象（如圆形、矩形等），而每种图形对象可能需要不同的初始化参数（如半径、宽度、高度等）</p>
<p>使用原型模式，可以在图形对象创建时复制已有的图形对象，然后根据需要修改其初始化参数，从而快速创建新的图形对象，避免了重新构造每种类型的图形对象</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li>当一个系统应该独立于它的产品创建、构成和表示时</li>
<li>当要实例化的类是在运行时指定时，例如，通过动态加载</li>
<li>为了避免创建一个与产品类层次平行的工厂类层次</li>
<li>当一个类的实例只有几个不同状态组合中的一种时。安装相应数量的原型并克隆它们可能比每次用适当的状态手动实例化该类更方便</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p><strong>避免子类化</strong></p>
<p>通过复制一个原型而不是请求一个工厂方法来创建一个对象，可以不用创建一个与产品类层次平行的工厂类层次</p>
</li>
<li><p><strong>简化对象的创建</strong></p>
<p>特别是当对象的创建过程比复制一个现有的实例更复杂或更昂贵时</p>
</li>
<li><p><strong>优化性能</strong></p>
<p>在实例化操作成本较高时，原型模式可以显著提高性能，因为<code>clone</code>通常比创建新实例更加高效</p>
</li>
</ul>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p><strong>复制复杂对象困难</strong></p>
<p>如果对象之间存在循环引用，或者对象的结构非常复杂，那么复制（克隆）可能很困难</p>
</li>
</ul>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>在ES6+中，最佳实践是使用<code>class</code>关键字来定义原型，并通过<code>Object.create</code>或者类的构造函数来创建新的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 创建型-原型模式</span></span><br><span class="line"><span class="comment"> * @Author: 5t5</span></span><br><span class="line"><span class="comment"> * @Time: 2024/4/9 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericPrototypePattern</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">properties</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> properties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (properties.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>[prop] = properties[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">printProperties</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;prop&#125;</span>: <span class="subst">$&#123;<span class="variable language_">this</span>[prop]&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">clone</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的对象，将当前对象的属性复制到新对象上</span></span><br><span class="line">        <span class="keyword">let</span> clonedObject = <span class="keyword">new</span> <span class="title class_">GenericPrototypePattern</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">                clonedObject[prop] = <span class="variable language_">this</span>[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clonedObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">GenericPrototypePattern</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// region HOW TO USE</span></span><br><span class="line"><span class="comment">// 使用原型模式创建新对象</span></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> <span class="title class_">GenericPrototypePattern</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;Object 1&#x27;</span>, <span class="attr">value</span>: <span class="number">10</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> obj2 = obj1.<span class="title function_">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改克隆后的对象的属性</span></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;Object 2&#x27;</span>;</span><br><span class="line">obj2.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用通用方法</span></span><br><span class="line">obj1.<span class="title function_">printProperties</span>(); <span class="comment">// 输出: name: Object 1, value: 10</span></span><br><span class="line">obj2.<span class="title function_">printProperties</span>(); <span class="comment">// 输出: name: Object 2, value: 10, color: blue</span></span><br><span class="line"><span class="comment">// endregion HOW TO USE</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个名为 <code>GenericPrototypePattern</code> 的类，它实现了原型模式。这个类包含了构造函数、一个打印属性的方法 <code>printProperties()</code> 和一个克隆方法 <code>clone()</code></p>
<ul>
<li>构造函数 <code>constructor(properties)</code> 接受一个参数 <code>properties</code>，它是一个对象，用于初始化实例的属性。构造函数将 <code>properties</code> 对象中的属性复制到新创建的对象上</li>
<li><code>printProperties()</code> 方法用于打印实例对象的所有属性</li>
<li><code>clone()</code> 方法用于克隆当前对象，并返回一个新的对象实例。克隆方法会创建一个新的对象，并将当前对象的属性复制到新对象上，从而实现了对象的克隆</li>
</ul>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>对象创建开销大，但对象之间差异不大的情况下</strong></p>
<p>例如在游戏开发中，可以使用原型模式来创建大量的敌人对象，它们可能有不同的外观、属性，但是大部分行为和属性都是相似的，这时候可以通过克隆原型对象来节省创建对象的开销</p>
</li>
<li><p><strong>需要避免使用复杂的继承结构</strong></p>
<p>有些场景中，类的继承结构非常复杂，使用原型模式可以简化对象的创建过程，避免过深的继承链带来的问题</p>
</li>
<li><p><strong>动态加载类、对象或者模块</strong></p>
<p>在一些需要动态加载类或者模块的场景中，原型模式可以用来在运行时创建新的对象，而无需提前知道对象的具体类型</p>
</li>
<li><p><strong>保护性拷贝</strong></p>
<p>有时候需要对对象进行保护性拷贝，以避免外部对原对象的修改影响到其他对象，原型模式提供了一种简单的方式来实现这一点</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/Creational/PrototypePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《备忘录模式（行为型）》</title>
    <url>/posts/e88d43d9/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不暴露对象实现细节的情况下，捕获并存储对象的内部状态，并在需要时恢复到先前的状态</p>
<p><br/></p>
<p>备忘录模式通过引入三个核心角色来实现这一点：发起人（Originator）、备忘录（Memento）和管理者（Caretaker）</p>
<ul>
<li><p><strong>发起人（Originator）</strong></p>
<p>负责创建备忘录对象，并在需要时使用备忘录对象恢复其状态</p>
<p>发起人可以访问其内部状态，并在需要时将其保存到备忘录中或从备忘录中恢复状态</p>
</li>
<li><p><strong>备忘录（Memento）</strong></p>
<p>用于存储发起人对象的内部状态</p>
<p>备忘录对象可以是不可变的，以确保其状态不会被外部修改</p>
</li>
<li><p><strong>管理者（Caretaker）</strong></p>
<p>负责存储和管理备忘录对象</p>
<p>管理者通常不直接操作备忘录的内容，而是将备忘录对象传递给发起人，以便发起人可以恢复其状态</p>
</li>
</ul>
<p><br/></p>
<p>备忘录模式的核心思想是将对象的状态保存到备忘录对象中，并在需要时将状态恢复到先前的状态，从而实现对象状态的回溯</p>
<p>这种模式的优点在于，可以避免在对象内部暴露其状态的细节，同时也使得状态的存储和恢复变得更加灵活和可控</p>
<p>备忘录模式适用于以下情况：</p>
<ul>
<li>当需要保存和恢复对象的状态，并且不希望暴露对象内部状态细节时，可以使用备忘录模式</li>
<li>当需要实现撤销/重做功能或者历史记录功能时，备忘录模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个文本编辑器</p>
<p>用户在编辑文本时可以进行多次修改，而备忘录模式可以用来保存每次修改前的文本状态，以便用户可以撤销到先前的状态或者查看编辑历史记录</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>需要保存和恢复对象的状态</strong></p>
<p>备忘录模式适用于需要保存对象状态，并在需要时将其恢复到先前状态的情况</p>
<p>这通常涉及到对象的状态频繁变化，需要在某个时间点保存状态以便后续恢复</p>
</li>
<li><p><strong>需要实现状态保存和恢复的封装</strong></p>
<p>备忘录模式将状态的保存和恢复封装到备忘录对象中，因此需要定义备忘录对象和相应的接口来实现状态的保存和恢复</p>
</li>
<li><p><strong>需要保持备忘录对象与原发器对象之间的隔离</strong></p>
<p>备忘录模式通过备忘录对象来保存原发器对象的状态，因此需要保持备忘录对象与原发器对象之间的隔离，以防止原发器对象直接访问备忘录对象的内部状态</p>
</li>
<li><p><strong>需要提供恢复状态的接口</strong></p>
<p>备忘录模式通常需要提供一个接口或方法来将对象恢复到之前保存的状态</p>
<p>这样，在需要恢复状态时，可以通过调用该接口或方法来实现状态的恢复</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>状态保存和恢复的封装</strong></p>
<p>备忘录模式将对象状态的保存和恢复封装到备忘录对象中，使得原发器对象可以专注于自身的业务逻辑，而不需要关心状态的保存和恢复</p>
</li>
<li><p><strong>状态的可控性</strong></p>
<p>备忘录模式允许在任意时间点保存对象的状态，并在需要时将其恢复到先前的状态，从而提供了一种灵活的方式来管理对象的状态</p>
</li>
<li><p><strong>隔离备忘录对象与原发器对象</strong></p>
<p>备忘录模式通过备忘录对象来保存原发器对象的状态，从而实现了备忘录对象与原发器对象之间的隔离，使得原发器对象无法直接访问备忘录对象的内部状态，保证了对象状态的封装性和安全性</p>
</li>
<li><p><strong>支持多次撤销和重做操作</strong></p>
<p>备忘录模式允许保存多个状态快照，并支持多次撤销和重做操作，从而提供了一种有效的方式来管理对象状态的变化历史</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能导致内存消耗过大</strong></p>
<p>备忘录模式需要在备忘录对象中保存对象的状态信息，如果对象的状态信息较大或者状态信息保存的备忘录对象过多，可能会导致内存消耗过大</p>
</li>
<li><p><strong>可能导致性能下降</strong></p>
<p>备忘录模式需要在备忘录对象中保存对象的状态信息，如果频繁保存状态或者频繁恢复状态，可能会导致性能下降</p>
</li>
<li><p><strong>可能增加代码复杂度</strong></p>
<p>备忘录模式需要定义备忘录对象、原发器对象和负责人对象等多个角色，并且需要正确管理这些对象之间的关系，可能会增加代码的复杂度</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>编辑器类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EditorMemento 类用于保存编辑器的状态（内容）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorMemento</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; content 编辑器的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">content</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TextEditor 类表示一个文本编辑器，支持打字、保存状态、撤销操作等功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 编辑器当前的内容</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = [] <span class="comment">// 编辑器的状态历史记录</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">historySize</span> = <span class="number">10</span> <span class="comment">// 限制历史记录的最大大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前内容后添加文字。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; words 要添加的文字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">type</span>(<span class="params">words</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> += words</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存当前编辑器状态到历史记录。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">EditorMemento</span>(<span class="variable language_">this</span>.<span class="property">content</span>)) <span class="comment">// 将当前内容状态保存到历史记录</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> &gt; <span class="variable language_">this</span>.<span class="property">historySize</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">shift</span>() <span class="comment">// 如果历史记录超过限制，则移除最旧的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 撤销最后的操作，恢复之前的状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">undo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">pop</span>() <span class="comment">// 移除最新保存的状态</span></span><br><span class="line">            <span class="comment">// 如果历史记录为空，则内容为空字符串；否则，内容恢复为最新保存的状态</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">content</span> = <span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> === <span class="number">0</span> ? <span class="string">&#x27;&#x27;</span> : <span class="variable language_">this</span>.<span class="property">history</span>[<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>].<span class="property">content</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;没有更多的历史状态可以撤销&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 恢复到指定历史记录的状态。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index 要恢复的历史记录的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">restore</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">content</span> = <span class="variable language_">this</span>.<span class="property">history</span>[index].<span class="property">content</span> <span class="comment">// 恢复指定索引的内容状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;无效的历史索引&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前编辑器的内容。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 编辑器的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">content</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取编辑器的历史记录（状态内容的副本）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">string[]</span>&#125; 历史记录中内容的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">map</span>(<span class="function"><span class="params">memento</span> =&gt;</span> memento.<span class="property">content</span>) <span class="comment">// 返回历史记录中内容的副本，而非引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除编辑器的历史记录。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">clearHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TextEditor</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入TextEditor类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TextEditor</span> <span class="keyword">from</span> <span class="string">&#x27;../MediatorPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TextEditor实例</span></span><br><span class="line"><span class="keyword">const</span> editor = <span class="keyword">new</span> <span class="title class_">TextEditor</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入文本并保存</span></span><br><span class="line">editor.<span class="title function_">type</span>(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">editor.<span class="title function_">save</span>()</span><br><span class="line"><span class="comment">// 继续输入文本并保存</span></span><br><span class="line">editor.<span class="title function_">type</span>(<span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line">editor.<span class="title function_">save</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前编辑器内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(editor.<span class="title function_">getContent</span>()) <span class="comment">// 输出：Hello, world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行撤销操作</span></span><br><span class="line">editor.<span class="title function_">undo</span>()</span><br><span class="line"><span class="comment">// 打印撤销后的内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(editor.<span class="title function_">getContent</span>()) <span class="comment">// 输出：Hello,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次执行撤销操作</span></span><br><span class="line">editor.<span class="title function_">undo</span>()</span><br><span class="line"><span class="comment">// 打印再次撤销后的内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(editor.<span class="title function_">getContent</span>()) <span class="comment">// 输出：（空字符串）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用无效的历史索引进行恢复操作</span></span><br><span class="line">editor.<span class="title function_">restore</span>(<span class="number">1</span>) <span class="comment">// 输出：无效的历史索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印编辑器的历史记录</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(editor.<span class="title function_">getHistory</span>())</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>文本编辑器和IDE</strong>:</p>
<p>文本编辑器可以使用备忘录模式来保存编辑历史记录，以便用户可以撤销到先前的状态或者查看编辑历史</p>
</li>
<li><p><strong>图形编辑器</strong></p>
<p>图形编辑器（如绘图软件）可以使用备忘录模式来保存图形对象的状态，以便用户可以撤销/重做操作，或者在需要时恢复到先前的绘图状态</p>
</li>
<li><p><strong>电子邮件应用</strong></p>
<p>在电子邮件应用中，用户可以使用备忘录模式保存草稿状态，以便在稍后继续编辑或者恢复到先前的编辑状态</p>
</li>
<li><p><strong>游戏应用</strong></p>
<p>游戏应用中可以使用备忘录模式来保存游戏进度或者关卡状态，以便玩家可以在需要时回溯到先前的游戏状态</p>
</li>
<li><p><strong>事务管理</strong></p>
<p>在数据库系统中，备忘录模式可以用于事务管理，允许在执行事务时保存数据库状态，并在需要时回滚到先前的状态</p>
</li>
<li><p><strong>撤销/重做功能</strong></p>
<p>许多应用程序都提供了撤销/重做功能，备忘录模式是实现这种功能的常见方式之一</p>
<p>它可以记录每次操作前的状态，以便用户可以在需要时撤销或者重做操作</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/MediatorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《代理模式（结构型）》</title>
    <url>/posts/54233691/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>代理模式（Proxy Pattern）是一种结构型设计模式，它允许你创建一个代理对象，用来控制对另一个对象的访问</p>
<p><br/></p>
<p>代理模式通过引入一个代理对象来代替原始对象，实现了对原始对象的间接访问、控制或者增强</p>
<p>代理对象拥有与原始对象相同的接口，使得客户端无需知道代理对象的存在</p>
<p><br/></p>
<p>在代理模式中，存在两个关键角色：真实主题（Real Subject）和代理主题（Proxy Subject）</p>
<p>真实主题是客户端直接访问的对象，而代理主题是客户端通过代理间接访问真实主题的对象</p>
<p>通过代理模式，可以实现多种功能，比如：</p>
<ul>
<li><p><strong>远程代理（Remote Proxy）</strong></p>
<p>代理对象可以代表远程的对象，允许客户端通过代理对象访问远程的资源或服务，而无需了解远程对象的具体细节</p>
</li>
<li><p><strong>虚拟代理（Virtual Proxy）</strong></p>
<p>代理对象可以延迟加载真实对象，只有当客户端需要访问真实对象时才进行加载，从而提高系统的性能和资源利用率</p>
</li>
<li><p><strong>保护代理（Protective Proxy）</strong></p>
<p>代理对象可以控制对真实对象的访问权限，限制客户端对真实对象的直接访问，增强系统的安全性</p>
</li>
<li><p><strong>缓存代理（Cache Proxy）</strong></p>
<p>代理对象可以缓存真实对象的结果，当客户端再次请求相同的操作时，可以直接返回缓存的结果，减少重复计算，提高系统的性能</p>
</li>
</ul>
<p><br/></p>
<p>代理模式的核心思想是通过引入代理对象来控制对真实对象的访问，从而实现对真实对象的间接访问、控制或者增强</p>
<p>这种分离使得系统更加灵活，能够更好地应对需求变化，同时也提高了系统的安全性和性能</p>
<p><br/></p>
<p>举个简单的例子，考虑一个网络请求的程序</p>
<p>可以有不同类型的网络请求（如GET请求、POST请求等），也可以有不同的处理方式（如异步处理、同步处理等）</p>
<p>使用代理模式，可以将网络请求的类型和处理方式分离开来，使得可以很容易地添加新的网络请求类型或处理方式，而不需要修改已有的代码</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>目标对象</strong></p>
<p>代理模式需要有一个目标对象，它是需要被代理的对象</p>
<p>目标对象定义了要被代理的功能和行为</p>
</li>
<li><p><strong>代理对象</strong></p>
<p>代理对象是一个与目标对象具有相同接口的对象</p>
<p>代理对象在客户端和目标对象之间起到中间人的作用，通过拦截对目标对象的访问，可以对目标对象的行为进行控制、调整或增强</p>
</li>
<li><p><strong>一致的接口</strong></p>
<p>代理对象和目标对象通常应具有相同的接口</p>
<p>这意味着代理对象可以接受和处理客户端对目标对象的所有请求</p>
<p>客户端通过使用代理对象而不是直接使用目标对象，可以完全透明地调用目标对象的功能</p>
</li>
<li><p><strong>处理程序</strong></p>
<p>代理对象通常包含一个处理程序（handler），它定义了如何拦截并处理客户端对目标对象的请求</p>
<p>这可能包括操作前后的额外逻辑、权限控制、日志记录、数据验证等</p>
</li>
<li><p><strong>拦截机制</strong></p>
<p>代理对象需要能够拦截对目标对象的操作</p>
<p>这可以通过 JavaScript 中的 <code>Proxy</code> 对象来实现，<code>Proxy</code> 对象提供了一系列拦截器（如 <code>get</code>、<code>set</code>、<code>apply</code> 等）来处理属性访问和函数调用等操作</p>
</li>
<li><p><strong>透明性</strong></p>
<p>代理模式应保持对客户端的透明性，这意味着客户端不需要知道它正在与代理对象交互而不是目标对象</p>
<p>这使得客户端可以专注于业务逻辑而不必关心代理的细节</p>
</li>
<li><p><strong>控制访问和增强</strong></p>
<p>代理模式的核心是通过代理对象控制和增强对目标对象的访问</p>
<p>代理对象可以选择性地允许或拒绝客户端对目标对象的请求，或者在请求前后添加额外的逻辑</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>分离关注点</strong></p>
<p>代理模式使目标对象和客户端之间的逻辑分离</p>
<p>这可以使目标对象的实现更加专注于其核心功能，而代理负责其他方面的逻辑（例如，验证、权限控制、缓存、日志记录等）</p>
</li>
<li><p><strong>增强对象功能</strong></p>
<p>通过代理对象，可以在不修改目标对象的情况下增强其功能</p>
<p>例如，可以在目标对象的操作前后添加额外的行为</p>
</li>
<li><p><strong>控制访问</strong></p>
<p>代理模式可以控制对目标对象的访问</p>
<p>代理可以决定是否允许访问目标对象的特定功能，并在必要时进行权限验证或日志记录</p>
</li>
<li><p><strong>延迟初始化</strong></p>
<p>通过代理模式，可以将目标对象的初始化延迟到实际需要的时候</p>
<p>这有助于优化性能，避免不必要的资源消耗</p>
</li>
<li><p><strong>安全性</strong></p>
<p>代理模式可以用于提高系统的安全性</p>
<p>例如，通过代理对象，可以在调用目标对象的方法之前进行权限验证，确保只有授权的用户才能访问目标对象的功能</p>
</li>
<li><p><strong>透明性</strong></p>
<p>代理对象通常提供与目标对象相同的接口，因此客户端不需要了解目标对象是否被代理</p>
<p>这样，客户端的代码可以保持简单和一致</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>额外的复杂性</strong></p>
<p>引入代理对象可能会增加代码的复杂性，因为需要管理额外的对象和逻辑</p>
<p>特别是当代理对象和目标对象之间的逻辑较复杂时，这种复杂性会更明显</p>
</li>
<li><p><strong>性能开销</strong></p>
<p>代理模式可能引入一定的性能开销</p>
<p>例如，代理对象在执行操作时需要额外的拦截和逻辑处理，这可能会影响系统的性能</p>
</li>
<li><p><strong>调试难度</strong></p>
<p>由于代理对象在目标对象和客户端之间起到中间层的作用，这可能使调试变得更复杂，因为问题可能出现在代理对象、目标对象或二者之间的交互中</p>
</li>
<li><p><strong>维护难度</strong></p>
<p>代理模式可能导致代码维护难度增加，尤其是当代理对象和目标对象之间的逻辑复杂时</p>
<p>在设计代理对象时需要特别注意清晰的接口定义和职责划分</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li><p>ES6 Proxy</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义目标对象</span></span><br><span class="line"><span class="comment">// 目标对象是需要被代理的对象，包括属性和方法</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// greet 方法用于打印一个问候语</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处理程序对象</span></span><br><span class="line"><span class="comment">// 处理程序对象包含了代理对象的行为拦截逻辑</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 拦截对目标对象属性的读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27;`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.get 方法获取目标对象的属性值</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如权限控制、日志记录等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截对目标对象属性的设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; to &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.set 方法设置目标对象的属性值</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如数据验证、权限控制等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截对目标对象方法的调用操作</span></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling function with arguments: <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 使用 Reflect.apply 方法调用目标对象的方法</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加额外的逻辑，例如日志记录、权限控制等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Proxy 构造函数创建代理对象</span></span><br><span class="line"><span class="comment">// 参数为目标对象和处理程序对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问代理对象的 name 属性</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.get 拦截器</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// 获取 name 属性，拦截器将打印日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理对象的 age 属性</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.set 拦截器</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 设置 age 属性，拦截器将打印日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代理对象的 greet 方法</span></span><br><span class="line"><span class="comment">// 代理对象会调用 handler.apply 拦截器</span></span><br><span class="line">proxy.<span class="title function_">greet</span>(); <span class="comment">// 调用 greet 方法，拦截器将打印日志</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target</span> = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截对目标对象的属性读取</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27;`</span>);</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">target</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">target</span>[property];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截对目标对象的属性设置</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; to &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;`</span>);</span><br><span class="line">        <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">target</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">target</span>[property] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">methodName, ...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27; with arguments: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">const</span> method = <span class="variable language_">this</span>.<span class="property">target</span>[methodName];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> method === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Method &#x27;<span class="subst">$&#123;methodName&#125;</span>&#x27; does not exist on target object.`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理类来创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(handler.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// 获取 name 属性，拦截器将打印日志</span></span><br><span class="line">handler.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>); <span class="comment">// 设置 age 属性，拦截器将打印日志</span></span><br><span class="line">handler.<span class="title function_">apply</span>(<span class="string">&#x27;greet&#x27;</span>); <span class="comment">// 调用 greet 方法，拦截器将打印日志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br/></p>
</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>Vue.js</strong></p>
<p>Vue 使用代理模式来实现数据绑定和响应式编程</p>
<p>Vue 创建了一个代理对象，通过代理对象监视数据的变化，然后根据变化自动更新 UI</p>
</li>
<li><p><strong>Redux 中的 Middleware</strong></p>
<p>虽然 Redux 本身是一个状态管理库，但在中间件（middleware）的设计中有使用代理模式</p>
<p>中间件可以拦截并调整 Redux 的动作，这样可以在动作被派发和状态更新之间添加额外的逻辑，如日志记录、异步请求等</p>
</li>
<li><p><strong>Node.js 的 HTTP 代理</strong></p>
<p>在 Node.js 中，开发人员可以使用库如 <code>http-proxy</code> 来创建 HTTP 代理</p>
<p>这个代理模式允许开发人员在客户端和服务器之间创建一个中间层，通过该层可以调整 HTTP 请求和响应</p>
<p>例如，可以修改请求头、缓存请求或将请求重定向到其他服务器</p>
</li>
<li><p><strong>GraphQL 中的 Resolvers</strong></p>
<p>在 GraphQL 中，Resolvers 是用于处理 GraphQL 查询的函数</p>
<p>通过代理模式，可以在查询结果返回客户端之前，对结果进行拦截和调整</p>
<p>例如，添加额外的数据处理、权限控制等</p>
</li>
<li><p><strong>Angular</strong></p>
<p>Angular 框架中的依赖注入系统使用了代理模式</p>
<p>通过拦截服务的创建和调用，Angular 可以实现服务的生命周期管理、配置和注入依赖等</p>
</li>
<li><p><strong>jQuery</strong></p>
<p>虽然 jQuery 不直接使用原生的 JavaScript <code>Proxy</code> 对象，但 jQuery 中的一些功能，例如事件代理（event delegation），与代理模式的理念相似</p>
<p>通过事件代理，jQuery 可以在父元素上监听事件，然后根据事件的目标元素来执行特定的处理</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/ProxyPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《命令模式（行为型）》</title>
    <url>/posts/25e1ecde/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而允许用不同的请求对客户进行参数化，队列或记录请求日志，并支持可撤销的操作</p>
<p><br/></p>
<p>命令模式通常涉及四个核心角色：命令（Command）、接收者（Receiver）、调用者（Invoker）和客户端（Client）</p>
<ul>
<li><p><strong>命令（Command）</strong></p>
<p>定义了执行操作的接口</p>
<p>通常包含一个执行操作的方法，以及可能包含一些其他方法用于支持命令的撤销、重做等操作</p>
</li>
<li><p><strong>接收者（Receiver）</strong></p>
<p>实际执行命令操作的对象</p>
<p>接收者包含了具体的业务逻辑，负责实现命令接口定义的操作</p>
</li>
<li><p><strong>调用者（Invoker）</strong></p>
<p>负责调用命令对象来执行请求</p>
<p>调用者通常不直接与接收者交互，而是通过调用命令对象的方法来执行具体的操作</p>
</li>
<li><p><strong>客户端（Client）</strong></p>
<p>创建命令对象，并将命令对象传递给调用者来执行请求</p>
<p>客户端通常不需要知道命令对象的具体实现，只需要知道如何创建命令对象，并将其传递给调用者即可</p>
</li>
</ul>
<p><br/></p>
<p>命令模式的核心思想是将请求封装成一个对象，使得请求的发送者和接收者之间解耦，从而可以灵活地添加、修改和重用命令对象，同时也提供了一种统一的方式来处理请求的执行、撤销和重做等操作</p>
<p>命令模式适用于以下情况：</p>
<ul>
<li>当需要将请求的发送者和接收者之间解耦，并且希望在不同的请求之间进行参数化时，可以使用命令模式</li>
<li>当希望支持命令的撤销、重做等操作，并且希望将这些操作封装到命令对象中时，命令模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个遥控器系统</p>
<p>遥控器可以控制不同的家电设备（如电视、音响等），而命令模式可以将每个控制命令（如打开、关闭、调高音量等）封装成一个命令对象，并将命令对象传递给遥控器来执行具体的控制操作</p>
<p>这样，可以实现遥控器与家电设备之间的解耦，同时也提供了一种统一的方式来处理控制命令的执行、撤销和重做等操作</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在命令对象</strong></p>
<p>命令模式适用于存在一组需要被执行的命令，并且希望将这些命令封装成独立的对象的情况</p>
</li>
<li><p><strong>需要将请求者和接收者解耦</strong></p>
<p>命令模式适用于需要将请求者和接收者解耦的情况，即请求者不需要知道接收者的具体实现细节，而是通过命令对象来与接收者进行通信</p>
</li>
<li><p><strong>需要支持撤销和重做操作</strong></p>
<p>命令模式适用于需要支持撤销和重做操作的情况，因为命令对象可以保存执行命令的历史记录，并且可以根据需要进行撤销和重做操作</p>
</li>
<li><p><strong>需要支持命令队列或者日志</strong></p>
<p>命令模式适用于需要支持命令队列或者日志的情况，因为命令对象可以将所有的命令保存在一个队列中，并且可以将执行命令的日志保存下来</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>解耦请求者和接收者</strong></p>
<p>命令模式将请求封装成命令对象，使得请求者和接收者之间解耦，请求者不需要知道接收者的具体实现细节</p>
</li>
<li><p><strong>容易扩展新的命令</strong></p>
<p>由于命令模式将每个命令封装成独立的对象，因此容易扩展新的命令，只需要创建新的命令对象并实现对应的执行逻辑即可</p>
</li>
<li><p><strong>支持撤销和重做操作</strong></p>
<p>命令模式可以轻松地支持撤销和重做操作，因为每个命令对象都可以保存执行命令的历史记录，并且可以根据需要进行撤销和重做操作</p>
</li>
<li><p><strong>支持命令队列和日志</strong></p>
<p>命令模式可以支持命令队列和日志功能，因为命令对象可以将所有的命令保存在一个队列中，并且可以将执行命令的日志保存下来</p>
</li>
<li><p><strong>降低系统的耦合度</strong></p>
<p>命令模式降低了系统的耦合度，使得请求者和接收者之间的关系更加灵活，易于维护和扩展</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能导致类爆炸</strong></p>
<p>命令模式可能会导致类爆炸，因为每个命令都需要定义一个独立的命令类，如果命令较多，可能会导致类的数量增加</p>
</li>
<li><p><strong>增加代码复杂度</strong></p>
<p>命令模式可能会增加代码的复杂度，因为需要定义大量的命令类，并且需要正确地组织和管理这些命令类</p>
</li>
<li><p><strong>可能降低性能</strong></p>
<p>命令模式可能会降低系统的性能，因为需要创建和管理大量的命令对象，并且需要保存命令的历史记录，可能会导致内存占用和执行时间增加</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>控制器基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Command</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./SubClass/Command&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 远程控制类，用于管理和执行命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化命令列表和历史记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">commands</span> = [] <span class="comment">// 储存待执行的命令</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = [] <span class="comment">// 用于存储执行过的命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Command</span>&#125; <span class="variable">command</span> - 需要设置的命令对象，必须是Command的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 会抛出错误如果传入的参数不是Command的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setCommand</span>(<span class="params">command</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(command <span class="keyword">instanceof</span> <span class="title class_">Command</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;传递的参数必须是Command的实例&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">push</span>(command)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下按钮执行命令</span></span><br><span class="line"><span class="comment">     * 如果有可执行的命令，则执行队列中的第一个命令，并将其移出队列，存入历史记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pressButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">commands</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> command = <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">shift</span>() <span class="comment">// 执行队列中的第一个命令</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;execute&#x27;</span> <span class="keyword">in</span> command) &#123;</span><br><span class="line">                command.<span class="title function_">execute</span>()</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(command) <span class="comment">// 将执行的命令存入历史记录</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法执行命令：缺少execute方法&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有可执行的命令&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下撤销按钮，执行撤销操作</span></span><br><span class="line"><span class="comment">     * 如果历史记录中有命令，则执行历史记录中的最后一个命令的undo方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pressUndo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> command = <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">pop</span>() <span class="comment">// 取出历史记录中的最后一个命令</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;undo&#x27;</span> <span class="keyword">in</span> command) &#123;</span><br><span class="line">                command.<span class="title function_">undo</span>()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法撤销命令：缺少undo方法&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有可撤销的命令&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">RemoteControl</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Command 类定义了一个命令模式的基本结构。</span></span><br><span class="line"><span class="comment"> * 该类是抽象的，不应该直接实例化，它的目的是为了被子类继承。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">device</span> - 与命令相关联的设备对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 会抛出错误如果尝试直接实例化 Command 类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">device</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Command</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;本类不能实例化&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">device</span> = device</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行命令的方法。该方法在子类中被重写，以提供具体的命令执行逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 会抛出错误如果该方法在子类中没有被重写。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;execute 方法必须被重写&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 撤销命令的方法。该方法在子类中被重写，以提供具体的命令撤销逻辑。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 会抛出错误如果该方法在子类中没有被重写。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">undo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;undo 方法必须被重写&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TurnOnCommand 类继承自 Command 类，用于执行打开设备的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOnCommand</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Command</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行打开设备的操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">device</span>.<span class="title function_">turnOn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 撤销打开设备的操作，即关闭设备。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">undo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">device</span>.<span class="title function_">turnOff</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TurnOffCommand 类继承自 Command 类，用于执行关闭设备的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOffCommand</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Command</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行关闭设备的操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">device</span>.<span class="title function_">turnOff</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 撤销关闭设备的操作，即打开设备。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">undo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">device</span>.<span class="title function_">turnOn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Command, TurnOnCommand, TurnOffCommand 供其他模块使用。</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">Command</span>,</span><br><span class="line">    <span class="title class_">TurnOnCommand</span>,</span><br><span class="line">    <span class="title class_">TurnOffCommand</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stereo类代表一个音响系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stereo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开音响。</span></span><br><span class="line"><span class="comment">     * 无参数。</span></span><br><span class="line"><span class="comment">     * 无返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">turnOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;音响已打开&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭音响。</span></span><br><span class="line"><span class="comment">     * 无参数。</span></span><br><span class="line"><span class="comment">     * 无返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">turnOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;音响已关闭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出Stereo类作为默认模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Stereo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电视类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Television</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开电视</span></span><br><span class="line"><span class="comment">     * @无参数</span></span><br><span class="line"><span class="comment">     * @无返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">turnOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;电视已打开&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭电视</span></span><br><span class="line"><span class="comment">     * @无参数</span></span><br><span class="line"><span class="comment">     * @无返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">turnOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;电视已关闭&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出电视类作为默认模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Television</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段代码展示了使用命令模式来控制家电设备（电视和音响）的示例。</span></span><br><span class="line"><span class="comment"> * 它通过将具体的打开和关闭命令分配给遥控器的不同按键来实现对家电设备的控制，</span></span><br><span class="line"><span class="comment"> * 并且提供了撤销操作的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入远程控制、电视和音响类以及开关命令类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RemoteControl</span> <span class="keyword">from</span> <span class="string">&#x27;../CommandPattern&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Television</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Television&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Stereo</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Stereo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TurnOffCommand</span>, <span class="title class_">TurnOnCommand</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Command&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建电视和音响实例</span></span><br><span class="line"><span class="keyword">const</span> tv = <span class="keyword">new</span> <span class="title class_">Television</span>()</span><br><span class="line"><span class="keyword">const</span> stereo = <span class="keyword">new</span> <span class="title class_">Stereo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建电视和音响的开关命令实例</span></span><br><span class="line"><span class="keyword">const</span> turnOnTvCommand = <span class="keyword">new</span> <span class="title class_">TurnOnCommand</span>(tv)</span><br><span class="line"><span class="keyword">const</span> turnOffTvCommand = <span class="keyword">new</span> <span class="title class_">TurnOffCommand</span>(tv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> turnOnStereoCommand = <span class="keyword">new</span> <span class="title class_">TurnOnCommand</span>(stereo)</span><br><span class="line"><span class="keyword">const</span> turnOffStereoCommand = <span class="keyword">new</span> <span class="title class_">TurnOffCommand</span>(stereo)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建远程控制实例，并设置命令</span></span><br><span class="line"><span class="keyword">const</span> remoteControl = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>()</span><br><span class="line"></span><br><span class="line">remoteControl.<span class="title function_">setCommand</span>(turnOnTvCommand)</span><br><span class="line">remoteControl.<span class="title function_">setCommand</span>(turnOffTvCommand)</span><br><span class="line">remoteControl.<span class="title function_">setCommand</span>(turnOnStereoCommand)</span><br><span class="line">remoteControl.<span class="title function_">setCommand</span>(turnOffStereoCommand)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用遥控器控制电视和音响的开关，并演示撤销操作</span></span><br><span class="line">remoteControl.<span class="title function_">pressButton</span>() <span class="comment">// 输出：电视已打开</span></span><br><span class="line">remoteControl.<span class="title function_">pressButton</span>() <span class="comment">// 输出：电视已关闭</span></span><br><span class="line">remoteControl.<span class="title function_">pressButton</span>() <span class="comment">// 输出：音响已打开</span></span><br><span class="line">remoteControl.<span class="title function_">pressButton</span>() <span class="comment">// 输出：音响已关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示撤销操作，每次按下undo按钮将撤销上一步的操作</span></span><br><span class="line">remoteControl.<span class="title function_">pressUndo</span>()   <span class="comment">// 输出：音响已打开</span></span><br><span class="line">remoteControl.<span class="title function_">pressUndo</span>()   <span class="comment">// 输出：音响已关闭</span></span><br><span class="line">remoteControl.<span class="title function_">pressUndo</span>()   <span class="comment">// 输出：电视已打开</span></span><br><span class="line">remoteControl.<span class="title function_">pressUndo</span>()   <span class="comment">// 输出：电视已关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有更多的命令可以撤销时，给出相应提示</span></span><br><span class="line">remoteControl.<span class="title function_">pressUndo</span>()   <span class="comment">// 输出：没有可撤销的命令</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>GUI应用程序</strong></p>
<p>在GUI应用程序中，命令模式常用于实现菜单和工具栏按钮的操作</p>
<p>每个菜单项或按钮都可以关联一个命令对象，当用户点击时，执行与该命令对象关联的操作</p>
</li>
<li><p><strong>撤销和重做功能</strong></p>
<p>命令模式非常适合实现撤销和重做功能</p>
<p>通过记录执行的命令历史，可以轻松地撤销上一步操作，并且可以再次执行已经撤销的操作</p>
</li>
<li><p><strong>多线程请求处理</strong></p>
<p>在多线程环境下，命令模式可以用于将请求封装成独立的命令对象，这样可以安全地将请求发送给不同的线程进行处理</p>
</li>
<li><p><strong>日程安排</strong></p>
<p>在日程安排应用程序中，用户可以添加、编辑和删除日程事件</p>
<p>每个操作可以表示为一个命令对象，以便能够轻松地撤销或重做这些操作</p>
</li>
<li><p><strong>数据库事务</strong></p>
<p>在数据库操作中，命令模式可以用于实现事务管理</p>
<p>每个数据库操作可以表示为一个命令对象，并且可以将多个命令组合成一个事务，以便能够一次性地执行或回滚一系列操作</p>
</li>
<li><p><strong>远程控制</strong></p>
<p>类似于你提到的遥控器系统，远程控制设备也是命令模式的典型应用场景</p>
<p>通过将每个控制命令封装成一个命令对象，并将命令对象传递给远程设备执行具体的控制操作，可以实现设备之间的解耦</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/CommandPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《单例模式（创建型）》</title>
    <url>/posts/4fda2d18/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问该实例</p>
<p>单例模式通过将类的构造函数设为私有，防止外部直接创建实例，同时提供一个静态方法或者属性来获取该实例，从而保证在整个应用程序中只有一个实例存在</p>
<p><br/></p>
<p>单例模式的核心思想是确保一个类只有一个实例存在，并提供一个全局访问点来访问该实例</p>
<p>这种模式的优点在于，可以节省系统资源，提高系统性能，同时也可以保证全局访问点的一致性</p>
<p><br/></p>
<p>然而，需要注意的是，单例模式可能会引入全局状态，增加了代码的耦合度，降低了代码的可测试性</p>
<p>因此，在使用单例模式时需要谨慎考虑</p>
<p><br/></p>
<p>举个简单的例子，考虑一个日志记录器</p>
<p>无论在应用程序的任何地方都需要记录日志，而且只需要一个日志记录器实例来处理所有的日志记录任务</p>
<p>使用单例模式，可以确保在整个应用程序中只有一个日志记录器实例存在，从而实现日志记录的统一管理和控制</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li>单例类的<strong>构造函数</strong>必须是<strong>私有的</strong>，这样才能将类的创建权控制在类的内部，从而使得类的外部不能创建类的实例。</li>
<li>单例类通过一个<strong>私有的静态变量</strong>来存储其唯一实例。</li>
<li>单例类通过提供一个<strong>公开的静态方法</strong>，使得外部使用者可以访问类的唯一实例</li>
</ol>
<blockquote>
<p>注意：</p>
<p>因为单例类的构造函数是私有的，所以单例类不能被继承</p>
</blockquote>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p><strong>控制实例的创建</strong></p>
<p>确保一个类只有一个实例，并提供一个全局访问点</p>
</li>
<li><p><strong>空间节约</strong></p>
<p>由于单例模式限制了实例的数量，因此可以减少由于创建多个相似实例而可能导致的内存浪费</p>
</li>
</ul>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p><strong>全局状态</strong></p>
<p>单例对象本质上是一个全局状态，这可能导致代码之间的不必要的耦合，使得单元测试变得困难</p>
</li>
<li><p><strong>对于并发环境可能需要特别处理</strong></p>
<p>在多线程环境下，需要特别小心以确保单例的线程安全</p>
</li>
</ul>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>使用一个变量存储类实例对象（值初始为 <code>null/undefined</code> ）</p>
<p>进行类实例化时，判断类实例对象是否存在，存在则返回该实例，不存在则创建类实例后返回</p>
<p>多次调用类生成实例方法，返回同一个实例对象</p>
<ol>
<li><p>利用导出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Func</span> ()</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性单例（使用时才new）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式类</span></span><br><span class="line"><span class="comment"> * 该类确保一个类只有一个实例，并且提供一个全局访问点来获得这个唯一实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericSingletonPattern</span> &#123;</span><br><span class="line">    <span class="comment">// 私有静态成员变量，用于保存唯一实例</span></span><br><span class="line">    <span class="keyword">static</span> #instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     * 防止通过new关键字创建多个实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">GenericSingletonPattern</span>.#instance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cannot instantiate singleton class using new operator.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公有静态方法，用于获取唯一实例</span></span><br><span class="line"><span class="comment">     * 如果实例不存在，则创建一个新的实例并返回；如果已存在，则直接返回该实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">GenericSingletonPattern</span>&#125; 单例模式的唯一实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">GenericSingletonPattern</span>.#instance) &#123;</span><br><span class="line">            <span class="title class_">GenericSingletonPattern</span>.#instance = <span class="keyword">new</span> <span class="title class_">GenericSingletonPattern</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">GenericSingletonPattern</span>.#instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">GenericSingletonPattern</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// region HOW TO USE</span></span><br><span class="line"><span class="comment">// 获取单例对象的实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="title class_">GenericSingletonPattern</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="title class_">GenericSingletonPattern</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是同一个实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1 === instance2); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图使用 new 关键字创建实例，会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> instance3 = <span class="keyword">new</span> <span class="title class_">GenericSingletonPattern</span>(); <span class="comment">// 抛出错误: Cannot instantiate singleton class using new operator.</span></span><br><span class="line"><span class="comment">// endregion HOW TO USE</span></span><br></pre></td></tr></table></figure>
<p><br/>这段代码定义了一个名为 <code>GenericSingletonPattern</code> 的类，它实现了单例模式。单例模式确保一个类只有一个实例，并提供一个全局访问点来获取这个唯一实例</p>
<ul>
<li>类中的 <code>#instance</code> 是一个私有的静态成员变量，用于保存唯一实例</li>
<li>构造函数 <code>constructor()</code> 是私有的，它会在实例化时被调用。如果已经存在实例，则会抛出一个错误，防止通过 <code>new</code> 关键字创建多个实例</li>
<li><code>getInstance()</code> 方法是一个公有的静态方法，用于获取唯一实例。如果实例不存在，则会创建一个新的实例并返回；如果已存在，则直接返回该实例</li>
</ul>
<p><br/></p>
</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li>定义命名空间和实现分支型方法</li>
<li>登录框</li>
<li>vuex 和 redux中的store</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/Creational/SingletonPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《外观模式（结构型）》</title>
    <url>/posts/bd865a4b/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外观模式（Facade Pattern）是一种结构型设计模式，旨在为复杂系统提供一个简单的接口</p>
<p>它通过隐藏系统的复杂性，为客户端提供一个简单的接口，使得客户端与系统的子系统之间的通信和交互更加简单</p>
<p><br/>在外观模式中，一个单一的外观类提供了一个高级接口，它将系统中的一组接口进行了封装，对外只暴露少量的接口，客户端通过这些接口与系统进行交互，而不需要了解系统中具体的子系统之间的关联和细节</p>
<p><br/></p>
<p>举个例子，考虑一个电脑系统，它包含了各种硬件和软件组件，如CPU、内存、硬盘、操作系统等</p>
<p>客户端如果要使用这些组件，可能需要直接与这些组件进行交互，这样会使得客户端代码变得复杂且不易维护</p>
<p>使用外观模式，可以定义一个电脑外观类，封装各个组件的初始化、启动和关闭等操作，客户端只需要与电脑外观类交互，而不需要了解具体的硬件和软件组件</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>系统包含多个子系统</strong></p>
<p>系统由多个复杂的子系统组成，这些子系统可能相互关联，但客户端不需要知道这些细节</p>
</li>
<li><p><strong>需要简化客户端与子系统之间的交互</strong></p>
<p>客户端需要与系统交互，但由于系统复杂性的原因，直接与子系统交互可能会导致代码复杂性增加</p>
</li>
<li><p><strong>需要实现系统的解耦</strong></p>
<p>客户端与系统之间的耦合度过高，需要通过一个统一的接口来降低耦合度，从而实现系统的解耦</p>
</li>
<li><p><strong>需要提供统一的接口</strong></p>
<p>系统中的一组接口需要被封装在一个统一的接口后面，以简化客户端的操作</p>
</li>
<li><p><strong>需要提高系统的安全性和稳定性</strong></p>
<p>通过外观模式，可以对系统进行更好的封装和隔离，提高系统的安全性和稳定性</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>简化接口</strong></p>
<p>外观模式提供了一个简单的接口，隐藏了系统的复杂性，使得客户端只需与外观类交互，而不需要了解系统的内部结构和细节</p>
</li>
<li><p><strong>降低耦合度</strong></p>
<p>外观模式降低了客户端与系统之间的耦合度，客户端只与外观类进行交互，而不需要直接与系统中的各个子系统交互，从而降低了代码的复杂度</p>
</li>
<li><p><strong>提高可维护性</strong></p>
<p>外观模式将系统中的复杂性封装在一个外观类中，使得系统更易于理解、维护和修改</p>
</li>
<li><p><strong>提高安全性和稳定性</strong></p>
<p>通过外观模式，可以对系统进行更好的封装和隔离，提高了系统的安全性和稳定性</p>
</li>
<li><p><strong>遵循单一职责原则</strong></p>
<p>外观模式将系统中的各个子系统功能进行了分离，每个子系统只负责自己的功能，遵循了单一职责原则</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>不符合开闭原则</strong></p>
<p>如果需要新增或修改系统的功能，可能需要修改外观类，这违反了开闭原则</p>
</li>
<li><p><strong>可能隐藏系统的复杂性过多</strong></p>
<p>外观模式可能会导致系统的某些复杂性被过度隐藏，使得一些高级功能无法实现，或者导致性能问题</p>
</li>
<li><p><strong>可能引入性能损耗</strong></p>
<p>在某些情况下，外观模式可能会引入额外的性能损耗，因为客户端通过外观类来访问子系统，而不是直接访问，可能会增加额外的调用开销</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>定义子系统，跟外观系统</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频解码器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责解码音频文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioDecoder</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码指定的音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; audioFile 需要解码的音频文件路径或名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">decode</span>(<span class="params">audioFile</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`解码音频文件: <span class="subst">$&#123;audioFile&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频控制器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责管理音频的播放控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">play</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;播放音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pause</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;暂停音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止音频播放。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;停止音频&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音量控制器类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 负责管理音量的设置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VolumeController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置音量级别。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; volumeLevel 需要设置的音量级别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setVolume</span>(<span class="params">volumeLevel</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置音量为: <span class="subst">$&#123;volumeLevel&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频播放器外观类 (Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供一个简单统一的接口来控制音频的播放、暂停、停止以及音量设置，隐藏了子系统的复杂性。</span></span><br><span class="line"><span class="comment"> * 通过封装`AudioDecoder`、`AudioController`和`VolumeController`等子系统，简化了对外部使用者的交互逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayerFacade</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化音频解码器、音频控制器和音量控制器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioDecoder</span> = <span class="keyword">new</span> <span class="title class_">AudioDecoder</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span> = <span class="keyword">new</span> <span class="title class_">AudioController</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">volumeController</span> = <span class="keyword">new</span> <span class="title class_">VolumeController</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放指定的音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; audioFile 需要播放的音频文件路径或名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">playAudio</span>(<span class="params">audioFile</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioDecoder</span>.<span class="title function_">decode</span>(audioFile)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">play</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停当前正在播放的音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pauseAudio</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">pause</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止当前正在播放的音频。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">stopAudio</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audioController</span>.<span class="title function_">stop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置播放音量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; volumeLevel 需要设置的音量级别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setVolume</span>(<span class="params">volumeLevel</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">volumeController</span>.<span class="title function_">setVolume</span>(volumeLevel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AudioPlayerFacade</span></span><br></pre></td></tr></table></figure>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用外观模式控制音频播放</span></span><br><span class="line"><span class="comment">// 导入AudioPlayerFacade类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AudioPlayerFacade</span> <span class="keyword">from</span> <span class="string">&#x27;../AppearancePattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个AudioPlayerFacade的实例</span></span><br><span class="line"><span class="keyword">const</span> audioPlayerFacade = <span class="keyword">new</span> <span class="title class_">AudioPlayerFacade</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放音频文件&quot;music.mp3&quot;</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">playAudio</span>(<span class="string">&quot;music.mp3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停当前正在播放的音频</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">pauseAudio</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置音量为80%</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">setVolume</span>(<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止当前正在播放的音频</span></span><br><span class="line">audioPlayerFacade.<span class="title function_">stopAudio</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>jQuery</strong></p>
<p> jQuery 是一个流行的 JavaScript 库，它简化了 DOM 操作和事件处理</p>
<p>通过使用 jQuery，开发人员可以使用简洁的语法来访问和操作 DOM 元素，从而隐藏了底层浏览器的差异性，这可以看作是一种外观模式的应用</p>
</li>
<li><p><strong>React</strong></p>
<p> React 是一个用于构建用户界面的 JavaScript 库，它采用了组件化的开发模式</p>
<p>在 React 中，每个组件都可以看作是一个外观，它封装了一部分 UI 和逻辑，并提供了一个简单的接口供其他组件使用</p>
</li>
<li><p><strong>Vue.js</strong></p>
<p> Vue.js 是另一个流行的 JavaScript 框架，也是基于组件化开发的</p>
<p>在 Vue.js 中，组件提供了一个简单的接口来封装复杂的 UI 和逻辑，从而降低了组件之间的耦合度，这也可以看作是一种外观模式的应用</p>
</li>
<li><p><strong>Bootstrap</strong>:</p>
<p>Bootstrap 是一个流行的前端框架，它提供了许多预定义的 UI 组件和样式，可以帮助开发人员快速构建具有统一外观和响应式设计的网站和应用程序</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/AppearancePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《建造者模式（创建型）》</title>
    <url>/posts/7e3e0f32/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>建造者模式（Builder Pattern）是一种创建型设计模式，它将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示</p>
<p>建造者模式通过引入一个建造者接口和具体建造者实现类来实现这一点</p>
<p><br/></p>
<p>在建造者模式中，通常存在四个核心角色：产品（Product）、建造者（Builder）、具体建造者（Concrete Builder）和指挥者（Director）</p>
<p>产品是最终要构建的复杂对象，建造者定义了构建产品所需的步骤和方法，具体建造者实现了建造者接口，负责实际构建产品的过程，而指挥者负责指导构建过程的顺序和调用具体建造者的方法来构建产品</p>
<p><br/></p>
<p>建造者模式的核心思想是将一个复杂对象的构建过程分解成多个简单的步骤，然后由具体建造者来逐步构建产品的各个部分，最终组装成完整的产品</p>
<p>这种分离使得同样的构建过程可以创建不同的表示，使得系统更加灵活、可维护和可扩展</p>
<p>建造者模式适用于以下情况：</p>
<ol>
<li>构建过程需要多个步骤或者需要根据不同的条件来构建不同的产品</li>
<li>需要控制产品的构建过程，以及灵活地组合各个部分</li>
</ol>
<p><br/></p>
<p>举个简单的例子，考虑一个汽车制造过程</p>
<p>汽车有多个部件（如车轮、发动机、车身等），而不同型号的汽车可能需要不同配置的部件</p>
<p>使用建造者模式，可以将汽车的制造过程分解成多个步骤，每个步骤由具体建造者来实现，从而实现了不同型号汽车的定制化生产</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li>当一个对象的构建过程复杂时，例如对象由多个部分组成，且对象的创建需要按照特定的顺序或流程</li>
<li>当需要提供一个清晰的对象构建API，隐藏对象的内部表示和构建过程</li>
<li>当对象需要有不同的表示形式，且需要允许外部代码在不同表示之间进行切换</li>
</ol>
<p><br/></p>
<h2 id="实现的方式"><a href="#实现的方式" class="headerlink" title="实现的方式"></a>实现的方式</h2><p>在JavaScript中，建造者模式可以通过多种方式实现：</p>
<ol>
<li><p><strong>链式调用（Fluent Interface）</strong></p>
<p>通过在建造者的每个设置方法末尾返回 <code>this</code> 实现链式调用</p>
</li>
<li><p><strong>独立的Builder类</strong></p>
<p>创建一个单独的Builder类，专门负责构造复杂对象</p>
</li>
<li><p><strong>使用函数参数</strong></p>
<p>使用配置对象作为函数参数，内部通过一系列操作构建最终对象</p>
</li>
<li><p><strong>分步骤构建</strong></p>
<p>将对象的构建分解为多个不同的步骤，每个步骤负责构建对象的一部分</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">    <span class="comment">// 更多属性...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 其他方法 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setMake</span>(<span class="params">make</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">make</span> = make</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setModel</span>(<span class="params">model</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">model</span> = model</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">color</span> = color</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 其他设置方法 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">car</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用建造者</span></span><br><span class="line"><span class="keyword">const</span> carBuilder = <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line"><span class="keyword">const</span> car = carBuilder.<span class="title function_">setMake</span>(<span class="string">&#x27;Audi&#x27;</span>).<span class="title function_">setModel</span>(<span class="string">&#x27;A4&#x27;</span>).<span class="title function_">setColor</span>(<span class="string">&#x27;blue&#x27;</span>).<span class="title function_">build</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li><p><strong>SQL查询构建器</strong>（如 <a href="http://knexjs.org/">Knex.js</a>）</p>
<p>允许通过链式方法构建SQL查询</p>
</li>
<li><p><strong>HTTP请求库</strong>（如 <a href="https://github.com/axios/axios">Axios</a> 或 <a href="https://github.com/request/request">Request</a>）</p>
<p>提供了一个流畅的API来构建HTTP请求</p>
</li>
<li><p><strong>UI库</strong>（如 <a href="https://vuejs.org/">Vue.js</a> 的组件构建过程）</p>
<p>使用了类似建造者的模式来构建和配置组件</p>
</li>
</ul>
<p>建造者模式的主要优势是提高了代码的可读性和可维护性，特别是在构建复杂对象时</p>
<p>通过逐步构建对象，并且可以随时改变对象的状态，可以使代码更加灵活和易于理解</p>
<blockquote>
<p>[!Important]</p>
<p>直接把参数都传入进去不就好了？为什么要分步骤设置</p>
<p>直接将所有参数传入构造函数确实是一种可行的方法，特别是在对象结构简单或者参数数量较少时。然而，建造者模式的优势在于它提供了一种更灵活、更清晰的方式来构建复杂对象，尤其是在以下情况下：</p>
<ol>
<li><p><strong>增强可读性</strong></p>
<p>当创建一个包含多个属性的对象时，直接传递一个包含大量参数的构造函数可能会降低代码的可读性。使用建造者模式，每个步骤的方法名可以清晰地表达正在设置的属性，使得代码更易于理解</p>
</li>
<li><p><strong>可选参数和默认值</strong></p>
<p>在创建对象时，可能有一些属性是可选的，或者可以有默认值。建造者模式允许你只设置那些需要被覆盖的属性，而不必为每个属性提供一个参数</p>
</li>
<li><p><strong>不变性</strong></p>
<p>一旦对象被构建，它就可以是不可变的。这意味着，创建对象后，就不能再更改它的状态。这在多线程环境中是非常有用的，因为它避免了状态同步问题</p>
</li>
<li><p><strong>灵活的构造过程</strong></p>
<p>如果对象的构建过程涉及多个步骤，这些步骤可能会根据特定的逻辑或条件而变化，建造者模式允许你控制这个过程，而不是一次性地提供所有数据</p>
</li>
<li><p><strong>复杂对象的构建</strong></p>
<p>对于复杂对象，可能需要执行额外的逻辑来正确地初始化对象的状态。建造者模式提供了一个中心位置来包含这种逻辑，而不是将它分散在应用程序的多个位置</p>
</li>
<li><p><strong>构建对象的不同表示</strong></p>
<p>如果你需要根据不同的配置或条件构建多种不同的对象表示，建造者模式可以使这一过程更加直接和清晰</p>
</li>
<li><p><strong>链式调用</strong></p>
<p>建造者模式允许链式调用，这使得构建指令更加流畅。这在函数式编程中很常见，可以提高代码的表现力</p>
</li>
</ol>
<p>举一个简单的例子，如果你正在创建一个配置复杂的图表对象，你可能需要设置数据源、图表类型、颜色主题、标题、图例以及其他许多配置项</p>
<p>如果你的构造函数接受所有这些作为参数，调用它会变得非常复杂</p>
<p>但是，如果你使用建造者模式，你可以逐步设置这些属性，并且在每个步骤中都可以应用特定的逻辑或验证</p>
<p>总的来说，建造者模式并不是在所有情况下都是必要的，但对于复杂对象的构建，它提供了一种更加灵活和清晰的方法</p>
</blockquote>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/Creational/BuilderPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《桥接模式（结构型）》</title>
    <url>/posts/2b8aa55b/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>桥接模式（Bridge Pattern）是一种结构型设计模式，它用于将抽象部分与它的实现部分分离，使它们可以独立变化</p>
<p>桥接模式通过将继承关系转化为组合关系来实现这一点</p>
<p><br/>在桥接模式中，存在两个独立的继承层次结构：抽象部分（Abstraction）和实现部分（Implementation）</p>
<p>抽象部分定义了高层次的抽象接口，而实现部分则提供了这些接口的具体实现。通过将抽象部分和实现部分分离，可以使它们可以独立地扩展和变化，而不会相互影响</p>
<p><br/>这种模式的核心思想是通过抽象与实现之间的桥梁来连接它们，使得它们可以独立变化</p>
<p>这种分离使得系统更加灵活，能够更好地应对需求变化。</p>
<p><br/></p>
<p>举个简单的例子，考虑一个绘制图形的程序</p>
<p>可以有不同类型的图形（如圆形、矩形等），也可以有不同的绘制方式（如在屏幕上绘制、在打印机上绘制等）</p>
<p>使用桥接模式，可以将图形的类型和绘制方式分离开来，使得可以很容易地添加新的图形类型或绘制方式，而不需要修改已有的代码</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p>存在多个维度的变化</p>
<p>桥接模式适用于有多个维度的变化，并且这些变化需要独立地进行扩展</p>
<p>例如，一个类有两个或更多的维度，每个维度都可能变化，而且这些变化不应该相互影响</p>
</li>
<li><p>需要在抽象部分和实现部分之间建立关联</p>
<p>桥接模式的核心是将抽象部分和实现部分分离，但又需要在它们之间建立关联</p>
<p>因此，在桥接模式中，需要有一种方式将抽象部分和实现部分连接起来，使它们可以协同工作</p>
</li>
<li><p>需要在运行时选择具体实现</p>
<p>桥接模式适用于需要在运行时选择具体实现的情况</p>
<p>通过桥接模式，可以将抽象部分和实现部分分离开来，并且可以在运行时动态地选择具体的实现</p>
</li>
<li><p>可以通过组合而不是继承来实现</p>
<p>在桥接模式中，通常是通过组合而不是继承来实现抽象部分和实现部分之间的关联</p>
<p>因此，需要考虑如何将抽象部分和实现部分通过组合关系来连接起来</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>分离抽象和实现</strong></p>
<p>桥接模式通过将抽象部分和实现部分分离，使它们可以独立变化</p>
<p>这样一来，可以更容易地扩展和修改系统的功能。</p>
</li>
<li><p><strong>可扩展性</strong></p>
<p>由于桥接模式分离了抽象部分和实现部分，因此可以很容易地添加新的抽象部分或实现部分，而不会影响到已有的代码。</p>
</li>
<li><p><strong>透明性</strong></p>
<p>客户端不需要了解抽象部分和实现部分的具体实现细节，只需要通过抽象接口与抽象部分交互即可，这提高了系统的透明性。</p>
</li>
<li><p><strong>高内聚低耦合</strong></p>
<p>桥接模式使得系统中的不同部分之间的耦合度降低，同时提高了内聚性，使得系统更易于理解和维护。</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>增加复杂性</strong></p>
<p>引入桥接模式会增加一定的复杂性，因为需要定义抽象部分、实现部分以及它们之间的桥梁，这可能会增加代码量和理解难度</p>
</li>
<li><p><strong>可能导致过度设计</strong></p>
<p>如果系统中的抽象部分和实现部分之间的关系并不复杂，使用桥接模式可能会显得过度设计，增加不必要的开销</p>
</li>
<li><p><strong>抽象和实现分离的代价</strong></p>
<p>虽然将抽象部分和实现部分分离可以提高系统的灵活性和可扩展性，但同时也会增加系统的理解难度，特别是在复杂的系统中可能会增加维护的成本</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基础的Shape类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shape 类定义了基本的形状对象，包括颜色和位置属性，并提供了一系列方法来操作这些属性。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">color</span> - 形状的颜色，默认为&quot;black&quot;。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color = <span class="string">&quot;black&quot;</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color  <span class="comment">// 设置形状颜色</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span> = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;  <span class="comment">// 初始化形状位置为原点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置形状的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">color</span> - 新的颜色值，默认为&quot;black&quot;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setColor</span>(<span class="params">color = <span class="string">&quot;black&quot;</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取形状的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 返回当前形状的颜色。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置形状的位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span> - x轴坐标。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">y</span> - y轴坐标。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setPosition</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">x</span> = x</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">y</span> = y</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取形状的位置。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125; 返回一个包含x和y属性的对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getPosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; ...<span class="variable language_">this</span>.<span class="property">position</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，用于绘制形状。子类需要重写此方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;draw&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Shape</span>  <span class="comment">// 导出默认的 Shape 类</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>使用方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Square 类继承自 Shape 类，代表一个正方形形状。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> <span class="variable">Shape</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个新的 Square 实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; color 正方形的颜色。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; sideLength 正方形的边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color, sideLength</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(color) <span class="comment">// 调用父类的构造函数设置颜色</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setSideLength</span>(sideLength) <span class="comment">// 设置正方形的边长</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置正方形的边长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; sideLength 想要设置的边长值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果边长小于等于零，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setSideLength</span>(<span class="params">sideLength</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sideLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Side length must be greater than zero.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sideLength</span> = sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取正方形的边长。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 返回当前正方形的边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getSideLength</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sideLength</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绘制正方形。</span></span><br><span class="line"><span class="comment">     * 在控制台输出绘制的信息，包括颜色和边长。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Drawing Square with color <span class="subst">$&#123;<span class="variable language_">this</span>.getColor()&#125;</span> and side length <span class="subst">$&#123;<span class="variable language_">this</span>.getSideLength()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个蓝色的正方形实例，边长为20</span></span><br><span class="line"><span class="keyword">const</span> blueSquare = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="string">&quot;blue&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置正方形的位置为 (200, 200)</span></span><br><span class="line">blueSquare.<span class="title function_">setPosition</span>(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并输出正方形的位置信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Square position:&quot;</span>, blueSquare.<span class="title function_">getPosition</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出正方形的边长</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Square side length:&quot;</span>, blueSquare.<span class="title function_">getSideLength</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制正方形</span></span><br><span class="line">blueSquare.<span class="title function_">draw</span>() <span class="comment">// 输出：Drawing Square with color blue and side length 20</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><strong>UI 组件库</strong>：<ul>
<li>UI 组件库通常需要支持多种不同的主题样式和外观，例如不同的色彩、字体、布局等。桥接模式可以用来将 UI 组件的核心功能与不同的主题样式进行解耦，从而实现灵活的主题切换。</li>
</ul>
</li>
<li><strong>跨浏览器兼容性库</strong>：<ul>
<li>在前端开发中，需要考虑不同浏览器之间的兼容性问题，例如不同的 CSS 属性、JavaScript API 等。桥接模式可以用来将前端代码的核心功能与不同的浏览器兼容性进行解耦，从而实现跨浏览器兼容性。</li>
</ul>
</li>
<li><strong>数据可视化库</strong>：<ul>
<li>数据可视化库通常需要支持多种不同的图表类型和图形样式，例如折线图、柱状图、饼图等。桥接模式可以用来将数据可视化库的核心功能与不同的图表类型和图形样式进行解耦，从而实现灵活的数据可视化。</li>
</ul>
</li>
<li><strong>前端框架</strong>：<ul>
<li>前端框架（如 React、Vue、Angular 等）通常需要支持多种不同的 UI 组件、路由、状态管理等功能。桥接模式可以用来将前端框架的核心功能与不同的 UI 组件库、路由库、状态管理库进行解耦，从而实现灵活的前端开发。</li>
</ul>
</li>
<li><strong>HTTP 请求库</strong>：<ul>
<li>前端应用通常需要与后端进行数据交互，例如发送 HTTP 请求获取数据。桥接模式可以用来将前端应用的核心功能与不同的 HTTP 请求库进行解耦，从而实现灵活的数据交互。</li>
</ul>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/BridgePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《抽象工厂模式（创建型）》</title>
    <url>/posts/7aab53ba/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口用于创建相关或依赖对象的家族，而不需要指定具体类</p>
<p><br/></p>
<p>抽象工厂模式通过引入抽象工厂接口和具体工厂实现类来实现这一点</p>
<p>在抽象工厂模式中，存在两个关键角色：抽象工厂（Abstract Factory）和具体工厂（Concrete Factory）</p>
<p>抽象工厂定义了创建产品家族的方法，而具体工厂实现了这些方法，用于创建具体的产品对象</p>
<p>每个产品家族都有一组相互关联的产品，而每个具体产品由具体工厂类创建</p>
<ol>
<li><p><strong>抽象工厂接口（Abstract Factory Interface）</strong></p>
<p>定义了一组创建产品的抽象方法，客户端通过调用这些抽象方法来创建产品</p>
</li>
<li><p><strong>具体工厂类（Concrete Factory）</strong></p>
<p>实现了抽象工厂接口，负责创建一组相关的产品</p>
</li>
<li><p><strong>抽象产品（Abstract Product）</strong></p>
<p>定义了一组产品的抽象接口或抽象类</p>
</li>
<li><p><strong>具体产品（Concrete Product）</strong></p>
<p>实现了抽象产品接口或抽象类的具体类</p>
</li>
</ol>
<p><br/></p>
<p>抽象工厂模式的核心思想是通过引入抽象工厂来创建产品家族，使得客户端代码可以与具体的产品类解耦，从而使得系统更加灵活，能够更容易地应对需求变化</p>
<p><br/></p>
<p>举个简单的例子，考虑一个跨平台图形界面工具包</p>
<p>可以有不同类型的界面元素（如按钮、文本框等），也可以有不同的主题（如浅色主题、深色主题等）</p>
<p>使用抽象工厂模式，可以将界面元素的类型和主题分离开来，使得可以很容易地添加新的界面元素类型或主题，而不需要修改已有的代码</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一组相关或相互依赖的产品</strong></p>
<p>抽象工厂模式适用于需要创建一组相关或相互依赖的产品的情况</p>
<p>这些产品通常是属于同一产品族或产品等级结构的，它们之间有一定的关联性或依赖关系</p>
</li>
<li><p><strong>需求频繁变化的系统</strong></p>
<p>如果系统中的产品族经常需要变化，或者需要支持多个不同的产品族，并且这些产品族的组成结构可能不断变化，那么抽象工厂模式可以提供一种灵活的方式来管理这些变化</p>
</li>
<li><p><strong>客户端代码不依赖于具体产品类</strong></p>
<p>抽象工厂模式要求客户端代码不依赖于具体的产品类，而是通过抽象工厂接口来创建产品，从而实现了客户端代码与具体产品类的解耦</p>
</li>
<li><p><strong>需要一致性的创建过程</strong></p>
<p>如果系统中的产品需要遵循一致的创建过程，并且这些产品的创建过程可能随着产品族的变化而变化，那么抽象工厂模式可以提供一种统一的方式来管理这些创建过程</p>
</li>
<li><p><strong>需求层次结构化</strong></p>
<p>抽象工厂模式适用于系统中的产品具有层次结构的情况</p>
<p>例如，产品族之间可能存在一定的层次结构关系，或者产品族内部的产品也可能具有层次结构</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p><strong>隔离具体类的生成</strong></p>
<p>使用者不需要知道具体的实现细节，只需关心接口和返回的抽象产品</p>
</li>
<li><p><strong>易于交换产品系列</strong></p>
<p>由于具体的工厂类在一个应用中只需要在初始化的时候出现一次，这使得改变一个应用的具体实现变得相对容易</p>
</li>
<li><p><strong>促进一致性</strong></p>
<p>当产品构成一系列的时候，确保客户端始终只使用同一个产品系列中的对象</p>
</li>
</ul>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p><strong>难以支持新种类的产品</strong></p>
<p>扩展抽象工厂以生产新种类的产品是困难的，这是因为接口确定后不容易修改</p>
</li>
</ul>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>使用ES6的Class创建最基础的抽象工厂接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GenericAbstractFactoryPattern 是一个通用的抽象工厂模式类。</span></span><br><span class="line"><span class="comment"> * 该类定义了创建不同类型汽车及其组件的方法，但并不具体实现这些方法。</span></span><br><span class="line"><span class="comment"> * 子类需要根据具体的汽车类型实现这些抽象方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericAbstractFactoryPattern</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建汽车的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createCar () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建发动机的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createEngine () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建车架的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createChassis () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建车身的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createBody () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建电气系统的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createElectrical () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建变速器的方法。这是一个抽象方法，需要在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createTransmission () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建汽车类型的抽象方法。子类需要根据具体的汽车类型实现该方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 抛出错误提示不能调用抽象方法，请子类自己实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createType () &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;不能调用抽象方法，请自己实现&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">GenericAbstractFactoryPattern</span></span><br></pre></td></tr></table></figure>
<p>新建汽车基础类，让车辆继承父类的一些基本方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, options || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">drive</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the name of the car that s driving right now is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stopDriving () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the name of the car that stopped&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Chassis</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, options || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">assemble</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The chassis made of <span class="subst">$&#123;<span class="variable language_">this</span>.material&#125;</span> and type <span class="subst">$&#123;<span class="variable language_">this</span>.type&#125;</span> is being assembled.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, options || &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The <span class="subst">$&#123;<span class="variable language_">this</span>.type&#125;</span> engine with <span class="subst">$&#123;<span class="variable language_">this</span>.horsepower&#125;</span> horsepower is starting.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建子类进行调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">GenericAbstractFactoryPattern</span> <span class="keyword">from</span> <span class="string">&#x27;../AbstractFactoryPattern&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Car</span>, <span class="title class_">Chassis</span>, <span class="title class_">Engine</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./BasicCarClass&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AudiCar类，继承自Car类，代表一辆奥迪汽车。</span></span><br><span class="line"><span class="comment"> * 该类通过构造函数初始化一辆奥迪汽车的具体属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiCar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Car</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Audi&#x27;</span>, <span class="attr">lights</span>: <span class="string">&#x27;LED&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;Black&#x27;</span>, ...options &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiEngine</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Engine</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;Audi Engine&#x27;</span>, <span class="attr">horsepower</span>: <span class="string">&#x27;300&#x27;</span>, ...options &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiChassis</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Chassis</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(&#123; <span class="attr">material</span>: <span class="string">&#x27;Aluminum&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;Audi Chassis&#x27;</span>, ...options &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AudiSubclass类，继承自GenericAbstractFactoryPattern类。</span></span><br><span class="line"><span class="comment"> * 该类作为一个工厂类，用于创建奥迪品牌的汽车、发动机和车架。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiSubclass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">GenericAbstractFactoryPattern</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">options</span> = options</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一辆奥迪汽车。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">AudiCar</span>&#125; 返回一个AudiCar实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createCar () &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">options</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">carInfo</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AudiCar</span>(<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">carInfo</span>)<span class="comment">// 创建并返回一辆奥迪汽车实例</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;未提供正确的汽车信息&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个奥迪发动机。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">AudiEngine</span>&#125; 返回一个AudiEngine实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createEngine () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AudiEngine</span>() <span class="comment">// 创建并返回一个奥迪发动机实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个奥迪车架。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">AudiChassis</span>&#125; 返回一个AudiChassis实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    createChassis () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AudiChassis</span>() <span class="comment">// 创建并返回一个奥迪车架实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AudiSubclass</span></span><br></pre></td></tr></table></figure>
<p>然后在代码里面使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AudiSubclass</span> <span class="keyword">from</span> <span class="string">&#x27;./AudiSubclass&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">carInfo</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Audi A4&#x27;</span>,</span><br><span class="line">        <span class="attr">lights</span>: <span class="string">&#x27;LED&#x27;</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&#x27;Black&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建AudiSubclass实例</span></span><br><span class="line"><span class="keyword">const</span> audiFactory = <span class="keyword">new</span> <span class="title class_">AudiSubclass</span>(options)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用工厂创建一个AudiCar实例</span></span><br><span class="line">    <span class="keyword">const</span> myAudiCar = audiFactory.<span class="title function_">createCar</span>()</span><br><span class="line">    <span class="comment">// 调用drive方法</span></span><br><span class="line">    myAudiCar.<span class="title function_">drive</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>代码示例是一个抽象工厂模式的实现，它定义了创建汽车及其组件的通用接口。这个模式用于创建一系列相关或依赖对象的家族，而无需指定其具体类</p>
<ol>
<li><p><strong>抽象工厂类（<code>GenericAbstractFactoryPattern</code>）</strong></p>
<p>这个类定义了一系列创建不同汽车组件的抽象方法，这是抽象工厂模式的典型实现，它允许子类来具体实现这些方法</p>
</li>
<li><p><strong>具体工厂类（<code>AudiSubclass</code>）</strong></p>
<p>这个类继承自抽象工厂类，并实现了创建奥迪汽车和相关组件的具体方法</p>
<p>这里您只展示了<code>createCar</code>方法的实现，其他组件的创建方法（如<code>createEngine</code>和<code>createChassis</code>）还没有具体的实现细节</p>
</li>
<li><p><strong>具体产品类（<code>AudiCar</code>）</strong></p>
<p>这是一个具体的产品类，它继承自<code>Car</code>类，并在构造函数中初始化了奥迪汽车的属性</p>
</li>
<li><p><strong><code>Car</code>类</strong></p>
<p>这个类定义了汽车的基础属性和方法，如<code>drive</code>和<code>stopDriving</code></p>
</li>
</ol>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>抽象工厂模式适用于以下情况：</p>
<ol>
<li>系统要求产品族内的对象之间存在相互关联或依赖关系</li>
<li>系统需要独立于其产品的创建、组合和表示时</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/Creational/AbstractFactoryPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《状态模式（行为型）》</title>
    <url>/posts/d207f3e/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状态模式（State Pattern）是一种行为型设计模式，它允许对象在内部状态发生变化时改变其行为，使得对象看起来好像修改了其类</p>
<p><br/></p>
<p>状态模式通常涉及三个核心角色：上下文（Context）、状态（State）和具体状态（Concrete State）</p>
<ul>
<li><p><strong>上下文（Context）</strong></p>
<p>维护一个当前状态对象，并将状态相关的操作委托给当前状态对象处理</p>
<p>上下文对象通常会包含一个状态对象的引用，并提供方法来切换当前状态和执行状态相关的操作</p>
</li>
<li><p><strong>状态（State）</strong></p>
<p>定义了一个接口用于封装与上下文相关的行为</p>
<p>状态对象通常会包含多个方法，用于处理上下文对象的请求，并可能会改变上下文对象的状态</p>
</li>
<li><p><strong>具体状态（Concrete State）</strong></p>
<p>实现了状态接口，并负责实现具体的状态行为</p>
<p>具体状态对象通常会包含状态相关的业务逻辑，并根据需要改变上下文对象的状态</p>
</li>
</ul>
<p><br/></p>
<p>状态模式的核心思想是将对象的状态和行为进行分离，使得状态的改变不会影响对象的行为，从而实现对象的灵活性和可扩展性</p>
<p>这种模式的优点在于，可以将状态的转换和状态的行为封装到不同的状态对象中，使得状态之间的转换更加灵活和可扩展</p>
<p>状态模式适用于以下情况：</p>
<ul>
<li>当对象的行为取决于其状态，并且状态可能在运行时发生变化时，可以使用状态模式</li>
<li>当希望将状态的转换和状态的行为封装到不同的状态对象中，并且希望通过配置来动态地改变对象的行为时，状态模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个自动售货机系统</p>
<p>自动售货机的行为可能会根据不同的状态（如有货、缺货、正在出货等）而发生变化，而状态模式可以将每种状态抽象成一个状态对象，并根据当前状态来执行相应的行为</p>
<p>例如，当自动售货机处于有货状态时，可以执行出售商品的行为；当自动售货机处于缺货状态时，可以执行补货的行为</p>
<p>这样，可以通过改变状态对象来动态地改变自动售货机的行为，而不需要修改自动售货机的代码</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在多个状态</strong></p>
<p>状态模式适用于存在多个状态，并且对象在不同状态下会有不同的行为的情况</p>
</li>
<li><p><strong>状态之间存在转换关系</strong></p>
<p>状态模式适用于状态之间存在转换关系，并且状态转换是由一定的条件触发的情况</p>
</li>
<li><p><strong>需要封装对象的状态</strong></p>
<p>状态模式适用于需要封装对象的状态，并且根据对象的状态来决定对象的行为的情况</p>
</li>
<li><p><strong>行为随状态的改变而改变</strong></p>
<p>状态模式适用于对象的行为随状态的改变而改变的情况，状态模式将对象的行为分离成多个状态类，每个状态类负责管理对象在特定状态下的行为</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>封装了状态相关行为</strong></p>
<p>状态模式将每个状态封装成一个类，使得每个状态都有独立的类实现，从而简化了状态之间的转换和管理</p>
</li>
<li><p><strong>消除了大量的条件判断语句</strong></p>
<p>状态模式将对象的行为随状态的改变而改变，避免了大量的条件判断语句，使得代码更加清晰和易于维护</p>
</li>
<li><p><strong>符合开闭原则</strong></p>
<p>状态模式符合开闭原则，可以通过增加新的状态类来扩展系统的功能，而无需修改已有的代码</p>
</li>
<li><p><strong>增强了对象的封装性</strong></p>
<p>状态模式将对象的状态封装到不同的状态类中，使得对象的状态对外部是透明的，增强了对象的封装性</p>
</li>
<li><p><strong>简化了对象的行为切换</strong></p>
<p>状态模式将对象的行为切换和状态转换都交由状态类来管理，使得对象的行为切换更加简单和灵活</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能会增加类的数量</strong></p>
<p>状态模式会将每个状态都封装成一个类，可能会导致系统中类的数量增加，从而增加系统的复杂度</p>
</li>
<li><p><strong>状态之间的转换可能复杂</strong></p>
<p>状态模式要求状态之间存在转换关系，如果状态之间的转换关系比较复杂，可能会导致状态模式的实现变得复杂</p>
</li>
<li><p><strong>可能导致逻辑分散</strong></p>
<p>状态模式将对象的行为切换和状态转换都交由状态类来管理，可能会导致对象的行为和状态分散到多个状态类中，增加了代码的理解和维护难度</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>自动售货机类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动售货机类，管理产品状态和行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VendingMachineState</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/VendingMachineState&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HasProductState</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/HasProductState&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SoldOutState</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/SoldOutState&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化自动售货机状态。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; initialStock 初始库存量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">initialStock</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hasProductState</span> = <span class="keyword">new</span> <span class="title class_">HasProductState</span>(<span class="variable language_">this</span>) <span class="comment">// 当有产品时的状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">soldOutState</span> = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="variable language_">this</span>) <span class="comment">// 当产品售罄时的状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentState</span> = initialStock &gt; <span class="number">0</span> ? <span class="variable language_">this</span>.<span class="property">hasProductState</span> : <span class="variable language_">this</span>.<span class="property">soldOutState</span> <span class="comment">// 根据初始库存设置当前状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自动售货机的状态。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">VendingMachineState</span>&#125; newState 新的状态对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setState</span>(<span class="params">newState</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newState <span class="keyword">instanceof</span> <span class="title class_">VendingMachineState</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`状态变化：从<span class="subst">$&#123;<span class="variable language_">this</span>.currentState.constructor.name&#125;</span>到<span class="subst">$&#123;newState.constructor.name&#125;</span>`</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">currentState</span> = newState</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;无效的状态对象&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取有产品状态对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">HasProductState</span>&#125; 有产品状态对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getHasProductState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hasProductState</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取售罄状态对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">SoldOutState</span>&#125; 售罄状态对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getSoldOutState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">soldOutState</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售产品，行为取决于当前状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sellProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentState</span>.<span class="title function_">sellProduct</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 补充库存，行为取决于当前状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">restock</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">currentState</span>.<span class="title function_">restock</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VendingMachine</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>状态基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VendingMachineState类定义了自动售货机状态的基类，为状态模式的一部分。</span></span><br><span class="line"><span class="comment"> * 这个类主要是为了提供给子类继承，子类需要实现其中的sellProduct和restock方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; vendingMachine 对象引用，指向自动售货机实例，允许状态对象访问或修改自动售货机的状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化VendingMachineState实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; vendingMachine 自动售货机实例，用于在状态中控制和访问售货机功能。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vendingMachine</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vendingMachine</span> = vendingMachine; <span class="comment">// 绑定自动售货机实例到当前状态对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，要求子类实现售出商品的逻辑。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果子类未实现此方法，抛出错误提示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sellProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须实现此方法&#x27;</span>) <span class="comment">// 强制子类重写以实现具体售货逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，要求子类实现补货的逻辑。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果子类未实现此方法，抛出错误提示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">restock</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须实现此方法&#x27;</span>) <span class="comment">// 强制子类重写以实现具体补货逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出VendingMachineState类作为模块的默认导出项，便于其他模块使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VendingMachineState</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>状态子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类表示售货机已有商品的状态。</span></span><br><span class="line"><span class="comment"> * 继承自VendingMachineState，以提供特定于售出商品状态的行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VendingMachineState</span> <span class="keyword">from</span> <span class="string">&#x27;./VendingMachineState&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasProductState</span> <span class="keyword">extends</span> <span class="title class_ inherited__">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出售产品的方法。当售出产品时，将状态切换到售罄状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sellProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;商品已售出&quot;</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vendingMachine</span>.<span class="title function_">setState</span>(<span class="variable language_">this</span>.<span class="property">vendingMachine</span>.<span class="title function_">getSoldOutState</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试为售货机补货的方法。在已有商品的状态下，该操作不被允许，</span></span><br><span class="line"><span class="comment">     * 所以只是打印一条信息并不进行任何操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">restock</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法补货，售货机中已有商品&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HasProductState</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SoldOutState类继承自VendingMachineState，用于表示自动售货机售罄状态。</span></span><br><span class="line"><span class="comment"> * 在这种状态下，自动售货机无法出售商品，但可以进行补货操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VendingMachineState</span> <span class="keyword">from</span> <span class="string">&#x27;./VendingMachineState&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">extends</span> <span class="title class_ inherited__">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试出售商品时的操作。</span></span><br><span class="line"><span class="comment">     * 由于售罄状态，此操作将不执行任何动作，仅输出一条信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">sellProduct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法售出，商品已售罄&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行补货操作。</span></span><br><span class="line"><span class="comment">     * 当调用此方法时，自动售货机将改变状态为有货状态（HasProductState）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">restock</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;补货成功&quot;</span>)</span><br><span class="line">        <span class="comment">// 切换状态至有货状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vendingMachine</span>.<span class="title function_">setState</span>(<span class="variable language_">this</span>.<span class="property">vendingMachine</span>.<span class="title function_">getHasProductState</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">SoldOutState</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入VendingMachine类，该类实现了状态模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VendingMachine</span> <span class="keyword">from</span> <span class="string">&#x27;../StatePattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化一个拥有10个商品的自动售货机实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> vendingMachine = <span class="keyword">new</span> <span class="title class_">VendingMachine</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在有货状态下进行商品销售和补货操作的示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vendingMachine.<span class="title function_">sellProduct</span>() <span class="comment">// 输出：商品已售出</span></span><br><span class="line">vendingMachine.<span class="title function_">restock</span>() <span class="comment">// 输出：无法补货，售货机中已有商品</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切换自动售货机到缺货状态，并进行操作示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vendingMachine.<span class="title function_">setState</span>(vendingMachine.<span class="title function_">getSoldOutState</span>())</span><br><span class="line">vendingMachine.<span class="title function_">sellProduct</span>() <span class="comment">// 输出：无法售出，商品已售罄</span></span><br><span class="line">vendingMachine.<span class="title function_">restock</span>() <span class="comment">// 输出：补货成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试传入无效状态进行测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vendingMachine.<span class="title function_">setState</span>(<span class="string">&quot;InvalidState&quot;</span>) <span class="comment">// 输出：无效的状态对象</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>自动售货机</strong></p>
<p>自动售货机是一个很好的状态模式的应用示例</p>
<p>根据货物存量的不同，自动售货机的行为会发生变化，比如有货时可以售卖商品，缺货时需要进行补货等</p>
</li>
<li><p><strong>订单状态管理</strong></p>
<p>在电子商务系统中，订单状态经常会发生变化，比如订单创建、支付、发货、完成等</p>
<p>可以使用状态模式来管理订单的各种状态，使得订单对象能够根据不同状态执行不同的行为</p>
</li>
<li><p><strong>文档编辑器</strong></p>
<p>在文档编辑器中，可以根据文档的当前状态（比如编辑中、已保存、已发布等）来决定编辑器的行为，比如保存、发布、撤销等操作</p>
</li>
<li><p><strong>多媒体播放器</strong></p>
<p>在多媒体播放器中，播放器的行为会根据当前播放状态（比如播放、暂停、停止等）来改变，使用状态模式可以方便地管理播放器的状态转换</p>
</li>
<li><p><strong>网络连接管理</strong></p>
<p>在网络应用中，网络连接的状态经常会发生变化，比如连接中、已连接、断开连接等</p>
<p>状态模式可以用来管理网络连接的状态，以便根据不同的状态执行不同的操作</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/StatePattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《工厂模式（创建型）》</title>
    <url>/posts/7e9872a1/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂模式（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的接口，但是允许子类决定实例化哪个类</p>
<p><br/></p>
<p>工厂模式通过定义一个创建对象的接口，但将实际的实例化过程推迟到子类中去完成，从而使得一个类在创建对象时不需要关心具体的实现类</p>
<p>在工厂模式中，通常存在一个工厂类（Factory），它负责创建对象的实例</p>
<p>工厂类可以是简单工厂，也可以是工厂方法或抽象工厂的具体实现</p>
<p><br/></p>
<p>工厂模式的核心思想是将对象的创建过程封装起来，使得客户端代码与具体的对象类解耦，从而提高系统的灵活性和可维护性</p>
<p>这种模式的优点在于，可以在不修改现有代码的情况下很容易地添加新的产品类，而且客户端代码与具体产品类解耦，使得系统更加灵活、可维护和可扩展</p>
<p><br/></p>
<p>举个简单的例子，考虑一个文档编辑器</p>
<p>可以有不同类型的文档（如文本文档、图像文档等），而每种类型的文档可能需要不同的创建方式（如文本文档可以直接创建，而图像文档可能需要先加载图片）</p>
<p>使用工厂模式，可以将文档的创建过程封装到工厂类中，根据不同的类型来创建不同的文档对象，从而实现了文档的统一创建管理</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><p>工厂模式适用于一些特定的情况，包括但不限于：</p>
<ol>
<li>当一个系统需要独立于其产品的创建、组成和表示时，工厂模式能够帮助我们实现这一点</li>
<li>当要实例化的类在运行时才能确定时，例如，通过动态加载，工厂模式非常有用</li>
<li>当我们想要避免创建一个与产品类层次平行的工厂类层次时，工厂模式可以帮助我们减少类的数量</li>
<li>当一个类的实例只有几个不同状态组合中的一种时，使用工厂模式可能会比手动实例化更加方便，因为我们可以创建多个原型并根据需要克隆它们</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>封装性</strong></p>
<p>工厂模式可以隐藏创建对象的复杂逻辑，用户只需要知道他们可以从工厂获取对象，而无需关心对象的创建细节</p>
</li>
<li><p><strong>扩展性</strong></p>
<p>如果需要引入新的产品类，只需要扩展工厂类并在其中添加新的创建方法，这样不会影响已有的类代码</p>
</li>
<li><p><strong>解耦</strong></p>
<p>客户端代码和具体产品类解耦，客户端只依赖于产品的抽象类</p>
<p>这意味着客户端代码不需要更改就可以使用不同的产品</p>
</li>
<li><p><strong>复用性</strong></p>
<p>工厂类中的代码可以被多次复用，因为它们不依赖于具体的产品类</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>类的数量增多</strong></p>
<p>每增加一个新的产品类型，都需要增加一个具体的产品类和一个与之对应的具体工厂类，这会使系统中类的总数增加，增加了系统的复杂度</p>
</li>
<li><p><strong>系统的复杂性</strong></p>
<p>随着产品变种的增加，相应的工厂类也会增加，系统的复杂性也随之增加，从而增加了理解和维护的难度</p>
</li>
<li><p><strong>抽象性的问题</strong></p>
<p>工厂模式的使用需要客户端依赖于工厂类的抽象编程，这对于一些需要理解具体类之间关系的场景可能不是很方便</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个人的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span> <span class="variable">Person</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span> - 人的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">age</span> - 人的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向他人打招呼并介绍自己</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;, and I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用工厂模式类，用于创建Person实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span> <span class="variable">GenericFactoryPattern</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericFactoryPattern</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个Person实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@static</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span> - 人的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">age</span> - 人的年龄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Person</span>&#125; 返回一个初始化后的Person实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果名字不是字符串或年龄不是正数，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">createPerson</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证输入参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid input: &quot;name&quot; parameter must be a string.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> age !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(age) || age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid input: &quot;age&quot; parameter must be a positive number.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建并返回Person实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name, age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">GenericFactoryPattern</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// region HOW TO USE</span></span><br><span class="line"><span class="comment">// 使用工厂类创建对象</span></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title class_">GenericFactoryPattern</span>.<span class="title function_">createPerson</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title class_">GenericFactoryPattern</span>.<span class="title function_">createPerson</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象的方法</span></span><br><span class="line">person1.<span class="title function_">greet</span>() <span class="comment">// 输出：Hello, my name is Alice, and I&#x27;m 30 years old.</span></span><br><span class="line">person2.<span class="title function_">greet</span>() <span class="comment">// 输出：Hello, my name is Bob, and I&#x27;m 25 years old.</span></span><br><span class="line"><span class="comment">// endregion HOW TO USE</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个 <code>Person</code> 类和一个通用的工厂模式类 <code>GenericFactoryPattern</code>，用于创建 <code>Person</code> 实例。下面是对这段代码的解释：</p>
<ol>
<li><strong>Person 类：</strong><ul>
<li>这个类表示一个人，具有两个属性 <code>name</code> 和 <code>age</code>，分别代表人的名字和年龄</li>
<li>类中有一个方法 <code>greet()</code>，用于向他人打招呼并介绍自己，它会在控制台输出一条打招呼的消息</li>
</ul>
</li>
<li><strong>GenericFactoryPattern 类：</strong><ul>
<li>这个类是一个通用的工厂模式类，用于创建 <code>Person</code> 实例</li>
<li>类中有一个静态方法 <code>createPerson(name, age)</code>，用于创建一个 <code>Person</code> 实例。该方法接收两个参数，分别是人的名字和年龄</li>
<li>方法内部对输入参数进行合法性验证，确保 <code>name</code> 是字符串且 <code>age</code> 是正数。如果参数不符合要求，则抛出相应的错误</li>
<li>如果参数验证通过，则使用输入参数创建并返回一个初始化后的 <code>Person</code> 实例</li>
</ul>
</li>
</ol>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li>JQuery的$()</li>
<li>Vue异步组件</li>
<li>Moment.js 中的 <code>moment()</code></li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/Creational/FactoryPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《模版方法模式（行为型）》</title>
    <url>/posts/8472c90e/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现</p>
<p><br/></p>
<p>模板方法模式通常涉及两个核心角色：模板类（Abstract Class）和具体实现类（Concrete Class）</p>
<ul>
<li><p><strong>模板类（Abstract Class）</strong></p>
<p>定义了一个算法的骨架，其中包含了算法的各个步骤，其中某些步骤可能由子类实现</p>
</li>
<li><p><strong>具体实现类（Concrete Class）</strong></p>
<p>实现了模板类中定义的具体步骤。具体实现类负责实现模板类中定义的抽象方法，从而提供算法的具体实现</p>
</li>
</ul>
<p><br/></p>
<p>模板方法模式的核心思想是将算法的不变部分封装到模板类中，而将可变部分留给子类来实现</p>
<p>这种模式的优点在于，可以避免代码的重复，提高代码的复用性，并且可以在不修改模板类的情况下改变算法的某些部分</p>
<p>模板方法模式适用于以下情况：</p>
<ul>
<li>当希望定义一个算法的骨架，并允许子类为其中的某些步骤提供具体实现时，可以使用模板方法模式</li>
<li>当希望在不修改模板类的情况下改变算法的某些部分时，模板方法模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个制作咖啡和茶的过程</p>
<p>制作咖啡和茶的过程中都有一些共同的步骤（如煮水、冲泡、加调味品等），而某些步骤可能因为制作的饮料不同而有所不同</p>
<p>模板方法模式可以将制作饮料的算法抽象成一个模板类，并将其中的共同步骤封装到模板类中，而将可变步骤留给具体的实现类来实现</p>
<p>这样，就可以通过继承模板类并重写其中的部分方法来实现不同种类饮料的制作过程，而不需要重复编写相同的代码</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在多个子类</strong></p>
<p>模板方法模式适用于存在多个子类，并且这些子类之间存在一定的共同行为或者流程的情况</p>
</li>
<li><p><strong>需要定义一个算法的框架</strong></p>
<p>模板方法模式适用于需要定义一个算法的框架，并且允许子类根据需要重写其中的某些步骤的情况</p>
</li>
<li><p><strong>需要避免代码重复</strong></p>
<p>模板方法模式适用于需要避免代码重复的情况，通过将共同行为或者流程抽象到父类中，可以避免在每个子类中重复编写相同的代码</p>
</li>
<li><p><strong>需要在运行时动态确定算法的具体实现</strong></p>
<p>模板方法模式适用于需要在运行时动态确定算法的具体实现的情况，因为模板方法模式允许子类根据需要重写父类中的某些步骤，从而实现不同的算法</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>提高代码复用性</strong></p>
<p>模板方法模式将共同的行为封装到父类中，子类只需要实现特定的步骤即可，从而提高了代码的复用性</p>
</li>
<li><p><strong>提高扩展性</strong></p>
<p>模板方法模式通过将算法的框架定义在父类中，并且允许子类重写特定的步骤，提高了系统的扩展性，可以灵活地增加或者修改算法的具体实现</p>
</li>
<li><p><strong>符合开闭原则</strong></p>
<p>模板方法模式符合开闭原则，父类中定义的算法框架是稳定的，而具体步骤的实现可以在子类中灵活扩展或者修改，因此对于扩展是开放的，对于修改是关闭的</p>
</li>
<li><p><strong>提高了系统的适应性</strong></p>
<p>模板方法模式可以定义一个算法的框架，并且允许子类根据具体情况来实现算法的特定步骤，从而提高了系统的适应性和灵活性</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能导致代码的阅读和理解难度增加</strong></p>
<p>模板方法模式将算法的框架定义在父类中，而具体步骤的实现分散在不同的子类中，可能会导致代码的阅读和理解难度增加</p>
</li>
<li><p><strong>可能限制子类的灵活性</strong></p>
<p>模板方法模式将算法的框架固定在父类中，可能会限制子类的灵活性，如果算法的框架需要在运行时动态确定，可能会导致子类的扩展受到限制</p>
</li>
<li><p><strong>可能增加系统的复杂度</strong></p>
<p>模板方法模式将算法的具体实现分散在不同的子类中，可能会增加系统的复杂度，特别是当算法的具体实现比较复杂时</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>模板基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Beverage类，表示一个饮料的制作过程。这个基类定义了基本步骤，</span></span><br><span class="line"><span class="comment"> * 包括煮水、冲泡、倒入杯子和添加调料。子类需要覆盖brew和addCondiments方法</span></span><br><span class="line"><span class="comment"> * 来实现具体的饮料制作逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * prepareBeverage方法，执行饮品的制作流程。</span></span><br><span class="line"><span class="comment">     * 此方法调用了一系列抽象方法来完成整个制作过程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">prepareBeverage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">boilWater</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">brew</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">pourInCup</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addCondiments</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * boilWater方法，模拟煮水的过程，并打印相关信息到控制台。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">boilWater</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;煮水&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pourInCup方法，将煮好的水倒入杯子中。</span></span><br><span class="line"><span class="comment">     * 这是一个抽象方法，由子类具体实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pourInCup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;倒入杯子&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * brew方法，执行冲泡饮料的操作。</span></span><br><span class="line"><span class="comment">     * 这是一个抽象方法，需要子类根据具体饮料类型实现。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@abstract</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">brew</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须实现brew方法&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * addCondiments方法，向饮品中添加调料或附加物。</span></span><br><span class="line"><span class="comment">     * 这是一个抽象方法，需要子类根据具体饮料类型实现。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@abstract</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">addCondiments</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;子类必须实现addCondiments方法&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Beverage</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>模板子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Coffee 类继承自 Beverage 类，实现了冲泡咖啡以及添加糖和牛奶的具体步骤。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Beverage</span> <span class="keyword">from</span> <span class="string">&#x27;../TemplateMethodPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Beverage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冲泡咖啡的具体步骤。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">brew</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冲泡咖啡&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加糖和牛奶到咖啡中的具体步骤。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">addCondiments</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加糖和牛奶&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Coffee</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tea 类继承自 Beverage 类，实现了冲泡茶的具体步骤。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Beverage</span> <span class="keyword">from</span> <span class="string">&#x27;../TemplateMethodPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Beverage</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冲泡茶叶的方法。</span></span><br><span class="line"><span class="comment">     * 此方法为 Tea 类实现的抽象方法，具体冲泡过程为：冲泡茶叶。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">brew</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冲泡茶叶&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加调料的方法。</span></span><br><span class="line"><span class="comment">     * 对于茶来说，通常不添加额外的调料，因此此方法实现为不进行任何操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">addCondiments</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不加东西&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Tea</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主函数演示如何制作咖啡和茶。</span></span><br><span class="line"><span class="comment"> * 本函数不接受参数，也不返回任何值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Coffee</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Coffee&#x27;</span> <span class="comment">// 导入咖啡类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tea</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Tea&#x27;</span> <span class="comment">// 导入茶类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作咖啡的流程</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;制作咖啡：&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> <span class="title class_">Coffee</span>() <span class="comment">// 创建咖啡实例</span></span><br><span class="line">coffee.<span class="title function_">prepareBeverage</span>() <span class="comment">// 准备咖啡</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作茶的流程</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n制作茶：&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> tea = <span class="keyword">new</span> <span class="title class_">Tea</span>() <span class="comment">// 创建茶实例</span></span><br><span class="line">tea.<span class="title function_">prepareBeverage</span>() <span class="comment">// 准备茶</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>框架设计</strong></p>
<p>在软件框架中，可以使用模板方法模式定义框架的算法骨架，让具体的子类实现算法的细节</p>
<p>这样做可以确保框架的一致性，并且使得框架更容易扩展和定制</p>
</li>
<li><p><strong>库函数</strong></p>
<p>许多编程语言和库中都使用了模板方法模式，例如Java中的Collections.sort()方法就是一个模板方法，它定义了排序算法的骨架，具体的排序算法由Comparator接口的实现类来提供</p>
</li>
<li><p><strong>算法实现</strong></p>
<p>在算法设计中，如果一个算法有多个具体实现，但是它们共享相同的算法骨架，那么可以使用模板方法模式</p>
<p>这样做可以避免代码重复，并且更容易理解和维护</p>
</li>
<li><p><strong>生命周期管理</strong></p>
<p>在生命周期管理中，可以使用模板方法模式来定义对象的创建、初始化、销毁等过程</p>
<p>例如，Android中的Activity生命周期就是一个典型的模板方法模式</p>
</li>
<li><p><strong>流程控制</strong></p>
<p>在业务流程中，如果有一系列步骤需要按照特定顺序执行，但是某些步骤的具体实现可能不同，可以使用模板方法模式</p>
<p>这样做可以保持流程的一致性，并且提高代码的复用性</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/TemplateMethodPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《组合模式（结构型）》</title>
    <url>/posts/79a1bf69/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许将对象组合成树形结构以表示部分-整体的层次结构</p>
<p>组合模式使得客户端可以统一地处理单个对象和对象集合</p>
<p><br/></p>
<p>组合模式通常涉及两个核心角色：组件（Component）和叶子节点（Leaf）</p>
<ul>
<li><p><strong>组件（Component）</strong></p>
<p>定义了组合中所有对象共有的接口和行为，并提供了管理子组件的方法</p>
<p>组件可以是抽象类或接口，它可以是叶子节点或容器节点</p>
</li>
<li><p><strong>叶子节点（Leaf）</strong></p>
<p>表示组合中的叶子对象，它没有子组件</p>
<p>叶子节点通常是组合的最小单元，它实现了组件接口的具体行为</p>
</li>
</ul>
<p><br/></p>
<p>组合模式的核心思想是将对象组合成树形结构，并且统一对待单个对象和对象集合</p>
<p>这种模式的优点在于，可以简化客户端和对象之间的交互，客户端不需要区分单个对象和对象集合，而是统一地对待它们</p>
<p>同时，组合模式也提供了一种灵活的方式来组织和管理对象的层次结构</p>
<p>组合模式适用于以下情况：</p>
<ul>
<li>当希望将对象组合成树形结构，并且统一对待单个对象和对象集合时，可以使用组合模式</li>
<li>当希望客户端可以统一地处理单个对象和对象集合时，组合模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个文件系统中的目录和文件对象</p>
<p>目录可以包含其他目录和文件对象，而文件是组合中的叶子节点</p>
<p>组合模式可以将目录和文件抽象成组件对象，并将它们组合成树形结构</p>
<p>这样，可以通过统一的方式来处理目录和文件对象，而不需要区分它们的类型</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>对象具有层次结构</strong></p>
<p>组合模式适用于对象具有层次结构的情况，对象可以按照树形结构组织，并且对象之间存在整体-部分关系</p>
</li>
<li><p><strong>客户端统一处理叶子对象和容器对象</strong></p>
<p>组合模式适用于客户端需要统一处理叶子对象和容器对象的情况，客户端无需区分对象是叶子对象还是容器对象，可以统一对待</p>
</li>
<li><p><strong>对整体和部分具有一致性要求</strong></p>
<p>组合模式适用于对整体和部分具有一致性要求的情况，客户端可以通过统一的接口对整体对象和部分对象进行操作，无需关心具体是哪种对象</p>
</li>
<li><p><strong>需要简化客户端代码</strong></p>
<p>组合模式适用于需要简化客户端代码的情况，客户端无需关心对象的层次结构和具体实现细节，只需要使用统一的接口来操作对象</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>统一接口</strong></p>
<p>组合模式统一了叶子对象和容器对象的接口，使得客户端可以统一对待叶子对象和容器对象，无需区分</p>
</li>
<li><p><strong>灵活性</strong></p>
<p>组合模式使得客户端可以像处理单个对象一样处理对象的组合，从而增加了系统的灵活性</p>
</li>
<li><p><strong>可扩展性</strong></p>
<p>组合模式通过递归结构实现了对象的树形结构，可以方便地扩展和修改树形结构，从而提高了系统的可扩展性</p>
</li>
<li><p><strong>简化客户端代码</strong></p>
<p>组合模式使得客户端无需关心对象的层次结构和具体实现细节，只需要使用统一的接口来操作对象，从而简化了客户端代码</p>
</li>
<li><p><strong>增加了安全性</strong></p>
<p>组合模式可以通过类型检查来保证容器对象只能包含叶子对象或者其他容器对象，从而增加了系统的安全性</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>限制子对象的类型</strong></p>
<p>组合模式将叶子对象和容器对象统一成了一种类型，可能会限制子对象的类型，使得子对象的类型不能发生变化</p>
</li>
<li><p><strong>增加了系统复杂度</strong></p>
<p>组合模式通过递归结构实现了对象的树形结构，可能会增加系统的复杂度，特别是在处理复杂的树形结构时</p>
</li>
<li><p><strong>不适用于需求变化频繁的场景</strong></p>
<p>如果对象的结构和层次经常发生变化，可能会导致组合模式的实现变得复杂和不稳定，不适用于需求变化频繁的场景</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基础类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示文件系统的一个组件，是一个抽象基类，不能直接实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，创建一个文件系统组件实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 组件的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当尝试直接实例化FileSystemComponent时抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">FileSystemComponent</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;FileSystemComponent is an abstract class and cannot be instantiated directly.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行文件系统组件的操作，此方法在子类中被重写。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当调用此方法时抛出错误，因为这是一个抽象方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;This method should be overridden&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个目录，继承自FileSystemComponent。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，创建一个目录实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 目录的名称。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span> = [] <span class="comment">// 存储子组件的数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向目录中添加一个组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">FileSystemComponent</span>&#125; component 要添加的文件系统组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当添加的对象不是FileSystemComponent的实例时抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">component</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(component <span class="keyword">instanceof</span> <span class="title class_">FileSystemComponent</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Component must be an instance of FileSystemComponent&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(component)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从目录中移除一个组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">FileSystemComponent</span>&#125; component 要移除的文件系统组件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">boolean</span>&#125; 成功移除返回true，否则返回false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">component</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">indexOf</span>(component)</span><br><span class="line">        <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行目录的操作，包括打印目录名称和所有子组件的信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="string">&#x27; &#x27;</span>.repeat(indent)&#125;</span>Directory: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="title function_">operation</span>(indent + <span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个文件，继承自FileSystemComponent。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行文件的操作，即打印文件的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; indent 缩进级别，用于格式化输出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">indent = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="string">&#x27; &#x27;</span>.repeat(indent)&#125;</span>File: <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段代码展示了使用组合模式来管理文件系统对象的例子。</span></span><br><span class="line"><span class="comment"> * 首先，导入了组合模式中的 Directory 和 File 类。</span></span><br><span class="line"><span class="comment"> * 然后，创建了一个根目录 root，两个子目录 dir1 和 dir2，以及两个文件 file1 和 file2。</span></span><br><span class="line"><span class="comment"> * 接着，将 dir1 和 file1 添加到 root 目录中，将 file2 添加到 dir1 目录中。</span></span><br><span class="line"><span class="comment"> * 最后，对 root 目录执行 operation 操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Directory</span>, <span class="title class_">File</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../CombinationPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根目录和一系列子目录及文件</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dir1 = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;dir1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dir2 = <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&#x27;dir2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;file1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&#x27;file2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子目录和文件添加到根目录中</span></span><br><span class="line">root.<span class="title function_">add</span>(dir1)</span><br><span class="line">root.<span class="title function_">add</span>(file1)</span><br><span class="line">root.<span class="title function_">add</span>(dir2)</span><br><span class="line"><span class="comment">// 将文件添加到子目录中</span></span><br><span class="line">dir1.<span class="title function_">add</span>(file2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对根目录执行操作（如打印文件结构等）</span></span><br><span class="line">root.<span class="title function_">operation</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>文件系统</strong></p>
<p>文件系统是组合模式的经典应用，其中目录可以包含其他目录和文件，而文件是组合中的叶子节点</p>
</li>
<li><p><strong>图形用户界面(GUI)</strong></p>
<p>GUI中的UI元素通常也可以使用组合模式来实现，比如窗口可以包含其他窗口、面板、按钮等UI组件</p>
</li>
<li><p><strong>组织结构</strong></p>
<p>企业组织结构可以使用组合模式来表示，部门可以包含其他部门和员工，而员工是叶子节点</p>
</li>
<li><p><strong>菜单系统</strong></p>
<p>菜单系统通常也可以使用组合模式来实现，菜单可以包含子菜单和菜单项，从而形成多级菜单结构</p>
</li>
<li><p><strong>电子商务平台</strong></p>
<p>电子商务平台的商品分类系统通常也可以使用组合模式来实现，分类可以包含子分类和商品，从而形成多级分类结构</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/CombinationPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《策略模式（行为型）》</title>
    <url>/posts/1445619f/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法，并将每个算法封装成单独的对象，使它们可以相互替换。策略模式允许算法的变化独立于使用算法的客户端</p>
<p><br/></p>
<p>策略模式通常涉及三个核心角色：上下文（Context）、策略接口（Strategy Interface）和具体策略类（Concrete Strategies）</p>
<ul>
<li><p><strong>上下文（Context）</strong></p>
<p>负责维护对策略对象的引用，并在需要时调用策略对象的算法</p>
<p>上下文通常会将请求委派给策略对象来执行特定的算法。</p>
</li>
<li><p><strong>策略接口（Strategy Interface）</strong></p>
<p>定义了所有具体策略类必须实现的算法接口</p>
<p>这个接口通常只有一个方法，用于执行具体的算法。</p>
</li>
<li><p><strong>具体策略类（Concrete Strategies）</strong></p>
<p>实现了策略接口，包含了具体的算法实现</p>
<p>每个具体策略类代表了一个具体的算法，可以根据需求增加或修改</p>
</li>
</ul>
<p><br/></p>
<p>策略模式的核心思想是将算法封装成独立的对象，并使这些对象可以相互替换，从而使得算法的变化不会影响到使用算法的客户端</p>
<p>这种模式的优点在于，提高了代码的灵活性和可维护性，使得算法可以在不修改客户端代码的情况下进行替换或者扩展</p>
<p>策略模式适用于以下情况：</p>
<ul>
<li>当一个系统需要支持多种算法，并且这些算法可以相互替换时，可以使用策略模式</li>
<li>当一个类的行为取决于一些动态变化的条件时，可以考虑使用策略模式</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个电商系统中的支付功能</p>
<p>系统可以支持多种支付方式，如支付宝、微信支付、信用卡支付等</p>
<p>策略模式可以将每种支付方式封装成一个具体的策略类，然后根据用户选择的支付方式来动态地选择并使用相应的支付策略，从而实现支付功能的灵活性和可扩展性</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一组相关的算法</strong></p>
<p>策略模式适用于存在一组相关的算法，并且客户端需要在运行时选择其中一个算法来使用的情况</p>
</li>
<li><p><strong>算法之间可以相互替换</strong></p>
<p>策略模式的核心思想是将算法封装成策略对象，并且允许客户端在不修改客户端代码的情况下替换算法</p>
</li>
<li><p><strong>需要避免使用条件语句来选择算法</strong></p>
<p>如果存在多个条件语句来选择不同的算法，可能会导致代码的可读性和可维护性下降</p>
<p>策略模式可以将条件语句替换为对象之间的关系，从而提高代码的可读性和可维护性</p>
</li>
<li><p><strong>需要将算法的实现和使用分离</strong></p>
<p>策略模式将算法的实现和使用分离，使得客户端可以独立于具体算法进行变化，从而提高系统的灵活性和可扩展性</p>
</li>
<li><p><strong>需要将变化的部分封装成独立的对象</strong></p>
<p>策略模式将算法封装成策略对象，并将策略对象作为客户端和上下文对象的一部分，从而将变化的部分封装成独立的对象，方便扩展和修改</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>灵活性高</strong></p>
<p>策略模式允许客户端在运行时动态地选择算法，从而提高系统的灵活性和可扩展性</p>
</li>
<li><p><strong>可维护性好</strong></p>
<p>策略模式将算法封装成独立的策略对象，使得算法的实现和使用分离，从而提高了代码的可维护性</p>
</li>
<li><p><strong>避免使用条件语句</strong></p>
<p>策略模式避免了使用过多的条件语句来选择不同的算法，从而提高了代码的可读性和可维护性</p>
</li>
<li><p><strong>增加代码复用性</strong></p>
<p>策略模式将算法封装成独立的策略对象，可以在不同的上下文中重复使用相同的算法，从而提高了代码的复用性</p>
</li>
<li><p><strong>符合开闭原则</strong></p>
<p>策略模式通过定义一组算法族，并通过策略对象进行封装和使用，可以方便地添加新的算法或修改现有算法，从而符合开闭原则</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>增加对象数量</strong></p>
<p>策略模式将每个算法都封装成独立的策略对象，可能会增加对象数量，从而增加了系统的复杂度</p>
</li>
<li><p><strong>客户端需要了解所有策略</strong></p>
<p>客户端需要了解所有可用的策略，并在运行时选择合适的策略，可能会增加客户端的复杂度</p>
</li>
<li><p><strong>可能增加系统的运行开销</strong></p>
<p>策略模式需要在运行时动态地选择算法，可能会增加系统的运行开销</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>支付类实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付策略工厂类，用于创建和管理不同的支付策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentStrategyFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化一个空的策略映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">strategies</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册一个新的支付策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 策略的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">PaymentStrategy</span>&#125; strategy 实现了PaymentStrategy接口的策略实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果策略没有实现PaymentStrategy接口，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">register</span>(<span class="params">name, strategy</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(strategy <span class="keyword">instanceof</span> <span class="title class_">PaymentStrategy</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;注册的策略必须实现PaymentStrategy接口&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">strategies</span>.<span class="title function_">set</span>(name, strategy)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销一个已注册的支付策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 要注销的策略名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Error</span>&#125; 如果策略被成功注销，则无返回值；如果策略不存在，则打印警告</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">unregister</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">strategies</span>.<span class="title function_">has</span>(name)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">strategies</span>.<span class="title function_">delete</span>(name)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`尝试注销不存在的支付策略: <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个指定名称的支付策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 策略的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">PaymentStrategy</span>&#125; 返回指定名称的支付策略实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果未找到指定名称的策略，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getStrategy</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> strategy = <span class="variable language_">this</span>.<span class="property">strategies</span>.<span class="title function_">get</span>(name)</span><br><span class="line">        <span class="keyword">if</span> (!strategy) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`未找到名为 <span class="subst">$&#123;name&#125;</span> 的支付策略`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>基础支付类实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicPaymentStrategy</span> &#123;</span><br><span class="line">    <span class="title function_">pay</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;pay() 方法必须在子类中实现&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">BasicPaymentStrategy</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>收银台类实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结账类，用于处理支付过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Checkout</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化一个支付工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">PaymentStrategyFactory</span>&#125; paymentFactory 用于创建支付策略的工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">paymentFactory</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">paymentFactory</span> = paymentFactory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理支付请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; amount 需要支付的金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; strategyName 支付策略的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果找不到指定的支付策略，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">processPayment</span>(<span class="params">amount, strategyName</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> strategy = <span class="variable language_">this</span>.<span class="property">paymentFactory</span>.<span class="title function_">getStrategy</span>(strategyName)</span><br><span class="line">        strategy.<span class="title function_">pay</span>(amount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>具体支付类实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付宝支付策略类，继承自基础支付策略类 BasicPaymentStrategy。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">BasicPaymentStrategy</span> <span class="keyword">from</span> <span class="string">&#x27;../Basic/BasicPaymentStrategy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AliPayStrategy</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BasicPaymentStrategy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化支付宝支付策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>() <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_partnerId</span> = <span class="literal">null</span> <span class="comment">// 合作伙伴ID，初始化为null</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_sellerId</span> = <span class="literal">null</span> <span class="comment">// 卖家ID，初始化为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置支付所需的合作伙伴和卖家ID。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; partnerId 合作伙伴ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; sellerId 卖家ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">AliPayStrategy</span>&#125; 返回当前实例，支持链式调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果缺少合作伙伴ID或卖家ID，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setCredentials</span>(<span class="params">partnerId, sellerId</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!partnerId || !sellerId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;partnerId 和 sellerId 都是必填项&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_partnerId</span> = partnerId</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_sellerId</span> = sellerId</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行支付操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; amount 需要支付的金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果未设置合作伙伴ID或卖家ID，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">pay</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_partnerId</span> || !<span class="variable language_">this</span>.<span class="property">_sellerId</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请先调用 setCredentials 设置 PartnerId 和 SellerId&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`使用支付宝支付，PartnerId: <span class="subst">$&#123;<span class="variable language_">this</span>._partnerId&#125;</span>, SellerId: <span class="subst">$&#123;<span class="variable language_">this</span>._sellerId&#125;</span>, 金额: <span class="subst">$&#123;amount&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">AliPayStrategy</span> <span class="comment">// 导出一个初始化好的 AliPayStrategy 实例</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入策略模式相关的类和支付策略的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CheckStand</span>, <span class="title class_">PaymentStrategy</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../StrategyPattern&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">WeChatPayStrategy</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Expansion/WeChatPayStrategy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AliPayStrategy</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Expansion/AliPayStrategy&#x27;</span></span><br><span class="line"><span class="keyword">import</span> creditCardStrategy <span class="keyword">from</span> <span class="string">&#x27;../SubClass/Expansion/CreditCardStrategy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册不同的支付策略并设置其凭证或细节</span></span><br><span class="line"><span class="comment"> * 1. 微信支付: 设置appId和apiKey</span></span><br><span class="line"><span class="comment"> * 2. 支付宝支付: 设置合作伙伴ID和卖家ID</span></span><br><span class="line"><span class="comment"> * 3. 信用卡支付: 设置卡号、安全码和到期日期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">PaymentStrategy</span>.<span class="title function_">register</span>(<span class="string">&quot;wechat&quot;</span>, <span class="title class_">WeChatPayStrategy</span>.<span class="title function_">setCredentials</span>(<span class="string">&quot;wxAppId123&quot;</span>, <span class="string">&quot;apiKey456&quot;</span>))</span><br><span class="line"><span class="title class_">PaymentStrategy</span>.<span class="title function_">register</span>(<span class="string">&quot;alipay&quot;</span>, <span class="title class_">AliPayStrategy</span>.<span class="title function_">setCredentials</span>(<span class="string">&quot;aliPartnerId789&quot;</span>, <span class="string">&quot;sellerId012&quot;</span>))</span><br><span class="line"><span class="title class_">PaymentStrategy</span>.<span class="title function_">register</span>(<span class="string">&quot;creditCard&quot;</span>, creditCardStrategy.<span class="title function_">setCardDetails</span>(<span class="string">&#x27;1234567890123456&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;12/23&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理不同方式的支付</span></span><br><span class="line"><span class="comment"> * 1. 微信支付 100 元</span></span><br><span class="line"><span class="comment"> * 2. 支付宝支付 200 元</span></span><br><span class="line"><span class="comment"> * 3. 信用卡支付 200 元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CheckStand</span>.<span class="title function_">processPayment</span>(<span class="number">100</span>, <span class="string">&quot;wechat&quot;</span>) <span class="comment">// 使用微信支付</span></span><br><span class="line"><span class="title class_">CheckStand</span>.<span class="title function_">processPayment</span>(<span class="number">200</span>, <span class="string">&quot;alipay&quot;</span>) <span class="comment">// 使用支付宝支付</span></span><br><span class="line"><span class="title class_">CheckStand</span>.<span class="title function_">processPayment</span>(<span class="number">200</span>, <span class="string">&quot;creditCard&quot;</span>) <span class="comment">// 使用信用卡支付</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态添加新的支付策略</span></span><br><span class="line"><span class="comment"> * 可以通过扩展PaymentStrategy来创建新的支付方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPaymentStrategy</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 代码参考其他具体支付策略类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">PaymentStrategy</span>.<span class="title function_">register</span>(<span class="string">&quot;newMethod&quot;</span>, <span class="title class_">NewPaymentStrategy</span>.<span class="title function_">setCredentials</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试新添加的支付策略</span></span><br><span class="line"><span class="comment"> * 使用新方法支付50元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CheckStand</span>.<span class="title function_">processPayment</span>(<span class="number">50</span>, <span class="string">&quot;newMethod&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除不再支持的支付策略</span></span><br><span class="line"><span class="comment"> * 从支持列表中移除微信支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">PaymentStrategy</span>.<span class="title function_">unregister</span>(<span class="string">&quot;wechat&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>表单验证</strong></p>
<p>当需要根据不同的条件执行不同的验证逻辑时，可以使用策略模式</p>
<p>例如，根据用户输入的不同数据类型（文本、数字、日期等），选择不同的验证算法</p>
</li>
<li><p><strong>排序算法</strong></p>
<p>如果一个应用程序需要支持多种排序算法（如冒泡排序、快速排序、归并排序等），可以使用策略模式</p>
<p>根据数据量大小、数据结构等因素，选择合适的排序策略</p>
</li>
<li><p><strong>价格计算</strong></p>
<p>在线购物网站可能需要根据不同的促销活动或会员级别来计算产品的价格</p>
<p>使用策略模式可以使得价格计算算法独立于产品和促销活动的变化</p>
</li>
<li><p><strong>缓存策略</strong></p>
<p>在应用程序中实现缓存时，可能会有多种缓存策略可供选择，例如基于时间过期的策略、基于访问频率的策略等</p>
<p>策略模式可以用于管理这些不同的缓存策略</p>
</li>
<li><p><strong>日志记录</strong></p>
<p>根据日志级别（如调试、信息、警告、错误等），选择不同的日志记录策略</p>
<p>例如，在生产环境中可能只记录错误日志，而在开发环境中记录所有日志</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/StrategyPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《职责链模式（行为型）》</title>
    <url>/posts/ae2b73e3/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系</p>
<p><br/></p>
<p>职责链模式通常涉及两个核心角色：处理者（Handler）和客户端（Client）</p>
<ul>
<li><p><strong>处理者（Handler）</strong></p>
<p>定义了一个处理请求的接口，并维护了一个后继处理者的引用</p>
<p>处理者可以决定是否处理请求，或者将请求传递给后继处理者</p>
</li>
<li><p><strong>客户端（Client）</strong></p>
<p>创建处理者对象，并将请求发送给处理者链的第一个处理者</p>
<p>客户端通常不需要知道处理者链的具体结构，只需要将请求发送给第一个处理者即可</p>
</li>
</ul>
<p><br/></p>
<p>职责链模式的核心思想是将请求发送者和接收者解耦，使得多个对象都有机会处理请求，并且可以灵活地调整处理者链的结构</p>
<p>这种模式的优点在于，可以降低请求发送者和接收者之间的耦合度，提高系统的灵活性和可扩展性</p>
<p>职责链模式适用于以下情况：</p>
<ul>
<li>当有多个对象可以处理同一个请求，并且希望将请求发送者和接收者解耦时，可以使用职责链模式</li>
<li>当希望动态地调整处理者链的结构，并且希望在运行时决定请求的处理者时，职责链模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个请假审批系统</p>
<p>请假申请可以被多个领导依次审批，而每个领导都有不同的审批权限</p>
<p>职责链模式可以将每个领导视为一个处理者对象，并将请假申请发送给处理者链的第一个处理者</p>
<p>如果第一个处理者无法处理请求，则将请求传递给下一个处理者，直到找到能够处理请求的处理者为止</p>
<p>这样，可以实现请求发送者和接收者的解耦，同时也提供了一种灵活的方式来处理请求</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>多个对象处理同一请求</strong></p>
<p>职责链模式适用于多个对象处理同一请求的情况，请求会按照一定的顺序经过一系列的处理者，直到找到合适的处理者处理请求为止</p>
</li>
<li><p><strong>请求发送者不需要明确知道接收</strong></p>
</li>
<li><p>职责链模式适用于请求发送者不需要明确知道接收者是谁的情况，请求发送者只需要将请求发送给第一个处理者，由处理者之间相互传递请求，直到找到合适的处理者</p>
</li>
<li><p><strong>请求可以被任意处理者处理</strong></p>
<p>职责链模式适用于请求可以被任意处理者处理的情况，处理者之间没有严格的顺序要求，可以根据具体情况自由选择处理请求的方式</p>
</li>
<li><p><strong>需要动态添加或者删除处理者</strong></p>
<p>职责链模式适用于需要动态添加或者删除处理者的情况，处理者之间的关系是动态变化的，可以根据需要灵活地调整处理者的顺序和数量</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>降低耦合度</strong></p>
<p>职责链模式将请求发送者和接收者解耦，请求发送者不需要知道具体的接收者是谁，接收者也不需要知道请求的发送者是谁，从而降低了对象之间的耦合度</p>
</li>
<li><p><strong>增强灵活性</strong></p>
<p>职责链模式允许请求沿着一条链传递，每个处理者都有机会处理请求或者将请求传递给下一个处理者，从而增强了系统的灵活性和可扩展性</p>
</li>
<li><p><strong>简化对象的相互连接</strong></p>
<p>职责链模式可以简化对象之间的相互连接，每个处理者只需要保存对下一个处理者的引用即可，无需了解整个处理链的结构，降低了系统的复杂度</p>
</li>
<li><p><strong>增强了请求的处理过程</strong></p>
<p>职责链模式将请求的处理过程分解成多个处理者来共同完成，每个处理者只负责自己能够处理的部分，使得请求的处理过程更加清晰和可控</p>
</li>
<li><p><strong>动态添加或者删除处理者</strong>职</p>
<p>责链模式允许动态地添加或者删除处理者，处理者之间的关系是动态变化的，可以根据需要灵活地调整处理者的顺序和数量</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>请求可能未被处理</strong></p>
<p>如果请求没有合适的处理者来处理，可能会导致请求未被处理，需要额外的机制来处理这种情况，例如设置一个默认处理者</p>
</li>
<li><p><strong>性能问题</strong></p>
<p>职责链模式可能会导致性能问题，特别是处理链比较长或者请求频繁的情况下，可能会造成请求的传递和处理延迟</p>
</li>
<li><p><strong>调试困难</strong></p>
<p>由于请求的处理过程被分解到多个处理者中，可能会导致调试困难，难以确定请求的处理流程和具体是哪个处理者处理了请求</p>
</li>
<li><p><strong>可能导致循环引用</strong></p>
<p>如果处理链中存在循环引用的情况，可能会导致请求无法正常处理，甚至造成系统崩溃，需要谨慎设计处理链的结构</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>处理者基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processor类定义了一个处理器的基本结构，包括处理器的名称、权限级别以及下一个处理器的设置。</span></span><br><span class="line"><span class="comment"> * 它是一个抽象类，不允许直接实例化，必须通过继承来扩展。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化处理器的名称和权限级别，并检查是否尝试直接实例化抽象类。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 处理器的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; authorityLevel 处理器的权限级别。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果尝试直接实例化Processor类，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, authorityLevel</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Processor</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;不能实例化抽象类Processor&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">authorityLevel</span> = authorityLevel</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nextProcessor</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个处理器。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Processor</span>&#125; nextProcessor 下一个处理器的实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果传入的不是Processor的实例，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">setNextProcessor</span>(<span class="params">nextProcessor</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(nextProcessor <span class="keyword">instanceof</span> <span class="title class_">Processor</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;下一个审批者必须是Processor的实例&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">nextProcessor</span> = nextProcessor</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求的方法，这是一个抽象方法，必须在子类中实现。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; request 待处理的请求对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 必须在子类中实现此方法，否则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">processRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;必须实现processRequest方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Processor</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>子类基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入链式责任模式的处理器基类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Processor</span> <span class="keyword">from</span> <span class="string">&#x27;../ChainOfResponsibilityPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 团队领导类，继承自处理器基类，处理员工请假请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TeamLeader</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Processor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化团队领导实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&quot;团队领导&quot;</span>, <span class="number">2</span>) <span class="comment">// 调用父类构造器，设置名称为“团队领导”，审批权限级别为2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请假请求的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; request 请假请求对象，包含请假天数等信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">processRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请假天数在团队领导的审批权限范围内，则审批通过</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">leaveDays</span> &lt;= <span class="variable language_">this</span>.<span class="property">authorityLevel</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>审批了<span class="subst">$&#123;request.leaveDays&#125;</span>天的请假。`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextProcessor</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果请假天数超出团队领导的审批范围，但存在下一个处理器（比如经理），则转交下一个处理器处理</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>无法处理，请转交给<span class="subst">$&#123;<span class="variable language_">this</span>.nextProcessor.name&#125;</span>`</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">nextProcessor</span>.<span class="title function_">processRequest</span>(request)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果请假天数超出团队领导的审批范围，并且不存在下一个处理器，则审批不通过</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`无法处理，请假天数过长。`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出TeamLeader类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TeamLeader</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入链式责任模式的处理器基类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Processor</span> <span class="keyword">from</span> <span class="string">&#x27;../ChainOfResponsibilityPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 部门经理类，继承自处理器基类，用于处理员工请假请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepartmentManager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Processor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化部门经理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&quot;部门经理&quot;</span>, <span class="number">5</span>) <span class="comment">// 调用父类构造函数，设置名称为“部门经理”，审批权限级别为5天</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请假请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; request 请假请求对象，包含请假天数等信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">processRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请假天数在部门经理的审批权限范围内，则审批通过</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">leaveDays</span> &lt;= <span class="variable language_">this</span>.<span class="property">authorityLevel</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>审批了<span class="subst">$&#123;request.leaveDays&#125;</span>天的请假。`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextProcessor</span>) &#123; <span class="comment">// 如果存在下一个处理器（上级领导），则将请求转交</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>无法处理，请转交给<span class="subst">$&#123;<span class="variable language_">this</span>.nextProcessor.name&#125;</span>`</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">nextProcessor</span>.<span class="title function_">processRequest</span>(request)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有下一个处理器，表示无法处理此请求</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`无法处理，请假天数过长。`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出部门经理类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DepartmentManager</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入链式责任模式的处理器基类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Processor</span> <span class="keyword">from</span> <span class="string">&#x27;../ChainOfResponsibilityPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人力资源经理类，继承自处理器基类，用于处理员工请假请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HRManager</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Processor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化人力资源经理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">&quot;人力资源经理&quot;</span>, <span class="number">10</span>) <span class="comment">// 调用父类构造函数，设置名称为“人力资源经理”，审批权限级别为10天</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请假请求。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; request 请假请求对象，包含请假天数等信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">processRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果请假天数在权限级别内，审批通过</span></span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">leaveDays</span> &lt;= <span class="variable language_">this</span>.<span class="property">authorityLevel</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>审批了<span class="subst">$&#123;request.leaveDays&#125;</span>天的请假。`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextProcessor</span>) &#123; <span class="comment">// 如果存在下一个处理器，则将请求转交给下一个处理器</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>无法处理，请转交给<span class="subst">$&#123;<span class="variable language_">this</span>.nextProcessor.name&#125;</span>`</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">nextProcessor</span>.<span class="title function_">processRequest</span>(request)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有下一个处理器，则表示无法处理该请求</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`无法处理，请假天数过长。`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出HRManager类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HRManager</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LeaveRequest 类用于创建一个请假申请实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; leaveDays 请假天数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">leaveDays</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leaveDays</span> = leaveDays; <span class="comment">// 初始化请假天数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LeaveRequest</span>; <span class="comment">// 导出LeaveRequest类作为默认模块</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序入口用于演示如何处理员工请假流程。</span></span><br><span class="line"><span class="comment"> * 首先，创建了团队领导、部门经理和人力资源经理的实例。</span></span><br><span class="line"><span class="comment"> * 然后，设定它们之间的处理顺序，即团队领导先处理请假申请，然后传递给部门经理，最后由人力资源经理处理。</span></span><br><span class="line"><span class="comment"> * 接着，创建了几个请假申请实例，并通过团队领导的实例处理这些请假申请。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入相关的类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TeamLeader</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/TeamLeader&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DepartmentManager</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/DepartmentManager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HRManager</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/HRManager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LeaveRequest</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/LeaveRequest&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建团队领导、部门经理和人力资源经理的实例</span></span><br><span class="line"><span class="keyword">const</span> teamLeader = <span class="keyword">new</span> <span class="title class_">TeamLeader</span>()</span><br><span class="line"><span class="keyword">const</span> departmentManager = <span class="keyword">new</span> <span class="title class_">DepartmentManager</span>()</span><br><span class="line"><span class="keyword">const</span> hrManager = <span class="keyword">new</span> <span class="title class_">HRManager</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置处理流程的链式关系</span></span><br><span class="line">teamLeader.<span class="title function_">setNextProcessor</span>(departmentManager)</span><br><span class="line">departmentManager.<span class="title function_">setNextProcessor</span>(hrManager)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建请假申请实例，并提交给团队领导处理</span></span><br><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> request3 = <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> request7 = <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">const</span> request12 = <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">teamLeader.<span class="title function_">processRequest</span>(request1)</span><br><span class="line">teamLeader.<span class="title function_">processRequest</span>(request3)</span><br><span class="line">teamLeader.<span class="title function_">processRequest</span>(request7)</span><br><span class="line">teamLeader.<span class="title function_">processRequest</span>(request12)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>电子商务订单处理系统</strong> </p>
<p>假设一个电子商务平台，订单的处理包括库存检查、支付验证、地址验证、配送等多个环节</p>
<p>每个环节都有不同的处理者，可以使用职责链模式来构建订单处理流程</p>
<p>订单首先经过库存检查处理者，如果库存充足，则传递给支付验证处理者，依次类推，直到订单被完全处理</p>
</li>
<li><p><strong>工作流引擎</strong> </p>
<p>工作流引擎是一种用于管理和执行工作流程的系统</p>
<p>在工作流引擎中，每个工作流程包含多个步骤或任务，每个步骤都有对应的处理者</p>
<p>职责链模式可以用来管理工作流程中的步骤和处理者，以实现任务的自动化处理</p>
</li>
<li><p><strong>网络安全防护系统</strong> </p>
<p>在网络安全防护系统中，通常会对网络流量进行多层次的检测和过滤，包括入侵检测、恶意软件检测、数据包过滤等</p>
<p>每个检测和过滤功能可以作为一个处理者，通过职责链模式将它们串联起来，以便逐层检测和过滤网络流量</p>
</li>
<li><p><strong>工程质量检查系统</strong> </p>
<p>在软件开发中，经常需要进行代码审查和质量检查，以确保代码符合规范和质量标准</p>
<p>可以使用职责链模式来构建质量检查系统，其中每个质量检查功能（如代码格式检查、代码风格检查、代码性能检查等）作为一个处理者，根据需要逐个应用于待检查的代码</p>
</li>
<li><p><strong>文件处理系统</strong></p>
<p> 在文件处理系统中，可能需要对不同类型的文件进行处理，如文本文件、图像文件、音频文件等</p>
<p>每种类型的文件都需要不同的处理方式，可以使用职责链模式来管理文件处理流程，使得每个文件根据其类型被传递给相应的处理者进行处理</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/ChainOfResponsibilityPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《观察者模式（行为型）》</title>
    <url>/posts/73dbb689/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听并收到目标对象的状态变化</p>
<p><br/></p>
<p>观察者模式通常涉及两个核心角色：目标（Subject）和观察者（Observer）</p>
<ul>
<li><p><strong>目标（Subject）</strong></p>
<p>也称为主题或者可观察对象，它是被观察的对象</p>
<p>目标对象会维护一个观察者列表，并提供方法来添加、移除和通知观察者</p>
</li>
<li><p><strong>观察者（Observer）</strong></p>
<p>也称为订阅者或者监听者，它是接收目标对象状态变化通知的对象</p>
<p>观察者对象通常会实现一个更新方法，用于接收目标对象状态变化的通知</p>
</li>
</ul>
<p><br/></p>
<p>观察者模式的核心思想是通过定义目标对象和观察者对象之间的一对多依赖关系，使得目标对象状态变化时能够通知所有的观察者对象</p>
<p>这种模式的优点在于，实现了目标对象和观察者对象的解耦，使得它们可以独立变化，同时也提供了一种灵活的机制来实现发布-订阅模式</p>
<p>观察者模式适用于以下情况：</p>
<ul>
<li>当一个对象的状态变化需要通知其他对象，并且这些对象的数量和类型在运行时可以动态变化时，可以使用观察者模式</li>
<li>当一个对象的状态变化可能引起其他对象的状态变化，并且希望避免对象之间的紧耦合关系时，观察者模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个新闻发布系统</p>
<p>新闻发布者是目标对象，而订阅者是观察者对象。当新闻发布者发布了新的新闻时，所有订阅者都会收到新闻通知，并更新自己的状态</p>
<p>观察者模式可以很好地实现这种发布-订阅的机制，同时也保持了发布者和订阅者之间的解耦</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一个一对多的依赖关系</strong></p>
<p>观察者模式适用于存在一个主题（Subject）对象和多个观察者（Observer）对象之间的一对多的依赖关系的情况，当主题对象的状态发生变化时，所有依赖于该主题对象的观察者对象都会得到通知</p>
</li>
<li><p><strong>主题对象的状态发生变化需要通知观察者对象</strong></p>
<p>观察者模式适用于主题对象的状态发生变化时需要通知所有观察者对象的情况，观察者对象根据主题对象的状态变化来更新自己的状态或者执行相应的操作</p>
</li>
<li><p><strong>观察者对象的数量相对固定</strong></p>
<p>观察者模式适用于观察者对象的数量相对固定的情况，因为主题对象需要维护观察者对象的引用，并且在状态发生变化时通知所有观察者对象</p>
</li>
<li><p><strong>观察者对象与主题对象之间的解耦</strong></p>
<p>观察者模式将主题对象和观察者对象之间的关系进行了解耦，使得主题对象和观察者对象可以相互独立地变化，而不需要相互了解具体的实现细节</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>简化事件管理</strong></p>
<p>在前端开发中，观察者模式可以用于简化事件管理。主题对象就是事件源，而观察者对象就是事件处理函数</p>
<p>当事件源状态变化时，观察者（事件处理函数）会得到通知并执行相应的操作，从而使得事件管理更加简单清晰</p>
</li>
<li><p><strong>模块解耦</strong></p>
<p>观察者模式可以帮助将模块解耦，使得代码更具灵活性和可维护性</p>
<p>通过观察者模式，主题对象（被观察者）和观察者对象之间的依赖关系被解耦，它们可以独立地变化和扩展</p>
</li>
<li><p><strong>数据驱动界面更新</strong></p>
<p>在前端应用中，观察者模式常用于数据驱动界面更新</p>
<p>当数据发生变化时，主题对象会通知所有的观察者对象，而这些观察者对象可以负责更新相应的界面元素，实现了数据和界面的分离</p>
</li>
<li><p><strong>事件监听</strong></p>
<p>在前端开发中，观察者模式常用于事件监听。通过注册事件监听器（观察者），可以在事件发生时执行相应的操作，从而实现事件驱动的编程模型</p>
</li>
<li><p><strong>组件通信</strong></p>
<p>观察者模式也常被用于组件间的通信。当一个组件的状态发生变化时，可以通过观察者模式通知其他组件进行相应的更新或者操作，从而实现组件间的解耦和通信</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>可能引起内存泄漏</strong></p>
<p>如果观察者对象没有被正确地释放或者没有及时地取消注册，可能会导致主题对象保持对观察者对象的引用，从而导致内存泄漏</p>
</li>
<li><p><strong>可能引起循环引用</strong></p>
<p>如果观察者对象之间存在循环引用，可能会导致系统出现死锁或者其他不可预期的问题</p>
</li>
<li><p><strong>可能导致性能问题</strong></p>
<p>当观察者对象过多或者观察者对象的通知频率过高时，可能会导致系统的性能下降</p>
</li>
<li><p><strong>可能导致事件顺序问题</strong></p>
<p>观察者模式通常是异步通知观察者对象的，因此可能会导致观察者对象接收到通知的顺序与注册的顺序不一致的问题</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>创建基础的观察者类，并冻结它</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者类，提供订阅、取消订阅和通知功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化观察者对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 使用Set存储订阅的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅功能，添加一个观察者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span> - 需要订阅的函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果传入的参数不是函数类型，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Observer.subscribe: Expected function&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅功能，移除一个观察者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span> - 需要取消订阅的函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果传入的参数不是函数类型，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">unsubscribe</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Observer.unsubscribe: Expected function&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">delete</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有订阅者函数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">data</span> - 传递给订阅者函数的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>(data)) <span class="comment">// 循环调用所有订阅者函数，传入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个全局不变的观察者实例</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Watcher</span> = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(<span class="keyword">new</span> <span class="title class_">Observer</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Watcher</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>导入使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入Watcher对象，该对象来自于ObserverPattern模块，用于实现观察者模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Watcher</span> <span class="keyword">from</span> <span class="string">&#x27;../ObserverPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义第一个观察者函数，当接收到数据时，打印出数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">data</span> - 接收到的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observer1</span> = data =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Observer 1 received: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义第二个观察者函数，当接收到数据时，打印出数据。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">data</span> - 接收到的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observer2</span> = data =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Observer 2 received: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅observer1和observer2，使其成为Watcher的观察者。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">subscribe</span>(observer1)</span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">subscribe</span>(observer2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有观察者，发送消息&#x27;Hello World&#x27;。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">notify</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消observer1的订阅。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">unsubscribe</span>(observer1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次通知所有观察者，发送消息&#x27;How are you?&#x27;，此时observer1不会收到该消息。</span></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="title function_">notify</span>(<span class="string">&#x27;How are you?&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>表单字段的验证与提示</strong></p>
<p> 当用户在表单中输入内容时，需要实时验证输入的有效性，并及时提示用户</p>
<p>这里可以将表单字段作为观察者，输入事件作为主题，当字段的值发生变化时，触发相应的验证函数来更新提示信息</p>
</li>
<li><p><strong>组件间通信</strong>：</p>
<p>在复杂的前端应用中，不同的组件之间可能需要进行通信和数据传递</p>
<p>观察者模式可以被用来实现组件间的解耦，一个组件可以作为主题，而其他组件则可以订阅主题来获取相关的数据或状态更新</p>
</li>
<li><p><strong>全局状态管理</strong></p>
<p> 在大型前端应用中，可能会存在一些全局的状态需要在不同的组件中共享和管理</p>
<p>观察者模式可以被用来实现全局状态的管理，一个状态对象可以作为主题，而其他组件则可以订阅该主题来获取状态的更新</p>
</li>
<li><p><strong>路由管理</strong></p>
<p>在单页面应用（SPA）中，路由管理是一个重要的功能</p>
<p>当路由发生变化时，不同的页面或组件需要做出相应的响应</p>
<p>观察者模式可以被用来实现路由管理，路由对象可以作为主题，而页面或组件则可以订阅该主题来获取路由的变化</p>
</li>
<li><p><strong>事件总线</strong></p>
<p>在前端开发中，可能会遇到需要在不同组件之间进行事件通信的情况</p>
<p>观察者模式可以被用来实现事件总线，一个事件总线对象可以作为主题，而其他组件则可以订阅事件总线来接收和处理事件</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/ObserverPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《装饰器模式（结构型）》</title>
    <url>/posts/f51f74c/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许动态地给一个对象添加一些额外的职责，而不需要通过继承来实现</p>
<p>装饰器模式通过引入一个装饰器类和具体组件类来实现这一点</p>
<p><br/></p>
<p>在装饰器模式中，通常存在四个核心角色：抽象组件（Component）、具体组件（Concrete Component）、抽象装饰器（Decorator）和具体装饰器（Concrete Decorator）</p>
<p>抽象组件定义了对象的基本行为，具体组件实现了抽象组件的行为，抽象装饰器继承了抽象组件，并持有一个抽象组件的引用，具体装饰器继承了抽象装饰器，并通过调用抽象组件的方法来增加额外的职责</p>
<p><br/></p>
<p>装饰器模式的核心思想是通过组合的方式来动态地给一个对象添加一些额外的职责，而不需要通过继承来修改原有的类结构</p>
<p>这种模式的优点在于，可以在不改变原有对象的情况下，动态地增加新的功能，从而提高了系统的灵活性和可维护性</p>
<p>装饰器模式适用于以下情况：</p>
<ol>
<li>需要动态地给一个对象添加一些额外的职责，而不希望通过继承来实现</li>
<li>需要在不影响其他对象的情况下，给一个对象添加一些额外的功能</li>
</ol>
<p><br/></p>
<p>举个简单的例子，考虑一个咖啡店</p>
<p>咖啡店提供基本的咖啡（具体组件），但是顾客可能需要在咖啡中加入额外的调料，比如牛奶、糖等</p>
<p>使用装饰器模式，可以通过装饰器来动态地给咖啡对象添加额外的调料功能，而不需要修改原有的咖啡类结构，从而实现了对咖啡对象的灵活扩展</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><p>要实现装饰器模式，通常需要以下条件：</p>
<ol>
<li><p>组件接口</p>
<p>一个定义了对象的基本功能的接口</p>
</li>
<li><p>具体组件</p>
<p>实现或继承自组件接口的类，它定义了基本功能</p>
</li>
<li><p>装饰器类</p>
<p>实现或继承自组件接口的类，它包含具体组件的实例，并添加新的功能</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>增加职责</strong></p>
<p>可以在不修改原始代码的情况下，向对象添加新的功能</p>
</li>
<li><p><strong>灵活性</strong></p>
<p>可以动态地添加或删除功能</p>
</li>
<li><p><strong>功能组合</strong></p>
<p>可以组合多个装饰器，创造出复杂的功能</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>复杂性</strong></p>
<p>使用大量装饰器会增加系统的复杂性</p>
</li>
<li><p><strong>维护难度</strong></p>
<p>过多的层次和装饰可能会使系统变得难以维护</p>
</li>
<li><p><strong>性能问题</strong></p>
<p>在某些情况下，过多的包装层可能会影响性能</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>基本对象定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口（或者抽象类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;getCost()&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Method &#x27;getDescription()&#x27; must be implemented.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本咖啡类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰器类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeInterface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">coffee</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="keyword">if</span> (!(coffee <span class="keyword">instanceof</span> <span class="title class_">CoffeeInterface</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Decorator requires a CoffeeInterface instance.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">coffee</span> = coffee</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基本对象上增加新东西的装饰器类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 牛奶装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">getCost</span>() + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.coffee.getDescription()&#125;</span>, Milk`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糖装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="title function_">getCost</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">coffee</span>.<span class="title function_">getCost</span>() + <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.coffee.getDescription()&#125;</span>, Sugar`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用装饰器</span></span><br><span class="line"><span class="keyword">let</span> myCoffee = <span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>() <span class="comment">// 创建一个基本的咖啡对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line">myCoffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(myCoffee) <span class="comment">// 向咖啡中添加牛奶</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee, Milk</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：6</span></span><br><span class="line"></span><br><span class="line">myCoffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(myCoffee) <span class="comment">// 向咖啡中添加糖</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getDescription</span>()) <span class="comment">// 输出：Simple Coffee, Milk, Sugar</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myCoffee.<span class="title function_">getCost</span>()) <span class="comment">// 输出：6.5</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>接口定义</strong></p>
<p><code>CoffeeInterface</code> 是一个抽象接口或类，定义了 <code>getCost()</code> 和 <code>getDescription()</code> 两个方法</p>
<p>这些方法代表了咖啡对象的基本功能，装饰器和基本对象都应该实现这个接口</p>
</li>
<li><p><strong>基本对象</strong></p>
<p><code>SimpleCoffee</code> 类是一个基本的咖啡对象，继承自 <code>CoffeeInterface</code>，并实现了 <code>getCost()</code> 和 <code>getDescription()</code> 方法</p>
<p>这个类代表了最基本的咖啡，没有任何额外的添加</p>
</li>
<li><p><strong>抽象装饰器类</strong></p>
<p><code>CoffeeDecorator</code> 是一个抽象装饰器类，继承自 <code>CoffeeInterface</code></p>
<p>它的构造函数接受一个 <code>CoffeeInterface</code> 类型的对象，并确保传入的对象符合该接口</p>
</li>
<li><p><strong>具体装饰器类</strong></p>
<p><code>MilkDecorator</code> 和 <code>SugarDecorator</code> 类继承自 <code>CoffeeDecorator</code>，分别代表牛奶和糖装饰器</p>
<p>它们在原始对象的基础上扩展了 <code>getCost()</code> 和 <code>getDescription()</code> 方法，添加了相应的功能</p>
</li>
<li><p><strong>组合装饰器</strong></p>
<p>装饰器模式允许将不同的装饰器组合在一起</p>
<p>通过在装饰器链中逐一应用装饰器，<code>myCoffee</code> 对象依次被 <code>MilkDecorator</code> 和 <code>SugarDecorator</code> 装饰，从而在原始 <code>SimpleCoffee</code> 对象上添加了牛奶和糖的功能</p>
</li>
</ol>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>React 高阶组件</strong></p>
<ul>
<li><strong>高阶组件</strong>（HOC，Higher-Order Component）是 React 中的一种模式，它类似于装饰器模式。高阶组件接受一个组件作为参数，并返回一个新的组件。这种方式可以用来增强组件的功能</li>
<li>例如，<code>react-redux</code> 中的 <code>connect</code> 函数就是一个高阶组件，它将组件与 Redux 的状态和派发函数相连接</li>
</ul>
</li>
<li><p><strong>Node.js 中的中间件</strong></p>
<ul>
<li>在 Node.js 中，特别是在 Web 框架（如 Express 和 Koa）中，中间件模式类似于装饰器模式。中间件通过将请求和响应对象传递给一系列函数，从而动态地添加或修改功能。</li>
<li>例如，在 Express 中，你可以使用中间件来对请求进行身份验证、解析数据、添加日志记录等</li>
</ul>
</li>
<li><p><strong>Python 装饰器</strong></p>
<ul>
<li><p>虽然 Python 不是 JavaScript，但其装饰器特性可以提供一个参考</p>
<p>Python 中的装饰器用于为函数或方法添加额外的行为</p>
<p>在 JavaScript 中，你可以通过闭包和高阶函数来模拟类似的效果</p>
</li>
</ul>
</li>
<li><p><strong>Angular 装饰器</strong></p>
<ul>
<li><p>Angular 框架使用装饰器</p>
<p>（如 <code>@Component</code>、<code>@Injectable</code> 等）来定义组件、服务、模块等</p>
<p>这些装饰器本质上是函数，用于为类添加元数据和功能</p>
</li>
</ul>
</li>
<li><p><strong>JavaScript 中的工具和库</strong></p>
<ul>
<li><p><strong>Lodash</strong> 和 <strong>underscore</strong> 等工具库提供了一些高阶函数</p>
<p>可以用于以装饰器的形式对函数进行封装，如 <code>_.debounce</code> 和 <code>_.throttle</code></p>
</li>
<li><p><strong>TypeScript 装饰器</strong></p>
<p>TypeScript 支持类和方法装饰器</p>
<p>它们可以用来为类或方法添加元数据或功能</p>
<p>虽然这在语法上不同于传统的装饰器模式，但它提供了类似的功能</p>
</li>
</ul>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/DecoratorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《解释器模式（行为型）》</title>
    <url>/posts/29dbf566/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一种语言的文法，并提供了一种解释器来解释该语言中的句子</p>
<p><br/></p>
<p>解释器模式通常涉及两个核心角色：解释器（Interpreter）和上下文（Context）</p>
<ul>
<li><p><strong>解释器（Interpreter）</strong></p>
<p>定义了一个抽象的解释操作接口，用于解释文法中的各种句子</p>
<p>解释器通常会包含多个解释方法，每个方法对应文法中的一个语法规则</p>
</li>
<li><p><strong>上下文（Context）</strong></p>
<p>包含了需要解释的文法内容</p>
<p>上下文对象通常会包含一些全局信息或者状态，供解释器对象使用</p>
</li>
</ul>
<p><br/></p>
<p>解释器模式的核心思想是将语言的文法抽象成一个解释器对象，并通过解释器对象来解释文法中的句子</p>
<p>这种模式的优点在于，可以将语言的解释和实现分离，使得解释过程更加灵活和可扩展</p>
<p>解释器模式适用于以下情况：</p>
<ul>
<li>当需要解释一种语言的文法，并且希望解释过程与实现解释的对象解耦时，可以使用解释器模式</li>
<li>当希望将解释过程封装到一个对象中，并提供一种统一的接口来解释不同类型的句子时，解释器模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个简单的数学表达式解析器</p>
<p>解释器模式可以将数学表达式的文法抽象成一个解释器对象，并通过解释器对象来解释和计算表达式的值</p>
<p>例如，给定一个表达式 “3 + 5 * 2”，解释器模式可以通过解释器对象来解析该表达式，并计算出其结果为 13</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一种语言</strong></p>
<p>解释器模式适用于存在一种自定义语言或者规则的情况，需要解释和执行这种语言或者规则</p>
</li>
<li><p><strong>需要对语言进行解释和执行</strong></p>
<p>解释器模式适用于需要对一种自定义语言或者规则进行解释和执行的情况，例如编译器、解析器等</p>
</li>
<li><p><strong>语言的规则相对固定</strong></p>
<p>解释器模式适用于语言的规则相对固定，并且不太容易发生变化的情况</p>
<p>因为解释器模式需要定义一组解释器对象，并且需要根据语言的规则来实现这些解释器对象</p>
</li>
<li><p><strong>需要对语言进行扩展</strong></p>
<p>解释器模式适用于需要对语言进行扩展的情况，因为解释器模式可以通过定义新的解释器对象来扩展语言的功能</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>性能问题</strong></p>
<p>解释器模式通常需要解释和执行语言的语法规则，因此可能会导致性能问题，特别是在处理大规模和复杂的语法规则时</p>
</li>
<li><p><strong>复杂度高</strong></p>
<p>解释器模式通常需要定义大量的解释器对象，并且需要正确地组合这些解释器对象来实现语言的语法规则，可能会导致系统的复杂度增加</p>
</li>
<li><p><strong>不适用于所有情况</strong></p>
<p>解释器模式适用于对语言进行解释和执行的情况，但并不适用于所有情况，特别是对性能要求较高或者语言规则变化频繁的情况</p>
</li>
<li><p><strong>难以维护</strong></p>
<p>解释器模式通常会涉及到大量的解释器对象和语法规则，可能会导致代码的维护成本增加</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>性能问题</strong></p>
<p>解释器模式通常需要解释和执行语言的语法规则，因此可能会导致性能问题，特别是在处理大规模和复杂的语法规则时</p>
</li>
<li><p><strong>复杂度高</strong></p>
<p>解释器模式通常需要定义大量的解释器对象，并且需要正确地组合这些解释器对象来实现语言的语法规则，可能会导致系统的复杂度增加</p>
</li>
<li><p><strong>不适用于所有情况</strong></p>
<p>解释器模式适用于对语言进行解释和执行的情况，但并不适用于所有情况，特别是对性能要求较高或者语言规则变化频繁的情况</p>
</li>
<li><p><strong>难以维护</strong></p>
<p>解释器模式通常会涉及到大量的解释器对象和语法规则，可能会导致代码的维护成本增加</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>解释器基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主文件导入各个表达式子类并定义表达式相关类和方法。</span></span><br><span class="line"><span class="comment"> * 提供了基本的数学运算表达式及其组合的构建和解释能力。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入表达式子类</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AdditionExpression</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/AdditionExpression&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SubtractionExpression</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/SubtractionExpression&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MultiplicationExpression</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/MultiplicationExpression&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DivisionExpression</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/DivisionExpression&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ModuloExpression</span> <span class="keyword">from</span> <span class="string">&#x27;./SubClass/ModuloExpression&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表达式基类，定义了表达式的基本行为。</span></span><br><span class="line"><span class="comment"> * 子类需要实现interpret()方法来提供具体的解释执行逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;interpret() must be implemented in derived class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复合表达式基类，用于组合两个表达式进行运算。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> Expression 表达式基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompoundExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Expression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化复合表达式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 第一个操作数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 第二个操作数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果任一操作数不是Expression实例，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="keyword">if</span> (!(expression1 <span class="keyword">instanceof</span> <span class="title class_">Expression</span>) || !(expression2 <span class="keyword">instanceof</span> <span class="title class_">Expression</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Both operands must be instances of Expression&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">expression1</span> = expression1</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">expression2</span> = expression2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数字表达式类，用于表示和解释一个简单的数字表达式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@extends</span> Expression 表达式基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Expression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化数字表达式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; number 表达式代表的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果输入不是数字，则抛出错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">number</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;NumberExpression requires a number&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">number</span> = number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释执行数字表达式，直接返回数字本身。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 表达式代表的数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助方法，用于简化创建加法表达式的过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 第一个加数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 第二个加数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">AdditionExpression</span>&#125; 新创建的加法表达式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AdditionExpression</span>(expression1, expression2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助方法，用于简化创建减法表达式的过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 被减数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 减数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">SubtractionExpression</span>&#125; 新创建的减法表达式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubtractionExpression</span>(expression1, expression2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助方法，用于简化创建乘法表达式的过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 第一个乘数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 第二个乘数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">MultiplicationExpression</span>&#125; 新创建的乘法表达式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiplicationExpression</span>(expression1, expression2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助方法，用于简化创建除法表达式的过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 被除数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 除数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">DivisionExpression</span>&#125; 新创建的除法表达式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DivisionExpression</span>(expression1, expression2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助方法，用于简化创建取模表达式的过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression1 被除数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Expression</span>&#125; expression2 除数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">ModuloExpression</span>&#125; 新创建的取模表达式实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">modulo</span>(<span class="params">expression1, expression2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModuloExpression</span>(expression1, expression2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出各类表达式和辅助方法供外部使用</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">Expression</span>,</span><br><span class="line">    <span class="title class_">CompoundExpression</span>,</span><br><span class="line">    <span class="title class_">NumberExpression</span>,</span><br><span class="line">    add,</span><br><span class="line">    subtract,</span><br><span class="line">    multiply,</span><br><span class="line">    divide,</span><br><span class="line">    modulo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>表达式子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ModuloExpression类继承自CompoundExpression，用于解释求模运算。</span></span><br><span class="line"><span class="comment"> * 它接收两个表达式作为分子和分母，并在求模运算时抛出零除错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompoundExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModuloExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CompoundExpression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行求模运算。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 返回两个表达式求模后的结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当分母为零时抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 解释并获取分母的值</span></span><br><span class="line">        <span class="keyword">const</span> divisor = <span class="variable language_">this</span>.<span class="property">expression2</span>.<span class="title function_">interpret</span>()</span><br><span class="line">        <span class="comment">// 检查分母是否为零</span></span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Modulo by zero&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行求模运算并返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression1</span>.<span class="title function_">interpret</span>() % divisor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ModuloExpression</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DivisionExpression 类继承自 CompoundExpression，</span></span><br><span class="line"><span class="comment"> * 用于实现除法表达式的解释操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompoundExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivisionExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CompoundExpression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行除法操作并返回结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 两个表达式相除的结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果除数为零，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 获取除数并检查是否为零</span></span><br><span class="line">        <span class="keyword">const</span> divisor = <span class="variable language_">this</span>.<span class="property">expression2</span>.<span class="title function_">interpret</span>()</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Division by zero&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算并返回两个表达式相除的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression1</span>.<span class="title function_">interpret</span>() / divisor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">DivisionExpression</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultiplicationExpression 类继承自 CompoundExpression，</span></span><br><span class="line"><span class="comment"> * 用于表示乘法运算的表达式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompoundExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiplicationExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CompoundExpression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释执行乘法运算。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 返回两个表达式相乘的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 执行两个子表达式的解释操作，并返回其乘积</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression1</span>.<span class="title function_">interpret</span>() * <span class="variable language_">this</span>.<span class="property">expression2</span>.<span class="title function_">interpret</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MultiplicationExpression</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubtractionExpression 类继承自 CompoundExpression，</span></span><br><span class="line"><span class="comment"> * 用于实现减法运算的解释器模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompoundExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractionExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CompoundExpression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行减法运算并返回结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 返回两个表达式相减的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 调用两个子表达式的 interpret 方法并执行减法运算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression1</span>.<span class="title function_">interpret</span>() - <span class="variable language_">this</span>.<span class="property">expression2</span>.<span class="title function_">interpret</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">SubtractionExpression</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AdditionExpression 类继承自 CompoundExpression，</span></span><br><span class="line"><span class="comment"> * 用于实现解释器模式中的加法表达式解释功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompoundExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditionExpression</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CompoundExpression</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解释执行加法表达式。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; 表达式的解释结果，即两个表达式结果的和。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">interpret</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 对两个子表达式进行解释，并求和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">expression1</span>.<span class="title function_">interpret</span>() + <span class="variable language_">this</span>.<span class="property">expression2</span>.<span class="title function_">interpret</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AdditionExpression</span></span><br></pre></td></tr></table></figure>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入解释器模式中的加法、乘法函数及数字表达式类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, multiply, <span class="title class_">NumberExpression</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../InterpreterPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个表达式，该表达式表示 3 加上 5 乘以 2 的结果</span></span><br><span class="line"><span class="keyword">const</span> expression = <span class="title function_">add</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">3</span>),</span><br><span class="line">    <span class="title function_">multiply</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">5</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出表达式的解释结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(expression.<span class="title function_">interpret</span>()) <span class="comment">// 输出: 13</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>语言解释器</strong></p>
<p>该模式最典型的应用场景是在编程语言解释器中，例如解释器可以解析并执行自定义的脚本或领域特定语言（DSL）</p>
</li>
<li><p><strong>正则表达式解析器</strong></p>
<p>在处理文本搜索、替换或验证等场景中，解释器模式可以用于解析和执行正则表达式</p>
</li>
<li><p><strong>配置解析器</strong></p>
<p>当需要解析复杂的配置文件或数据格式时，可以使用解释器模式来实现解析器，例如解析 XML、JSON 等格式</p>
</li>
<li><p><strong>查询语言解释器</strong></p>
<p>在数据库查询、搜索引擎等领域，解释器模式可以用于解析用户输入的查询语言，并执行相应的查询操作</p>
</li>
<li><p><strong>数学表达式求值器</strong></p>
<p>如前面所示的示例，解释器模式可以用于实现数学表达式的解析和求值</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/InterpreterPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式汇总</title>
    <url>/posts/d342d2ec/</url>
    <content><![CDATA[<h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式是在软件工程中被反复使用的、经过验证的解决方案，用于解决特定问题或设计软件架构</p>
<p>它们提供了一种在设计和开发过程中重用的可靠方式，有助于解决常见的设计问题并促进代码的可维护性、可扩展性和可重用性</p>
<p><br/>设计模式并不是一种具体的编程语言特性或库，而是一种通用的解决方案</p>
<p>它们是从实际开发经验中总结出来的，并被广泛接受和使用</p>
<p>设计模式通常包括了面向对象设计的一些基本原则和惯例，通过它们可以更好地组织代码结构、降低耦合度、提高代码的灵活性和可维护性</p>
<p><br/>设计模式之所以出现，是因为在软件开发中经常会遇到一些常见的问题，比如对象创建、对象之间的关系、算法的选择等等</p>
<p>这些问题在不同的项目和场景中可能会多次出现，因此工程师们开始寻找并提炼出一些通用的解决方案，这就是设计模式产生的原因</p>
<p>设计模式有助于开发人员更快速地理解和解决问题，提高了开发效率</p>
<p>此外，它们还有助于提高代码的可读性和可维护性，因为它们是经过验证的、被广泛认可的解决方案，可以减少因为设计上的错误而造成的后续问题</p>
<p><br/></p>
<h2 id="设计模式遵循原则"><a href="#设计模式遵循原则" class="headerlink" title="设计模式遵循原则"></a>设计模式遵循原则</h2><p>设计模式的原则通常指的是一些基本的设计理念和规范，它们指导着设计模式的实现和应用。以下是一些常见的设计模式原则：</p>
<ol>
<li><p><strong>单一责任原则（Single Responsibility Principle, SRP）</strong>：</p>
<p>一个类应该只有一个引起变化的原因</p>
<p>换句话说，一个类应该只负责一项职责</p>
</li>
<li><p><strong>开放-封闭原则（Open-Closed Principle, OCP）</strong>：</p>
<p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭</p>
<p>即应该通过扩展现有代码来实现新功能，而不是直接修改已有代码</p>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong>：</p>
<p>所有能够使用父类对象的地方都应该能够使用子类对象</p>
<p>即子类应该能够替换父类并且不影响程序的正确性</p>
</li>
<li><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong>：</p>
<p>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</p>
<p>抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象</p>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong>：</p>
<p>客户端不应该被迫依赖于它们不使用的接口</p>
<p>即应该将大接口拆分成更小、更具体的接口，以便客户端只需要知道它们需要使用的接口</p>
</li>
<li><p><strong>合成/聚合复用原则（Composition/Aggregation Reuse Principle, CARP）</strong>：</p>
<p>优先使用对象组合/聚合，而不是继承来达到代码复用的目的</p>
<p>通过将对象组合到新的对象中，而不是通过继承来实现代码复用，可以更灵活地实现代码的复用</p>
</li>
</ol>
<p>这些原则是面向对象设计的基础，设计模式通常都遵循这些原则，以提高代码的可维护性、可扩展性和可重用性</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol>
<li><p>创建型</p>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/4fda2d18/">单例模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/14ddad5d/">原型模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/7e9872a1/">工厂模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/7aab53ba/">抽象工厂模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/7e3e0f32/">建造者模式</a></p>
            </div></li>
<li><p>结构型</p>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/edf2252f/">适配器模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/f51f74c/">装饰器模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/54233691/">代理模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/bd865a4b/">外观模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/2b8aa55b/">桥接模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/79a1bf69/">组合模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/469c39d8/">享元模式</a></p>
            </div></li>
<li><p>行为型</p>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/73dbb689/">观察者模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/b1de33a6/">迭代器模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/1445619f/">策略模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/8472c90e/">模板方法模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/ae2b73e3/">职责链模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/25e1ecde/">命令模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/e88d43d9/">备忘录模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/d207f3e/">状态模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/edaaf222/">访问者模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/957fddbf/">中介者模式</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/29dbf566/">解释器模式</a></p>
            </div>
</li>
</ol>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《访问者模式（行为型）》</title>
    <url>/posts/edaaf222/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不改变被访问对象的类的前提下定义对其进行操作的新操作</p>
<p><br/></p>
<p>访问者模式通常涉及两个核心角色：访问者（Visitor）和被访问元素（Element）</p>
<ul>
<li><p><strong>访问者（Visitor）</strong></p>
<p>定义了对每个被访问元素的操作方法</p>
<p>每个操作方法都对应着被访问元素的不同类型，可以通过访问者来实现对被访问元素的不同操作</p>
</li>
<li><p><strong>被访问元素（Element）</strong></p>
<p>定义了一个接受访问者对象的方法，并将自身作为参数传递给访问者对象</p>
<p>被访问元素可以是单个对象或者对象的集合</p>
</li>
</ul>
<p><br/></p>
<p>访问者模式的核心思想是将对对象的操作（算法）从对象本身中提取出来，并将其封装到不同的访问者对象中，从而实现对对象操作的解耦</p>
<p>这种模式的优点在于，可以在不修改被访问对象的类的情况下定义新的操作，同时也使得新增操作的扩展更加灵活和可控</p>
<p>访问者模式适用于以下情况：</p>
<ul>
<li>当需要对一个对象结构中的元素进行不同类型的操作，并且希望将操作与对象的数据结构解耦时，可以使用访问者模式</li>
<li>当希望在不修改对象类的情况下定义新的操作，并且希望新增操作的扩展更加灵活和可控时，访问者模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个文件系统中的不同类型的文件对象（如文本文件、图像文件、音频文件等）</p>
<p>访问者模式可以将对文件对象的操作（如打印文件内容、压缩文件、加密文件等）抽象成访问者对象，并在不修改文件对象类的情况下定义新的操作，从而实现对文件对象的不同操作的解耦</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一组不同类型的对象</strong></p>
<p>访问者模式适用于存在一组不同类型的对象，并且这些对象之间存在一定的复杂关系，例如对象之间存在继承关系或者对象之间存在组合关系等</p>
</li>
<li><p><strong>需要对对象进行不同的操作</strong></p>
<p>访问者模式适用于需要对一组不同类型的对象进行不同的操作，并且这些操作可能会随着对象的类型而变化的情况</p>
</li>
<li><p><strong>对象的结构相对稳定</strong></p>
<p>访问者模式适用于对象的结构相对稳定，并且不太容易发生变化的情况</p>
<p>因为访问者模式需要将不同类型的对象和操作进行解耦，如果对象的结构经常发生变化，可能会导致访问者对象的变化较大</p>
</li>
<li><p><strong>需要对对象进行多种操作</strong></p>
<p>访问者模式适用于需要对一组对象进行多种不同操作的情况，并且这些操作之间可能没有直接关联</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>增加新的操作很容易</strong></p>
<p>访问者模式使得增加新的操作很容易，只需要定义一个新的访问者对象即可，无需修改现有的对象结构</p>
</li>
<li><p><strong>符合开闭原则</strong></p>
<p>访问者模式通过将操作封装在访问者对象中，并将访问者对象与对象结构分离，使得可以在不修改现有对象结构的情况下增加新的操作，符合开闭原则</p>
</li>
<li><p><strong>解耦了对象结构和操作</strong></p>
<p>访问者模式将对象结构和操作进行了解耦，使得可以独立地改变对象结构或者操作，并且可以相互独立地进行扩展</p>
</li>
<li><p><strong>支持不同类型的访问者</strong></p>
<p>访问者模式支持定义不同类型的访问者对象，并且可以在不同的情况下选择合适的访问者对象进行操作，从而提高了系统的灵活性和可扩展性</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>增加新的元素类很困难</strong></p>
<p>访问者模式使得增加新的元素类变得很困难，因为需要在每个访问者对象中添加对应的操作，可能会导致访问者对象的数量和复杂度增加</p>
</li>
<li><p><strong>破坏封装性</strong></p>
<p>访问者模式将操作封装在访问者对象中，可能会破坏对象的封装性，因为访问者对象需要访问对象的内部状态和结构</p>
</li>
<li><p><strong>可能导致性能问题</strong></p>
<p>访问者模式需要在访问者对象和元素对象之间建立关联，可能会导致访问者对象过多或者访问者对象过于庞大，从而可能会导致性能问题</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>访问者基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个Visitor类，提供访问者模式的基本结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问给定的文件对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 文件对象，需要有getType方法用于获取文件类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">any</span>&#125; 返回调用的具体访问方法的结果。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果找不到对应的访问方法，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">visit</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>[file.<span class="title function_">getType</span>()] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[file.<span class="title function_">getType</span>()](file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Visitor does not support files of type: <span class="subst">$&#123;file.getType()&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>访问者子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PrintVisitor类继承自Visitor类，实现对不同文件类型的打印操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintVisitor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印文本文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 文本文件对象，需要包含name和content属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">text</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Printing text file <span class="subst">$&#123;file.name&#125;</span>:`</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(file.<span class="property">content</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印图像文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 图像文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的图像打印逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">image</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Printing image file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 实际的图像打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 音频文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的音频打印逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">audio</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Printing audio file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 实际的音频打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CompressVisitor类继承自Visitor类，实现对不同文件类型的压缩操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompressVisitor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩文本文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 文本文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">text</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Compressing text file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 文本文件压缩逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩图像文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 图像文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的图像压缩逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">image</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Compressing image file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 图像文件压缩逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 音频文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的音频压缩逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">audio</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Compressing audio file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 音频文件压缩逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EncryptVisitor类继承自Visitor类，实现对不同文件类型的加密操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncryptVisitor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Visitor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密文本文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 文本文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">text</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Encrypting text file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 文本文件加密逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密图像文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 图像文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的图像文件加密逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">image</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Encrypting image file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 图像文件加密逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密音频文件。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; file 音频文件对象，需要包含name属性。</span></span><br><span class="line"><span class="comment">     * 此方法为示例，实际的音频文件加密逻辑需要根据需求实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">audio</span>(<span class="params">file</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Encrypting audio file <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// 音频文件加密逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出定义的类</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">Visitor</span>,</span><br><span class="line">    <span class="title class_">PrintVisitor</span>,</span><br><span class="line">    <span class="title class_">CompressVisitor</span>,</span><br><span class="line">    <span class="title class_">EncryptVisitor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>文件基类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Visitor</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../VisitorPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FileSystem类表示文件系统的一个抽象基类。</span></span><br><span class="line"><span class="comment"> * 该类提供了基本的文件系统对象功能，包括接受访问者和获取文件类型的方法。</span></span><br><span class="line"><span class="comment"> * 该类不应该直接实例化，应由其子类实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化文件系统对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 文件系统的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">TypeError</span>&#125; 如果尝试直接构造FileSystem实例，则抛出TypeError。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">FileSystem</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot construct File instances directly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受一个访问者对象并对当前对象进行访问。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Visitor</span>&#125; visitor 访问者对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">TypeError</span>&#125; 如果传入的参数不是Visitor类型，则抛出TypeError。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">accept</span>(<span class="params">visitor</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(visitor <span class="keyword">instanceof</span> <span class="title class_">Visitor</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Visitor object expected&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件类型的抽象方法。</span></span><br><span class="line"><span class="comment">     * 该方法应由子类实现，以提供具体的文件类型信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 当调用该方法时，抛出一个错误，提示必须由子类实现该方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getType</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;getType method must be implemented by subclasses&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FileSystem</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>文件子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TextFile类继承自FileSystem类，用于处理文本文件的相关操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSystem</span> <span class="keyword">from</span> <span class="string">&#x27;./File&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个TextFile实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 文件名。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; content 文件内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextFile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystem</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, content</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name) <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = content <span class="comment">// 设置文件内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 返回文件类型，此处固定为&#x27;text&#x27;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getType</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;text&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TextFile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ImageFile类继承自FileSystem类，用于处理图像文件相关操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSystem</span> <span class="keyword">from</span> <span class="string">&#x27;./File&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个ImageFile实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; name 文件名。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Blob|Uint8Array</span>&#125; data 文件数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageFile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystem</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name) <span class="comment">// 调用父类构造函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = data <span class="comment">// 存储文件数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 返回文件类型，此处固定为&#x27;image&#x27;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getType</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;image&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ImageFile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入文件系统基础类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FileSystem</span> <span class="keyword">from</span> <span class="string">&#x27;./File&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AudioFile 类，继承自 FileSystem，用于表示音频文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioFile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystem</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，创建一个 AudioFile 实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">name</span> - 音频文件的名称。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string|Blob|MediaSource</span>&#125; <span class="variable">audio</span> - 音频数据，可以是文件路径、Blob对象或MediaSource对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, audio</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">audio</span> = audio</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件类型，此处固定返回 &#x27;audio&#x27;。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125; 返回字符串 &#x27;audio&#x27;，表示此类处理的是音频文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">getType</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;audio&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出 AudioFile 类作为默认导出，便于其他模块使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">AudioFile</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>使用方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导入各种文件类型的子类和访问者模式的相关类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TextFile</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/TextFile&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ImageFile</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/ImageFile&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AudioFile</span> <span class="keyword">from</span> <span class="string">&#x27;../SubClass/AudioFile&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CompressVisitor</span>, <span class="title class_">EncryptVisitor</span>, <span class="title class_">PrintVisitor</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../VisitorPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同类型的文件实例</span></span><br><span class="line"><span class="keyword">const</span> textFile = <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;document.txt&quot;</span>, <span class="string">&quot;This is the content of the text file.&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> imageFile = <span class="keyword">new</span> <span class="title class_">ImageFile</span>(<span class="string">&quot;photo.jpg&quot;</span>, <span class="string">&quot;Image data...&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> audioFile = <span class="keyword">new</span> <span class="title class_">AudioFile</span>(<span class="string">&quot;music.mp3&quot;</span>, <span class="string">&quot;Audio data...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同功能的访问者实例</span></span><br><span class="line"><span class="keyword">const</span> printVisitor = <span class="keyword">new</span> <span class="title class_">PrintVisitor</span>()</span><br><span class="line"><span class="keyword">const</span> compressVisitor = <span class="keyword">new</span> <span class="title class_">CompressVisitor</span>()</span><br><span class="line"><span class="keyword">const</span> encryptVisitor = <span class="keyword">new</span> <span class="title class_">EncryptVisitor</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有文件进行打印访问</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Printing text file document.txt:</span></span><br><span class="line"><span class="comment">// This is the content of the text file.</span></span><br><span class="line">textFile.<span class="title function_">accept</span>(printVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Printing image file photo.jpg</span></span><br><span class="line">imageFile.<span class="title function_">accept</span>(printVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Printing audio file music.mp3</span></span><br><span class="line">audioFile.<span class="title function_">accept</span>(printVisitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有文件进行压缩访问</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Compressing text file document.txt</span></span><br><span class="line">textFile.<span class="title function_">accept</span>(compressVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Compressing image file photo.jpg</span></span><br><span class="line">imageFile.<span class="title function_">accept</span>(compressVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Compressing audio file music.mp3</span></span><br><span class="line">audioFile.<span class="title function_">accept</span>(compressVisitor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对所有文件进行加密访问</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Encrypting text file document.txt</span></span><br><span class="line">textFile.<span class="title function_">accept</span>(encryptVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Encrypting image file photo.jpg</span></span><br><span class="line">imageFile.<span class="title function_">accept</span>(encryptVisitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Encrypting audio file music.mp3</span></span><br><span class="line">audioFile.<span class="title function_">accept</span>(encryptVisitor)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p><strong>编译器设计</strong></p>
<p>编译器可以使用访问者模式来遍历语法树并执行不同的操作，例如语法分析、类型检查、代码生成等</p>
</li>
<li><p><strong>文件处理</strong></p>
<p>像你之前提到的文件系统中的不同类型的文件对象，可以使用访问者模式来实现文件的不同操作，如打印、压缩、加密等</p>
</li>
<li><p><strong>UI 组件</strong></p>
<p>在图形界面开发中，如果有不同类型的 UI 组件（如按钮、文本框、下拉菜单等），可以使用访问者模式来执行不同的操作，如渲染、验证、序列化等</p>
</li>
<li><p><strong>数据结构操作</strong></p>
<p>当需要对数据结构执行多种操作时，例如遍历树、图等，可以使用访问者模式来实现这些操作，而不必修改数据结构本身</p>
</li>
<li><p><strong>游戏开发</strong></p>
<p>在游戏开发中，访问者模式可以用于实现不同类型的游戏对象的行为，如处理碰撞、更新状态等</p>
</li>
<li><p><strong>医疗信息系统</strong></p>
<p>在医疗信息系统中，可以使用访问者模式来执行不同的操作，如数据采集、统计分析、报表生成等</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/VisitorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《迭代器模式（行为型）》</title>
    <url>/posts/b1de33a6/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示</p>
<p><br/></p>
<p>迭代器模式通常涉及两个核心角色：迭代器（Iterator）和可迭代对象（Iterable）</p>
<ul>
<li><p><strong>迭代器（Iterator）</strong></p>
<p>负责定义访问和遍历聚合对象元素的接口</p>
<p>迭代器对象通常会追踪当前位置，并提供方法来获取下一个元素、检查是否还有下一个元素等</p>
</li>
<li><p><strong>可迭代对象（Iterable）</strong></p>
<p>表示包含一组元素的聚合对象，并提供一个方法来获取对应的迭代器</p>
<p>可迭代对象可以是集合类、数组、列表等</p>
</li>
</ul>
<p><br/></p>
<p>迭代器模式的核心思想是将遍历聚合对象的行为抽象出来，并将其封装到迭代器对象中，从而实现聚合对象与遍历算法的解耦</p>
<p>这种模式的优点在于，可以统一遍历接口，使得客户端代码与聚合对象的内部结构解耦，同时也提供了一种通用的遍历方法，适用于各种不同类型的聚合对象</p>
<p>迭代器模式适用于以下情况：</p>
<ul>
<li>当需要对聚合对象进行遍历，并且希望遍历算法与聚合对象的内部结构解耦时，可以使用迭代器模式</li>
<li>当希望提供一种统一的遍历接口，使得客户端代码可以统一处理不同类型的聚合对象时，迭代器模式也是一个很好的选择</li>
</ul>
<p><br/></p>
<p>举个简单的例子，考虑一个集合类（如列表、数组）中包含一组元素</p>
<p>而迭代器模式可以将遍历集合元素的算法抽象成一个迭代器对象，从而使得客户端代码可以通过迭代器对象来访问和遍历集合元素，而不需要了解集合对象的内部结构</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ol>
<li><p><strong>存在一个聚合对象</strong></p>
<p>迭代器模式适用于需要遍历一组元素的情况，因此需要存在一个聚合对象来存储这组元素</p>
</li>
<li><p><strong>需要对元素进行遍历操作</strong></p>
<p>迭代器模式适用于需要对聚合对象中的元素进行遍历操作的情况</p>
</li>
<li><p><strong>需要对遍历方式进行抽象</strong></p>
<p>迭代器模式将遍历方式抽象成迭代器对象，并提供一组统一的接口来对元素进行遍历，从而使得客户端可以统一地处理不同类型的聚合对象</p>
</li>
<li><p><strong>需要支持多种遍历方式</strong></p>
<p>迭代器模式允许定义多种不同的迭代器对象，从而支持多种不同的遍历方式，例如正向遍历、逆向遍历、按照某种顺序遍历等</p>
</li>
</ol>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p><strong>简化聚合对象的接口</strong></p>
<p>迭代器模式将遍历操作封装在迭代器对象中，使得客户端可以统一地对聚合对象进行遍历操作，简化了聚合对象的接口</p>
</li>
<li><p><strong>解耦迭代算法和聚合对象</strong></p>
<p>迭代器模式将遍历算法与聚合对象进行了解耦，使得聚合对象的内部结构可以独立于其遍历算法的变化</p>
</li>
<li><p><strong>支持多种遍历方式</strong></p>
<p>迭代器模式允许定义多种不同的迭代器对象，从而支持多种不同的遍历方式，例如正向遍历、逆向遍历、按照某种顺序遍历等</p>
</li>
<li><p><strong>增加代码复用性</strong></p>
<p>迭代器模式将遍历操作封装在迭代器对象中，可以在不同的聚合对象之间重复使用相同的迭代器对象，从而提高了代码的复用性</p>
</li>
<li><p><strong>简化客户端代码</strong></p>
<p>迭代器模式使得客户端可以统一地对聚合对象进行遍历操作，不需要关心聚合对象的内部结构和遍历方式，从而简化了客户端的代码</p>
</li>
</ol>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p><strong>增加对象数量</strong></p>
<p>迭代器模式需要定义迭代器对象和聚合对象之间的关系，可能会增加对象数量，从而增加了系统的复杂度</p>
</li>
<li><p><strong>可能降低性能</strong></p>
<p>迭代器模式需要在迭代器对象中保存迭代状态，并且可能需要频繁地进行状态转换，可能会降低系统的性能</p>
</li>
<li><p><strong>可能增加代码复杂度</strong></p>
<p>迭代器模式需要定义迭代器对象和聚合对象之间的关系，并且可能需要在迭代器对象中保存迭代状态，可能会增加代码的复杂度</p>
</li>
</ol>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListCollection类定义了一个列表集合，支持添加元素、删除元素、迭代遍历以及对函数执行或其它类型数据打印的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListCollection</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数初始化集合元素数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">elements</span> = [] <span class="comment">// 初始化集合元素数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向集合中添加元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; element 要添加到集合中的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">element</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">elements</span>.<span class="title function_">push</span>(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从集合中删除指定索引的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index 要删除元素的索引。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> &#123;<span class="type">Error</span>&#125; 如果索引超出范围，则抛出错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">elements</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">elements</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Index out of bounds&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现迭代器协议，允许集合被遍历。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@yields</span> &#123;<span class="type">any</span>&#125; 遍历集合中的每个元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历集合，如果元素是函数则执行，否则打印元素。</span></span><br><span class="line"><span class="comment">     * 该方法为内部方法，不直接暴露给外部使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">forEachExecuteOrLog</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="title function_">item</span>() <span class="comment">// 执行函数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// 输出其他类型数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">ListCollection</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ListCollection</span> <span class="keyword">from</span> <span class="string">&#x27;../IteratorPattern&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向列表中添加各种类型的元素。</span></span><br><span class="line"><span class="comment"> * 包括数字、函数、对象和字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">ListCollection</span>.<span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title class_">ListCollection</span>.<span class="title function_">add</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Function executed!&#x27;</span>) &#125;)</span><br><span class="line"><span class="title class_">ListCollection</span>.<span class="title function_">add</span>(&#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line"><span class="title class_">ListCollection</span>.<span class="title function_">add</span>(<span class="string">&#x27;Text&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历列表中的每个元素，并尝试执行它们。</span></span><br><span class="line"><span class="comment"> * 如果元素是函数，则执行该函数；</span></span><br><span class="line"><span class="comment"> * 如果元素是字符串或其他类型，则仅在控制台打印。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">ListCollection</span>.<span class="title function_">forEachExecuteOrLog</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li><p>数组的迭代方法</p>
<p>JavaScript 的原生数组方法，如 forEach, map, filter, reduce 等，都是迭代器模式的体现</p>
<p>这些方法让你能够遍历数组并对每个元素执行操作，而无需直接操作数组的索引</p>
</li>
<li><p>DOM 遍历</p>
<p>在处理DOM元素时，经常需要遍历节点树</p>
<p>虽然DOM API本身不是严格意义上的迭代器模式实现，但你可以使用类似迭代器的思维模式，比如使用 NodeList.prototype.forEach 或者创建自己的迭代器来遍历DOM子节点</p>
</li>
<li><p>React中的Keys</p>
<p>在React中，当渲染列表时，为列表项分配唯一key是一个最佳实践</p>
<p>虽然这不是直接的迭代器模式，但它体现了对集合元素进行迭代和管理的思想，确保高效更新虚拟DOM</p>
</li>
<li><p>Redux Saga / RxJS</p>
<p>在状态管理库Redux中，Redux Saga使用迭代器函数来处理异步操作流，这是一种高级的迭代器模式应用</p>
<p>同样，RxJS（Reactive Extensions for JavaScript）利用Observables来处理异步数据流，其背后的概念与迭代器模式紧密相关，提供了强大的数据处理能力</p>
</li>
<li><p><strong>Iterable Protocols</strong></p>
<p>ECMAScript中的可迭代协议（例如使用 [Symbol.iterator] 方法）允许对象定义自身的迭代行为</p>
<p>这使得任何实现了这个协议的对象都可以被 for…of 循环遍历，这是迭代器模式的直接应用</p>
</li>
<li><p><strong>Immutable.js</strong></p>
<p>这是一个流行的JavaScript库，用于不可变数据结构的处理</p>
<p>它内部广泛使用迭代器模式来遍历Map、List等数据结构，同时保持数据不变性</p>
</li>
<li><p><strong>Lodash/Underscore</strong></p>
<p>这些实用库提供了丰富的集合操作方法，如 <em>.each, </em>.map, _.filter 等，它们背后都运用了迭代器模式的理念，简化了对集合数据的操作</p>
</li>
<li><p><strong>Vue.js的v-for指令</strong></p>
<p>Vue框架中的v-for指令用来遍历数组或对象属性，并渲染每个项目到DOM</p>
<p>虽然这是模板语法的一部分，但它基于迭代器模式思想，让用户能以声明式的方式遍历数据</p>
</li>
</ol>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/BehaviorType/IteratorPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ThreeJS-《Camera（官网案例）》</title>
    <url>/posts/9462a334/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript设计模式 - 《适配器模式（结构型）》</title>
    <url>/posts/edf2252f/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户端所期望的另一个接口</p>
<p>适配器模式通过引入一个适配器对象来实现这一点</p>
<p><br/></p>
<p>在适配器模式中，通常存在三个核心角色：目标接口（Target）、适配器（Adapter）和被适配者（Adaptee）</p>
<p>目标接口定义了客户端所期望的接口，适配器类实现了目标接口，并在内部持有一个被适配者对象，通过调用被适配者对象的方法来实现目标接口的方法</p>
<p><br/></p>
<p>适配器模式的核心思想是将一个类的接口转换成另一个接口，使得原本由于接口不兼容而无法一起工作的类可以协同工作</p>
<p>这种模式的优点在于，可以使得原本不兼容的类能够协同工作，同时也可以使得客户端代码与具体实现类解耦，提高系统的灵活性和可维护性</p>
<p><br/></p>
<p>适配器模式适用于以下情况：</p>
<ol>
<li>需要将一个类的接口转换成另一个客户端所期望的接口</li>
<li>需要复用一些现有的类，但是其接口与系统要求的不兼容</li>
</ol>
<p><br/></p>
<p>举个简单的例子，考虑一个英文翻译系统</p>
<p>系统中有一个英文翻译器类，但是客户端需要使用一个中文翻译器</p>
<p>这时可以引入一个适配器类，将中文翻译器的接口适配成英文翻译器的接口，使得客户端能够通过适配器类来调用中文翻译器的方法，从而实现了英文翻译系统和中文翻译器的协同工作</p>
<p><br/></p>
<h2 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h2><ul>
<li><p><strong>存在至少两个不兼容的接口</strong></p>
<p>一个是客户端期望的接口，另一个是已经存在的接口</p>
</li>
<li><p><strong>不想或不能修改现有的代码</strong></p>
<p>可能是因为你不拥有那部分代码的源代码，或者任何修改都会涉及大量的依赖和复杂性</p>
</li>
</ul>
<p><br/></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p><strong>接口兼容性</strong></p>
<p>使原本由于接口不兼容而不能一起工作的类可以一起工作</p>
</li>
<li><p><strong>代码解耦</strong></p>
<p>可以将程序的业务逻辑和具体实现解耦，提高代码的可用性</p>
</li>
<li><p><strong>灵活性和扩展性</strong></p>
<p>适配器模式提高了现有代码的灵活性和扩展性，特别是在开发过程中需要引入新的类或组件时</p>
</li>
</ul>
<p><br/></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li><p><strong>代码复杂性</strong></p>
<p>在某些情况下，引入适配器会使系统的代码更加复杂</p>
</li>
<li><p><strong>过多使用</strong></p>
<p>过多地使用适配器可能会让系统变得零碎和难以理解</p>
</li>
</ul>
<p><br/></p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>已存在的旧接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧的数据库接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OldDatabase</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">operate</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 旧的数据库操作</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Operation on old database&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增加的接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新的数据库接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewDatabase</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">request</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 新的数据库操作</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Operation on new database&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本的适配器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseAdapter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">newDatabase</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">database</span> = newDatabase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">operate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">database</span>.<span class="title function_">request</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用旧的数据库接口</span></span><br><span class="line"><span class="keyword">const</span> oldDB = <span class="keyword">new</span> <span class="title class_">OldDatabase</span>();</span><br><span class="line">oldDB.<span class="title function_">operate</span>(); <span class="comment">// 输出: Operation on old database</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器与新的数据库接口</span></span><br><span class="line"><span class="keyword">const</span> newDB = <span class="keyword">new</span> <span class="title class_">NewDatabase</span>();</span><br><span class="line"><span class="keyword">const</span> adaptedDB = <span class="keyword">new</span> <span class="title class_">DatabaseAdapter</span>(newDB);</span><br><span class="line">adaptedDB.<span class="title function_">operate</span>(); <span class="comment">// 输出: Operation on new database</span></span><br></pre></td></tr></table></figure>
<p><code>DatabaseAdapter</code> 类充当适配器</p>
<p>将 <code>NewDatabase</code> 类的 <code>request</code> 方法适配为 <code>OldDatabase</code> 类的 <code>operate</code> 方法</p>
<p>这样，即使客户端代码期望使用 <code>operate</code> 方法，也可以无缝地切换到使用新的数据库接口</p>
<p><br/></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul>
<li><p><strong>数据库适配器</strong></p>
<p>许多数据库库（如 Sequelize 或 TypeORM）提供了统一的接口来连接不同的数据库系统</p>
</li>
<li><p><strong>服务器端适配器</strong></p>
<p>Express 或 Koa 中间件经常用于将不同的服务或框架接口适配为统一的中间件接口</p>
</li>
<li><p><strong>前端框架与第三方库</strong></p>
<p>Vue.js、React 或 Angular等前端框架经常使用适配器模式来整合第三方库（如路由、状态管理库等）</p>
</li>
<li><p><strong>API适配器</strong></p>
<p>当你的应用程序需要与第三方服务通信时，你可能会写一个适配器来适配第三方API的接口</p>
</li>
</ul>
<p><br/></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/DesignPattern/tree/main/StructuralType/AdapterPattern"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=DesignPattern&show_owner=true"/></a>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy代理对象</title>
    <url>/posts/e9e23f4f/</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>在开发过程中遇到的一个具有挑战性的需求，涉及到一个独特且复杂的数据结构，这直接关系到如何有效地更新建筑信息</p>
<p>这个项目需求源自于对建筑数据精确管理的必要性，其中建筑数据按照其属性被划分为三种主要类型：多栋建筑、独栋建筑以及局部建筑</p>
<p><strong>多栋建筑</strong>是指那些包含若干子建筑单元的复合体，它们共享一套总体的数据——大约10余条重要的信息，并且拥有一个庞大的数组，这个数组详细记录了其中每一个子建筑或局部建筑的详细信息，每个子单元的数据大约包含40至50条具体信息</p>
<p><strong>独栋建筑</strong>在数据结构上与多栋建筑中的单个建筑单元类似，同样维护着大约40至50条的详细信息，但它独立存在，不属于任何多栋建筑的一部分</p>
<p><strong>局部建筑</strong>则相对较小，包含的数据项约30条，关注点更集中在具体的、局部的部分上</p>
<p><br/></p>
<p>鉴于建筑数据的复杂性和数量众多，我们设计了专门的数据接口来处理查询和更新操作</p>
<p>局部建筑由单一的接口管理，而栋建筑的数据则通过四个不同的接口进行操作，多栋建筑最为复杂，需要六个接口来维护其数据的准确性和时效性</p>
<p>面对这种需求，关键在于如何在用户对某个建筑的数据进行编辑或修改时，能够准确地捕捉到这些变动，并通过正确的接口将更新推送至服务器</p>
<p>为了实现这一目标，我借鉴了Vue3的核心设计理念，采用了Proxy技术</p>
<p>这使得我们能够以一种智能且效率高的方式监听数据的变化，一旦侦测到用户对数据的编辑或更新，就能迅速准确地分析出需要调用的接口类型，进而完成数据的同步更新</p>
<p><br /></p>
<h2 id="为什么选Proxy"><a href="#为什么选Proxy" class="headerlink" title="为什么选Proxy"></a>为什么选Proxy</h2><p>在项目开发过程中，我们深入讨论并评估了几种不同的数据更新策略，目的是为了找到最适合我们复杂应用需求的方法</p>
<p>以下是我们考虑的三个方案：</p>
<ol>
<li><strong>方案一：事件监听</strong><br><strong>描述</strong>：通过在模板中对相关节点设置<code>@change</code>事件监听来处理数据更新<br><strong>评估</strong>：此方法虽然直接且易于实现，但当面对复杂交互时，显著增加了HTML编码的工作量及重复性的函数定义，导致代码维护成本上升</li>
<li><strong>方案二：Proxy</strong><br><strong>描述</strong>：利用JavaScript的Proxy特性来拦截对象的操作，从而实现数据的响应式更新<br><strong>评估</strong>：Proxy能够提供一套强大的数据监听与拦截机制，但由于其在Vue3项目中的应用相对较新，对于部分开发者而言，学习与应用的门槛相对较高</li>
<li><strong>方案三：全量更新</strong><br><strong>描述</strong>：每当数据发生变化时，请求服务器并全面更新页面数据<br><strong>评估</strong>：尽管这种方法实现起来较为简单，但它对服务器资源的消耗过大，在面向大规模用户（如一个省份级别的用户群体）的项目中，这种做法显然是不经济、不实际的</li>
</ol>
<details class="folding-tag" purple><summary> proxy </summary>
              <div class='content'>
              <p><code>Proxy</code> 是 ES6 引入的一种机制，它允许我们创建一个对象，该对象可以拦截并自定义基本操作（例如属性查找、赋值、枚举、函数调用等）</p><ol><li><p><strong><code>Proxy</code> 对象的基本概念</strong></p><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）</p><p><code>Proxy</code> 由两个部分组成：</p><ul><li><strong>目标对象</strong>：代理将虚拟化该对象的某些操作</li><li><strong>处理器（handler）</strong>：一个对象，其属性是当执行一个操作时定义代理行为的函数</li></ul></li><li><p><strong>使用场景</strong></p><ul><li><strong>数据验证</strong>：可以在对象属性赋值时进行验证</li><li><strong>属性代理</strong>：可以代理对象的属性访问和修改</li><li><strong>函数代理</strong>：可以代理函数的调用</li><li><strong>观察者模式</strong>：可以用来实现观察者模式，监听对象的变化</li></ul></li><li><p><strong>注意事项</strong></p><ul><li><strong>性能开销</strong>：过度使用 <code>Proxy</code> 可能会带来性能开销</li><li><strong>兼容性</strong>：<code>Proxy</code> 在某些旧版本的浏览器中可能不受支持，尤其是 IE 浏览器。因此，在使用 <code>Proxy</code> 时，确保你的代码运行环境支持它</li><li><strong>不可代理的对象</strong>：某些内置对象和函数不允许被代理，例如 <code>Function.prototype</code></li><li><strong>陷阱限制</strong>：某些陷阱有具体的行为限制。例如，<code>get</code> 陷阱不能返回未定义的属性，而 <code>set</code> 陷阱必须返回 <code>true</code> 或 <code>false</code></li></ul></li><li><p><strong>代理的局限性</strong></p><p>虽然 <code>Proxy</code> 非常强大，但它也有一些局限性：</p><ul><li><strong>不可代理的内置对象</strong>：某些 JavaScript 内置对象无法被代理，如 <code>ArrayBuffer</code></li><li><strong>性能问题</strong>：代理每次操作都会触发陷阱，这可能会导致性能问题，特别是在需要高性能的场景中</li><li><strong>调试困难</strong>：由于代理的动态特性，调试代理对象可能会更加复杂</li><li><strong>递归代理</strong>：如果需要深度代理对象（例如嵌套对象），需要递归地创建代理，这可能会增加代码复杂性</li></ul></li><li><p><strong>代理的实际用例</strong></p><ul><li><strong>数据绑定</strong>：在前端框架中，<code>Proxy</code> 常用于实现数据绑定。例如 Vue 3 中的响应式系统就是基于 <code>Proxy</code> 实现的</li><li><strong>访问控制</strong>：可以用 <code>Proxy</code> 来控制对对象属性的访问。例如，可以限制某些属性的可读性或可写性</li><li><strong>日志记录</strong>：可以用 <code>Proxy</code> 来记录对对象的所有操作，便于调试和监控</li></ul></li></ol>
              </div>
            </details>
<p><br /></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="定义Proxy的类"><a href="#定义Proxy的类" class="headerlink" title="定义Proxy的类"></a>定义<code>Proxy</code>的类</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line"> * @<span class="title class_">Description</span>: <span class="title class_">Proxy</span>代理对象</span><br><span class="line"> * @<span class="title class_">Author</span>: 5t5</span><br><span class="line"> * @<span class="title class_">Time</span>: <span class="number">2023</span>/<span class="number">1</span>/<span class="number">13</span> <span class="number">23</span>:<span class="number">18</span></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ProxyDeep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化对象或数组的深度代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object|Array</span>&#125; <span class="variable">obj</span> - 需要代理的目标对象或数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">handle</span> - 代理处理器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Proxy|null</span>&#125; - 返回代理对象或null（如果目标非法）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">initProxy</span>(<span class="params">obj, handle</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查传入的目标是否为对象或数组</span></span><br><span class="line">        <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Illegal agent target: Target must be an object or array.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查代理处理器是否为对象</span></span><br><span class="line">        <span class="keyword">if</span> (!handle || <span class="keyword">typeof</span> handle !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Illegal handler: Handler must be an object.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助函数，用于检查值是否为对象（包括数组）</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">val</span>) =&gt; val !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 递归遍历目标对象或数组，将其所有嵌套对象和数组都代理化</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">Object|Array</span>&#125; <span class="variable">target</span> - 当前处理的对象或数组</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@returns</span> &#123;<span class="type">Object|Array|null</span>&#125; - 处理后的对象或数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">traverse</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标是数组</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">                <span class="comment">// 遍历数组的每一项</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; target.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前项是对象或数组，则递归调用traverse进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isObject</span>(target[i])) &#123;</span><br><span class="line">                        target[i] = <span class="title function_">traverse</span>(target[i])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果目标是对象</span></span><br><span class="line">                <span class="comment">// 遍历对象的每一个属性</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">                    <span class="comment">// 确保只处理对象自身的属性</span></span><br><span class="line">                    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; <span class="title function_">isObject</span>(target[key])) &#123;</span><br><span class="line">                        target[key] = <span class="title function_">traverse</span>(target[key])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回处理后的目标</span></span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对传入的对象或数组进行遍历处理，并返回代理后的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title function_">traverse</span>(obj), handle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释解释</strong></p>
<ol>
<li><strong>类及构造函数</strong>：<ul>
<li><code>ProxyDeep</code> 类的构造函数目前没有任何初始化操作，留空即可</li>
</ul>
</li>
<li><strong><code>initProxy</code> 方法</strong>：<ul>
<li>参数<ul>
<li><code>obj</code>：需要代理的目标对象或数组</li>
<li><code>handle</code>：代理处理器对象，定义了代理的行为</li>
</ul>
</li>
<li>返回值<ul>
<li>如果目标非法（<code>null</code> 或者非对象类型），返回 <code>null</code></li>
<li>否则，返回代理后的对象或数组</li>
</ul>
</li>
<li>逻辑<ul>
<li>首先检查目标是否为对象或数组，如果不是则打印错误信息并返回 <code>null</code></li>
<li>定义辅助函数 <code>isObject</code> 用于检查值是否为对象（包括数组）</li>
<li>定义递归函数 <code>traverse</code>，用于遍历目标对象或数组的所有嵌套对象和数组，并将其代理化</li>
<li>最后，调用 <code>traverse</code> 函数处理传入的对象或数组，并返回代理后的结果</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>traverse</code> 函数</strong>：<ul>
<li>参数<ul>
<li><code>target</code>：当前处理的对象或数组</li>
</ul>
</li>
<li>返回值<ul>
<li>处理后的对象或数组</li>
</ul>
</li>
<li>逻辑<ul>
<li>如果目标是数组，遍历数组的每一项，如果当前项是对象或数组，则递归调用 <code>traverse</code> 进行处理</li>
<li>如果目标是对象，遍历对象的每一个属性，如果当前属性值是对象或数组，则递归调用 <code>traverse</code> 进行处理</li>
<li>返回处理后的目标</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br /></p>
<h4 id="定义handle处理对象"><a href="#定义handle处理对象" class="headerlink" title="定义handle处理对象"></a>定义<code>handle</code>处理对象</h4><p>此为示例，具体实现可以根据项目需求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    <span class="comment">// 拦截属性访问</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27;`</span>)</span><br><span class="line">        <span class="comment">// 该函数在获取代理对象对应的值的时候会触发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截属性设置</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; to &#x27;<span class="subst">$&#123;value&#125;</span>&#x27;`</span>)</span><br><span class="line">        <span class="comment">// 该函数在设置代理对象对应的值的时候会触发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> handle </summary>
              <div class='content'>
              <p>关于 <code>Proxy</code> 的 <code>handler</code> 对象是 <code>Proxy</code> 的核心部分之一</p><p>它定义了拦截操作的行为</p><p>通过在 <code>handler</code> 对象中定义特定的陷阱（trap），你可以拦截和自定义对象的各种操作行为</p><ol><li><p><strong>基本结构</strong></p><p>一个 <code>handler</code> 对象是一个包含多个陷阱方法的普通 JavaScript 对象</p><p>每个陷阱方法对应一个对象操作，例如属性访问、属性设置、函数调用等</p></li><li><p><strong>常见陷阱方法</strong></p><p>示例对象使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例对象</span></span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, handle);</span><br></pre></td></tr></table></figure><p>以下方法都是基于这个例子</p><ul><li><p><strong>get(target, property, receiver)</strong></p><p>拦截属性访问操作，例如 <code>proxy.property</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：被访问的属性名</li><li><code>receiver</code>：代理对象或继承代理对象的对象</li></ul></li><li><strong>作用</strong>：拦截属性访问操作</li><li><strong>返回值</strong>：返回属性的值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">a</span>); <span class="comment">// Getting property a</span></span><br></pre></td></tr></table></figure></li><li><p><strong>set(target, property, value, receiver)</strong></p><p>拦截属性设置操作，例如 <code>proxy.property = value</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：被设置的属性名</li><li><code>value</code>：要设置的属性值</li><li><code>receiver</code>：代理对象或继承代理对象的对象</li></ul></li><li><strong>作用</strong>：拦截属性设置操作</li><li><strong>返回值</strong>：必须返回一个布尔值，表示是否成功设置属性</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property <span class="subst">$&#123;property&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, property, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line">proxy.<span class="property">b</span> = <span class="number">10</span>; <span class="comment">// Setting property b to 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>has(target, property)</strong></p><p>拦截 <code>in</code> 操作符，例如 <code>property in proxy</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：要检查的属性名</li></ul></li><li><strong>作用</strong>：拦截 <code>in</code> 操作符</li><li><strong>返回值</strong>：返回一个布尔值，表示属性是否存在</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Checking if property <span class="subst">$&#123;property&#125;</span> exists`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, property);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> proxy); <span class="comment">// Checking if property b exists</span></span><br></pre></td></tr></table></figure></li><li><p><strong>deleteProperty(target, property)</strong></p><p>拦截 <code>delete</code> 操作符，例如 <code>delete proxy.property</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：要删除的属性名</li></ul></li><li><strong>作用</strong>：拦截 <code>delete</code> 操作符</li><li><strong>返回值</strong>：返回一个布尔值，表示属性是否成功删除</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Deleting property <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, property);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">c</span>; <span class="comment">// Deleting property c</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ownKeys(target)</strong></p><p>拦截对象自身属性的枚举操作，例如 <code>Object.keys(proxy)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li></ul></li><li><strong>作用</strong>：拦截对象自身属性的枚举操作，例如 <code>Object.keys(proxy)</code> 和 <code>for...in</code> 循环</li><li><strong>返回值</strong>：返回一个包含目标对象自身属性的数组</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting own keys of the target`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)); <span class="comment">// Getting own keys of the target</span></span><br></pre></td></tr></table></figure></li><li><p><strong>getOwnPropertyDescriptor(target, property)</strong></p><p>拦截 <code>Object.getOwnPropertyDescriptor(proxy, property)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：要获取描述符的属性名</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.getOwnPropertyDescriptor(proxy, property)</code></li><li><strong>返回值</strong>：返回属性描述符对象或 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting descriptor for property <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, property);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;a&#x27;</span>)); <span class="comment">// Getting descriptor for property a</span></span><br></pre></td></tr></table></figure></li><li><p><strong>defineProperty(target, property, descriptor)</strong></p><p>拦截 <code>Object.defineProperty(proxy, property, descriptor)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：要定义或修改的属性名</li><li><code>descriptor</code>：属性描述符对象</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.defineProperty(proxy, property, descriptor)</code></li><li><strong>返回值</strong>：返回一个布尔值，表示属性是否成功定义或修改</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Defining property <span class="subst">$&#123;property&#125;</span> with descriptor`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&#x27;d&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">4</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;); <span class="comment">// Defining property d with descriptor</span></span><br></pre></td></tr></table></figure></li><li><p><strong>preventExtensions(target)</strong></p><p>拦截 <code>Object.preventExtensions(proxy)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.preventExtensions(proxy)</code></li><li><strong>返回值</strong>：返回一个布尔值，表示对象是否成功被标记为不可扩展</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Preventing extensions on the target`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy); <span class="comment">// Preventing extensions on the target</span></span><br></pre></td></tr></table></figure></li><li><p><strong>isExtensible(target)</strong></p><p>拦截 <code>Object.isExtensible(proxy)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.isExtensible(proxy)</code></li><li><strong>返回值</strong>：返回一个布尔值，表示对象是否是可扩展的</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Checking if the target is extensible`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy)); <span class="comment">// Checking if the target is extensible</span></span><br></pre></td></tr></table></figure></li><li><p><strong>getPrototypeOf(target)</strong></p><p>拦截 <code>Object.getPrototypeOf(proxy)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.getPrototypeOf(proxy)</code></li><li><strong>返回值</strong>：返回目标对象的原型对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting prototype of the target`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy)); <span class="comment">// Getting prototype of the target</span></span><br></pre></td></tr></table></figure></li><li><p><strong>setPrototypeOf(target, prototype)</strong></p><p>拦截 <code>Object.setPrototypeOf(proxy, prototype)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标对象</li><li><code>prototype</code>：新的原型对象</li></ul></li><li><strong>作用</strong>：拦截 <code>Object.setPrototypeOf(proxy, prototype)</code></li><li><strong>返回值</strong>：返回一个布尔值，表示原型是否成功设置</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting prototype of the target`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(target, prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象的操作示例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, <span class="literal">null</span>); <span class="comment">// Setting prototype of the target</span></span><br></pre></td></tr></table></figure></li><li><p><strong>apply(target, thisArg, argumentsList)</strong></p><p>拦截函数调用，例如 <code>proxy(...args)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标函数</li><li><code>thisArg</code>：调用函数时的 <code>this</code> 值</li><li><code>argumentsList</code>：调用函数时的参数列表</li></ul></li><li><strong>作用</strong>：拦截函数调用操作，例如 <code>proxy(...args)</code></li><li><strong>返回值</strong>：返回函数调用的结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Applying function with arguments <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(target, thisArg, argumentsList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数代理示例</span></span><br><span class="line"><span class="keyword">const</span> targetFunction = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyFunction = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetFunction, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxyFunction</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// Applying function with arguments 1,2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>construct(target, argumentsList, newTarget)</strong></p><p>拦截构造函数调用，例如 <code>new proxy(...args)</code></p><ul><li>参数<ul><li><code>target</code>：被代理的目标构造函数</li><li><code>argumentsList</code>：调用构造函数时的参数列表</li><li><code>newTarget</code>：创建实例时的构造函数</li></ul></li><li><strong>作用</strong>：拦截构造函数调用操作，例如 <code>new proxy(...args)</code></li><li><strong>返回值</strong>：返回一个新的对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Constructing new instance with arguments <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(target, argumentsList, newTarget);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数代理示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyClass = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">TargetClass</span>, handler);</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">proxyClass</span>(<span class="string">&#x27;Proxy&#x27;</span>); <span class="comment">// Constructing new instance with arguments Proxy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> Reflect </summary>
              <div class='content'>
              <p><code>Reflect</code> 对象是ES6（ECMAScript 2015）引入的一个内置对象，它提供了一些方法用于操作对象的属性和原型</p><p><code>Reflect</code> 对象的设计目的是为了与 <code>Proxy</code> 对象一起使用，提供更一致和可预测的行为</p><p><code>Reflect</code> 对象的方法与 <code>Object</code> 对象的方法类似，但有一些关键的区别</p><ol><li><p><strong>与 Proxy 的关系</strong></p><p><code>Reflect</code> 对象的设计初衷是为了与 <code>Proxy</code> 对象配合使用</p><p><code>Proxy</code> 对象可以拦截并自定义基本操作（例如属性查找、赋值、枚举、函数调用等），而 <code>Reflect</code> 提供了默认的行为实现</p><p>这样，使用 <code>Reflect</code> 可以更容易地在 <code>Proxy</code> 中调用默认行为</p></li><li><p><strong>一致性和简洁性</strong></p><p><code>Reflect</code> 方法的命名和参数顺序与 <code>Proxy</code> 的捕获器（trap）方法保持一致</p><p>这种一致性使得代码更易读，也更容易理解和维护</p></li><li><p><strong>返回值</strong></p><p><code>Reflect</code> 方法通常返回布尔值来指示操作是否成功，而不是像某些 <code>Object</code> 方法那样抛出异常</p><p>例如，<code>Reflect.defineProperty</code> 在属性定义失败时返回 <code>false</code>，而不是抛出异常</p></li><li><p><strong>避免重复代码</strong></p><p>在编写 <code>Proxy</code> 处理器时，使用 <code>Reflect</code> 可以避免重复代码</p><p>例如，在 <code>set</code> 捕获器中，可以使用 <code>Reflect.set</code> 来执行默认的属性赋值操作</p></li></ol><p><strong>方法详解</strong></p><ol><li><p><code>Reflect.apply(target, thisArgument, argumentsList)</code></p><ul><li><p><strong>描述</strong>: 调用一个目标函数，并传入指定的 <code>this</code> 值和参数</p></li><li><p>参数</p><ul><li><code>target</code>: 目标函数</li><li><code>thisArgument</code>: 函数调用时的 <code>this</code> 值</li><li><code>argumentsList</code>: 一个数组或类数组对象，包含要传递给函数的参数</li></ul></li><li><p><strong>返回值</strong>: 函数调用的结果</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(sum, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.construct(target, argumentsList[, newTarget])</code></p><ul><li><p><strong>描述</strong>: 等同于使用 <code>new</code> 操作符调用一个构造函数</p></li><li><p>参数</p><ul><li><code>target</code>: 目标构造函数</li><li><code>argumentsList</code>: 一个数组或类数组对象，包含要传递给构造函数的参数</li><li><code>newTarget</code> (可选): 新创建对象的原型。如果未提供，则默认为 <code>target</code></li></ul></li><li><p><strong>返回值</strong>: 新创建的对象</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Person</span>, [<span class="string">&#x27;Alice&#x27;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.defineProperty(target, propertyKey, attributes)</code></p><ul><li><p><strong>描述</strong>: 类似于 <code>Object.defineProperty</code>，定义对象的属性</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li><li><code>attributes</code>: 属性描述符</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示属性是否成功定义</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.deleteProperty(target, propertyKey)</code></p><ul><li><p><strong>描述</strong>: 删除对象的属性</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示属性是否成功删除</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.get(target, propertyKey[, receiver])</code></p><ul><li><p><strong>描述</strong>: 获取对象的属性值</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li><li><code>receiver</code> (可选): 如果是一个代理对象，则作为 <code>this</code> 值传递给 <code>getter</code> 函数</li></ul></li><li><p><strong>返回值</strong>: 属性值</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code></p><ul><li><p><strong>描述</strong>: 获取对象自身属性的属性描述符。</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li></ul></li><li><p><strong>返回值</strong>: 属性描述符对象或 <code>undefined</code></p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">// &#123; value: &#x27;Alice&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.getPrototypeOf(target)</code></p><ul><li><p><strong>描述</strong>: 获取对象的原型</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li></ul></li><li><p><strong>返回值</strong>: 目标对象的原型</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proto = <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proto); <span class="comment">// Object.prototype</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.has(target, propertyKey)</code></p><ul><li><p><strong>描述</strong>: 检查对象是否具有某个属性（包括原型链上的属性）</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示属性是否存在</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> hasName = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hasName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.isExtensible(target)</code></p><ul><li><p><strong>描述</strong>: 检查对象是否可扩展（即是否可以添加新属性）</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示对象是否可扩展</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> extensible = <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(extensible); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.ownKeys(target)</code></p><ul><li><p><strong>描述</strong>: 获取对象的所有属性键，包括不可枚举属性和符号属性</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li></ul></li><li><p><strong>返回值</strong>: 包含对象所有属性键的数组</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys); <span class="comment">// [&#x27;name&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.preventExtensions(target)</code></p><ul><li><p><strong>描述</strong>: 防止对象扩展（即不允许添加新属性）</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示操作是否成功</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(obj)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.set(target, propertyKey, value[, receiver])</code></p><ul><li><p><strong>描述</strong>: 设置对象的属性值</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>propertyKey</code>: 属性键</li><li><code>value</code>: 要设置的值</li><li><code>receiver</code> (可选): 如果是一个代理对象，则作为 <code>this</code> 值传递给 <code>setter</code> 函数</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示属性是否成功设置</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Reflect.setPrototypeOf(target, proto)</code></p><ul><li><p><strong>描述</strong>: 设置对象的原型</p></li><li><p>参数</p><ul><li><code>target</code>: 目标对象</li><li><code>proto</code>: 新的原型对象</li></ul></li><li><p><strong>返回值</strong>: 布尔值，表示原型是否成功设置</p></li><li><p>示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const proto = &#123; greeting: &#x27;Hello&#x27; &#125;;</span><br><span class="line">const success = Reflect.setPrototypeOf(obj, proto);</span><br><span class="line">console.log(success); // true</span><br><span class="line">console.log(obj.greeting); // Hello</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br /></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 建筑的结构代码 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import ProxyDeep from &#x27;@/utils/proxyDeep&#x27;</span><br><span class="line"></span><br><span class="line">const targetData = &#123;&#125;</span><br><span class="line">const proxyDeep = new ProxyDeep()</span><br><span class="line">const handler = &#123;... code ...&#125;</span><br><span class="line"></span><br><span class="line">const startProxy = (info) =&gt; &#123;</span><br><span class="line">    ... code ...</span><br><span class="line">    targetData = proxyDeep.initProxy(info, handler)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite创建Vue3项目</title>
    <url>/posts/8dce8b29/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ThreeJS-基础环境搭建</title>
    <url>/posts/1d0a14b2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite创建React项目</title>
    <url>/posts/8dce8b29/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack创建React项目</title>
    <url>/posts/11f6c0d3/</url>
    <content><![CDATA[<div class="note info modern"><h4 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h4><p><code>node</code>版本需要18及以上，否则下载最新的<code>webpack</code>一些包，运行起来会出问题</p>
<p><code>npm</code>版本一般都是跟随<code>node</code>的</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>最好是可以利用<code>nvm</code>来对你电脑的<code>node</code>版本进行管理</p>
<h4 id="如何查看版本"><a href="#如何查看版本" class="headerlink" title="如何查看版本"></a>如何查看版本</h4><ol>
<li><p>调出来你的<code>cmd</code>工具</p>
<p>按键：<code>Win+R</code></p>
</li>
<li><p>查看node版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/17/VaZAtojXedkKRYL.png" alt="image-20240517160158000"></p>
<p>得到版本为<code>V 18.18.2</code></p>
</li>
<li><p>查看npm版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/17/ib8c5pIE9YBhN4G.png" alt="image-20240517160244635"></p>
<p>得到版本为<code>V 9.8.1</code></p>
</li>
</ol>
</div>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本章节前置知识点、优化点大部分均在<u>[Webapck创建Vue3项目](https://wutiaowu5t5.github.io/posts/54d94922/)</u>这里</p>
<p><br /></p>
<h2 id="一、新建项目"><a href="#一、新建项目" class="headerlink" title="一、新建项目"></a>一、新建项目</h2><p>新建一个项目，并在编辑器里面打开，这里用的是<code>Webstorm</code>，项目名字是<code>WebpackCreateReact</code></p>
<p><br /></p>
<h2 id="二、初始化项目"><a href="#二、初始化项目" class="headerlink" title="二、初始化项目"></a>二、初始化项目</h2><p>打开终端， 运行下面这段命令，会给我们的项目初始化，生成一个<code>package.json</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/27/mVvlZOKUhrRNaJ8.png" alt="image-20240527163346809"></p>
<p><br /></p>
<h2 id="三、搭建项目"><a href="#三、搭建项目" class="headerlink" title="三、搭建项目"></a>三、搭建项目</h2><p>这一步将要实现目标就是：</p>
<ol>
<li>给<code>webpack</code>区分打包环境</li>
<li>给项目添加<code>React</code></li>
<li>给项目添加<code>css</code>预处理器</li>
<li>把项目跑起来</li>
</ol>
<h3 id="3-1-Webpack基础包"><a href="#3-1-Webpack基础包" class="headerlink" title="3.1-Webpack基础包"></a>3.1-Webpack基础包</h3><p>执行下面这段命令，我们就可以启动<code>webpack</code>项目了，这些包在使用<code>Webpack</code>进行项目构建时常用到的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server webpack webpack-cli webpack-merge --save-dev</span><br></pre></td></tr></table></figure>
<p>这时候我们看到到项目里面多出来了一个目录<code>node_modules</code>，一个文件<code>package-lock.json</code>，<code>package.json</code>里面多出来了一个<code>devDependencies</code></p>
<h3 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2-配置文件"></a>3.2-配置文件</h3><p>项目内创建<code>webpackConfig</code>目录，用来保存和<code>webpack</code>相关的配置文件，和项目文件分离出来</p>
<p><img src="https://s2.loli.net/2024/05/17/E9k6XNRBlow4Sgt.png" alt="image-20240517172236108"></p>
<h4 id="webpack-common-js公共配置文件"><a href="#webpack-common-js公共配置文件" class="headerlink" title="webpack.common.js公共配置文件"></a><code>webpack.common.js</code>公共配置文件</h4><h5 id="配置模块解析规则-resolve"><a href="#配置模块解析规则-resolve" class="headerlink" title="配置模块解析规则 resolve"></a>配置模块解析规则 resolve</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引入Node.js的path模块</span></span><br><span class="line"><span class="comment"> * 该模块提供了一系列处理文件路径的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 配置模块解析规则</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="comment">// 后缀名自动补全，当引入模块时，可以不写具体的后缀名，这里指定了可用的后缀名列表</span></span><br><span class="line">        <span class="attr">extensions</span>: [</span><br><span class="line">            <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.less&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 配置别名，方便在import时使用简写，提高编码效率</span></span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 使用&#x27;@&#x27;作为简写，指向项目的src目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">            <span class="comment">// &#x27;cmp&#x27;别名指向组件目录，方便直接引入组件</span></span><br><span class="line">            <span class="string">&#x27;cmp&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/components&#x27;</span>),</span><br><span class="line">            <span class="comment">// &#x27;api&#x27;别名指向API接口目录，便于调用接口</span></span><br><span class="line">            <span class="string">&#x27;api&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/api&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h5 id="配置入口文件entry"><a href="#配置入口文件entry" class="headerlink" title="配置入口文件entry"></a>配置入口文件entry</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 配置入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/main.tsx&#x27;</span>),</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h5 id="配置输出选项output"><a href="#配置输出选项output" class="headerlink" title="配置输出选项output"></a>配置输出选项output</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 配置输出选项</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定输出的文件名，[chunkhash:8]表示使用8位的块哈希值作为文件名的一部分</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 指定输出文件的路径</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 启用异步块加载</span></span><br><span class="line">        <span class="attr">asyncChunks</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置资源的公共路径，对于在页面中引用的静态资源，都将以此路径为基础</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="comment">// 清除上一次打包构建出来的文件</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Webpack配置中，<code>output</code> 属性告诉Webpack如何写出它所创建的bundles（打包后的文件），以及在哪里写出它们</p>
<p>这个属性定义了打包过程生成的文件的输出方式和位置</p>
<p>它的配置对于确定你打包后的资源如何分发和使用至关重要</p>
<p><br /></p>
<h5 id="定义模块的规则配置module"><a href="#定义模块的规则配置module" class="headerlink" title="定义模块的规则配置module"></a>定义模块的规则配置module</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// 这里是模块规则的数组，用于配置不同类型的文件如何被处理</span></span><br><span class="line">            <span class="comment">// 每个规则包括测试表达式（test）、加载器（loader）和选项（options）等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好之后进行下一步操作，后续随着配置增加，会给这个rules数组添加新东西</p>
<p><br /></p>
<h5 id="插件配置数组plugins"><a href="#插件配置数组plugins" class="headerlink" title="插件配置数组plugins"></a>插件配置数组plugins</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 这里放置项目使用的插件列表</span></span><br><span class="line">        <span class="comment">// 插件可以执行各种任务，如自动优化和压缩代码、注入环境变量等</span></span><br><span class="line">    ]</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好之后进行下一步操作，后续随着配置增加，会给这个数组添加新东西</p>
<p><br /></p>
<h4 id="webpack-dev-js开发环境配置文件"><a href="#webpack-dev-js开发环境配置文件" class="headerlink" title="webpack.dev.js开发环境配置文件"></a><code>webpack.dev.js</code>开发环境配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并基础的webpack配置文件与开发环境的特定配置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@module</span> <span class="variable">exports</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">base</span> - 来自webpack.common.js的基础配置对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125; 返回一个合并后的webpack配置对象，专用于开发环境。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>) <span class="comment">// 引入webpack合并配置的工具</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common.js&quot;</span>) <span class="comment">// 引入基础的webpack配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 设置为开发模式</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// 启用source-map，便于调试</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>, <span class="comment">// 启用gzip压缩</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">// 设置监听的端口号</span></span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">// 启用热更新</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">// 使得HTML5 History API可以正常工作</span></span><br><span class="line">        <span class="attr">client</span>: &#123;</span><br><span class="line">            <span class="attr">progress</span>: <span class="literal">true</span>, <span class="comment">// 显示编译进度</span></span><br><span class="line">            <span class="attr">logging</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 仅输出错误日志</span></span><br><span class="line">            <span class="attr">overlay</span>: &#123;</span><br><span class="line">                <span class="attr">errors</span>: <span class="literal">true</span>, <span class="comment">// 在浏览器上覆盖错误警告</span></span><br><span class="line">                <span class="attr">warnings</span>: <span class="literal">true</span> <span class="comment">// 在浏览器上覆盖警告</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="comment">// 设置对&quot;/apis&quot;开头的请求的代理</span></span><br><span class="line">            <span class="string">&quot;/apis&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;your-target-url&quot;</span>, <span class="comment">// 目标服务器URL</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;^/apis&quot;</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="comment">// 将请求路径中的&quot;/apis&quot;移除</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 设置请求的origin为目标服务器的origin</span></span><br><span class="line">                <span class="attr">secure</span>: <span class="literal">false</span> <span class="comment">// 目标服务器地址是否为https，false表示不是</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码使用 <code>webpack-merge</code> 工具来合并基础的Webpack配置和开发环境特定的配置，生成一个适用于开发环境的Webpack配置对象</p>
<p><br /></p>
<h4 id="webpack-pros-js生产环境配置文件"><a href="#webpack-pros-js生产环境配置文件" class="headerlink" title="webpack.pros.js生产环境配置文件"></a><code>webpack.pros.js</code>生产环境配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">       </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h4 id="修改script启动项目命令"><a href="#修改script启动项目命令" class="headerlink" title="修改script启动项目命令"></a>修改script启动项目命令</h4><p>运行这段命令，安装<code>cross-env</code>包，用于设置跨平台环境变量，通常用于设置NODE_ENV等环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure>
<p>然后修改<code>package.json</code>文件的<code>script</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=development webpack serve --config ./webpackConfig/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=production webpack --config ./webpackConfig/webpack.prod.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-React系列"><a href="#3-3-React系列" class="headerlink" title="3.3-React系列"></a>3.3-React系列</h3><p>安装<code>React</code>全家桶</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react react-dom</span><br></pre></td></tr></table></figure>
<h4 id="新建src文件"><a href="#新建src文件" class="headerlink" title="新建src文件"></a>新建src文件</h4><p>这个目录是我们<code>React</code>项目的主要存放地方，所有<code>Vue</code>的东西都是包含在这里面的</p>
<h4 id="新建assets"><a href="#新建assets" class="headerlink" title="新建assets"></a>新建assets</h4><p>这个目录主要存放我们的资源：图片、字体、css</p>
<h4 id="新建apis"><a href="#新建apis" class="headerlink" title="新建apis"></a>新建apis</h4><p>这个目录主要存放我们的接口，分成不同的模块js文件去存放对应的接口</p>
<h4 id="新建utils"><a href="#新建utils" class="headerlink" title="新建utils"></a>新建utils</h4><p>这个目录主要存放我们的一些公共函数</p>
<h4 id="新建hooks"><a href="#新建hooks" class="headerlink" title="新建hooks"></a>新建hooks</h4><p>这个目录主要存放我们的一些hooks函数</p>
<h4 id="新建components"><a href="#新建components" class="headerlink" title="新建components"></a>新建components</h4><p>这个目录主要存放我们的公共组件</p>
<h4 id="新建store"><a href="#新建store" class="headerlink" title="新建store"></a>新建store</h4><p>这个目录是要存放公共状态管理，是<code>pinia</code>的使用入口</p>
<h4 id="新建pages"><a href="#新建pages" class="headerlink" title="新建pages"></a>新建pages</h4><p>这个目录存放项目的<code>React</code>主要页面</p>
<h4 id="新建main-tsx"><a href="#新建main-tsx" class="headerlink" title="新建main.tsx"></a>新建main.tsx</h4><p>这个文件是Webpack的项目入口，也是<code>React</code>的实例创建文件</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(root) &#123;</span><br><span class="line">  <span class="title function_">createRoot</span>(root).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新建App-tsx"><a href="#新建App-tsx" class="headerlink" title="新建App.tsx"></a>新建App.tsx</h4><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>webpack5-react-ts<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>
<h4 id="安装Ts类型依赖"><a href="#安装Ts类型依赖" class="headerlink" title="安装Ts类型依赖"></a>安装Ts类型依赖</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @types/react @types/react-dom babel-loader @babel/core @babel/preset-react @babel/preset-typescript -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.(ts|tsx)$/</span>, <span class="comment">// 匹配.ts, tsx文件</span></span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// 预设执行顺序由右往左,所以先处理ts,再处理jsx</span></span><br><span class="line">            <span class="attr">presets</span>: [</span><br><span class="line">              <span class="string">&#x27;@babel/preset-react&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;@babel/preset-typescript&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="新增tsconfig-json文件"><a href="#新增tsconfig-json文件" class="headerlink" title="新增tsconfig.json文件"></a>新增<strong>tsconfig.json</strong>文件</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;DOM&quot;</span><span class="punctuation">,</span> <span class="string">&quot;DOM.Iterable&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react&quot;</span><span class="punctuation">,</span> <span class="comment">// react18这里也可以改成react-jsx</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@cmp/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/components/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@api/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/apis/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@utils/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/utils/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./src&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>到此为止的目录结构如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">├─node<span class="emphasis">_modules     </span></span><br><span class="line"><span class="emphasis">├─src</span></span><br><span class="line"><span class="emphasis">│  ├─apis         // 项目接口</span></span><br><span class="line"><span class="emphasis">│  ├─assets       // css、图片、字体资源</span></span><br><span class="line"><span class="emphasis">│  │  ├─css</span></span><br><span class="line"><span class="emphasis">│  │  ├─fonts</span></span><br><span class="line"><span class="emphasis">│  │  └─images</span></span><br><span class="line"><span class="emphasis">│  ├─components   // 公共组件</span></span><br><span class="line"><span class="emphasis">│  ├─directive    // 自定义指令</span></span><br><span class="line"><span class="emphasis">│  ├─hooks        // hooks函数</span></span><br><span class="line"><span class="emphasis">│  ├─router       // 路由管理</span></span><br><span class="line"><span class="emphasis">│  ├─store        // Pinia状态管理</span></span><br><span class="line"><span class="emphasis">│  │  └─modules</span></span><br><span class="line"><span class="emphasis">│  ├─utils        // 公共工具函数</span></span><br><span class="line"><span class="emphasis">│  └─pages        // 项目页面</span></span><br><span class="line"><span class="emphasis">│      ├─Home</span></span><br><span class="line"><span class="emphasis">│      └─Login</span></span><br><span class="line"><span class="emphasis">└─webpackConfig   // webpack公共、开发、生产配置</span></span><br></pre></td></tr></table></figure>
<h4 id="指定html文件"><a href="#指定html文件" class="headerlink" title="指定html文件"></a>指定html文件</h4><p>在项目的根目录下面新建一个<code>index.html</code>文件，内容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Create React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着运行这段命令，安装一下<code>html-webpack-plugin</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>这个插件可以帮助我们将打包好的文件都引入到<code>index.html</code>里面，不再需要我们自己手动去引入</p>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 这里放置项目使用的插件列表</span></span><br><span class="line">        <span class="comment">// 插件可以执行各种任务，如自动优化和压缩代码、注入环境变量等</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Vue3 + webpack -&gt; Web App&#x27;</span>,</span><br><span class="line">            <span class="attr">minify</span>: &#123;</span><br><span class="line">                <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 去掉空格</span></span><br><span class="line">                <span class="attr">removeComments</span>: <span class="literal">true</span> <span class="comment">// 去掉注释</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>控制台输入<code>npm run dev</code></p>
<p>这时候编辑器会自动在打包好以后给你在浏览器打开端口3000的地址</p>
<p><img src="https://s2.loli.net/2024/05/27/iXKLTqrPQb3wZpv.png" alt="image-20240527173235447"></p>
<p><br /></p>
<h3 id="3-4-样式系列"><a href="#3-4-样式系列" class="headerlink" title="3.4-样式系列"></a>3.4-样式系列</h3><p>在前端工程化里面，常用的预编译的<code>css</code>就是<code>less</code>、<code>scss</code>、<code>sass</code>，这里我们选用<code>less</code>来作为项目的预编译器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader less-loader less --save-dev</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// 这里是模块规则的数组，用于配置不同类型的文件如何被处理</span></span><br><span class="line">            <span class="comment">// 每个规则包括测试表达式（test）、加载器（loader）和选项（options）等</span></span><br><span class="line">    </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.css文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 将CSS样式插入到DOM中</span></span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.less文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 将CSS样式插入到DOM中</span></span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 编译LESS到CSS</span></span><br><span class="line">                    <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h2 id="四、优化项目"><a href="#四、优化项目" class="headerlink" title="四、优化项目"></a>四、优化项目</h2><h3 id="4-1-静默样式热更新"><a href="#4-1-静默样式热更新" class="headerlink" title="4.1-静默样式热更新"></a>4.1-静默样式热更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @pmmmwh/react-refresh-webpack-plugin react-refresh -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.dev.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactRefreshWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;@pmmmwh/react-refresh-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(baseConfig, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ReactRefreshWebpackPlugin</span>(), <span class="comment">// 添加热更新插件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五、源代码"><a href="#五、源代码" class="headerlink" title="五、源代码"></a>五、源代码</h2>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue权限设计</title>
    <url>/posts/922c3fd/</url>
    <content><![CDATA[<h1 id="Vue权限"><a href="#Vue权限" class="headerlink" title="Vue权限"></a>Vue权限</h1><p><img src="https://s2.loli.net/2022/07/22/gX734kTH5nfi1mq.png" alt="image-20220722225409659"></p>
<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p>
<p>而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发</p>
<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发</li>
</ul>
<p>总的来说，所有的请求发起都触发自前端路由或视图</p>
<p>所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：</p>
<ul>
<li>路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 <code>4xx</code> 提示页</li>
<li>视图方面，用户只能看到自己有权浏览的内容和有权操作的控件</li>
<li>最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截</li>
</ul>
<p><br /></p>
<h2 id="二、怎么做"><a href="#二、怎么做" class="headerlink" title="二、怎么做"></a>二、怎么做</h2><p>前端权限控制可以分为四个方面：</p>
<ul>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限</li>
</ul>
<p><br /></p>
<h3 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h3><p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>，跳转到登录页面重新进行登录</p>
<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = cookie.<span class="title function_">get</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">40099</span> || response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">40098</span>) &#123; <span class="comment">//token过期或者错误</span></span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="路由权限控制"><a href="#路由权限控制" class="headerlink" title="路由权限控制"></a><strong>路由权限控制</strong></h3><p><strong>方案一</strong></p>
<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routerMap = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/permission&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/permission/index&#x27;</span>,</span><br><span class="line">    <span class="attr">alwaysShow</span>: <span class="literal">true</span>, <span class="comment">// will always show the root menu</span></span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;permission&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&#x27;lock&#x27;</span>,</span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;editor&#x27;</span>] <span class="comment">// you can set roles in root nav</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;page&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/permission/page&#x27;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;pagePermission&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;pagePermission&#x27;</span>,</span><br><span class="line">        <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] <span class="comment">// or you can only set roles in sub nav</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/permission/directive&#x27;</span>),</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;directivePermission&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;directivePermission&#x27;</span></span><br><span class="line">        <span class="comment">// if do not set roles, means: this page does not require permission</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方式存在以下四种缺点：</p>
<ul>
<li>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</li>
<li>全局路由守卫里，每次路由跳转都要做权限判断。</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><strong>方案二</strong></p>
<p>初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制</p>
<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span> <span class="comment">// progress bar</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span><span class="comment">// progress bar style</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span> <span class="comment">// getToken from cookie</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NProgress</span>.<span class="title function_">configure</span>(&#123; <span class="attr">showSpinner</span>: <span class="literal">false</span> &#125;)<span class="comment">// NProgress Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// permission judge function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">roles, permissionRoles</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (roles.<span class="title function_">indexOf</span>(<span class="string">&#x27;admin&#x27;</span>) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// admin permission passed directly</span></span><br><span class="line">  <span class="keyword">if</span> (!permissionRoles) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> roles.<span class="title function_">some</span>(<span class="function"><span class="params">role</span> =&gt;</span> permissionRoles.<span class="title function_">indexOf</span>(role) &gt;= <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/authredirect&#x27;</span>]<span class="comment">// no redirect whitelist</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">start</span>() <span class="comment">// start progress bar</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>()) &#123; <span class="comment">// determine if there has token</span></span><br><span class="line">    <span class="comment">/* has token*/</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// if current page is dashboard will not trigger afterEach hook, so manually handle it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">roles</span>.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="comment">// 判断当前用户是否已拉取完user_info信息</span></span><br><span class="line">        store.<span class="title function_">dispatch</span>(<span class="string">&#x27;GetUserInfo&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="comment">// 拉取user_info</span></span><br><span class="line">          <span class="keyword">const</span> roles = res.<span class="property">data</span>.<span class="property">roles</span> <span class="comment">// note: roles must be a array! such as: [&#x27;editor&#x27;,&#x27;develop&#x27;]</span></span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">&#x27;GenerateRoutes&#x27;</span>, &#123; roles &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 根据roles权限生成可访问的路由表</span></span><br><span class="line">            router.<span class="title function_">addRoutes</span>(store.<span class="property">getters</span>.<span class="property">addRouters</span>) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">            <span class="title function_">next</span>(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;) <span class="comment">// hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          store.<span class="title function_">dispatch</span>(<span class="string">&#x27;FedLogOut&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Message</span>.<span class="title function_">error</span>(err || <span class="string">&#x27;Verification failed, please login again&#x27;</span>)</span><br><span class="line">            <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasPermission</span>(store.<span class="property">getters</span>.<span class="property">roles</span>, to.<span class="property">meta</span>.<span class="property">roles</span>)) &#123;</span><br><span class="line">          <span class="title function_">next</span>()<span class="comment">//</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/401&#x27;</span>, <span class="attr">replace</span>: <span class="literal">true</span>, <span class="attr">query</span>: &#123; <span class="attr">noGoBack</span>: <span class="literal">true</span> &#125;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可删 ↑</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123; <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">// 否则全部重定向到登录页</span></span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// if current page is login will not trigger afterEach hook, so manually handle it</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// finish progress bar</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>
<p>这种方式也存在了以下的缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<p><br /></p>
<h3 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a><strong>菜单权限</strong></h3><p>菜单权限可以理解成将页面与理由进行解耦</p>
<p><strong>方案一</strong></p>
<p>菜单与路由分离，菜单由后端返回</p>
<p>前端定义路由信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/pages/Login.vue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code>字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有<code>name</code>对应的字段，并且做唯一性校验</p>
<p>全局路由守卫里做判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">router, accessMenu</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(router.<span class="property">path</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> menu = <span class="title class_">Util</span>.<span class="title function_">getMenuByName</span>(router.<span class="property">name</span>, accessMenu);</span><br><span class="line">  <span class="keyword">if</span> (menu.<span class="property">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Router</span>.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getToken</span>()) &#123;</span><br><span class="line">    <span class="keyword">let</span> userInfo = store.<span class="property">state</span>.<span class="property">user</span>.<span class="property">userInfo</span>;</span><br><span class="line">    <span class="keyword">if</span> (!userInfo.<span class="property">name</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&quot;GetUserInfo&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;updateAccessMenu&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;home_index&#x27;</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//Util.toDefaultPage([...routers], to.name, router, next);</span></span><br><span class="line">          <span class="title function_">next</span>(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)<span class="comment">//菜单权限更新完成,重新进一次当前路由</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123; <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">          <span class="title function_">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">next</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;home_index&#x27;</span> &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasPermission</span>(to, store.<span class="property">getters</span>.<span class="property">accessMenu</span>)) &#123;</span><br><span class="line">          <span class="title class_">Util</span>.<span class="title function_">toDefaultPage</span>(store.<span class="property">getters</span>.<span class="property">accessMenu</span>,to, routes, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/403&#x27;</span>,<span class="attr">replace</span>:<span class="literal">true</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123; <span class="comment">// 在免登录白名单，直接进入</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> menu = <span class="title class_">Util</span>.<span class="title function_">getMenuByName</span>(to.<span class="property">name</span>, store.<span class="property">getters</span>.<span class="property">accessMenu</span>);</span><br><span class="line">  <span class="title class_">Util</span>.<span class="title function_">title</span>(menu.<span class="property">title</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Router</span>.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的<code>name</code>与路由的<code>name</code>是一一对应的，而后端返回的菜单就已经是经过权限过滤的</p>
<p>如果根据路由<code>name</code>找不到对应的菜单，就表示用户有没权限访问</p>
<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载</p>
<p>这种方式的缺点：</p>
<ul>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
</ul>
<p><strong>方案二</strong></p>
<p>菜单和路由都由后端返回</p>
<p>前端统一定义路由组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/Home.vue&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&quot;../pages/UserInfo.vue&quot;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">home</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后端路由组件返回以下格式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        name<span class="punctuation">:</span> <span class="string">&quot;home&quot;</span><span class="punctuation">,</span></span><br><span class="line">        path<span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        component<span class="punctuation">:</span> <span class="string">&quot;home&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        name<span class="punctuation">:</span> <span class="string">&quot;home&quot;</span><span class="punctuation">,</span></span><br><span class="line">        path<span class="punctuation">:</span> <span class="string">&quot;/userinfo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        component<span class="punctuation">:</span> <span class="string">&quot;userInfo&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将<code>component</code>字段换为真正的组件</p>
<p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</p>
<p>这种方法也会存在缺点：</p>
<ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高</li>
</ul>
<p><br /></p>
<h3 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a><strong>按钮权限</strong></h3><p><strong>方案一</strong></p>
<p>按钮权限也可以用<code>v-if</code>判断</p>
<p>但是如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断</p>
<p>这种方式就不展开举例了</p>
<p><strong>方案二</strong></p>
<p>通过自定义指令进行按钮权限的判断</p>
<p>首先配置路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/permission&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;权限测试&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">btnPermissions</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;supper&#x27;</span>, <span class="string">&#x27;normal&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//页面需要的权限</span></span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;supper&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title function_">_import</span>(<span class="string">&#x27;system/supper&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;权限测试页&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;</span><br><span class="line">            <span class="attr">btnPermissions</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;supper&#x27;</span>]</span><br><span class="line">        &#125; <span class="comment">//页面需要的权限</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title function_">_import</span>(<span class="string">&#x27;system/normal&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;权限测试页&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;</span><br><span class="line">            <span class="attr">btnPermissions</span>: [<span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line">        &#125; <span class="comment">//页面需要的权限</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义权限鉴定指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">/**权限指令**/</span></span><br><span class="line"><span class="keyword">const</span> has = <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;has&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">bind</span>: <span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取页面按钮权限</span></span><br><span class="line">        <span class="keyword">let</span> btnPermissionsArr = [];</span><br><span class="line">        <span class="keyword">if</span>(binding.<span class="property">value</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。</span></span><br><span class="line">            btnPermissionsArr = <span class="title class_">Array</span>.<span class="title function_">of</span>(binding.<span class="property">value</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。</span></span><br><span class="line">            btnPermissionsArr = vnode.<span class="property">context</span>.<span class="property">$route</span>.<span class="property">meta</span>.<span class="property">btnPermissions</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.$_has(btnPermissionsArr)) &#123;</span><br><span class="line">            el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 权限检查方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$_has</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isExist = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取用户按钮权限</span></span><br><span class="line">    <span class="keyword">let</span> btnPermissionsStr = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;btnPermissions&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (btnPermissionsStr == <span class="literal">undefined</span> || btnPermissionsStr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">indexOf</span>(btnPermissionsStr) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        isExist = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isExist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;has&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的按钮中只需要引用<code>v-has</code>指令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-button @click=<span class="string">&#x27;editClick&#x27;</span> type=<span class="string">&quot;primary&quot;</span> v-has&gt;编辑&lt;/el-button&gt;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离</p>
<p>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Webapck创建Vue3项目</title>
    <url>/posts/54d94922/</url>
    <content><![CDATA[<div class="note info modern"><h4 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h4><p><code>node</code>版本需要18及以上，否则下载最新的<code>webpack</code>一些包，运行起来会出问题</p>
<p><code>npm</code>版本一般都是跟随<code>node</code>的</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>最好是可以利用<code>nvm</code>来对你电脑的<code>node</code>版本进行管理</p>
<h4 id="如何查看版本"><a href="#如何查看版本" class="headerlink" title="如何查看版本"></a>如何查看版本</h4><ol>
<li><p>调出来你的<code>cmd</code>工具</p>
<p>按键：<code>Win+R</code></p>
</li>
<li><p>查看node版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/17/VaZAtojXedkKRYL.png" alt="image-20240517160158000"></p>
<p>得到版本为<code>V 18.18.2</code></p>
</li>
<li><p>查看npm版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/17/ib8c5pIE9YBhN4G.png" alt="image-20240517160244635"></p>
<p>得到版本为<code>V 9.8.1</code></p>
</li>
</ol>
</div>
<h2 id="一、新建项目"><a href="#一、新建项目" class="headerlink" title="一、新建项目"></a>一、新建项目</h2><p>新建一个项目，并在编辑器里面打开，这里用的是<code>Webstorm</code>，项目名字是<code>WebpackCreateVue</code></p>
<p><br /></p>
<h2 id="二、初始化项目"><a href="#二、初始化项目" class="headerlink" title="二、初始化项目"></a>二、初始化项目</h2><p>打开终端， 运行下面这段命令，会给我们的项目初始化，生成一个<code>package.json</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/05/17/QJOlNMIkvWKrmpx.png" alt="image-20240517161006850"></p>
<p><br /></p>
<details class="folding-tag" purple><summary> package.json是什么 </summary>
              <div class='content'>
              <p><code>package.json</code> 文件是一个重要的文件，存在于 <code>Node.js</code> 应用或前端项目（通常用到了 <code>Node.js</code> 工具链，如使用 <code>npm/yarn</code> 进行包管理的项目）的根目录中</p><p>它用于存储项目的元数据和配置信息</p><p>这个文件是用 <code>JSON</code> 格式编写的，提供了一种标准化的方式来组织项目信息和管理项目的依赖</p><p>主要作用包括但不限于：</p><ol><li><p><strong>项目元数据</strong></p><p>定义项目的名称、版本、描述、作者、许可证等信息</p><p>这对于项目的标识和分发非常重要</p></li><li><p><strong>依赖管理</strong></p><p>列出了项目所需的各种依赖包及其版本号</p><p>这使得项目在不同环境中的部署变得容易和一致，因为 <code>npm</code> 或 <code>yarn</code> 这样的包管理器可以自动安装正确版本的依赖</p></li><li><p><strong>脚本</strong></p><p>定义一系列脚本命令，如启动项目、编译构建、测试等</p><p>这使得项目相关的任务可以轻松执行，增强了开发效率</p></li><li><p><strong>配置信息</strong></p><p>可以包含项目配置信息，如构建系统、测试框架和其他工具的配置</p><p>这些配置通常在开发过程中经常需要修改或参考</p></li><li><p><strong>私有标记</strong></p><p>如果 <code>package.json</code> 中包含 <code>&quot;private&quot;: true</code> 字段，可以防止不小心将私有仓库发布到 <code>npm</code> 上</p></li></ol><p>例如，一个典型的 <code>package.json</code> 文件可能看起来像这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-awesome-project&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A description of the project.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Your Name&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.17.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;nodemon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.7&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，你可以看到项目名称、版本、描述、主入口文件、脚本、作者、许可证以及依赖和开发依赖等信息</p><p>通过这些信息，开发者和工具可以了解如何处理和运行项目</p>
              </div>
            </details>
<p><br /></p>
<h2 id="三、搭建项目"><a href="#三、搭建项目" class="headerlink" title="三、搭建项目"></a>三、搭建项目</h2><p>这一步将要实现目标就是：</p>
<ol>
<li>给<code>webpack</code>区分打包环境</li>
<li>给项目添加<code>vue</code></li>
<li>给项目添加<code>css</code>预处理器</li>
<li>把项目跑起来</li>
</ol>
<h3 id="3-1-Webpack基础包"><a href="#3-1-Webpack基础包" class="headerlink" title="3.1-Webpack基础包"></a>3.1-Webpack基础包</h3><p>执行下面这段命令，我们就可以启动<code>webpack</code>项目了，这些包在使用<code>Webpack</code>进行项目构建时常用到的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server webpack webpack-cli webpack-merge --save-dev</span><br></pre></td></tr></table></figure>
<p>这时候我们看到到项目里面多出来了一个目录<code>node_modules</code>，一个文件<code>package-lock.json</code>，<code>package.json</code>里面多出来了一个<code>devDependencies</code></p>
<details class="folding-tag" purple><summary> 多出来一个目录node_modules是干什么的 </summary>
              <div class='content'>
              <p><code>node_modules</code>目录在<code>JavaScript</code>和<code>Node.js</code>项目中扮演着非常重要的角色</p><p>当你使用<code>npm（Node Package Manager）</code>或<code>yarn</code>等包管理工具安装包<code>（libraries）</code>或依赖<code>（dependencies）</code>时，这些安装的包都会被放置在<code>node_modules</code>目录下</p><p>以下是<code>node_modules</code>的一些详细解释：</p><ol><li><p><strong>依赖存放地</strong></p><p>项目所需的所有第三方包和它们的依赖都会被下载并存放在这个目录里</p><p>这些依赖可能是你直接安装的，也可能是你安装的包所依赖的其他包</p></li><li><p><strong>项目与依赖隔离</strong></p><p>通过将所有依赖放在单独的目录中，<code>node_modules</code>帮助项目保持组织性，同时确保了项目的根目录清爽、有序</p><p>这也使得依赖管理更为集中和简单</p></li><li><p><strong>模块解析</strong></p><p>当你在项目中<code>require</code>或从ES6模块中<code>import</code>模块时，Node.js会默认在<code>node_modules</code>目录中查找这些模块</p><p>这是因为Node.js的模块解析算法会检查这个目录来寻找安装的包</p></li><li><p><strong>便于版本控制和部署</strong></p><p><code>node_modules</code>通常不会被提交到版本控制系统（如Git）中，因为依赖可以通过<code>package.json</code>文件中记录的信息重新安装</p><p>这样做可以避免不必要的文件被提交，减小仓库大小，并确保每个环境（开发、测试、生产）都使用确切相同版本的依赖</p></li><li><p><strong>本地化依赖</strong></p><p><code>node_modules</code>目录的存在确保了项目的依赖是本地化的，这意味着不同的项目可以使用不同版本的相同依赖而互不干扰</p><p>这对于处理依赖之间的潜在冲突、实现版本控制非常有帮助</p></li></ol><p><code>node_modules</code>是项目的基石之一，它存储项目所需的所有外部代码，使得开发者不需要手动复制或链接到全局安装的库</p><p>这个机制极大地简化了<code>JavaScript</code>和<code>Node.js</code>的开发流程，同时提高了项目的可移植性和易管理性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 多出来一个文件package-lock.json是干什么的 </summary>
              <div class='content'>
              <p><code>package-lock.json</code>是一个由<code>npm</code>自动生成的文件，它在几个方面对<code>Node.js</code>项目非常重要：</p><ol><li><p><strong>锁定依赖版本</strong></p><p>此文件确保每次安装依赖时，无论安装环境或时间如何，都会得到相同版本的依赖</p><p><code>package-lock.json</code>详细记录了项目所使用的每个依赖包的确切版本，包括嵌套依赖（即依赖的依赖）</p></li><li><p><strong>确保一致性</strong></p><p>每当您或您的团队成员运行<code>npm install</code>时，<code>package-lock.json</code>文件都会让安装过程参考这个文件中记载的具体版本，这就确保了每个人的开发环境都是一致的，无论何时进行安装</p></li><li><p><strong>加快安装过程</strong></p><p>因为<code>package-lock.json</code>记录了整个依赖树的详细信息，所以<code>npm</code>可以利用这些信息来跳过部分依赖计算和版本解决步骤，从而加快安装过程</p></li><li><p><strong>安全性</strong></p><p><code>package-lock.json</code>可以为依赖关系树中的每一个包提供更详细的来源信息，包括包的来源地址和哈希校验码</p><p>如果安装的包的哈希码与<code>package-lock.json</code>不一致，<code>npm</code>会警告用户，这能够在一定程度上预防修改或损坏的依赖包对项目的破坏</p></li></ol><p>虽然<code>package-lock.json</code>不需要手动编辑，但它应该和项目一起被提交到版本控制系统（Git仓库）中</p><p>这样确保了所有参与项目的开发者以及部署环境可以使用同样版本的依赖，保持环境之间的一致性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> devDependencies和dependencies区别是什么 </summary>
              <div class='content'>
              <p>在<code>package.json</code>文件中，<code>dependencies</code>和<code>devDependencies</code>是两种不同类型的依赖声明，它们在Node.js项目中具有不同的用途和重要性：</p><ol><li><p><strong><code>dependencies</code></strong>:</p><ul><li>这些是项目运行时所必需的依赖。无论是在生产环境还是其他环境，只要你的应用正在运行，这里列出的模块就是必需的</li><li>例如，如果你的项目是一个web服务，那么像<code>express</code>这样的包就应该列在<code>dependencies</code>中</li><li>当你运行<code>npm install &lt;package_name&gt;</code>（没有指定任何范围标志）时，包会默认被添加到<code>dependencies</code>中</li></ul></li><li><p><strong><code>devDependencies</code></strong>:</p><ul><li><p>这些依赖仅在开发过程中需要，比如编译工具、测试框架或文档生成工具</p><p>它们不是项目运行时必须的，只是在开发过程中为了测试、构建或编译你的项目而需要</p></li><li><p>举例来说，如果你使用Jest来测试你的项目，那么<code>jest</code>应该被列为一个开发依赖</p></li><li><p>通过运行<code>npm install &lt;package_name&gt; --save-dev</code>来安装并将一个包添加为<code>devDependencies</code></p></li></ul></li></ol><p>主要区别在于它们的使用场景：<code>dependencies</code>是项目运行所需的依赖，而<code>devDependencies</code>是仅在开发过程中需要的依赖</p><p>在进行包管理时正确区分这两种依赖类型，对于确保项目的依赖清单既准确又高效尤为重要</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> webpack-dev-server webpack webpack-cli webpack-merge这4个包是干什么的 </summary>
              <div class='content'>
              <p>下面我将逐一解释它们各自的作用：</p><ul><li><p><strong>webpack-dev-server</strong></p><p> 这是一个轻量级的服务器，它可以提供静态文件服务，同时具备热更新（hot reloading）功能</p><p>当你修改了代码后，它能自动重新加载显示在浏览器上的页面或组件，从而大大提高开发效率</p></li><li><p><strong>webpack</strong>:</p><p>Webpack是一个现代JavaScript应用程序的静态模块打包器（module bundler）</p><p>它会分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式以供浏览器使用</p></li><li><p><strong>webpack-cli</strong>:</p><p>这个包提供了可以在命令行中使用的webpack命令，让你能够通过命令行方式来运行webpack的打包、构建等任务</p></li><li><p><strong>webpack-merge</strong>:</p><p>在实际开发过程中，我们常常需要针对不同的环境（如开发环境、生产环境）进行不同的配置，webpack-merge可以帮助我们轻松合并这些配置</p><p>这意味着你可以有一个基本的webpack配置文件，并根据不同的需求，将与环境相关的配置合并进来</p></li></ul><p>为什么创建Webpack项目需要这些包：</p><ul><li><strong>webpack</strong>是核心包，负责整个项目的模块打包和构建</li><li><strong>webpack-cli</strong>允许我们通过命令行接口来使用Webpack，为开发者提供了操作Webpack的便利方式</li><li><strong>webpack-dev-server</strong>提供了一个开发服务器，带有热更新特性，极大地提高了开发效率</li><li><strong>webpack-merge</strong>是为了更灵活地控制不同环境下的配置需求</li></ul>
              </div>
            </details>
<p><br /></p>
<h3 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2-配置文件"></a>3.2-配置文件</h3><p>项目内创建<code>webpackConfig</code>目录，用来保存和<code>webpack</code>相关的配置文件，和项目文件分离出来</p>
<p><img src="https://s2.loli.net/2024/05/17/E9k6XNRBlow4Sgt.png" alt="image-20240517172236108"></p>
<h4 id="webpack-common-js公共配置文件"><a href="#webpack-common-js公共配置文件" class="headerlink" title="webpack.common.js公共配置文件"></a><code>webpack.common.js</code>公共配置文件</h4><h5 id="配置模块解析规则-resolve"><a href="#配置模块解析规则-resolve" class="headerlink" title="配置模块解析规则 resolve"></a>配置模块解析规则 resolve</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引入Node.js的path模块</span></span><br><span class="line"><span class="comment"> * 该模块提供了一系列处理文件路径的函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 配置模块解析规则</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="comment">// 后缀名自动补全，当引入模块时，可以不写具体的后缀名，这里指定了可用的后缀名列表</span></span><br><span class="line">        <span class="attr">extensions</span>: [</span><br><span class="line">            <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;less&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 配置别名，方便在import时使用简写，提高编码效率</span></span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 使用&#x27;@&#x27;作为简写，指向项目的src目录</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">            <span class="comment">// &#x27;cmp&#x27;别名指向组件目录，方便直接引入组件</span></span><br><span class="line">            <span class="string">&#x27;cmp&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/components&#x27;</span>),</span><br><span class="line">            <span class="comment">// &#x27;api&#x27;别名指向API接口目录，便于调用接口</span></span><br><span class="line">            <span class="string">&#x27;api&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/api&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> extensions的作用 </summary>
              <div class='content'>
              <p>在Webpack的配置文件中，<code>resolve.extensions</code> 数组用于指定哪些文件扩展名可以省略不写</p><p>当你尝试通过 <code>import</code> 或 <code>require</code> 语句导入一个模块，而没有指定文件扩展名时，Webpack将按照 <code>resolve.extensions</code> 数组中指定的顺序尝试解析文件扩展名</p><p>此功能的好处是，当你引入模块时可以不必每次都写上文件的扩展名，从而使得导入语句更简洁。这在一个大型项目中能显著提高开发效率</p><p>以一个Vue 3项目为例，Vue 3通常会使用 <code>.vue</code>文件，同时也可能会包含JavaScript <code>.js</code> 文件或是 TypeScript <code>.ts</code> 文件</p><p>假设你的文件结构如下，并且希望在导入一些文件时不必指定扩展名，只要你写入了上面的<code>resolve.extensions</code>配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── components</span><br><span class="line">│   └── MyComponent.vue</span><br><span class="line">└── main.js</span><br></pre></td></tr></table></figure><p>在<code>main.js</code>文件中，你可以像这样导入<code>MyComponent.vue</code>组件，而不需要指定文件扩展名：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./components/MyComponent&#x27;</span></span><br></pre></td></tr></table></figure><p>由于<code>.vue</code>在<code>resolve.extensions</code>数组中列出，Webpack会自动解析<code>MyComponent</code>为<code>./components/MyComponent.vue</code></p><p>正确使用这个配置可以简化模块导入语句，减少冗余，提升开发体验</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> alias的作用 </summary>
              <div class='content'>
              <p>在 Webpack 的配置文件中，<code>resolve.alias</code> 配置项允许你为模块路径设置一个或多个别名（alias），这使得在导入模块时可以使用这些简短、易懂的别名，而不是长且复杂的相对路径或绝对路径</p><p>这个功能对于提高代码的可读性和减少在大型项目中导入模块时路径查找的复杂性非常有帮助</p><p>使用 <code>resolve.alias</code> 可以让你在引入模块时更加方便</p><p>对于频繁访问的深层目录，你不再需要写出繁琐的相对路径，从而使代码更加清晰</p><p>假设你的 Vue 3 项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├─ src/</span><br><span class="line">│  ├─ components/</span><br><span class="line">│  ├─ views/</span><br><span class="line">│  ├─ utils/</span><br><span class="line">│  └─ App.vue</span><br><span class="line">└─ ...</span><br></pre></td></tr></table></figure><p>在没有设置别名的情况下，如果你想从位于 <code>views</code> 目录下的某个组件中导入位于 <code>utils</code> 目录下的某个工具函数，你可能需要写出类似这样的导入语句：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someUtilityFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;../../utils/someUtilityFunction&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这种相对路径不仅难以阅读，而且当文件结构变动时，路径很可能会被破坏，需要手动更新路径</p><p>通过使用 <code>resolve.alias</code>，我们可以为 <code>utils</code> 目录设置一个别名</p><p>配置后，在项目中就可以使用别名来代替长路径了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; someUtilityFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;@utils/someUtilityFunction&#x27;</span>;</span><br></pre></td></tr></table></figure><p>同理，<code>@</code> 别名被设置为 <code>src/</code> 目录的路径，因此你可以更方便地从项目的任何地方引用 <code>src</code> 目录下的文件</p><p>使用 <code>resolve.alias</code> 使得模块导入语句更短、清晰，并且当项目目录结构发生变化时，你只需要更新 <code>webpack.config.js</code> 中的相应别名配置，而不需要去每个文件中修改路径，极大提高了维护效率</p>
              </div>
            </details>
<p><br /></p>
<h5 id="配置入口文件entry"><a href="#配置入口文件entry" class="headerlink" title="配置入口文件entry"></a>配置入口文件entry</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 配置入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src/main.js&#x27;</span>),</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> entry是什么 </summary>
              <div class='content'>
              <p>在Webpack的配置中，<code>entry</code> 属性用于定义入口点（或入口点集），指示Webpack从哪个文件开始构建依赖图</p><p>依赖图用于确定哪些模块和库是项目中需要被打包的</p><p>简单来说，<code>entry</code> 是Webpack开始构建打包过程的起点</p><p><code>entry</code> 的值可以是一个字符串、一个数组，或是一个对象</p><p>对于简单的单页面应用（SPA），通常使用字符串形式直接指向一个文件</p><p>对于更复杂的设置（例如，多页面应用或需要多个入口点的场景），则可以使用对象形式，以便为每个入口指定一个名称及其对应的起始文件</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> Vue里面的main.js可以干什么 </summary>
              <div class='content'>
              <p>对于 Vue.js 项目，<code>main.js</code> 通常是最为常见的入口文件</p><p>在这个文件中，你会创建 Vue 实例，并指定该实例挂载(mount)到页面的哪个元素上</p><p>此外，<code>main.js</code> 也用于执行一些全局性的配置或初始化任务，比如：</p><ul><li>导入 Vue 框架本身</li><li>导入 App 组件，这是应用的根组件</li><li>配置路由(Vue Router)</li><li>配置状态管理(Vuex)，如果项目中使用了</li><li>引入和使用全局样式文件</li><li>配置全局插件、混入(mixins)或自定义指令等</li></ul><p>这表示Webpack将从 <code>src/main.js</code> 文件开始构建依赖图，并进一步分析该文件内部引用的其他模块和库，以决定哪些资源需要被打包</p><p>在 <code>main.js</code> 中，通常会有如下的几项关键任务：</p><ol><li><p><strong>创建和挂载根 Vue 实例</strong></p><p>Vue 应用由一个通过 <code>new Vue()</code> 创建的根 Vue 实例，以及通过 <code>.vue</code> 文件定义的可嵌套的组件树构成</p><p>main.js` 文件负责创建这个实例并将其挂载到 DOM 上</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>全局配置</strong></p><p>在这个阶段，可能会设置Vue的一些全局配置项，比如关闭生产模式下的提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.config.productionTip = false;</span><br></pre></td></tr></table></figure></li><li><p><strong>插件和依赖的引入</strong></p><p>如果你的 Vue 项目中使用了 Vue Router、Vuex 或其他 Vue 插件，这些插件通常会在 <code>main.js</code> 中引入并配置</p><p>这确保了这些插件在 Vue 应用的任何地方都可用</p></li></ol>
              </div>
            </details>
<p><br /></p>
<h5 id="配置输出选项output"><a href="#配置输出选项output" class="headerlink" title="配置输出选项output"></a>配置输出选项output</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 配置输出选项</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定输出的文件名，[chunkhash:8]表示使用8位的块哈希值作为文件名的一部分</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 指定输出文件的路径</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 启用异步块加载</span></span><br><span class="line">        <span class="attr">asyncChunks</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置资源的公共路径，对于在页面中引用的静态资源，都将以此路径为基础</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="comment">// 清除上一次打包构建出来的文件</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Webpack配置中，<code>output</code> 属性告诉Webpack如何写出它所创建的bundles（打包后的文件），以及在哪里写出它们</p>
<p>这个属性定义了打包过程生成的文件的输出方式和位置</p>
<p>它的配置对于确定你打包后的资源如何分发和使用至关重要</p>
<p><br /></p>
<h5 id="定义模块的规则配置module"><a href="#定义模块的规则配置module" class="headerlink" title="定义模块的规则配置module"></a>定义模块的规则配置module</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// 这里是模块规则的数组，用于配置不同类型的文件如何被处理</span></span><br><span class="line">            <span class="comment">// 每个规则包括测试表达式（test）、加载器（loader）和选项（options）等</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好之后进行下一步操作，后续随着配置增加，会给这个rules数组添加新东西</p>
<details class="folding-tag" purple><summary> module可以干什么 </summary>
              <div class='content'>
              <p><code>module</code> 属性用于决定如何处理项目中的不同类型的模块</p><p>Webpack 本身只能理解 JavaScript，如果你要导入 CSS、图片、字体文件，或者其他Web资源，就需要对这些资源使用不同的加载器（loader）</p><p>加载器可以预处理文件，使你能够将任何静态资源当作模块导入</p><p>在Webpack中，加载器可以转换文件，或者是作为其他打包或加载过程的中间步骤</p><p>你可以使用加载器告诉Webpack如何去给特定的文件赋予正确的加载器</p>
              </div>
            </details>
<p><br /></p>
<h5 id="插件配置数组plugins"><a href="#插件配置数组plugins" class="headerlink" title="插件配置数组plugins"></a>插件配置数组plugins</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 这里放置项目使用的插件列表</span></span><br><span class="line">        <span class="comment">// 插件可以执行各种任务，如自动优化和压缩代码、注入环境变量等</span></span><br><span class="line">    ]</span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好之后进行下一步操作，后续随着配置增加，会给这个数组添加新东西</p>
<details class="folding-tag" purple><summary> plugins可以干什么 </summary>
              <div class='content'>
              <p><code>plugins</code> 属性用于处理Webpack打包构建过程中的各种任务，扩展Webpack的功能</p><p>它们会在构建过程的不同阶段执行，能够完成各种各样的任务，比如打包优化、资源管理、注入环境变量等</p><p>Webpack插件是一个具有 <code>apply</code> 方法的JavaScript对象</p><p><code>apply</code> 方法会被Webpack compiler调用，并且在整个编译生命周期都可以访问compiler对象</p>
              </div>
            </details>
<p><br /></p>
<h4 id="webpack-dev-js开发环境配置文件"><a href="#webpack-dev-js开发环境配置文件" class="headerlink" title="webpack.dev.js开发环境配置文件"></a><code>webpack.dev.js</code>开发环境配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并基础的webpack配置文件与开发环境的特定配置。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@module</span> <span class="variable">exports</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">base</span> - 来自webpack.common.js的基础配置对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125; 返回一个合并后的webpack配置对象，专用于开发环境。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>) <span class="comment">// 引入webpack合并配置的工具</span></span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common.js&quot;</span>) <span class="comment">// 引入基础的webpack配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 设置为开发模式</span></span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// 启用source-map，便于调试</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>, <span class="comment">// 启用gzip压缩</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">// 设置监听的端口号</span></span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>, <span class="comment">// 启用热更新</span></span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>, <span class="comment">// 使得HTML5 History API可以正常工作</span></span><br><span class="line">        <span class="attr">client</span>: &#123;</span><br><span class="line">            <span class="attr">progress</span>: <span class="literal">true</span>, <span class="comment">// 显示编译进度</span></span><br><span class="line">            <span class="attr">logging</span>: <span class="string">&#x27;error&#x27;</span>, <span class="comment">// 仅输出错误日志</span></span><br><span class="line">            <span class="attr">overlay</span>: &#123;</span><br><span class="line">                <span class="attr">errors</span>: <span class="literal">true</span>, <span class="comment">// 在浏览器上覆盖错误警告</span></span><br><span class="line">                <span class="attr">warnings</span>: <span class="literal">true</span> <span class="comment">// 在浏览器上覆盖警告</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="comment">// 设置对&quot;/apis&quot;开头的请求的代理</span></span><br><span class="line">            <span class="string">&quot;/apis&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;your-target-url&quot;</span>, <span class="comment">// 目标服务器URL</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;<span class="string">&quot;^/apis&quot;</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="comment">// 将请求路径中的&quot;/apis&quot;移除</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 设置请求的origin为目标服务器的origin</span></span><br><span class="line">                <span class="attr">secure</span>: <span class="literal">false</span> <span class="comment">// 目标服务器地址是否为https，false表示不是</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码使用 <code>webpack-merge</code> 工具来合并基础的Webpack配置和开发环境特定的配置，生成一个适用于开发环境的Webpack配置对象</p>
<ol>
<li><p>引入了 “<code>webpack-merge</code>“ 模块的 “<code>merge</code>“ 函数</p>
<p><code>webpack-merge</code> 是一个可以简化多个Webpack配置合并的工具</p>
</li>
<li><p>引入了基础的Webpack配置文件 “<code>webpack.common.js</code>“</p>
<p>这个文件包含适用于开发和生产环境的通用配置</p>
</li>
<li><p>使用 “<code>module.exports</code>“ 导出了合并后的Webpack配置对象</p>
<p>我们通过调用 “<code>merge</code>“ 函数并传递基础配置（”<code>base</code>“）及开发特定配置实现配置的合并</p>
<p>合并的配置包括：</p>
<ul>
<li><code>mode: &#39;development&#39;</code>：设置Webpack的模式为开发模式。这会启用一些默认的Webpack优化，方便开发者进行调试</li>
<li><code>devtool: &quot;source-map&quot;</code>：启用source-map，这有助于调试代码，因为它可以让你看到原始代码而不是转换后的代码</li>
<li><code>devServer</code>：配置了Webpack的开发服务器（<code>webpack-dev-server</code>）的相关选项，提升开发体验<ul>
<li><code>compress: true</code>: 启用gzip压缩，加快文件传输速率</li>
<li><code>port: 3000</code>: 开发服务器监听的端口号设为3000</li>
<li><code>hot: true</code>: 启用热替换功能(HMR)，无需完全刷新浏览器就可以更新模块</li>
<li><code>open: true</code>: 在开发服务器启动时自动打开浏览器</li>
<li><code>historyApiFallback: true</code>: 当使用HTML5 History API时，任意的404响应都可能需要被替换为<code>index.html</code></li>
<li>client: 配置客户端执行期间的选项，如进度展示和日志级别<ul>
<li><code>progress: true</code>: 在客户端（浏览器）显示编译进度</li>
<li><code>logging: &#39;error&#39;</code>: 仅在客户端记录错误日志</li>
<li><code>overlay</code>: 在发生错误或警告时，通过覆盖层在浏览器上直接显示</li>
</ul>
</li>
</ul>
</li>
<li><code>proxy</code>: 配置了一个代理，用于在开发过程中跨域请求API<ul>
<li>对于以”/apis”开头的请求，请求会被代理到指定的 “<code>target</code>“ URL</li>
<li><code>pathRewrite</code> 用于重写URL路径，这里把路径中的”/apis”移除</li>
<li><code>changeOrigin</code>: 设置为true来伪装请求的源头，使目标服务器认为请求是从自己的域名发起的</li>
<li><code>secure: false</code>: 如果目标服务器不是HTTPS，这个选项要设置为false</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br /></p>
<h4 id="webpack-pros-js生产环境配置文件"><a href="#webpack-pros-js生产环境配置文件" class="headerlink" title="webpack.pros.js生产环境配置文件"></a><code>webpack.pros.js</code>生产环境配置文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">&quot;./webpack.common.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">       </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<details class="folding-tag" purple><summary> 为什么webpack的配置文件要用module.exports </summary>
              <div class='content'>
              <p>使用 <code>module.exports</code> 来导出 <code>Webpack</code> 的配置文件是因为<code>Webpack</code>配置文件本质上是一个<code>Node.js</code>模块</p><p>在<code>Node.js</code>中，<code>module.exports</code> 是 <code>CommonJS</code> 规范的一部分，用于指定一个模块导出的内容，使其可以被其他模块通过 <code>require()</code> 函数导入和使用</p><p><code>Webpack</code> 本身是一个运行在 <code>Node.js</code> 环境中的模块打包工具，它的配置文件 <code>webpack.config.js</code> 就是一个普通的 <code>Node.js</code> 模块</p><p>当你运行 <code>webpack</code> 命令时，<code>Webpack</code> 会通过 <code>require()</code> 来加载这个配置文件，然后读取其中用 <code>module.exports</code> 导出的配置对象</p><p>这些配置包含了入口文件、输出路径、加载器（<code>loaders</code>）、插件（<code>plugins</code>）和其他配置项</p><p>使用 <code>module.exports</code> 的好处之一是它支持更加灵活和复杂的配置逻辑</p><p>由于 <code>webpack.config.js</code> 是一个普通的 <code>Node.js</code> 模块，你不仅可以导出一个对象，还可以在模块中使用 JavaScript 代码来生成配置</p><p>这意味着你可以根据不同的环境变量来动态地更改配置，或者根据需要编写和组合多个配置对象</p>
              </div>
            </details>
<p><br /></p>
<h4 id="修改script启动项目命令"><a href="#修改script启动项目命令" class="headerlink" title="修改script启动项目命令"></a>修改script启动项目命令</h4><p>运行这段命令，安装<code>cross-env</code>包，用于设置跨平台环境变量，通常用于设置NODE_ENV等环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure>
<p>然后修改<code>package.json</code>文件的<code>script</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=development webpack serve --config ./webpackConfig/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=production webpack --config ./webpackConfig/webpack.prod.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>dev脚本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=development webpack serve --config config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>cross-env</strong></p>
<p>这是一个跨平台的环境变量设置工具</p>
<p>确保无论在什么操作系统上（例如Windows，Linux，或macOS），都能以一致的方式设置和使用环境变量</p>
<p>在这里，它被用来设置<code>NODE_ENV</code>环境变量的值为<code>development</code></p>
</li>
<li><p><strong>NODE_ENV=development</strong></p>
<p>设置环境变量<code>NODE_ENV</code>的值为<code>development</code>，通常这个设置被用来通知脚本运行在开发环境中</p>
<p>很多工具和框架，如Webpack和Babel，会根据这个值调整它们的行为，例如启用更适合开发的配置（更详细的错误消息，源代码映射等）</p>
</li>
<li><p><strong>webpack serve</strong></p>
<p>这是启动Webpack的开发服务器<code>webpack-dev-server</code>的命令</p>
<p>webpack-dev-server`提供一个简单的web服务器和能够实时重新加载（live reloading）的能力</p>
</li>
<li><p><strong>—config config/webpack.dev.js</strong>:</p>
<p>这个参数告诉Webpack使用特定的配置文件启动</p>
<p>在这个例子里，使用的是<code>config/webpack.dev.js</code>文件</p>
<p>该文件应该包含了开发环境特定的Webpack配置</p>
</li>
</ul>
</li>
<li><p>build脚本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=production webpack --config ./config/webpack.prod.js&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>cross-env NODE_ENV=production</strong></p>
<p>类似于<code>dev</code>脚本，但这里设置的环境变量<code>NODE_ENV</code>的值为<code>production</code>，意味着接下来的操作是为生产环境准备的</p>
<p>在生产环境中，通常需要代码压缩、优化等操作，以确保应用运行高效、安全</p>
</li>
<li><p><strong>webpack</strong></p>
<p>这是启动Webpack的构建过程的命令</p>
<p>与<code>webpack serve</code>不同，这个命令是用于生成生产环境下使用的打包文件，并不启动一个开发服务器</p>
</li>
<li><p><strong>—config ./config/webpack.prod.js</strong></p>
<p>类似于<code>dev</code>脚本，但这里使用的是针对生产环境优化的Webpack配置文件：<code>webpack.prod.js</code></p>
</li>
</ul>
</li>
</ol>
<p><br /></p>
<h3 id="3-3-Vue系列"><a href="#3-3-Vue系列" class="headerlink" title="3.3-Vue系列"></a>3.3-Vue系列</h3><p>安装<code>Vue3</code>全家桶</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue vue-router pinia</span><br></pre></td></tr></table></figure>
<p>这时候会发现<code>package.json</code>文件的<code>dependencies</code>多出来3个<code>npm</code>包</p>
<p><img src="https://s2.loli.net/2024/05/20/CxLR8aoK6Ap1JHy.png" alt="image-20240520114428180"></p>
<p>这时候我们的<code>Vue3</code>已经安装好了，我们直接创建项目文件去测试打包</p>
<h4 id="新建src文件"><a href="#新建src文件" class="headerlink" title="新建src文件"></a>新建src文件</h4><p>这个目录是我们<code>Vue</code>项目的主要存放地方，所有<code>Vue</code>的东西都是包含在这里面的</p>
<h4 id="新建assets"><a href="#新建assets" class="headerlink" title="新建assets"></a>新建assets</h4><p>这个目录主要存放我们的资源：图片、字体、css</p>
<h4 id="新建apis"><a href="#新建apis" class="headerlink" title="新建apis"></a>新建apis</h4><p>这个目录主要存放我们的接口，分成不同的模块js文件去存放对应的接口</p>
<h4 id="新建utils"><a href="#新建utils" class="headerlink" title="新建utils"></a>新建utils</h4><p>这个目录主要存放我们的一些公共函数</p>
<h4 id="新建hooks"><a href="#新建hooks" class="headerlink" title="新建hooks"></a>新建hooks</h4><p>这个目录主要存放我们的一些hooks函数</p>
<h4 id="新建components"><a href="#新建components" class="headerlink" title="新建components"></a>新建components</h4><p>这个目录主要存放我们的公共组件</p>
<h4 id="新建store"><a href="#新建store" class="headerlink" title="新建store"></a>新建store</h4><p>这个目录是要存放公共状态管理，是<code>pinia</code>的使用入口</p>
<h4 id="新建views"><a href="#新建views" class="headerlink" title="新建views"></a>新建views</h4><p>这个目录存放项目的Vue主要页面</p>
<h4 id="新建main-js"><a href="#新建main-js" class="headerlink" title="新建main.js"></a>新建main.js</h4><p>这个文件是Webpack的项目入口，也是Vue的实例创建文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: Vue入口文件</span></span><br><span class="line"><span class="comment"> * @Author: 5t5</span></span><br><span class="line"><span class="comment"> * @Time: 2024/5/17 17:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建Vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入Pinia</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/store&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(store)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入Router</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>到此为止的目录结构如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">├─node<span class="emphasis">_modules     </span></span><br><span class="line"><span class="emphasis">├─src</span></span><br><span class="line"><span class="emphasis">│  ├─apis         // 项目接口</span></span><br><span class="line"><span class="emphasis">│  ├─assets       // css、图片、字体资源</span></span><br><span class="line"><span class="emphasis">│  │  ├─css</span></span><br><span class="line"><span class="emphasis">│  │  ├─fonts</span></span><br><span class="line"><span class="emphasis">│  │  └─images</span></span><br><span class="line"><span class="emphasis">│  ├─components   // 公共组件</span></span><br><span class="line"><span class="emphasis">│  ├─directive    // 自定义指令</span></span><br><span class="line"><span class="emphasis">│  ├─hooks        // hooks函数</span></span><br><span class="line"><span class="emphasis">│  ├─router       // 路由管理</span></span><br><span class="line"><span class="emphasis">│  ├─store        // Pinia状态管理</span></span><br><span class="line"><span class="emphasis">│  │  └─modules</span></span><br><span class="line"><span class="emphasis">│  ├─utils        // 公共工具函数</span></span><br><span class="line"><span class="emphasis">│  └─views        // 项目页面</span></span><br><span class="line"><span class="emphasis">│      ├─Home</span></span><br><span class="line"><span class="emphasis">│      └─Login</span></span><br><span class="line"><span class="emphasis">└─webpackConfig   // webpack公共、开发、生产配置</span></span><br></pre></td></tr></table></figure>
<h4 id="指定html文件"><a href="#指定html文件" class="headerlink" title="指定html文件"></a>指定html文件</h4><p>在项目的根目录下面新建一个<code>index.html</code>文件，内容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Create Vue3<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这一段千万不能变，因为上面我们的<code>main.js</code>里面挂载到<code>#app</code>这个节点上面</p>
<p>所以如果这里的<code>id</code>改变的话，<code>main.js</code>里面的也要改变</p>
<p>接着运行这段命令，安装一下<code>html-webpack-plugin</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>这个插件可以帮助我们将打包好的文件都引入到<code>index.html</code>里面，不再需要我们自己手动去引入</p>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 这里放置项目使用的插件列表</span></span><br><span class="line">        <span class="comment">// 插件可以执行各种任务，如自动优化和压缩代码、注入环境变量等</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;Vue3 + webpack -&gt; Web App&#x27;</span>,</span><br><span class="line">            <span class="attr">minify</span>: &#123;</span><br><span class="line">                <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 去掉空格</span></span><br><span class="line">                <span class="attr">removeComments</span>: <span class="literal">true</span> <span class="comment">// 去掉注释</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> html-webpack-plugin可以干什么 </summary>
              <div class='content'>
              <p><code>html-webpack-plugin</code> 是一个用于处理 <code>HTML</code> 文件的 <code>Webpack</code> 插件，它非常的实用并且在 <code>Webpack</code> 项目中被广泛使用</p><p>它的主要功能包括：</p><ol><li><p>生成一个新的 <code>HTML</code> 文件</p><p>一旦插件被加入到 <code>webpack</code> 配置中，运行 <code>webpack</code> 打包后会在 <code>output</code> 指定的目录下生成一个新的 <code>HTML</code> 文件</p></li><li><p>自动引入打包生成的 <code>JavaScript</code> 和 <code>CSS</code> 文件</p><p>生成的 <code>HTML</code> 文件会自动包含 <code>webpack</code> 打包生成的所有 <code>JavaScript</code> 和 <code>CSS</code> 文件的引用。插件会自动添加 <code>script</code> 和 <code>link</code> 标签</p></li><li><p>可以使用模板</p><p>你可以自定义一个 <code>HTML</code> 文件作为模板</p><p>插件会以此模板为基础来生成最终的 <code>HTML</code> 文件</p><p>模板文件可以包含一些特殊的占位符，插件在生成 HTML 文件时会自动对这些占位符进行替换</p><p>例如，你可以在模板的 <code>title</code> 标签中使用 <code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code>，这样就可以在 <code>webpack</code> 配置中通过 <code>html-webpack-plugin</code> 的 <code>options</code> 自定义你的 <code>title</code></p></li></ol><p>这个插件非常适合用来生成单页应用程序（SPA）的 <code>HTML</code> 文件</p><p>因为在这种应用程序中，通常只需要一个包含所有 <code>JavaScript</code> 和 <code>CSS</code> 引用的 <code>HTML</code> 文件</p><p>另外，你也可以在多页面应用程序（MPA）使用此插件，每个页面实例化一个插件的实例</p><p>它与 <code>webpack-dev-server</code> 的 <code>hot module replacement</code> 功能 (HMR) 无缝集成，使开发过程更为流畅</p>
              </div>
            </details>
<h4 id="让webpack可以识别Vue"><a href="#让webpack可以识别Vue" class="headerlink" title="让webpack可以识别Vue"></a>让webpack可以识别Vue</h4><p><code>webpack</code>是一个智能识别<code>js</code>文件的打包器，想要识别<code>vue</code>，就需要<code>vue</code>相关的加载器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue-loader @vue/compiler-sfc --save-dev</span><br></pre></td></tr></table></figure>
<p><code>vue-loader</code> 和 <code>@vue/compiler-sfc</code> 是 Vue.js 单文件组件（Single File Components, SFC）的处理工具</p>
<p>它们在将 <code>.vue</code> 文件转换为 JavaScript 模块的过程中起到了核心作用</p>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue-loader配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// 这里是模块规则的数组，用于配置不同类型的文件如何被处理</span></span><br><span class="line">            <span class="comment">// 每个规则包括测试表达式（test）、加载器（loader）和选项（options）等</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.vue文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                <span class="comment">// 使用vue-loader处理</span></span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 这里放置项目使用的插件列表</span></span><br><span class="line">        <span class="comment">// 插件可以执行各种任务，如自动优化和压缩代码、注入环境变量等</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// VueLoaderPlugin是一个Vue.js的加载器插件，它自动处理Vue组件的加载</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>(),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> @vue/compiler-sfc可以干什么 </summary>
              <div class='content'>
              <ul><li><code>@vue/compiler-sfc</code> 是 Vue 3 的一个官方库，主要用于编译 Vue 3 的单文件组件</li><li>它包含 Vue 3 的 SFC 编译逻辑，并负责将组件模板编译为渲染函数</li><li>使用这个库可以解析 <code>.vue</code> 文件的 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 以及其他自定义块，并编译模板成为渲染函数</li><li><code>@vue/compiler-sfc</code> 通常和 <code>vue-loader</code> 一同工作，在 webpack 构建流程中协同工作，进行源码到最终 JavaScript 代码的转换</li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> vue-loader可以干什么 </summary>
              <div class='content'>
              <ul><li><p><code>vue-loader</code> </p><p>一个 webpack 的 loader，它允许你以一种名为单文件组件（SFCs）的格式编写 Vue 组件</p><p>SFCs 通常保存在扩展名为 <code>.vue</code> 的文件中</p></li><li><p><code>.vue</code> 文件是一个自定义的文件类型，它允许开发者将一个组件的模板、脚本和样式封装在单个文件中</p></li><li><p>在构建过程中，<code>vue-loader</code> 会解析文件，抽取每个语言块（template、script、style 等），并需要相应的 loader 来处理它们，例如 <code>vue-template-compiler</code> 用于模板编译、<code>css-loader</code> 用于处理 CSS、<code>babel-loader</code> 用于处理 JavaScript 等</p></li></ul>
              </div>
            </details>
<p><br /></p>
<h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>控制台输入<code>npm run dev</code></p>
<p>这时候编辑器会自动在打包好以后给你在浏览器打开端口3000的地址</p>
<p><img src="https://s2.loli.net/2024/05/20/AXjsW5o4YJR1FMx.png" alt="image-20240520161359316"></p>
<p><br /></p>
<h4 id="控制台警告"><a href="#控制台警告" class="headerlink" title="控制台警告"></a>控制台警告</h4><p>打开控制台会发现</p>
<blockquote>
<p>[!WARNING]</p>
<p>Feature flags <strong>VUE_OPTIONS_API</strong>, <strong>VUE_PROD_DEVTOOLS</strong>, <strong>VUE_PROD_HYDRATION_MISMATCH_DETAILS</strong> are not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.</p>
</blockquote>
<p>这是因为你正在使用 Vue 的 ESM Bundler 构建，但没有在你的构建配置中显式地定义这些 Vue 的特性标志（Feature flag）</p>
<p>这些特性标志在 Vue 3 中用于启用或禁用 Vue 的一些特性</p>
<ul>
<li><p><code>__VUE_OPTIONS_API__</code></p>
<p>是否启用 Options API，如果你仅使用 Composition API，可以将其设置为 false，以减小最终的构建大小</p>
</li>
<li><p><code>__VUE_PROD_DEVTOOLS__</code></p>
<p>是否在生产环境中启用 Vue Devtools，如果不需要，可以设置为 false 来优化应用性能</p>
</li>
<li><p><code>__VUE_PROD_HYDRATION_MISMATCH_DETAILS__</code></p>
<p>对于服务器端渲染 (SSR) 的应用，是否应在生产环境中公开 hydration 不匹配细节，为了避免关键的信息泄露，可以设置为 false</p>
</li>
</ul>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="attr">__VUE_OPTIONS_API__</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">__VUE_PROD_DEVTOOLS__</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">__VUE_PROD_HYDRATION_MISMATCH_DETAILS__</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="3-4-样式系列"><a href="#3-4-样式系列" class="headerlink" title="3.4-样式系列"></a>3.4-样式系列</h3><p>在前端工程化里面，常用的预编译的<code>css</code>就是<code>less</code>、<code>scss</code>、<code>sass</code>，这里我们选用<code>less</code>来作为项目的预编译器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install css-loader style-loader less-loader less --save-dev</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue-loader配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">VueLoaderPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// 这里是模块规则的数组，用于配置不同类型的文件如何被处理</span></span><br><span class="line">            <span class="comment">// 每个规则包括测试表达式（test）、加载器（loader）和选项（options）等</span></span><br><span class="line">    </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.css文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 将CSS样式插入到DOM中</span></span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.less文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 将CSS样式插入到DOM中</span></span><br><span class="line">                    <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 编译LESS到CSS</span></span><br><span class="line">                    <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> 为什么样式的use需要这么写 </summary>
              <div class='content'>
              <ol><li><p><strong>处理顺序</strong></p><p><code>webpack</code> 使用 <code>loaders</code> 时遵循从右到左（或从下到上）的处理顺序</p><p>也就是说，在 <code>.less</code> 文件的处理链中，<code>less-loader</code> 首先工作，将 <code>LESS</code> 代码编译成 <code>CSS</code></p><p>然后 <code>css-loader</code> 处理得到的 <code>CSS</code> 代码，支持模块化等特性</p><p>最后 <code>style-loader</code> 将最终的 <code>CSS</code> 代码插入到 <code>DOM</code> 中</p><p>对于 <code>.css</code> 文件，由于不需要编译，所以不用 <code>less-loader</code></p></li><li><p><strong>功能划分</strong></p><p>每个 <code>loader</code> 都有自己的责任范围。<code>style-loader</code> 负责样式的加载到 <code>DOM</code>，<code>css-loader</code> 负责处理 CSS 文件中的依赖（如<code>@import</code>、<code>url()</code>等），<code>less-loader</code> 负责将 <code>LESS</code> 编译成 <code>CSS</code></p><p>这样的设计使得 <code>webpack</code> 配置更加灵活和模块化</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> css预编译是什么 </summary>
              <div class='content'>
              <p><code>CSS</code> 预编译器是一种用于扩展 <code>CSS</code> 语言的工具，它允许开发者使用更动态、更丰富的语法来书写样式，然后再将这些代码编译成标准的 <code>CSS</code> 文件，以便浏览器可以解析</p><p><code>CSS</code> 预编译器添加了许多编程特性，比如变量、嵌套规则、混入（<code>Mixins</code>）、函数等，这些特性使得编写 <code>CSS</code> 更加高效和可维护</p><ul><li><p><strong>Sass(SCSS)</strong></p><p>提供了很多高级功能，如变量，嵌套和混合等</p><p><code>Sass</code> 的语法是符合 <code>CSS3</code> 标准的，因此它看起来就像是增强了的 <code>CSS</code> 代码</p></li><li><p><strong>LESS</strong></p><p>与 Sass 类似，也提供了变量，嵌套，混合以及其他高级功能，主要差异在于语法和一些功能的实现</p></li><li><p><strong>Stylus</strong></p><p>提供了强大的功能和极其灵活的语法，与其他预处理器相比，它有着更加丰富的选择和高度的自定义</p></li></ul><p>使用 <code>CSS</code> 预处理器的好处包括：</p><ol><li><strong>更轻松地维护大型样式表</strong>：通过嵌套规则，可以更清晰地表示元素之间的层级关系</li><li><strong>代码的复用</strong>：使用混合（<code>mixins</code>），可以将一组属性从一个规则集引入到另一个规则集</li><li><strong>更快的开发速度</strong>：可以定义具有有参数的混合，以及使用循环构建复杂的样式网络</li><li><strong>更丰富的表现力</strong>：使用函数和条件语句可以更灵活地控制样式</li><li><strong>代码组织</strong>：允许分割 <code>CSS</code> 到多个文件中，可以有助于组织和管理样式代码</li></ol><p>这些预处理器通常需要使用特定的构建工具（如 <code>webpack</code> 或 <code>Gulp</code>）来编译为浏览器可解析的标准 <code>CSS</code> 文件</p><p>在现代 <code>web</code> 开发流程中，这些工具通常会集成在自动化构建系统中，以优化开发流程</p>
              </div>
            </details>
<p><br /></p>
<h2 id="四、优化项目"><a href="#四、优化项目" class="headerlink" title="四、优化项目"></a>四、优化项目</h2><h3 id="4-1-Javascript代码兼容"><a href="#4-1-Javascript代码兼容" class="headerlink" title="4.1-Javascript代码兼容"></a>4.1-Javascript代码兼容</h3><p>运行命令安装<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader @babel/core @babel/plugin-transform-runtime @babel/preset-env @babel/plugin-proposal-class-properties</span><br></pre></td></tr></table></figure>
<p>通过合并这些工具，你可以编写使用最新JavaScript语法（ES6/ES7及以上）的代码，然后将其转译为更广泛兼容的JavaScript版本（通常是ES5），以确保你的应用或网站可以在旧版浏览器和环境中运行</p>
<p>这对于前端项目来说是非常重要的，因为这意味着开发者可以利用最新的语言特性来编写更简洁、更易于维护的代码，同时又不牺牲兼容性</p>
<p>项目目录下新建<code>.babelrc</code>的配置文件并写入</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@babel/preset-env&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;@babel/plugin-transform-runtime&quot;</span><span class="punctuation">,</span> <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">                </span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> babel-loader干什么的 </summary>
              <div class='content'>
              <p>这是一个Webpack的loader，用于在Webpack构建过程中调用Babel转译器</p><p>它允许Webpack处理JavaScript代码，将其通过Babel转换成浏览器兼容的版本</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> @babel/plugin-transform-runtime干什么的 </summary>
              <div class='content'>
              <p>这个插件优化了Babel转译过程中的辅助代码</p><p>使用这个插件后，可以减少编译后代码的冗余（比如，避免多个文件重复包含同一辅助函数)，并能够使用<code>@babel/runtime</code>包来重复使用Babel转译的辅助代码</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> @babel/plugin-proposal-class-properties干什么的 </summary>
              <div class='content'>
              <p>这个Babel插件使你能在JavaScript类中使用静态属性和实例属性的声明语法</p><p>此特性曾是草案提案的一部分，在未来版本的JavaScript正式标准中得到支持之前，这个插件可以让你在当前的JavaScript代码中使用这些特性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> @babel/core干什么的 </summary>
              <div class='content'>
              <p>Babel的核心功能包含在这个包中</p><p>它提供了Babel转译器的核心API，用于转译JavaScript代码</p><p>没有它，Babel的其他插件或预设都无法运行</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> @babel/preset-env干什么的 </summary>
              <div class='content'>
              <p>一个Babel预设（preset）是一系列插件的集合，旨在支持特定的语言特性</p><p><code>@babel/preset-env</code>是一个智能预设，它能够根据你的目标环境（如特定版本的浏览器或Node.js）自动确定需要转译的JavaScript特性</p><p>它可以让你使用最新的JavaScript，而不用担心兼容性问题</p><p><code>@babel/preset-env</code>根据<code>browserslist</code>配置，只包含所需的Babel插件和polyfills来转译新的JavaScript语法，从而为你的目标环境量身定制输出</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-2-Css代码兼容"><a href="#4-2-Css代码兼容" class="headerlink" title="4.2-Css代码兼容"></a>4.2-Css代码兼容</h3><p>运行命令安装<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader postcss-flexbugs-fixes postcss-preset-env postcss-normalize autoprefixer postcss-nested --save-dev</span><br></pre></td></tr></table></figure>
<p><code>user-select</code>是一个很特殊的属性, 因为针对不同的浏览器要对它做不同的适配</p>
<p>这个写法兼容了这个属性</p>
<p>项目目录下创建<code>.browserslistrc</code>文件添加下面代码</p>
<p>用于指明想要支持的浏览器版本</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">last <span class="number">1</span> version</span><br><span class="line">&gt; <span class="number">1</span>%</span><br><span class="line">IE <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>项目目录下创建<code>postcss.config.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flexbugsFixes = <span class="built_in">require</span>(<span class="string">&#x27;postcss-flexbugs-fixes&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> presetEnv = <span class="built_in">require</span>(<span class="string">&#x27;postcss-preset-env&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> normalize = <span class="built_in">require</span>(<span class="string">&#x27;postcss-normalize&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> nested = <span class="built_in">require</span>(<span class="string">&#x27;postcss-nested&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个配置对象，用于PostCSS的处理</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 标识这个配置是为PostCSS准备的</span></span><br><span class="line">    <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">    <span class="comment">// 使用的插件列表</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        flexbugsFixes,</span><br><span class="line">        <span class="title function_">presetEnv</span>(&#123;</span><br><span class="line">            <span class="attr">autoprefixer</span>: &#123;</span><br><span class="line">                <span class="attr">flexbox</span>: <span class="string">&#x27;no-2009&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">stage</span>: <span class="number">3</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title function_">normalize</span>(),</span><br><span class="line">        nested</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">    		&#123;</span><br><span class="line">                <span class="comment">// 匹配.css文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 根据开发环境选择使用style-loader或将CSS提取到单独的文件中</span></span><br><span class="line">                    <span class="title class_">IsDev</span> ? <span class="string">&quot;style-loader&quot;</span> : <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                    <span class="comment">// 对CSS文件进行处理，支持模块化、压缩等操作</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;postcss-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.less文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 同上，根据开发环境选择合适的CSS加载器</span></span><br><span class="line">                    <span class="title class_">IsDev</span> ? <span class="string">&quot;style-loader&quot;</span> : <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 将LESS编译为CSS</span></span><br><span class="line">                    <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> postcss-loader可以干什么 </summary>
              <div class='content'>
              <p>用于在Webpack中集成PostCSS</p><p>它允许你使用PostCSS来处理CSS文件，通常与其他PostCSS插件配合使用</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> postcss-flexbugs-fixes可以干什么 </summary>
              <div class='content'>
              <p>一个PostCSS插件，用于尝试修复一些常见的flexbox的bug</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> postcss-preset-env可以干什么 </summary>
              <div class='content'>
              <p>这个插件包含了一组现代的CSS特性，使开发者可以使用未来CSS标准的语法，并且会根据浏览器的兼容情况自动做出适当的转换</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> postcss-normalize可以干什么 </summary>
              <div class='content'>
              <p>根据<code>browserslist</code>配置和CSS规则自动引入适当的<code>normalize.css</code>内容，以确保不同浏览器之间的一致性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> autoprefixer可以干什么 </summary>
              <div class='content'>
              <p>一个自动添加浏览器前缀的PostCSS插件，使开发者编写的CSS规则兼容多种浏览器</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> postcss-nested可以干什么 </summary>
              <div class='content'>
              <p>允许你在写CSS时使用嵌套语法，类似于Sass和Less之类的预处理器提供的功能</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-3-压缩Javascript代码"><a href="#4-3-压缩Javascript代码" class="headerlink" title="4.3-压缩Javascript代码"></a>4.3-压缩Javascript代码</h3><p>在开发环境中，通常更关注的是构建速度和增量构建的效率，以便快速预览和测试更改</p>
<p>因此，开发环境下一般不会开启压缩这样的耗时步骤</p>
<p>相对的，生产环境打包时的目标是减少应用的加载时间和网络传输成本，所以会使用<code>terser-webpack-plugin</code>这样的压缩工具来移除JavaScript代码中的所有多余空格、注释、未使用的代码等，以实现代码的最小化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>, <span class="comment">// 开启代码压缩</span></span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123; <span class="comment">// 使用TerserPlugin作为压缩工具</span></span><br><span class="line">                <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">                    <span class="attr">mangle</span>: &#123; <span class="comment">// 代码混淆相关选项</span></span><br><span class="line">                        <span class="attr">safari10</span>: <span class="literal">true</span>, <span class="comment">// 处理Safari 10/11的bug，避免在这些老版本Safari浏览器中出现的“删除”bug（删除let和const变量会抛出错误）</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">compress</span>: &#123; <span class="comment">// 代码压缩相关选项</span></span><br><span class="line">                        <span class="comment">// 下面的选项都是用来指定terser在压缩过程中是否应用某些转换</span></span><br><span class="line">                        <span class="attr">arrows</span>: <span class="literal">false</span>, <span class="comment">// 不转换箭头函数为ES5函数表达式</span></span><br><span class="line">                        <span class="attr">collapse_vars</span>: <span class="literal">false</span>, <span class="comment">// 不折叠具有单一使用的变量</span></span><br><span class="line">                        <span class="attr">comparisons</span>: <span class="literal">false</span>, <span class="comment">// 不进行优化比较操作</span></span><br><span class="line">                        <span class="attr">computed_props</span>: <span class="literal">false</span>, <span class="comment">// 不优化计算属性</span></span><br><span class="line">                        <span class="attr">hoist_funs</span>: <span class="literal">false</span>, <span class="comment">// 不提升函数声明</span></span><br><span class="line">                        <span class="attr">hoist_props</span>: <span class="literal">false</span>, <span class="comment">// 不提升对象属性</span></span><br><span class="line">                        <span class="attr">hoist_vars</span>: <span class="literal">false</span>, <span class="comment">// 变量提升关闭 (var 声明会被提升至函数作用域的顶部)</span></span><br><span class="line">                        <span class="attr">inline</span>: <span class="literal">false</span>, <span class="comment">// 不内联函数</span></span><br><span class="line">                        <span class="attr">loops</span>: <span class="literal">false</span>, <span class="comment">// 不优化循环</span></span><br><span class="line">                        <span class="attr">negate_iife</span>: <span class="literal">false</span>, <span class="comment">// 不否定立即执行的函数表达式</span></span><br><span class="line">                        <span class="attr">properties</span>: <span class="literal">false</span>, <span class="comment">// 不优化属性访问</span></span><br><span class="line">                        <span class="attr">reduce_funcs</span>: <span class="literal">false</span>, <span class="comment">// 不内联仅用一次的函数</span></span><br><span class="line">                        <span class="attr">reduce_vars</span>: <span class="literal">false</span>, <span class="comment">// 不减少非常量变量的引用</span></span><br><span class="line">                        <span class="attr">switches</span>: <span class="literal">false</span>, <span class="comment">// 不移除switch的分支</span></span><br><span class="line">                        <span class="attr">toplevel</span>: <span class="literal">false</span>, <span class="comment">// 不删除顶级函数和变量定义</span></span><br><span class="line">                        <span class="attr">typeofs</span>: <span class="literal">false</span>, <span class="comment">// 不进行typeofs优化</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 以下选项开启了一些常见的压缩优化策略</span></span><br><span class="line">                        <span class="attr">booleans</span>: <span class="literal">true</span>, <span class="comment">// 优化布尔表达式</span></span><br><span class="line">                        <span class="attr">if_return</span>: <span class="literal">true</span>, <span class="comment">// 优化if-return和if-continue</span></span><br><span class="line">                        <span class="attr">sequences</span>: <span class="literal">true</span>, <span class="comment">// 使用逗号运算符合并多个语句到一个表达式</span></span><br><span class="line">                        <span class="attr">unused</span>: <span class="literal">true</span>, <span class="comment">// 删除未使用的变量/function</span></span><br><span class="line">                        <span class="attr">conditionals</span>: <span class="literal">true</span>, <span class="comment">// 优化if-s和条件表达式</span></span><br><span class="line">                        <span class="attr">dead_code</span>: <span class="literal">true</span>, <span class="comment">// 移除不可到达的代码</span></span><br><span class="line">                        <span class="attr">evaluate</span>: <span class="literal">true</span>, <span class="comment">// 计算常量表达式</span></span><br><span class="line">                        <span class="attr">warnings</span>: <span class="literal">false</span>, <span class="comment">// 关闭Terser的警告信息，使构建输出更干净</span></span><br><span class="line">                        <span class="attr">drop_console</span>: <span class="literal">true</span>, <span class="comment">// 删除所有的console语句，可以减少最终输出的文件大小，对于生产环境是推荐的</span></span><br><span class="line">                        <span class="attr">pure_funcs</span>: [<span class="string">&#x27;console.log&#x27;</span>], <span class="comment">// 移除代码中的console.log调用</span></span><br><span class="line">                        <span class="comment">// 与drop_console相似，但是提供了更细致的控制，可以指定只删除某些特定的console方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span>, <span class="comment">// 并行压缩以提升构建速度</span></span><br><span class="line">                <span class="attr">extractComments</span>: <span class="literal">false</span>, <span class="comment">// 不把注释提取到一个单独的文件中，即去掉所有注释</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	... other code ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> TerserPlugin解析 </summary>
              <div class='content'>
              <ol><li><p><code>optimization</code>配置</p><ul><li><p><strong>minimize</strong></p><p> 设置为<code>true</code>，表示启用代码压缩</p><p>这是生产环境构建时常用的设置，旨在减小最终生成文件的大小，以提高加载速度和执行效率</p></li><li><p><strong>minimizer</strong></p><p>这是一个数组，允许为压缩过程指定一个或多个压缩插件</p><p>在此配置中，使用了<code>TerserPlugin</code>作为压缩工具</p></li></ul></li><li><p><code>TerserPlugin</code>配置</p><ul><li><p><strong>parallel</strong></p><p>设置为<code>true</code>，启用并行压缩</p><p>这意味着将同时使用多个子进程来进行代码压缩，可以显著加快构建速度</p></li><li><p><strong>extractComments</strong></p><p>设置为<code>false</code>，表示不将注释抽取到单独的文件中，即去除代码中的所有注释</p><p>这有助于进一步减小文件体积</p></li></ul></li><li><p><code>terserOptions</code>配置</p><ul><li><p><code>mangle</code>配置</p><ul><li><p><strong>safari10</strong></p><p>设置为<code>true</code>可避免在Safari 10/11上发生的一个已知问题，即在这些早期版本的Safari浏览器中，错误地删除<code>let</code>和<code>const</code>声明可能会导致脚本错误</p></li></ul></li><li><p><code>compress</code>配置</p><ul><li><p><strong>arrows、collapse_vars、comparisons、computed_props、hoist_funs、hoist_props、hoist_vars、inline、loops、negate_iife、properties、reduce_funcs、reduce_vars、switches、toplevel、typeofs</strong></p><p>这些选项被设置为<code>false</code>，意味着在压缩过程中不应用这些特定的代码转换</p><p>这些设置保证了代码转换的精细控制，避免可能导致代码运行出现问题的激进优化策略</p></li><li><p><strong>booleans、if_return、sequences、unused、conditionals、dead_code、evaluate</strong></p><p>这些选项被设置为<code>true</code>，允许Terser应用这些常见的压缩优化策略，如优化布尔表达式、if-返回模式、无用代码的剔除等，以达到减少代码体积和提高执行效率的目的</p></li><li><p><strong>warnings</strong></p><p>设置为<code>false</code>以在压缩过程中不显示警告信息，使构建输出更干净</p></li><li><p><strong>drop_console</strong></p><p>设置为<code>true</code>以删除所有的console语句</p><p>这有助于在生产环境中减少文件大小，提升运行性能</p></li><li><p><strong>pure_funcs</strong></p><p>设置为<code>[&#39;console.log&#39;]</code>，指示Terser删除所有<code>console.log</code>调用</p><p>这是一种比<code>drop_console</code>更细粒度的控制方式，允许保留如<code>console.error</code>或<code>console.warn</code>等可能对调试有用的console调用</p></li></ul></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> terser-webpack-plugin是干什么的 </summary>
              <div class='content'>
              <p><code>terser-webpack-plugin</code>是一个用于Webpack的插件</p><p>它的主要作用是在Webpack构建过程中压缩和优化JavaScript代码</p><p>这个插件使用Terser作为其压缩引擎，Terser是一个专为ES6+代码设计的JavaScript解析器和压缩器</p><p>通过去除代码中的所有不必要的字符（例如空格和注释）以及执行代码转换优化（如缩短变量名和删除未使用的代码），它能够减小JavaScript文件的大小，从而加快页面加载速度和提高应用程序的性能</p><p><code>terser-webpack-plugin</code>插件的主要特性包括：</p><ol><li><p><strong>删除未使用的代码</strong>（Dead code elimination）</p><p>删除那些已经写在代码中但实际上从未被执行或使用的部分</p></li><li><p><strong>压缩代码</strong></p><p>通过各种转换（如变量名缩短和优化逻辑表达式）来减少代码体积</p></li><li><p><strong>删除调试语句</strong></p><p>例如，可以配置插件来删除所有<code>console.log</code>语句</p></li><li><p><strong>支持ES6+语法</strong></p><p>能够压缩和优化ES6+语法的代码</p></li><li><p><strong>多线程压缩</strong></p><p>支持并行压缩，可以利用多核CPU加速代码的压缩过程</p></li><li><p><strong>自定义压缩选项</strong></p><p>用户可以通过自定义<code>terserOptions</code>来控制具体的压缩行为</p></li><li><p><strong>条件性注释的提取</strong></p><p>可以配置插件提取和保留特定的注释（例如版权声明）</p></li></ol><p>在使用<code>Webpack</code>进行现代<code>JavaScript</code>应用程序的构建过程中，压缩和优化代码是一个重要步骤</p><p><code>terser-webpack-plugin</code>提供了一个高效且灵活的方式来实现这一步骤，它可以帮助开发者缩短构建时间和减小最终生成文件的大小，改善用户体验</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-4-压缩Css代码"><a href="#4-4-压缩Css代码" class="headerlink" title="4.4-压缩Css代码"></a>4.4-压缩Css代码</h3><p>运行以下代码安装对应的<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Css提取分离</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开发环境</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">IsDev</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.css文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 根据开发环境选择使用style-loader或将CSS提取到单独的文件中</span></span><br><span class="line">                    <span class="title class_">IsDev</span> ? <span class="string">&quot;style-loader&quot;</span> : <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                    <span class="comment">// 对CSS文件进行处理，支持模块化、压缩等操作</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匹配.less文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="comment">// 同上，根据开发环境选择合适的CSS加载器</span></span><br><span class="line">                    <span class="title class_">IsDev</span> ? <span class="string">&quot;style-loader&quot;</span> : <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">                    <span class="comment">// 处理CSS文件，支持模块化、压缩等</span></span><br><span class="line">                    <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">                    <span class="comment">// 将LESS编译为CSS</span></span><br><span class="line">                    <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>:<span class="string">&#x27;[name]_[chunkhash:8].css&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩Css代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>, <span class="comment">// 开启代码压缩</span></span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="comment">// 使用css-minimizer-webpack-plugin插件实例进行CSS优化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CssMinimizerWebpackPlugin</span>(&#123;</span><br><span class="line">                <span class="comment">// 启用并行处理，提高构建性能，特别是在有大量CSS文件需要被压缩的情况下</span></span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// minimizerOptions用于传递选项到cssnano，它是css-minimizer-webpack-plugin背后的CSS压缩工具</span></span><br><span class="line">                <span class="attr">minimizerOptions</span>: &#123;</span><br><span class="line">                    <span class="comment">// &#x27;default&#x27;预设意味着使用cssnano的默认压缩选项，</span></span><br><span class="line">                    <span class="comment">// 这是一个适用于大多数场景的平衡配置，它既压缩了代码，也考虑了性能和兼容性</span></span><br><span class="line">                    <span class="attr">preset</span>: <span class="string">&#x27;default&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	... other code ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> css-minimizer-webpack-plugin是干什么的 </summary>
              <div class='content'>
              <p><code>mini-css-extract-plugin</code>是一个用于将CSS从JavaScript文件中提取到独立的CSS文件中的插件</p><p>这对于那些想要将CSS代码分离出来，以便单独缓存和加载的项目非常实用</p><p>它的主要特点包括：</p><ul><li><p><strong>分离CSS</strong></p><p>允许你将CSS从JavaScript中提取成单独的文件</p><p>这意味着CSS可以独立于JavaScript被浏览器加载和缓存，也就是说可以无需执行JavaScript就预先加载CSS</p></li><li><p><strong>异步加载</strong></p><p>支持加载非关键CSS，并异步加载次要的CSS文件，从而提升页面的渲染速度</p></li><li><p><strong>缓存优化</strong></p><p>由于CSS文件是独立的，这有助于客户端更高效地缓存它们，只有在文件发生变动时才需要重新下载</p></li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> mini-css-extract-plugin是干什么的 </summary>
              <div class='content'>
              <p><code>css-minimizer-webpack-plugin</code> 是一个用于压缩和优化CSS资源的插件</p><p>它利用了各种CSS压缩器，如cssnano，以最小化CSS文件的大小</p><p>这对于生产环境特别有用，因为它可以减少CSS资源的加载时间，从而提高网页加载速度并提升用户体验</p><p>它的主要特点包括：</p><ul><li><p><strong>压缩CSS文件</strong></p><p>它可以减少CSS文件的大小，通过移除空格、注释、不必要的后缀等</p></li><li><p><strong>支持Source Maps</strong></p><p>它可以生成Source Maps，帮助开发人员在开发工具中跟踪CSS源代码</p></li><li><p><strong>使用PostCSS</strong></p><p>它通常使用PostCSS生态中的工具进行CSS处理</p></li></ul>
              </div>
            </details>
<p><br /></p>
<h3 id="4-5-自动引入Element-Plus组件"><a href="#4-5-自动引入Element-Plus组件" class="headerlink" title="4.5-自动引入Element Plus组件"></a>4.5-自动引入Element Plus组件</h3><p>项目使用的<code>UI</code>框架以<code>Element Plus</code>为例子，需要运行以下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install element-plus @element-plus/icons-vue --save</span><br></pre></td></tr></table></figure>
<p>并且安装对应的自动导入的<code>webpack</code>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -D unplugin-vue-components unplugin-auto-import unplugin-icons</span><br></pre></td></tr></table></figure>
<p>这3个npm包截止目前2024年5月20日为止，最新的版本都是有问题的，运行的时候webpack会报错，类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError: IconsResolver is not a function</span><br><span class="line">TypeError: Components is not a function</span><br><span class="line">TypeError: AutoImport is not a function</span><br></pre></td></tr></table></figure>
<p>所以为了解决这个问题，回退一下版本就可以了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;unplugin-auto-import&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.16.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;unplugin-icons&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.14.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;unplugin-vue-components&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.25.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element Plus</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AutoImport</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-auto-import/webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Components</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-vue-components/webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ElementPlusResolver</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">IconsResolver</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-icons/resolver&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Icons</span> = <span class="built_in">require</span>(<span class="string">&#x27;unplugin-icons/webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置自动导入组件的功能</span></span><br><span class="line"><span class="comment">         * 使用ElementPlusResolver以便自动解析并导入Element Plus组件库中的组件。</span></span><br><span class="line"><span class="comment">         * 这样做旨在避免手动导入组件，从而提高开发效率。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [</span><br><span class="line">                <span class="title class_">ElementPlusResolver</span>()</span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注册组件的配置</span></span><br><span class="line"><span class="comment">         * 通过使用ElementPlusResolver，自动注册Element Plus组件库中的所有组件。</span></span><br><span class="line"><span class="comment">         * 使得这些组件在应用中可以直接使用，简化了组件注册流程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title class_">Components</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [</span><br><span class="line">                <span class="title class_">ElementPlusResolver</span>(),</span><br><span class="line">                <span class="title class_">IconsResolver</span>(&#123;</span><br><span class="line">                    <span class="comment">// 修改Icon组件前缀，不设置则默认为i,禁用则设置为false</span></span><br><span class="line">                    <span class="attr">prefix</span>: <span class="string">&#x27;icon&#x27;</span>,</span><br><span class="line">                    <span class="comment">// 仅启用名为&#x27;ep&#x27;的图标集合</span></span><br><span class="line">                    <span class="attr">enabledCollections</span>: [<span class="string">&#x27;ep&#x27;</span>],</span><br><span class="line">                &#125;)</span><br><span class="line">            ]</span><br><span class="line">        &#125;),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 配置图标插件，自动安装所需的图标库</span></span><br><span class="line">        <span class="title class_">Icons</span>(&#123;</span><br><span class="line">            <span class="attr">autoInstall</span>: <span class="literal">true</span> <span class="comment">// 自动安装图标库</span></span><br><span class="line">        &#125;),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-6-运行进度展示"><a href="#4-6-运行进度展示" class="headerlink" title="4.6-运行进度展示"></a>4.6-运行进度展示</h3><p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> webpack.<span class="title class_">ProgressPlugin</span>(), <span class="comment">// 运行进度</span></span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子可以帮助我们清晰的知道<code>webpack</code>的打包进度</p>
<p><img src="https://s2.loli.net/2024/05/20/T7Sys8C1RcgU62W.png" alt="image-20240520173808174"></p>
<p><br /></p>
<h3 id="4-7-Css的Tree-Shaking"><a href="#4-7-Css的Tree-Shaking" class="headerlink" title="4.7-Css的Tree-Shaking"></a>4.7-Css的Tree-Shaking</h3><p>运行下面的命令安装<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install purgecss-webpack-plugin glob -D</span><br></pre></td></tr></table></figure>
<p><code>purgecss-webpack-plugin</code>和<code>glob</code>是两个Node.js的包</p>
<p>它们通常在使用Webpack进行前端项目构建时用于优化CSS</p>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Css Tree-Shaking优化</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">PurgeCSSPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;purgecss-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PurgeCSSPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">// paths是一个配置项，该项接受一个文件路径数组。</span></span><br><span class="line">            <span class="comment">// 这些路径指向你的项目中的HTML文件或者模板，以及可能包含CSS类的JavaScript组件文件。</span></span><br><span class="line">            <span class="attr">paths</span>: glob.<span class="title function_">sync</span>([</span><br><span class="line">                    <span class="comment">// path.join(__dirname, &#x27;./public/index.html&#x27;)生成了指向项目中的index.html文件的绝对路径。</span></span><br><span class="line">                    <span class="comment">// __dirname是Node.js中的一个全局变量，它返回当前正在执行的脚本所在的目录。</span></span><br><span class="line">                    path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../index.html&#x27;</span>),</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// path.join(__dirname, &#x27;./src/**/*&#x27;)生成了一个glob模式，这个模式匹配src目录及其所有子目录下的所有文件。</span></span><br><span class="line">                    <span class="comment">// &#x27;./src/**/*&#x27; 是一个使用glob语法的模式字符串，表示src目录下的任意深度的所有文件。</span></span><br><span class="line">                    <span class="comment">// ** 是一个glob星号，匹配任意数量的目录和子目录。</span></span><br><span class="line">                    <span class="comment">// * 是一个glob星号，匹配任意数量的字符，除了路径分隔符（如/）。</span></span><br><span class="line">                    path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../src/**/*&#x27;</span>),</span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// nodir选项设置为true，意味着返回的匹配结果中不包含目录路径，只有文件路径。</span></span><br><span class="line">                <span class="comment">// 这确保PurgeCSSPlugin只会接收到文件路径，而不是目录路径，因为插件需要文件内容来确定哪些CSS类是被使用的。</span></span><br><span class="line">                &#123;<span class="attr">nodir</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> purgecss-webpack-plugin是干什么的 </summary>
              <div class='content'>
              <p><code>purgecss-webpack-plugin</code>是Webpack的一个插件，用于从你的最终CSS文件中删除未使用的样式，从而减小CSS文件的大小，加快加载速度</p><p>在构建过程中，特别是在生产环境中，移除那些在HTML文件或者JSX/模板组件中没有用到的CSS规则可以显著减少文件大小，从而提高性能</p><p>使用<code>purgecss-webpack-plugin</code>通常涉及在webpack配置中引入并配置该插件，指定它应该检查的文件路径（例如HTML模板、JS/JSX文件等），以便于分析哪些CSS类被实际使用了。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> glob是干什么的 </summary>
              <div class='content'>
              <p><code>glob</code>是一个小而强大的Node.js库，提供了一种根据所提供的模式匹配对文件进行搜索的方式，模式匹配通常被称作 “globbing”</p><p><code>glob</code>的功能不仅限于Node.js脚本中使用，它也经常与其他工具和插件一起用于前端项目中，比如与<code>purgecss-webpack-plugin</code>一起使用来指定需要分析的文件集合</p><p>在与<code>purgecss-webpack-plugin</code>一起使用时，<code>glob</code>可以帮助定义要清除未使用CSS的文件路径的模式（比如：”src/<em>*/</em>.html”表示项目src目录下的所有HTML文件），这使得<code>purgecss-webpack-plugin</code>能够有效地识别和移除所有未使用的CSS样式</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-8-删除上一次打包残留的dist文件"><a href="#4-8-删除上一次打包残留的dist文件" class="headerlink" title="4.8-删除上一次打包残留的dist文件"></a>4.8-删除上一次打包残留的dist文件</h3><p>运行下面的命令安装<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除上次打包的残留</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">// cleanStaleWebpackAssets: 当值为true时，插件将会在构建完成后，</span></span><br><span class="line">            <span class="comment">// 清理Webpack在上一次构建时生成，但这一次构建未再次生成的文件资产（assets）。</span></span><br><span class="line">            <span class="comment">// 这是一个用于控制是否应该清理在重新构建时不再使用的旧文件的布尔值。</span></span><br><span class="line">            <span class="comment">// 默认情况下，这个值是true——每次只有新产生的文件会被保留，</span></span><br><span class="line">            <span class="comment">// 所有的旧文件会在下一次构建完成之后被删除。</span></span><br><span class="line">            <span class="attr">cleanStaleWebpackAssets</span>: <span class="literal">true</span>,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cleanOnceBeforeBuildPatterns: 这个选项允许你定义一个模式数组（patterns array），</span></span><br><span class="line">            <span class="comment">// 插件会在Webpack构建前根据这些模式清理文件和目录。</span></span><br><span class="line">            <span class="comment">// 不同的模式可以匹配不同的文件或目录，以供清理。</span></span><br><span class="line">            <span class="comment">// 在此例中，它使用glob模式，以确保Webpack在构建之前清理指定目录。</span></span><br><span class="line">            <span class="comment">// path.resolve(__dirname, &quot;../dist&quot;) 用于生成“dist”目录的绝对路径。</span></span><br><span class="line">            <span class="comment">// 通常 &quot;__dirname&quot; 是Node.js中的一个全局变量，</span></span><br><span class="line">            <span class="comment">// 它返回代表当前执行脚本所在的目录的路径。</span></span><br><span class="line">            <span class="comment">// 通过 &quot;..&quot; 返回到上一级目录，再与 &quot;dist&quot; 连接起来形成清理路径，</span></span><br><span class="line">            <span class="comment">// 确保不管在哪个工作目录下执行Webpack，指定的“dist”文件夹路径都是正确的。</span></span><br><span class="line">            <span class="attr">cleanOnceBeforeBuildPatterns</span>: [ path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../dist&quot;</span>) ]</span><br><span class="line">        &#125;),</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> clean-webpack-plugin可以干什么 </summary>
              <div class='content'>
              <p><code>CleanWebpackPlugin</code>是一个在每次构建前自动清理/删除Webpack的<code>output.path</code>目录中的所有文件的插件</p><p>这个插件确保你的输出目录只包含用当前配置和源代码生成的文件，从而避免了构建残留文件的积累</p><p>使用<code>CleanWebpackPlugin</code>的主要好处包括：</p><ol><li><p><strong>保持输出目录的清洁</strong></p><p>在新的构建过程中自动删除过时的文件，保证你的发布目录始终只包含最新的输出资源</p></li><li><p><strong>减少手动干预</strong></p><p>自动处理文件删除，减少了需要手动清理输出目录的情况，特别是在频繁构建的开发过程中</p></li><li><p><strong>避免潜在的构建错误</strong></p><p>有时候，旧的文件和新生成的文件冲突会引发意外的问题</p><p>通过清除旧文件，可以减少这种问题的发生</p></li><li><p><strong>简化部署过程</strong></p><p>确保你部署的只是新生成的文件，而不是一堆已经过时的资源</p></li></ol>
              </div>
            </details>
<p><br /></p>
<h3 id="4-9-图片资源处理"><a href="#4-9-图片资源处理" class="headerlink" title="4.9-图片资源处理"></a>4.9-图片资源处理</h3><p>webpack5不需要安装额外的loader来处理，直接写就可以</p>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理图像文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp|avif)(\?.*)?$/</span>, <span class="comment">// 匹配多种图像文件格式</span></span><br><span class="line">                <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>, <span class="comment">// 将图像文件作为资产处理</span></span><br><span class="line">                <span class="attr">parser</span>: &#123;</span><br><span class="line">                    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                        <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 图片大小小于10KB将会被转成base64</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">generator</span>: &#123;</span><br><span class="line">                    <span class="attr">filename</span>: <span class="string">&quot;static/images/[hash:8][ext]&quot;</span>, <span class="comment">// 输出文件的命名规则，在images目录下，使用8位哈希值加原始扩展名</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-10-压缩图片"><a href="#4-10-压缩图片" class="headerlink" title="4.10-压缩图片"></a>4.10-压缩图片</h3><p>运行命令安装<code>npm</code>包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install image-minimizer-webpack-plugin imagemin imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo --save-dev</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 处理图像文件的规则配置</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp|avif)(\?.*)?$/</span>, <span class="comment">// 匹配多种图像文件格式</span></span><br><span class="line">                <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>, <span class="comment">// 将图像文件作为资产处理</span></span><br><span class="line">                <span class="attr">parser</span>: &#123;</span><br><span class="line">                    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                        <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 图片大小小于10KB将会被转成base64</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">generator</span>: &#123;</span><br><span class="line">                    <span class="attr">filename</span>: <span class="string">&quot;images/[hash:8][ext]&quot;</span>, <span class="comment">// 输出文件的命名规则，在images目录下，使用8位哈希值加原始扩展名</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图片压缩是一个计算密集型的过程，尤其是当你有大量图片需要处理时</p>
<p>这可能是导致你的打包过程变慢的原因</p>
<p>有一些方法可以尝试优化这一过程：</p>
<ol>
<li><p><strong>仅在生产构建中启用图片压缩</strong></p>
<p>你可以通过设置只在生产模式下启用这个插件来减少开发时的构建延迟</p>
</li>
<li><p><strong>并行处理</strong></p>
<p>如果可能的话，试着并行化图片的处理过程</p>
<p><code>ImageMinimizerPlugin</code>有一个<code>parallel</code>选项，可以显著加快处理速度，特别是在多核CPU上</p>
</li>
<li><p><strong>限制压缩的图片数量</strong></p>
<p>如果你的项目中有些图片不需要优化，可以配置规则来排除这些文件，从而减少处理时间</p>
</li>
<li><p><strong>预先压缩</strong></p>
<p>对于一些不经常变化的图片，可以考虑在添加到项目之前就手动压缩它们，避免在每次构建过程中重复压缩</p>
</li>
</ol>
<details class="folding-tag" purple><summary> image-minimizer-webpack-plugin是干什么的 </summary>
              <div class='content'>
              <p>这是一个Webpack插件，它允许你通过多种<code>imagemin</code>插件来优化构建过程中的图片</p><p>它的主要角色是作为图片压缩任务的协调者，调用不同的<code>imagemin</code>插件来处理不同格式的图片</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> imagemin是干什么的 </summary>
              <div class='content'>
              <p>这是一个用于优化图片的模块</p><p>它本身不对图片进行优化，而是依赖于一系列插件来处理特定格式的图片</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> imagemin-gifsicle是干什么的 </summary>
              <div class='content'>
              <p>用于优化GIF格式图片</p><p>它可以减少GIF文件的大小，而不会影响到动画效果或质量</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> imagemin-jpegtran是干什么的 </summary>
              <div class='content'>
              <p>用于优化JPEG/JPG格式图片</p><p>它主要进行无损压缩，意味着图片质量不会降低</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> imagemin-optipng是干什么的 </summary>
              <div class='content'>
              <p>用于优化PNG格式图片</p><p>它可以进行无损压缩，也可以通过调整优化级别来达到更高的压缩率，但可能会影响图片质量</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> imagemin-svgo是干什么的 </summary>
              <div class='content'>
              <p>针对SVG格式图片的优化工具</p><p>SVGO可以去除SVG文件中的不必要的信息，比如编辑器元数据、注释、隐藏的元素等，从而减小文件大小</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-11-公共代码提取"><a href="#4-11-公共代码提取" class="headerlink" title="4.11-公共代码提取"></a>4.11-公共代码提取</h3><p>一些概念了解：</p>
<ul>
<li><p><strong>module</strong></p>
<p>简单来说就是你通过import语句引入的代码，一个js文件就是一个module</p>
</li>
<li><p><strong>chunk</strong></p>
<p> chunk是webpack根据功能拆分出来的，包含三种情况：</p>
<ul>
<li>你的项目入口（entry）</li>
<li>通过import()动态引入的代码</li>
<li>通过splitChunks拆分出来的代码（公共代码）<br>chunk包含着module，可能是一对多也可能是一对一。</li>
</ul>
</li>
<li><p><strong>bundle</strong></p>
<p>bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系</p>
<p>bundle就是对chunk进行编译压缩打包等处理之后的产出</p>
<ul>
<li>通过splitChunks拆分出来的chunk不能算作bundle</li>
<li>bundle只指入口entry和import()动态导入生成的chunk （这样的bundle和chunk才是一对一的关系）<ul>
<li>一个entry对应一个chunk</li>
<li>一个import()动态导入对应一个chunk</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="comment">// splitChunks 用于控制如何拆分代码块</span></span><br><span class="line">        <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有类型的chunks进行拆分（包括动态和非动态模块）</span></span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">20000</span>, <span class="comment">// 新chunk的最小体积为20KB</span></span><br><span class="line">            <span class="attr">maxAsyncRequests</span>: <span class="number">6</span>, <span class="comment">// 每个异步加载的模块最多能被拆分成6个chunks</span></span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="number">6</span>, <span class="comment">// 入口点的最大并行请求数量</span></span><br><span class="line">            <span class="attr">enforceSizeThreshold</span>: <span class="number">50000</span>, <span class="comment">// 忽视其他限制，强制拆分体积为50KB的chunks</span></span><br><span class="line">            <span class="comment">// cacheGroups 用于定义如何共享模块/合并chunks</span></span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">                <span class="attr">libs</span>: &#123; <span class="comment">// 针对从node_modules中导入的模块</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;chunk-libs&quot;</span>,</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 指定是node_modules下的模块</span></span><br><span class="line">                    <span class="attr">priority</span>: <span class="number">10</span>, <span class="comment">// 优先级</span></span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&quot;initial&quot;</span> <span class="comment">// 仅对入口块进行处理</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">echarts</span>: &#123; <span class="comment">// 针对ECharts的单独拆分</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;chunk-echarts&quot;</span>,</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]echarts[\\/]/</span>,</span><br><span class="line">                    <span class="attr">priority</span>: <span class="number">20</span> <span class="comment">// 优先级高于libs</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">elementPlus</span>: &#123; <span class="comment">// Element Plus 单独拆包</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;chunk-elementPlus&quot;</span>,</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]element-plus[\\/]/</span>, <span class="comment">// 更新匹配 Element Plus 的路径</span></span><br><span class="line">                    <span class="attr">priority</span>: <span class="number">20</span> <span class="comment">// 权重要大于 libs</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">src</span>: &#123; <span class="comment">// 对src目录下的文件进行拆分</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&quot;chunk-src&quot;</span>,</span><br><span class="line">                    <span class="attr">test</span>: <span class="regexp">/[\\/]src[\\/]/</span>,</span><br><span class="line">                    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                    <span class="attr">priority</span>: <span class="number">10</span> <span class="comment">// 优先级等于libs，但因为特定配置可能在实际中优先级表现不同</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">commons</span>: &#123; <span class="comment">// 针对公共模块的拆分</span></span><br><span class="line">                    <span class="attr">name</span>: <span class="string">`chunk-commons`</span>,</span><br><span class="line">                    <span class="attr">minChunks</span>: <span class="number">2</span>, <span class="comment">// 最小引用次数</span></span><br><span class="line">                    <span class="attr">priority</span>: <span class="number">0</span>, <span class="comment">// 低优先级</span></span><br><span class="line">                    <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span> <span class="comment">// 如果一个模块已经被打包过，则复用它而不是再次打包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> splitChunks是干什么的 </summary>
              <div class='content'>
              <p><code>splitChunks</code> 是一个 Webpack 的配置选项，用于优化输出包的大小和加载性能</p><p>它的主要目的是从你的代码中自动提取和分割出通用的依赖模块、第三方库或者自定义的重复代码块到独立的文件(chunks)中</p><p>这样做的好处有很多：</p><ol><li><p><strong>减少重复</strong></p><p>通过将公共的代码分割成独立的chunks，多个入口或懒加载的模块可以共享相同的依赖，避免在每个bundle中重复打包相同的代码</p></li><li><p><strong>缓存优化</strong></p><p>分割出来的公共代码块通常变化较少，因此通过浏览器缓存可以减少加载时间</p></li><li><p><strong>并行加载</strong></p><p>将大的代码块拆分成更小的块可以并行加载，提高加载速度</p></li><li><p><strong>按需加载</strong></p><p>对于路由懒加载的场景，splitChunks可以帮助实现更细粒度的代码分割，按需加载资源，进一步减少首屏加载时间</p></li></ol><p>Webpack中的<code>splitChunks</code>配置提供了多种细粒度的控制选项，包括但不限于：</p><ul><li><p><code>chunks</code></p><p>指定哪些类型的块应该被拆分</p><p>可以是<code>initial</code>（只对入口文件处理）、<code>async</code>（只对异步加载的模块处理）和<code>all</code>（全部块）</p></li><li><p><code>minSize</code></p><p>生成块的最小大小。如果拆分后的块小于此值，则不会被拆分</p></li><li><p><code>maxAsyncRequests</code></p><p>按需加载时并行请求的最大数量</p></li><li><p><code>maxInitialRequests</code></p><p>入口点的最大并行请求数量</p></li><li><p><code>name</code></p><p>拆分块的名称。可以是固定的字符串或者函数返回值</p></li><li><p><code>cacheGroups</code></p><p>缓存组可以继承和/或覆盖splitChunks中的任何选项</p><p>通过cacheGroups，可以实现更细粒度的拆分策略，比如将React和Vue等框架代码拆分到独立的文件</p></li></ul>
              </div>
            </details>
<p><br /></p>
<h3 id="4-12-分割代码按需加载"><a href="#4-12-分割代码按需加载" class="headerlink" title="4.12-分割代码按需加载"></a>4.12-分割代码按需加载</h3><p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置输出选项</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定输出的文件名，[chunkhash:8]表示使用8位的块哈希值作为文件名的一部分</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 指定输出文件的路径</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 启用异步块加载</span></span><br><span class="line">        <span class="attr">asyncChunks</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 设置资源的公共路径，对于在页面中引用的静态资源，都将以此路径为基础</span></span><br><span class="line">        <span class="attr">publicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="comment">// 清除上一次打包构建出来的文件</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 用于指定非入口(non-initial) chunk 文件的名称，这通常是用于懒加载模块时Webpack按需加载的块</span></span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chunkFilename</code> 用于指定非入口(non-initial) chunk 文件的名称，这通常是用于懒加载模块时Webpack按需加载的块</p>
<p>这意味着，这些异步加载的块将以它们各自的 chunk 名称命名，不包含哈希值</p>
<p>在实际应用中，它有助于区分主bundle文件和异步加载的chunk文件</p>
<p><br /></p>
<h3 id="4-13-查看编译速度"><a href="#4-13-查看编译速度" class="headerlink" title="4.13-查看编译速度"></a>4.13-查看编译速度</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install speed-measure-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>新建一个<code>webpack.analysis.js</code>文件</p>
<p>这个文件不会输出dist文件，只是进行<code>webpack</code>的分析</p>
<p>执行编译速度分析一般都是针对需要极致性能的生产环境，所以开发环境就不配置分析了</p>
<p>修改<code>webpack.analysis.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">&quot;./webpack.prod.js&quot;</span>)</span><br><span class="line"><span class="comment">// 构建速度分析</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasurePlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;speed-measure-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasurePlugin</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = smp.<span class="title function_">wrap</span>(</span><br><span class="line">    <span class="title function_">merge</span>(prodConfig, &#123;</span><br><span class="line">    </span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> speed-measure-webpack-plugin可以干什么 </summary>
              <div class='content'>
              <p><code>speed-measure-webpack-plugin</code>（简称 SMP）是一个用于测量各个插件和加载器(<code>loaders</code>)在Webpack构建过程中的速度的webpack插件</p><p>它对于优化构建时间非常有用，因为它可以帮助你明确地看到构建过程中每一步的耗时，从而识别出哪些部分可能需要优化</p><ul><li><p><strong>性能监测</strong></p><p>它会显示Webpack构建过程中每个插件和loader的处理时间，帮助你理解构建时间被怎样花费的</p></li><li><p><strong>优化指导</strong></p><p>通过准确的性能数据，你可以优先对耗时最长的部分进行优化，以提高构建速度</p></li><li><p><strong>配置简单</strong></p><p>集成到现有的Webpack配置中非常简单，只需要几行代码即可启动和运行</p></li></ul>
              </div>
            </details>
<p><br /></p>
<h3 id="4-14-多进程"><a href="#4-14-多进程" class="headerlink" title="4.14-多进程"></a>4.14-多进程</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install thread-loader -D</span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> thread-loader可以干什么 </summary>
              <div class='content'>
              <p><code>thread-loader</code> 是一个Webpack的加载器，它可以将资源文件的加载和处理工作分配到一个独立的worker线程池中去执行</p><p>这样做可以显著提高构建速度，特别是在处理大量和耗时的任务时（如大型项目中的Babel转译），因为这允许你利用多核CPU的能力来并行处理任务</p><ul><li><p><strong>并行处理</strong></p><p>在多个worker线程中并行处理模块，使得资源文件的转译和加载更加快速</p></li><li><p><strong>提高构建效率</strong></p><p>通过减少主线程的负载，使得Webpack的构建过程更加高效</p></li><li><p><strong>可配置的</strong></p><p>你可以控制线程的数量，优化构建性能和资源的使用</p></li></ul>
              </div>
            </details>
<p>修改<code>webpack.common.js</code>文件</p>
<p>将<code>thread-loader</code>放在其他比较耗时的加载器之前</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;thread-loader&#x27;</span>, <span class="comment">// 在这里添加`thread-loader`</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">                </span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-15-精简终端输出"><a href="#4-15-精简终端输出" class="headerlink" title="4.15-精简终端输出"></a>4.15-精简终端输出</h3><p>如果觉得控制台的输出很多，很乱，你可以进行精简</p>
<p>修改<code>webpack.dev.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">stats</span>: <span class="string">&#x27;errors-only&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-16-字体资源处理"><a href="#4-16-字体资源处理" class="headerlink" title="4.16-字体资源处理"></a>4.16-字体资源处理</h3><p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义模块的规则配置</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>:<span class="regexp">/.(woff2?|eot|ttf|otf)$/</span>, <span class="comment">// 匹配字体图标文件</span></span><br><span class="line">                <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>, <span class="comment">// type选择asset</span></span><br><span class="line">                <span class="attr">parser</span>: &#123;</span><br><span class="line">                    <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                        <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span>, <span class="comment">// 小于10kb转base64位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">generator</span>:&#123;</span><br><span class="line">                    <span class="attr">filename</span>:<span class="string">&#x27;static/fonts/[hash:8][ext]&#x27;</span>, <span class="comment">// 文件输出目录和命名</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-18-打包生成gz"><a href="#4-18-打包生成gz" class="headerlink" title="4.18-打包生成gz"></a>4.18-打包生成gz</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.prod.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成压缩gzip</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span>  = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ... other code ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插件配置数组</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;[path][base].gz&#x27;</span>, <span class="comment">// 文件命名</span></span><br><span class="line">            <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>, <span class="comment">// 压缩格式,默认是gzip</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/.(js|css)$/</span>, <span class="comment">// 只生成css,js压缩文件</span></span><br><span class="line">            <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">// 只有大小大于该值的资源会被处理。默认值是 10k</span></span><br><span class="line">            <span class="attr">minRatio</span>: <span class="number">0.8</span> <span class="comment">// 压缩率,默认值是 0.8</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">	... other code ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-19-打包分析"><a href="#4-19-打包分析" class="headerlink" title="4.19-打包分析"></a>4.19-打包分析</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure>
<p>修改<code>webpack.analysis.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入分析打包结果插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = smp.<span class="title function_">wrap</span>(<span class="title function_">merge</span>(prodConfig, &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>() <span class="comment">// 配置分析打包结果插件</span></span><br><span class="line">    ]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-20-开启缓存"><a href="#4-20-开启缓存" class="headerlink" title="4.20-开启缓存"></a>4.20-开启缓存</h3><p>开启持久化缓存（Webpack5 新特性），缓存生成的 webpack 模块和 chunk，来改善构建速度</p>
<p>首次构建耗时增加 15% 左右，但是二次构建耗时减少 90% 左右</p>
<p>修改<code>webpack.dev.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">cache</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-21-编译过程美化"><a href="#4-21-编译过程美化" class="headerlink" title="4.21-编译过程美化"></a>4.21-编译过程美化</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @nuxt/friendly-errors-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>这个插件可以帮助我们优化构建过程的<code>webpack</code>在终端的输出，可以直接体验</p>
<p>修改<code>webpack.dev.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译过程终端美化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FriendlyErrorsWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;@nuxt/friendly-errors-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">     <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FriendlyErrorsWebpackPlugin</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-22-进度条美化"><a href="#4-22-进度条美化" class="headerlink" title="4.22-进度条美化"></a>4.22-进度条美化</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D webpackbar</span><br></pre></td></tr></table></figure>
<p>觉得webpack提供的默认进度条不是很好看，可以下载这个包</p>
<p>并替换掉<code>new webpack.ProgressPlugin()</code></p>
<p>修改<code>webpack.common.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 进度条插件：用于显示webpack构建的进度</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebpackBar</span>(&#123;</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&quot;#85d&quot;</span>,  <span class="comment">// 默认green，进度条颜色支持HEX</span></span><br><span class="line">            <span class="attr">basic</span>: <span class="literal">false</span>,   <span class="comment">// 默认true，启用一个简单的日志报告器</span></span><br><span class="line">            <span class="attr">profile</span>:<span class="literal">false</span>,  <span class="comment">// 默认false，启用探查器。</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br /></p>
<h3 id="4-23-Eslint配置代码规范"><a href="#4-23-Eslint配置代码规范" class="headerlink" title="4.23-Eslint配置代码规范"></a>4.23-Eslint配置代码规范</h3><p>运行命令安装npm包</p>
<p>为什么安装8.57.0的版本呢？因为9的版本实在是太难用了，跟以前的配置完全不一样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install eslint@8.57.0 eslint-plugin-vue --save-dev</span><br></pre></td></tr></table></figure>
<p>ESLint 是一款非常流行的JavaScript和JSX代码检测工具</p>
<p>主要原因在于它可以帮助开发者保持代码质量并确保代码风格的一致性</p>
<p>以下是使用ESLint的一些主要理由：</p>
<ol>
<li><p><strong>提高代码质量</strong></p>
<p>ESLint可以检测代码中的错误，比如未使用的变量、循环中错误的逻辑判断、语法错误等，这些都是在代码审查中可能漏检的错误</p>
<p>通过自动检测，可以在代码提交前发现并修正它们，从而避免了潜在的运行时错误</p>
</li>
<li><p><strong>保持代码风格一致性</strong></p>
<p>在团队开发过程中，不同的开发者可能有不同的代码编写习惯，这可能会导致项目中出现不一致的代码风格</p>
<p>ESLint 通过强制执行一套预定的规则（如缩进、分号使用、变量命名规范等），帮助团队成员保持代码的一致性，使得代码更易于读写和维护</p>
</li>
<li><p><strong>促进团队协作</strong></p>
<p>当团队成员使用ESLint，并遵循相同的代码规范时，会减少代码审查时的摩擦和误解</p>
<p>这不仅可以提高开发效率，也能促进团队间的沟通和协作</p>
</li>
<li><p><strong>自定义和灵活性</strong></p>
<p>ESLint提供了大量的内建规则，并且允许开发者自定义规则，这意味着你可以根据自己或团队的需求调整规则</p>
<p>此外，你还可以使用社区提供的配置集合，如<code>airbnb</code>、<code>google</code>等，或者集成到现有的构建系统中</p>
</li>
<li><p><strong>减少审查时间和成本</strong></p>
<p>自动检测代码中的问题可以显著减少人工代码审查所需的时间和精力</p>
<p>开发者可以集中精力解决更复杂的问题，而非一些基础的编码规范问题</p>
</li>
<li><p><strong>促进学习和指导</strong></p>
<p>对于新手开发者来说，ESLint不仅可以指出代码中的错误，还可以提供错误修正的建议，这对于学习JavaScript语言和提升编码技能非常有帮助</p>
</li>
</ol>
<p>项目目录下新建<code>.eslintignore</code>文件，用于排除应用eslint规则的文件或目录</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略 node_modules 目录</span></span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略构建输出目录</span></span><br><span class="line">/dist/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略配置目录</span></span><br><span class="line">webpackConfig/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略特定文件</span></span><br><span class="line">.babelrc</span><br><span class="line">.browserslistrc</span><br><span class="line">.gitignore</span><br><span class="line">package.json</span><br><span class="line">package-lock.json</span><br><span class="line"><span class="comment">#src/someFileToIgnore.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略某个目录中的所有文件</span></span><br><span class="line">src/assets</span><br><span class="line"><span class="comment">#src/someDirectoryToIgnore/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有的配置文件</span></span><br><span class="line">**/*.config.js</span><br></pre></td></tr></table></figure>
<p>项目目录下新建<code>.eslintrc.js</code>，具体代码可以直接看源码，如果想要个性化规则可以去翻阅Eslint文档</p>
<p>如果想在终端里面测试所有项目的话，可以在<code>package.json</code>里面的<code>script</code>配置<code>&quot;eslint&quot;: &quot;eslint ./src&quot;</code></p>
<p>这样子就可以直接运行检查项目<code>src</code>目录下面的所有文件了</p>
<p>如果想要在运行webpack的时候发现，可以下载npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i eslint-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>因为是开发环境才会有eslint规范，所以直接修改<code>webpack.dev.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终端检查代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ESLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(base, &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ESLintPlugin</span>(&#123;</span><br><span class="line">            <span class="comment">//运行的时候自动帮你修复错误</span></span><br><span class="line">            <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">exclude</span>: <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">            <span class="attr">extensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<details class="folding-tag" purple><summary> eslint可以干什么 </summary>
              <div class='content'>
              <p>ESLint是一个插件化的JavaScript代码检查工具</p><p>它可以识别和报告模式中的问题，并且能被配置为在代码中自动修复某些简单的问题</p><p>其主要用途是提高代码质量和保持代码风格的一致性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> eslint-plugin-vue可以干什么 </summary>
              <div class='content'>
              <p>ESLint的一个插件，提供了针对Vue.js模板的特定规则</p><p>这允许ESLint检查<code>.vue</code>文件中<code>&lt;template&gt;</code>部分的代码</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> eslint-webpack-plugin可以干什么 </summary>
              <div class='content'>
              <p><code>eslint-webpack-plugin</code> 是一个 Webpack 插件，用于在 Webpack 构建过程中运行 ESLint 检查</p><p>这意味着你可以在编译代码时自动进行代码质量检查，而不需要单独运行 ESLint 命令</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-24-配置husky"><a href="#4-24-配置husky" class="headerlink" title="4.24-配置husky"></a>4.24-配置husky</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i husky lint-staged -D</span><br></pre></td></tr></table></figure>
<p>修改<code>package.json</code>文件，在<code>script</code>下面添加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;husky install&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pre-check&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx lint-staged&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;src/**/*.&#123;js,vue&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;eslint --fix&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>生成<code>.husky</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure>
<p>在该目录下新建文件<code>pre-commit</code>，并写入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span></span><br><span class="line"></span><br><span class="line">npm run pre-check</span><br></pre></td></tr></table></figure>
<p>这时候运行代码提交操作的时候就会使用eslint检测你的代码规范了</p>
<details class="folding-tag" purple><summary> husky可以干什么 </summary>
              <div class='content'>
              <p>用于在 Git 钩子（hooks）上运行脚本，常用于在提交代码前进行代码检查、测试等任务</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> lint-staged可以干什么 </summary>
              <div class='content'>
              <p>在 Git 暂存文件（staged files）上运行 linters，确保只有通过检查的代码才能被提交</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-25-commit信息规范化"><a href="#4-25-commit信息规范化" class="headerlink" title="4.25-commit信息规范化"></a>4.25-commit信息规范化</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i @commitlint/config-conventional @commitlint/cli -D</span><br></pre></td></tr></table></figure>
<p>在项目目录下创建<code>commitlint.config.js</code>文件， 并写入代码，具体代码看源代码</p>
<p>在该目录下新建文件<code>commit-msg</code>，并写入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">. <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span></span><br><span class="line"></span><br><span class="line">npx --no-install commitlint --edit <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>这时候运行代码提交操作的时候就会使用commitlint.config.js检测你提交的信息规范了</p>
<details class="folding-tag" purple><summary> @commitlint/cli可以干什么 </summary>
              <div class='content'>
              <p>命令行工具，用于检查提交消息是否符合指定的规则</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> @commitlint/config-conventional可以干什么 </summary>
              <div class='content'>
              <p>提供一组符合 “Conventional Commits” 规范的默认提交消息规则配置</p>
              </div>
            </details>
<p><br /></p>
<h3 id="4-26-commit提交辅助备注信息"><a href="#4-26-commit提交辅助备注信息" class="headerlink" title="4.26-commit提交辅助备注信息"></a>4.26-commit提交辅助备注信息</h3><p>运行命令安装npm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D commitizen cz-conventional-changelog</span><br></pre></td></tr></table></figure>
<p>项目目录下新建<code>.czrc</code>文件，下入以下代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;cz-conventional-changelog&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>package.json</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;commit&quot;</span>: <span class="string">&quot;git-cz&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;config&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;commitizen&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:<span class="string">&quot;node_modules/cz-conventional-changelog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候可以在<code>git add .</code>命令之后使用<code>npm run commit</code>就可以帮助我们规范commit的提交</p>
<p>如果你还想要自定义commit的规范，那么我们可以这么操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D commitlint-config-cz cz-customizable</span><br></pre></td></tr></table></figure>
<p>在根目录下面新建<code>.cz-config.js</code>，写入代码看源代码</p>
<p>这时候我们就可以发现我们<code>.cz-config.js</code>里面配置的都会在命令行里</p>
<details class="folding-tag" purple><summary> commitizen可以干什么 </summary>
              <div class='content'>
              <p>用于帮助开发者编写符合规范的提交消息</p><p>它提供了一个交互式的命令行界面，引导用户填写提交信息，从而确保提交消息符合预定的格式和规则</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> cz-conventional-changelog可以干什么 </summary>
              <div class='content'>
              <p><strong>commitizen</strong> 的一个适配器，使用 “Conventional Commits” 规范来格式化提交消息</p><p>它定义了一组标准的提交类型（如 <code>feat</code>、<code>fix</code>、<code>chore</code> 等），帮助生成一致的提交历史记录</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> commitlint-config-cz可以干什么 </summary>
              <div class='content'>
              <p><strong>commitlint</strong> 的一个配置扩展，旨在与 <strong>commitizen</strong> 和 <strong>cz-conventional-changelog</strong> 兼容</p><p>它提供了一组预定义的提交消息规则，确保提交消息符合 “Conventional Commits” 规范</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> cz-customizable可以干什么 </summary>
              <div class='content'>
              <p><strong>commitizen</strong> 的一个可定制适配器，允许用户根据自己的需求自定义提交消息的提示和格式</p><p>你可以配置提交类型、范围、详细描述等，从而适应不同的项目需求</p>
              </div>
            </details>
<p><br /></p>
<h2 id="五、推送远程"><a href="#五、推送远程" class="headerlink" title="五、推送远程"></a>五、推送远程</h2><h3 id="5-1-添加-gitignore-文件"><a href="#5-1-添加-gitignore-文件" class="headerlink" title="5.1-添加.gitignore 文件"></a>5.1-添加<code>.gitignore</code> 文件</h3><p><code>.gitignore</code> 文件用于指定 <code>Git</code> 版本控制要忽略的未跟踪文件和目录</p>
<p>在一个 <code>Vue.js</code> 项目中，有多种文件和目录通常应该被添加到 <code>.gitignore</code> 文件中，特别是当开发工具是 <code>WebStorm (ws)</code> 和 <code>Visual Studio Code (vs)</code> 时</p>
<p><code>.gitignore</code> 文件应该根据项目需求和团队约定进行自定义</p>
<p>正式使用时还需要根据实际情况来调整和增减规则</p>
<p>写入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖</span><br><span class="line">/node_modules</span><br><span class="line"></span><br><span class="line"># 打包输出</span><br><span class="line">/dist</span><br><span class="line"></span><br><span class="line"># 环境变量文件</span><br><span class="line">.env</span><br><span class="line">.env.local</span><br><span class="line">.env.*.local</span><br><span class="line"></span><br><span class="line"># 开发工具目录</span><br><span class="line">.idea</span><br><span class="line">.vscode</span><br><span class="line"></span><br><span class="line"># 日志文件</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># 源映射</span><br><span class="line">*.map</span><br><span class="line"></span><br><span class="line"># MacOS系统文件</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line"># Windows系统文件</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>
<h2 id="六、文档、源代码"><a href="#六、文档、源代码" class="headerlink" title="六、文档、源代码"></a>六、文档、源代码</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/WebpackCreateVue3"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=WebpackCreateVue3&show_owner=true"/></a>
<p><a href="https://guojiongwei.top/article/649d7c17c0cd245c9f55bf68">掘金大佬文档</a></p>
<p><a href="https://webpack.docschina.org/configuration/">配置 | webpack 中文文档 (docschina.org)</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>《Css 面试题》</title>
    <url>/posts/179be34f/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：怎么触发BFC？BFC有什么应用场景"><a href="#Q1：怎么触发BFC？BFC有什么应用场景" class="headerlink" title="Q1：怎么触发BFC？BFC有什么应用场景"></a>Q1：怎么触发BFC？BFC有什么应用场景</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>BFC（块级格式化上下文）是一个独立的渲染区域，具有一定的规则和约束，它可以包含浮动元素、清除浮动、防止外边距重叠等特性。触发BFC的方法有多种，其中一些常见的方式包括：</p><ol><li><p><strong>float 属性：</strong> 当一个元素设置了 <code>float</code> 属性值不为 <code>none</code>，会触发该元素生成 BFC。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element &#123;</span><br><span class="line">    float: left; /* 触发BFC */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>position 属性：</strong> 当一个元素的 <code>position</code> 属性值为 <code>absolute</code> 或 <code>fixed</code>，也会触发该元素生成 BFC。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element &#123;</span><br><span class="line">    position: absolute; /* 触发BFC */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>display 属性：</strong> 当一个元素的 <code>display</code> 属性值为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code> 或 <code>flow-root</code>（新的值，用于触发BFC）时，会触发该元素生成 BFC。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element &#123;</span><br><span class="line">    display: inline-block; /* 触发BFC */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>overflow 属性：</strong> 当一个元素的 <code>overflow</code> 属性值不为 <code>visible</code>，会触发该元素生成 BFC。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element &#123;</span><br><span class="line">    overflow: auto; /* 触发BFC */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>应用场景：</p><ol><li><p><strong>清除浮动：</strong> BFC 可以包含浮动元素，这样可以解决浮动元素造成的父元素高度塌陷的问题。可以通过给父元素触发 BFC，如设置 <code>overflow: hidden;</code> 或 <code>display: flow-root;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.clearfix::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>防止外边距重叠：</strong> BFC 可以防止相邻块级元素的外边距重叠问题。</p></li><li><p><strong>自适应两栏布局：</strong> 利用 BFC 特性可以创建自适应两栏布局，其中一个栏固定宽度，另一个栏自适应剩余宽度。</p></li><li><p><strong>包含浮动元素：</strong> BFC 可以包含浮动元素，防止浮动元素溢出父容器。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：对CSS模块化的理解"><a href="#Q2：对CSS模块化的理解" class="headerlink" title="Q2：对CSS模块化的理解"></a>Q2：对CSS模块化的理解</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS 模块化是一种组织和管理 CSS 代码的方法，旨在提高代码的可维护性、可读性和可重用性。主要目标是避免全局污染、减少样式冲突，同时使得样式表结构更清晰。</p><p>以下是一些与 CSS 模块化相关的核心概念和实践：</p><ol><li><p><strong>命名空间：</strong> 在 CSS 模块化中，使用命名空间是一种将样式限定在特定区域的方法，以防止样式冲突。可以使用 BEM（块、元素、修饰符）等命名约定，或者通过工程化工具（如 CSS Modules）自动生成唯一的类名。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BEM 命名空间 */</span></span><br><span class="line"><span class="selector-class">.block</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.block__element</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.block--modifier</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CSS Modules 自动生成的唯一类名 */</span></span><br><span class="line"><span class="selector-class">.moduleBlock_foo</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.moduleBlock_bar</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>局部作用域：</strong> 使用工具或框架提供的局部作用域，确保样式只在特定模块或组件中生效。这可以通过 CSS-in-JS 库、CSS Modules、Scoped CSS 等实现。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS Modules */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="comment">/* 局部作用域 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>模块化工具：</strong> 使用模块化工具，例如 Sass、Less 或者 PostCSS，以便利用变量、嵌套、混合等功能，更好地组织样式代码。</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sass 示例 */</span></span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#3498db</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">darken</span>(<span class="variable">$primary-color</span>, <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件化开发：</strong> 将页面划分为独立的组件，每个组件包含自己的 HTML 结构和样式，以实现更模块化、可重用的代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件化开发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Header 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Footer 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>工程化工具：</strong> 使用构建工具和任务运行器，如Webpack、Parcel 或者 Gulp，来优化、压缩和组织 CSS 代码，同时支持 CSS 模块化的开发流程。</p></li></ol><p>CSS 模块化有助于团队协作，降低样式维护的复杂度，并提升项目的可维护性。选择适合项目需求的模块化方案，并在团队中建立一致的开发规范是保持代码质量的关键。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：flexbox是什么？适用于什么场景"><a href="#Q3：flexbox是什么？适用于什么场景" class="headerlink" title="Q3：flexbox是什么？适用于什么场景"></a>Q3：flexbox是什么？适用于什么场景</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Flexbox（Flexible Box）是一种用于布局设计的 CSS3 弹性盒子布局模型。它提供了一种更有效的方式来对容器内的子元素进行排列、对齐和分布，以适应各种屏幕尺寸和设备。Flexbox 的设计目标是在不同屏幕尺寸下，提供一种更加直观、灵活的布局方案。</p><p>Flexbox 的主要概念包括：</p><ol><li><p><strong>容器和项目：</strong> Flexbox 包含一个容器（<code>display: flex;</code> 或 <code>display: inline-flex;</code>）和其内部的一组项目。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  /* 子元素的样式 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>主轴和交叉轴：</strong> Flexbox 中有主轴和交叉轴，主轴是 <code>flex-direction</code> 属性定义的方向，交叉轴则是与主轴垂直的轴。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">  flex-direction: row; /* 主轴方向为水平方向 */</span><br><span class="line">  /* 或 flex-direction: column; 主轴方向为垂直方向 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>弹性容器属性：</strong> Flexbox 提供了多个容器属性，例如 <code>justify-content</code>（主轴对齐方式）、<code>align-items</code>（交叉轴对齐方式）、<code>flex-wrap</code>（项目是否换行）等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">  justify-content: space-between; /* 主轴上的项目分散对齐 */</span><br><span class="line">  align-items: center; /* 交叉轴上的项目居中对齐 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>弹性项目属性：</strong> Flexbox 提供了多个项目属性，例如 <code>flex-grow</code>（项目的放大比例）、<code>flex-shrink</code>（项目的缩小比例）、<code>flex-basis</code>（项目的初始大小）等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.item &#123;</span><br><span class="line">  flex-grow: 1; /* 项目的放大比例为1，占据剩余空间 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Flexbox 适用于许多场景，特别是在以下情况下：</p><ul><li><strong>均匀分布空间：</strong> 在容器中均匀分布项目，而不需要精确的尺寸或位置计算。</li><li><strong>动态尺寸：</strong> 适应不同屏幕尺寸，无论是横向还是纵向，都能够轻松调整布局。</li><li><strong>垂直居中：</strong> 在容器中垂直和水平居中项目。</li><li><strong>自适应空间分配：</strong> 在不同尺寸的屏幕上，自动适应空间分配，避免使用固定尺寸布局。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：设备像素、css像素、设备独立像素、dpr、ppi之间有什么区别？"><a href="#Q4：设备像素、css像素、设备独立像素、dpr、ppi之间有什么区别？" class="headerlink" title="Q4：设备像素、css像素、设备独立像素、dpr、ppi之间有什么区别？"></a>Q4：设备像素、css像素、设备独立像素、dpr、ppi之间有什么区别？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>设备像素（Device Pixel）：</strong><ul><li><strong>定义：</strong> 物理屏幕上的实际像素点。</li><li><strong>表示：</strong> 通常用于描述设备硬件的分辨率，例如 1920x1080 表示宽度为 1920 像素、高度为 1080 像素。</li></ul></li><li><strong>CSS像素（CSS Pixel）：</strong><ul><li><strong>定义：</strong> CSS 中使用的逻辑像素单位，用于衡量页面上的元素的尺寸。</li><li><strong>表示：</strong> 在不同设备上，CSS 像素的实际大小可以有所不同，取决于设备的像素密度（DPR）。</li></ul></li><li><strong>设备独立像素（Device-Independent Pixel）：</strong><ul><li><strong>定义：</strong> 逻辑上的虚拟像素，是为了让开发者在不同设备上更一致地设置元素的尺寸而引入的概念。</li><li><strong>表示：</strong> 通常与 CSS 像素相等，但在高 DPI 屏幕上，一个设备独立像素可能对应多个物理设备像素。</li></ul></li><li><strong>DPR（Device Pixel Ratio）：</strong><ul><li><strong>定义：</strong> 设备像素和设备独立像素的比率，表示屏幕上每个 CSS 像素对应的设备像素数目。</li><li><strong>计算公式：</strong> DPR = 设备像素数 / 设备独立像素数。</li></ul></li><li><strong>PPI（Pixels Per Inch）：</strong><ul><li><strong>定义：</strong> 表示每英寸的物理屏幕上的像素数目，用于描述屏幕的像素密度。</li><li><strong>计算公式：</strong> PPI = √(设备像素宽^2 + 设备像素高^2) / 屏幕尺寸（以英寸为单位）。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：对盒子模型的理解"><a href="#Q5：对盒子模型的理解" class="headerlink" title="Q5：对盒子模型的理解"></a>Q5：对盒子模型的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>盒子模型是CSS中用于描述网页元素尺寸和布局的概念。每个HTML元素都被视为一个矩形的”盒子”，这个盒子包含了内容、内边距、边框和外边距。这个模型定义了如何计算元素的总体尺寸，以及元素各个部分之间的关系。</p><p>盒子模型的主要组成部分包括：</p><ol><li><strong>内容区域（Content）：</strong><ul><li><strong>定义：</strong> 包含元素的实际内容，比如文本、图像等。</li><li><strong>表示：</strong> 由<code>width</code>和<code>height</code>属性决定。</li></ul></li><li><strong>内边距（Padding）：</strong><ul><li><strong>定义：</strong> 包围在内容区域外部，与内容区域之间的空间。</li><li><strong>表示：</strong> 由<code>padding</code>属性决定，分为上、右、下、左四个方向。</li></ul></li><li><strong>边框（Border）：</strong><ul><li><strong>定义：</strong> 包围在内边距外部，与内边距之间的空间，形成一个框。</li><li><strong>表示：</strong> 由<code>border</code>属性决定，包括宽度、样式和颜色。</li></ul></li><li><strong>外边距（Margin）：</strong><ul><li><strong>定义：</strong> 包围在边框外部，与边框之间的空间，用于控制元素与其他元素之间的距离。</li><li><strong>表示：</strong> 由<code>margin</code>属性决定，分为上、右、下、左四个方向。</li></ul></li></ol><p>元素的总宽度和高度计算公式为： </p><p>总宽度=内容区域宽度+左右内边距+左右边框宽度+左右外边距</p><p>总高度=内容区域高度+上下内边距+上下边框宽度+上下外边距</p><p>在CSS中，有两种盒模型：标准盒模型和怪异盒模型。这两者的主要区别在于计算元素宽度和高度时是否包括内边距和边框。</p><ol><li><strong>标准盒模型（content-box）：</strong><ul><li><strong>定义：</strong> 元素的宽度和高度仅包括内容区域，不包括内边距和边框。</li><li><strong>表示：</strong> <code>width</code>和<code>height</code>属性仅表示内容区域的宽度和高度。</li></ul></li><li><strong>怪异盒模型（border-box）：</strong><ul><li><strong>定义：</strong> 元素的宽度和高度包括内容区域、内边距和边框。</li><li><strong>表示：</strong> <code>width</code>和<code>height</code>属性表示整个盒子（内容区域 + 内边距 + 边框）的宽度和高度。</li></ul></li></ol><p>在实际应用中，可以通过设置元素的 <code>box-sizing</code> 属性来指定使用哪种盒模型。例如，<code>box-sizing: border-box;</code> 表示使用怪异盒模型，而 <code>box-sizing: content-box;</code> 表示使用标准盒模型。默认情况下，大多数浏览器采用标准盒模型，但在一些旧版本的IE中，可能会采用怪异盒模型。选择适当的盒模型取决于设计的需求和布局的期望。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：行内元素跟块级元素有什么区别"><a href="#Q6：行内元素跟块级元素有什么区别" class="headerlink" title="Q6：行内元素跟块级元素有什么区别"></a>Q6：行内元素跟块级元素有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>行内元素（Inline Elements）：</strong></p><ol><li><strong>默认布局：</strong> 行内元素不会独占一行，它们在同一行上显示，尽可能排满一行后换行。</li><li><strong>宽度和高度：</strong> 行内元素的宽度和高度由其内容的大小决定。</li><li><strong>不独占一行：</strong> 行内元素不会独占一行，相邻的行内元素会在同一行上显示，直到一行的空间不足，然后换行。</li><li><strong>不能设置上下边距（margin）：</strong> 行内元素上下的边距（margin）和内边距（padding）不会影响相邻元素，只有左右边距、内边距生效。</li></ol><p><strong>块级元素（Block Elements）：</strong></p><ol><li><strong>默认布局：</strong> 块级元素会独占一行，从新的一行开始，并且在前后都会产生换行。</li><li><strong>宽度和高度：</strong> 块级元素的宽度默认为容器的100%，高度由内容决定。</li><li><strong>独占一行：</strong> 块级元素会独占一行，相邻的块级元素会在不同行上显示。</li><li><strong>可设置上下边距：</strong> 块级元素的上下边距（margin）和内边距（padding）会影响相邻元素的布局。</li></ol><p><strong>常见的行内元素：</strong></p><ul><li><code>&lt;span&gt;</code></li><li><code>&lt;a&gt;</code></li><li><code>&lt;strong&gt;</code></li><li><code>&lt;em&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;br&gt;</code></li><li>…</li></ul><p><strong>常见的块级元素：</strong></p><ul><li><code>&lt;div&gt;</code></li><li><code>&lt;p&gt;</code></li><li><code>&lt;h1&gt; - &lt;h6&gt;</code></li><li><code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;li&gt;</code></li><li><code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;td&gt;</code></li><li><code>&lt;form&gt;</code></li><li>…</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：em-px-rem-vh-vw这些单位有什么区别"><a href="#Q7：em-px-rem-vh-vw这些单位有什么区别" class="headerlink" title="Q7：em\px\rem\vh\vw这些单位有什么区别"></a>Q7：em\px\rem\vh\vw这些单位有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong><code>px</code>（像素）：</strong><ul><li>像素是相对于显示器屏幕的最小单位，是一个固定的长度单位。</li><li>在不同设备上，1px 的实际物理尺寸可能不同，因为设备的像素密度不同。</li></ul></li><li><strong><code>em</code>：</strong><ul><li>相对单位，是相对于父元素的字体大小（font-size）。</li><li>如果应用在字体大小上，1em 等于当前元素的字体大小。</li><li>如果应用在非字体大小的属性上，1em 等于父元素的字体大小。</li></ul></li><li><strong><code>rem</code>（根元素em）：</strong><ul><li>相对于根元素（<code>html</code> 元素）的字体大小。</li><li>使用 <code>rem</code> 单位时，始终参照页面根元素的字体大小，不受嵌套影响。</li></ul></li><li><strong><code>vh</code>（视窗高度）：</strong><ul><li>相对于视窗（浏览器窗口）的高度的百分比。</li><li>1vh 等于视窗高度的 1%。</li></ul></li><li><strong><code>vw</code>（视窗宽度）：</strong><ul><li>相对于视窗（浏览器窗口）的宽度的百分比。</li><li>1vw 等于视窗宽度的 1%。</li></ul></li></ol><p>通常，相对单位（<code>em</code>、<code>rem</code>）更适用于字体大小</p><p>绝对单位（<code>px</code>）和相对于视窗的单位（<code>vh</code>、<code>vw</code>）更适用于布局和尺寸的定义</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：对CSS预编译语言的理解，以及他们之间的区别"><a href="#Q8：对CSS预编译语言的理解，以及他们之间的区别" class="headerlink" title="Q8：对CSS预编译语言的理解，以及他们之间的区别"></a>Q8：对CSS预编译语言的理解，以及他们之间的区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS 预编译语言是一种在 CSS 基础上进行扩展的语言，它们允许开发者使用变量、嵌套、混入、函数等高级特性，以更模块化和可维护的方式组织样式代码。主要的 CSS 预编译语言包括 Sass、Less 和 Stylus。</p><p><strong>Sass：</strong></p><ol><li><p><strong>语法：</strong> Sass 有两种语法，一种是缩进式 Sass（<code>.sass</code>），另一种是 SCSS（Sassy CSS）（<code>.scss</code>），它与传统的 CSS 语法更为接近。</p></li><li><p><strong>变量：</strong> 可以使用变量定义并引用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scssCopy code$primary-color: #3498db;</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: $primary-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套：</strong> 允许嵌套规则，减少了重复的选择器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scssCopy codenav &#123;</span><br><span class="line">  ul &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">  &#125;</span><br><span class="line">  li &#123; display: inline-block; &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    padding: 6px 12px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>混入（Mixin）：</strong> 允许定义可重用的样式块。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scssCopy code@mixin border-radius($radius) &#123;</span><br><span class="line">  -webkit-border-radius: $radius;</span><br><span class="line">  -moz-border-radius: $radius;</span><br><span class="line">  border-radius: $radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button &#123;</span><br><span class="line">  @include border-radius(10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数：</strong> 提供内置函数和支持自定义函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scssCopy code@function px-to-em($px, $base-font-size: 16px) &#123;</span><br><span class="line">  @return ($px / $base-font-size) * 1em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-size: px-to-em(18px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>Less：</strong></p><ol><li><p><strong>语法：</strong> Less 采用与 CSS 更为相似的语法。</p></li><li><p><strong>变量：</strong> 允许使用变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lessCopy code@primary-color: #3498db;</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: @primary-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套：</strong> 支持规则嵌套。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lessCopy codenav &#123;</span><br><span class="line">  ul &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    list-style: none;</span><br><span class="line">  &#125;</span><br><span class="line">  li &#123; display: inline-block; &#125;</span><br><span class="line">  a &#123;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    padding: 6px 12px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>混入（Mixin）：</strong> 支持定义和使用混入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lessCopy code.border-radius(@radius) &#123;</span><br><span class="line">  -webkit-border-radius: @radius;</span><br><span class="line">  -moz-border-radius: @radius;</span><br><span class="line">  border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button &#123;</span><br><span class="line">  .border-radius(10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>Stylus：</strong></p><ol><li><p><strong>语法：</strong> Stylus 采用非常简洁的语法，使用缩进而不是大括号。</p></li><li><p><strong>变量：</strong> 可以使用变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stylCopy codeprimary-color = #3498db</span><br><span class="line">body</span><br><span class="line">  background-color primary-color</span><br></pre></td></tr></table></figure></li><li><p><strong>嵌套：</strong> 支持规则嵌套。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stylCopy codenav</span><br><span class="line">  ul</span><br><span class="line">    margin 0</span><br><span class="line">    padding 0</span><br><span class="line">    list-style none</span><br><span class="line">  li</span><br><span class="line">    display inline-block</span><br><span class="line">  a</span><br><span class="line">    text-decoration none</span><br><span class="line">    padding 6px 12px</span><br></pre></td></tr></table></figure></li><li><p><strong>混入（Mixin）：</strong> 支持定义和使用混入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stylCopy codeborder-radius(radius)</span><br><span class="line">  -webkit-border-radius radius</span><br><span class="line">  -moz-border-radius radius</span><br><span class="line">  border-radius radius</span><br><span class="line"></span><br><span class="line">button</span><br><span class="line">  border-radius 10px</span><br></pre></td></tr></table></figure></li></ol><p><strong>区别总结：</strong></p><ol><li><strong>语法风格：</strong> Sass 和 Stylus 采用缩进式语法，而 Less 更接近传统 CSS 语法。</li><li><strong>变量符号：</strong> Sass 使用 <code>$</code>，Less 使用 <code>@</code>，Stylus 不需要特定的符号。</li><li><strong>嵌套规则：</strong> 所有三种预编译语言都支持规则嵌套，但在 Stylus 中，规则的嵌套是通过缩进实现的。</li><li><strong>混入（Mixin）：</strong> 三者都支持混入的概念，但在语法和使用上有一些差异。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：怎么理解回流跟重绘？什么场景下会触发？"><a href="#Q9-：怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="Q9 ：怎么理解回流跟重绘？什么场景下会触发？"></a>Q9 ：怎么理解回流跟重绘？什么场景下会触发？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>回流（Reflow）：</strong><ul><li>回流是指浏览器为了重新渲染部分或全部文档而重新计算元素的位置和几何结构的过程。</li><li>任何影响了元素几何属性（宽度、高度、位置等）的操作都会触发回流。</li><li>回流的开销很大，因为它涉及到整个页面的布局重置，会导致渲染树的重新构建和页面的重新绘制。</li></ul></li><li><strong>重绘（Repaint）：</strong><ul><li>重绘是指浏览器根据元素的新样式重新绘制页面元素，但不会影响它们的布局。</li><li>重绘的开销相对较小，因为它只涉及样式的改变和重新绘制。</li></ul></li><li><strong>触发回流和重绘的情况：</strong><ul><li>回流的触发条件：<ul><li>添加或删除可见的 DOM 元素。</li><li>元素的位置或尺寸发生变化。</li><li>页面布局初始化。</li><li>浏览器窗口大小发生变化。</li></ul></li><li>重绘的触发条件：<ul><li>修改元素的背景色、文字颜色等不影响布局的样式。</li><li>修改元素的可见性、透明度等。</li></ul></li></ul></li><li><strong>优化策略：</strong><ul><li><strong>使用 <code>transform</code> 和 <code>opacity</code> 进行动画：</strong> 这两个属性的修改不会触发回流，只会引起重绘。</li><li><strong>避免直接操作样式：</strong> 尽量使用 CSS 类进行样式的切换，减少对元素样式的直接操作。</li><li><strong>批量修改 DOM：</strong> 对多个 DOM 元素进行修改时，最好将操作集中在一起，减少回流的次数。</li><li><strong>使用文档片段（DocumentFragment）：</strong> 在内存中操作 DOM，然后一次性将变化的部分插入文档，减少回流和重绘。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：说一说你对CSS工程化的理解"><a href="#Q10：说一说你对CSS工程化的理解" class="headerlink" title="Q10：说一说你对CSS工程化的理解"></a>Q10：说一说你对CSS工程化的理解</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p> <strong>为什么要工程化？</strong></p><ol><li><strong>可维护性：</strong> 大型项目的样式表通常较为庞大，通过工程化可以模块化和组件化样式，提高代码的可维护性。</li><li><strong>可拓展性：</strong> 工程化使得样式表能够轻松应对项目的扩展和变化，通过组件化和模块化的方式添加、修改或删除样式。</li><li><strong>可复用性：</strong> 样式的组件化有助于提高样式的复用性，使得相似的样式能够在不同组件中共享，减少冗余代码。</li><li><strong>协同开发：</strong> 团队协同开发中，工程化能够提供一致的代码规范和结构，降低团队成员之间的沟通成本。</li><li><strong>性能优化：</strong> 自动化构建工具可以对样式进行压缩、合并、代码分割等优化，提高页面加载性能。</li></ol><p><strong>工程化实现方式及其解决的问题</strong></p><ol><li><strong>模块化和组件化：</strong><ul><li><strong>实现方式：</strong> 使用 BEM（块、元素、修饰符）等命名规范，将样式表拆分为独立的模块或组件。</li><li><strong>解决问题：</strong> 提高代码的可读性和可维护性，降低样式冲突，使样式和组件之间的关系更加清晰。</li></ul></li><li><strong>预处理器：</strong><ul><li><strong>实现方式：</strong> 使用 Sass、Less 等预处理器引入变量、嵌套、混合等功能。</li><li><strong>解决问题：</strong> 提高样式的灵活性，减少代码量，使样式表更加易于维护。</li></ul></li><li><strong>自动化构建工具：</strong><ul><li><strong>实现方式：</strong> 使用 Webpack、Gulp 等构建工具对样式进行自动化处理。</li><li><strong>解决问题：</strong> 压缩、合并、前缀添加等，提高性能并确保兼容性。</li></ul></li><li><strong>代码规范检查：</strong><ul><li><strong>实现方式：</strong> 使用 Stylelint、ESLint 等工具进行代码规范检查。</li><li><strong>解决问题：</strong> 统一代码风格，提高代码质量。</li></ul></li><li><strong>版本控制：</strong><ul><li><strong>实现方式：</strong> 使用 Git 或其他版本控制系统对样式表进行版本管理。</li><li><strong>解决问题：</strong> 跟踪样式的变化，实现代码回滚和协同工作。</li></ul></li><li><strong>响应式设计：</strong><ul><li><strong>实现方式：</strong> 使用媒体查询等技术实现响应式设计。</li><li><strong>解决问题：</strong> 使样式适应不同设备和屏幕尺寸，提高用户体验。</li></ul></li><li><strong>文档：</strong><ul><li><strong>实现方式：</strong> 提供清晰的样式文档，描述每个模块和组件的样式规则。</li><li><strong>解决问题：</strong> 快速了解和使用样式，降低新成员的学习成本。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：Sass、Less是什么？为什么要使用它们？"><a href="#Q11：Sass、Less是什么？为什么要使用它们？" class="headerlink" title="Q11：Sass、Less是什么？为什么要使用它们？"></a>Q11：Sass、Less是什么？为什么要使用它们？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong>Sass:</strong></p><ol><li><strong>特点：</strong><ul><li>支持两种语法格式：Sass（缩进风格）和SCSS（类似于CSS的花括号风格）。</li><li>引入了变量、嵌套规则、混合器、导入等功能。</li><li>提供强大的控制结构，如条件语句和循环。</li><li>有模块化的导入系统。</li></ul></li><li><strong>为什么使用Sass：</strong><ul><li><strong>更灵活的语法：</strong> Sass支持两种语法格式，可以选择更符合个人或团队的编码风格。</li><li><strong>丰富的功能：</strong> 提供了丰富的功能，如变量、混合器等，使得样式表更具表现力和可维护性。</li><li><strong>强大的控制结构：</strong> 支持条件语句和循环，增加了样式表的逻辑能力。</li><li><strong>社区支持：</strong> Sass有一个庞大的社区，提供了大量的资源和工具。</li></ul></li></ol><p><strong>Less:</strong></p><ol><li><strong>特点：</strong><ul><li>类似CSS语法，较为轻量。</li><li>支持变量、嵌套规则、混合器等基本功能。</li><li>提供运算功能，可以进行数字计算。</li><li>有模块化的导入系统。</li></ul></li><li><strong>为什么使用Less：</strong><ul><li><strong>低学习曲线：</strong> 由于Less语法较为接近原生CSS，对于初学者或迁移项目而言，学习曲线较低。</li><li><strong>轻量：</strong> 相对于Sass，Less的语法较为简单，适合一些对功能要求相对简单的项目。</li><li><strong>社区广泛：</strong> Less也有一个庞大的社区，提供了许多插件和工具。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Sass（Syntactically Awesome Stylesheets）和Less都是CSS的预处理器，它们在CSS的基础上提供了一些额外的功能和语法糖，旨在提高CSS代码的可维护性、可读性和开发效率。以下是它们的一些特点和为什么要使用它们的原因：</p><p><strong>为什么使用它们：</strong></p><ol><li><strong>变量和可重用性：</strong> 可以使用变量定义颜色、字体等，提高代码的可维护性和可重用性。</li><li><strong>嵌套规则：</strong> 嵌套规则可以更清晰地表示HTML结构，提高代码的可读性。</li><li><strong>混合器：</strong> 可以定义和引用可重用的样式块，减少代码冗余。</li><li><strong>导入机制：</strong> 可以将样式拆分为多个文件，通过导入的方式组织和管理样式。</li><li><strong>更丰富的功能：</strong> 提供了条件语句、循环等功能，增加了样式表的逻辑能力。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：硬件加速的原理是什么？"><a href="#Q12：硬件加速的原理是什么？" class="headerlink" title="Q12：硬件加速的原理是什么？"></a>Q12：硬件加速的原理是什么？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>硬件加速是指利用图形硬件（GPU）来加速页面渲染和动画效果的过程。硬件加速可以提高页面的性能和流畅度，特别是对于包含复杂图形和动画的应用。以下是Web前端硬件加速的原理：</p><ol><li><p><strong>CSS 属性：</strong> 使用一些特定的CSS属性可以触发硬件加速。常见的属性包括 <code>transform</code>、<code>opacity</code>、<code>filter</code> 等。这些属性可以将渲染任务交给GPU执行，提高性能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 例子：使用 transform 触发硬件加速 */</span><br><span class="line">.element &#123;</span><br><span class="line">  transform: translate3d(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>合成层：</strong> 浏览器会将某些元素单独创建为合成层（composite layer），这些层可以由GPU来处理。常见的触发合成层的方式包括使用3D变换、使用 <code>will-change</code> 属性等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 使用 will-change 属性触发合成层 */</span><br><span class="line">.element &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>硬件加速 API：</strong> 浏览器提供了一些JavaScript API，允许开发者通过代码来触发硬件加速。例如，使用 <code>requestAnimationFrame</code> 函数可以让浏览器在下一次重绘时使用硬件加速。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction animate() &#123;</span><br><span class="line">  // 执行动画</span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 启动动画</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Canvas 和 WebGL：</strong> Canvas 和 WebGL 是直接与GPU交互的技术，可以在Web页面上进行高性能的图形渲染。WebGL尤其适用于复杂的三维图形渲染。</p></li></ol><p>硬件加速的原理是将某些渲染任务交给GPU处理，利用GPU的并行计算能力来加速图形渲染过程，从而提高页面的性能和响应速度。需要注意的是，滥用硬件加速可能导致性能问题，因此在使用硬件加速时要谨慎选择合适的场景和属性。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：css动画跟js动画分别有什么优缺点？"><a href="#Q13：css动画跟js动画分别有什么优缺点？" class="headerlink" title="Q13：css动画跟js动画分别有什么优缺点？"></a>Q13：css动画跟js动画分别有什么优缺点？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>特性/优缺点</th><th>CSS动画</th><th>JavaScript动画</th></tr></thead><tbody><tr><td>性能优化</td><td>通常较好，可利用硬件加速</td><td>可能存在性能开销，特别是在复杂动画或低性能设备上</td></tr><tr><td>简便易用</td><td>对于基本动画效果，简单易用</td><td>相对较灵活，编写复杂动画需要更多代码</td></tr><tr><td>灵活性</td><td>有一定限制，难以实现复杂效果</td><td>更灵活，能够实现复杂和定制化的动画效果</td></tr><tr><td>交互性</td><td>较差，难以响应用户输入</td><td>更好的交互性，可以根据用户输入调整动画状态</td></tr><tr><td>动态计算</td><td>难以实现动态计算</td><td>可以使用JavaScript进行动态计算</td></tr><tr><td>响应式</td><td>可以响应页面样式变化</td><td>需要手动处理样式变化的响应性</td></tr><tr><td>代码复杂性</td><td>相对简单</td><td>可能需要更多代码和调试</td></tr></tbody></table></div><p><strong>综合选择：</strong></p><ol><li><strong>性能需求：</strong> 如果性能是首要考虑的因素，并且动画较简单，可以优先选择CSS动画。</li><li><strong>复杂度要求：</strong> 对于复杂、高度定制的动画效果，尤其是需要用户交互的场景，JavaScript动画更为适用。</li><li><strong>组合使用：</strong> 在一些场景中，CSS动画和JavaScript动画可以结合使用，发挥各自的优势，例如使用CSS实现基本动画，使用JavaScript进行交互和复杂计算。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：前端实现动画有哪些方式？"><a href="#Q14：前端实现动画有哪些方式？" class="headerlink" title="Q14：前端实现动画有哪些方式？"></a>Q14：前端实现动画有哪些方式？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>CSS3 动画：</strong> 使用 CSS3 的 <code>@keyframes</code> 规则可以定义动画关键帧，然后通过将动画应用到元素上，实现基本的动画效果。</li><li><strong>CSS3 过渡（Transition）：</strong> 利用 CSS3 过渡可以在元素的状态变化时实现平滑的过渡效果。通过设置过渡属性（如 <code>transition-property</code>、<code>transition-duration</code> 等），在状态变化时自动产生动画效果。</li><li><strong>JavaScript 动画库：</strong> 使用 JavaScript 编写动画的库，如 GreenSock Animation Platform (GSAP)、anime.js 等。这些库提供了更高级的动画控制和更丰富的功能，适用于复杂的动画场景。</li><li><strong>Web Animation API：</strong> 是一组在 JavaScript 中控制动画的新 API，提供更多的灵活性和控制权，可以用于创建复杂的动画效果。</li><li><strong>Canvas 动画：</strong> 通过 HTML5 的 Canvas 元素，可以使用 JavaScript 绘制图形并实现动画效果。</li><li><strong>SVG 动画：</strong> 使用可缩放矢量图形（SVG）格式，结合 SMIL（Synchronized Multimedia Integration Language）或 JavaScript，实现矢量图形的动画效果。</li><li><strong>React Spring 等动画库：</strong> 针对 React 框架的动画库，可以方便地在 React 应用中实现动画。</li><li><strong>Three.js 等 3D 库：</strong> 用于创建基于 WebGL 的 3D 动画效果。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：CSS为什么不支持父选择器？"><a href="#Q15：CSS为什么不支持父选择器？" class="headerlink" title="Q15：CSS为什么不支持父选择器？"></a>Q15：CSS为什么不支持父选择器？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS不直接支持父选择器的原因主要有两方面：</p><ol><li><strong>性能问题：</strong> 当浏览器解析 CSS 样式时，从右向左的匹配方式已经足够复杂，如果引入父选择器，会增加选择器的复杂性和计算成本。实现父选择器需要浏览器遍历整个文档树，找到每个元素的父元素，这样的计算对性能有较大影响。</li><li><strong>样式层级问题：</strong> 父选择器可能导致样式层级的混乱。CSS 的层叠样式表（Cascading Style Sheets）的核心思想是层叠和继承，样式应该具有继承性，而引入父选择器可能导致样式的来源变得不清晰，使得样式层级难以理解和维护。</li></ol><p>虽然 CSS 不直接支持父选择器，但通过其他手段，如使用 JavaScript 或一些预处理器（如 Sass 或 Less）可以达到一些类似的效果。未来可能会有一些新的 CSS 特性或选择器引入，但需要权衡性能和可维护性。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：脱离文档流有哪些方法？"><a href="#Q16：脱离文档流有哪些方法？" class="headerlink" title="Q16：脱离文档流有哪些方法？"></a>Q16：脱离文档流有哪些方法？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>脱离文档流是指元素不再按照正常的文档流排列，而是脱离文档流独立定位。以下是一些脱离文档流的常见方法：</p><ol><li><strong>position 属性：</strong><ul><li><strong>position: absolute;</strong>：使元素脱离文档流，并相对于其最近的非 static 定位的祖先元素定位。</li><li><strong>position: fixed;</strong>：使元素脱离文档流，并相对于浏览器窗口定位，不随页面滚动而变化。</li><li><strong>position: relative;</strong>：使元素脱离文档流，但仍然占据原来的位置，相对于其正常位置进行定位。</li></ul></li><li><strong>float 属性：</strong> 使用 <strong>float: left;</strong> 或 <strong>float: right;</strong> 可以使元素脱离文档流并向左或向右浮动。不过，浮动元素仍然会影响文档流中的其他元素。</li><li><strong>display 属性：</strong><ul><li><strong>display: none;</strong>：元素不可见，但不仅脱离文档流，还不占据空间。</li><li><strong>display: inline-block;</strong>：使元素脱离文档流，并允许设置宽度和高度，但仍然保持行内元素的特性。</li></ul></li><li><strong>flexbox 和 grid 布局：</strong><ul><li>使用 <strong>display: flex;</strong> 或 <strong>display: grid;</strong> 可以创建弹性盒子或网格布局，这些布局可以使元素脱离文档流，并按照不同的规则进行排列。</li></ul></li><li><strong>position: absolute;</strong> 结合 <strong>transform: translate(-50%, -50%);</strong>：这种方式可以使元素相对于其父元素的中心定位，同时脱离文档流。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：css的sprites是什么？怎么使用"><a href="#Q17：css的sprites是什么？怎么使用" class="headerlink" title="Q17：css的sprites是什么？怎么使用"></a>Q17：css的sprites是什么？怎么使用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS Sprites是一种将多个小图标或图片合并到一个单一图像文件中的技术。通过使用CSS的background-position属性，可以在页面上显示所需的图标或图片。这样做的主要目的是减少页面的HTTP请求数量，从而提高页面加载性能。</p><p>使用CSS Sprites的步骤如下：</p><ol><li><p><strong>准备图像：</strong> 将所有需要使用的小图标或图片合并成一个大图像。这个大图像通常称为雪碧图（Spritesheet）。</p></li><li><p><strong>创建CSS样式：</strong> 使用CSS样式来定义每个小图标在雪碧图中的位置。通过设置<code>background-position</code>属性，指定每个小图标在雪碧图中的偏移位置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.icon1 &#123;</span><br><span class="line">  background-image: url(&#x27;spritesheet.png&#x27;);</span><br><span class="line">  background-position: 0 0; /* 第一个图标的位置 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.icon2 &#123;</span><br><span class="line">  background-image: url(&#x27;spritesheet.png&#x27;);</span><br><span class="line">  background-position: -30px 0; /* 第二个图标的位置 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 更多图标的样式 */</span><br></pre></td></tr></table></figure></li><li><p><strong>应用样式：</strong> 在HTML中使用相应的样式类来显示对应的图标。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;div class=&quot;icon1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;icon2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 其他图标的HTML --&gt;</span><br></pre></td></tr></table></figure></li></ol><p>通过将多个图标合并成一个雪碧图，可以减少HTTP请求，提高页面加载速度。这对于移动端和需要快速加载的网页尤为重要。然而，使用CSS Sprites也需要考虑维护性和可扩展性，因为修改图标或添加新图标可能需要更新样式表。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18-：Atom-Css是什么？"><a href="#Q18-：Atom-Css是什么？" class="headerlink" title="Q18 ：Atom Css是什么？"></a>Q18 ：Atom Css是什么？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>一种遵循原子设计原则的 CSS 模式，那么我们可以理解为这是一种采用原子化的 CSS 类，每个类都负责执行一个特定的样式任务，以便更好地组合和复用样式。</p><p>优点：</p><ol><li><strong>可维护性：</strong> 将样式拆分为原子类可以使代码更模块化和可维护。每个类都负责一个特定的样式，使得修改和扩展样式更加容易。</li><li><strong>可重用性：</strong> 可以将原子类应用于多个元素，实现样式的可重用性。这有助于减少冗余的样式代码。</li><li><strong>灵活性：</strong> 每个原子类都代表一个小的、独立的样式单元，可以在不影响其他部分的情况下进行修改。</li></ol><p>缺点：</p><ol><li><strong>复杂性：</strong> 在一些情况下，使用过多的原子类可能导致样式表变得庞大且难以理解。过度的原子化可能会增加代码的复杂性。</li><li><strong>学习曲线：</strong> 对于新来的开发者，理解和熟悉原子类的命名规范可能需要一些时间。</li><li><strong>性能：</strong> 在某些情况下，使用过多的原子类可能导致页面加载时的样式表大小过大，从而影响性能。这可能需要通过一些工具进行优化。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19：CSS3新增了什么特性？"><a href="#Q19：CSS3新增了什么特性？" class="headerlink" title="Q19：CSS3新增了什么特性？"></a>Q19：CSS3新增了什么特性？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>选择器</strong>：<ul><li>更多的属性选择器，如 <code>:nth-child</code>、<code>:not</code> 等。</li><li>伪类选择器的增强，如 <code>:hover</code>、<code>:focus</code>、<code>:active</code> 等。</li></ul></li><li><strong>盒模型</strong>：<ul><li>圆角边框（<code>border-radius</code>）。</li><li>阴影效果（<code>box-shadow</code>）。</li><li>盒阴影效果（<code>text-shadow</code>）。</li></ul></li><li><strong>背景和渐变</strong>：<ul><li>线性渐变（<code>linear-gradient</code>）和径向渐变（<code>radial-gradient</code>）。</li><li>多重背景图像（<code>background-image</code>）。</li></ul></li><li><strong>颜色和透明度</strong>：<ul><li>RGBA 和 HSLA 颜色表示法。</li><li><code>opacity</code> 属性。</li></ul></li><li><strong>字体</strong>：<ul><li>Web 字体（<code>@font-face</code>）。</li><li>字体阴影（<code>text-shadow</code>）。</li></ul></li><li><strong>文本效果</strong>：<ul><li>文本渲染（<code>text-rendering</code>）。</li><li>文本溢出处理（<code>text-overflow</code>）。</li></ul></li><li><strong>2D 转换和变形</strong>：<ul><li><code>transform</code> 属性，包括平移、旋转、缩放等。</li><li><code>transition</code> 属性，用于实现平滑过渡效果。</li></ul></li><li><strong>3D 转换</strong>：<ul><li><code>perspective</code> 属性和 3D 变形。</li></ul></li><li><strong>动画</strong>：<ul><li><code>@keyframes</code> 规则，用于定义动画序列。</li><li><code>animation</code> 属性，用于应用动画。</li></ul></li><li><strong>多列布局</strong>：<ul><li><code>column-count</code>、<code>column-width</code> 等属性，用于实现多列布局。</li></ul></li><li><strong>Flexbox 弹性盒子布局</strong>：<ul><li><code>display: flex</code>，用于创建弹性容器。</li><li><code>flex</code> 属性，用于指定项目的放大比例。</li></ul></li><li><strong>网格布局</strong>：<ul><li><code>display: grid</code>，用于创建网格容器。</li><li><code>grid-template-rows</code>、<code>grid-template-columns</code> 等属性。</li></ul></li><li><strong>过渡效果</strong>：<ul><li><code>transition</code> 属性，用于在鼠标事件触发时实现平滑过渡。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h3 id="Q1：flex布局下怎么改变元素的顺序？"><a href="#Q1：flex布局下怎么改变元素的顺序？" class="headerlink" title="Q1：flex布局下怎么改变元素的顺序？"></a>Q1：flex布局下怎么改变元素的顺序？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在Flex布局中，你可以使用<code>order</code>属性来改变元素的顺序。默认情况下，所有的元素的<code>order</code>值都是0，表示它们按照源代码的顺序排列。通过为元素设置不同的<code>order</code>值，你可以改变它们在Flex容器中的显示顺序。</p><p><code>order</code>的取值可以是任意整数，负数也可以。<code>order</code>值越小，元素越靠前。</p><p>下面是一个简单的例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;order: 3;&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;order: -1;&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，元素2的<code>order</code>值为-1，所以它会在元素1的前面；元素3的<code>order</code>值为3，所以它会在元素4的后面。</p><p>请注意，<code>order</code>属性仅改变布局显示的顺序，而不改变文档流中的实际顺序。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：flex：-auto是什么意思？"><a href="#Q2：flex：-auto是什么意思？" class="headerlink" title="Q2：flex： auto是什么意思？"></a>Q2：flex： auto是什么意思？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在Flex布局中，<code>flex: auto</code>是一种设置<code>flex</code>属性的快捷方式，它表示元素应该根据其剩余空间来分配主轴空间。</p><p>具体来说，<code>flex: auto</code>将元素的<code>flex-grow</code>属性设置为1，表示该元素在主轴上会根据剩余空间进行拉伸，尽可能地占据可用空间。这通常用于使一些项目占据剩余空间，而其他项目则根据它们的内容或固定尺寸来分配空间。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: auto;</span><br><span class="line">  <span class="comment">/* 或者使用 flex: 1; */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="comment">/* 这个项目将根据内容占据空间，不会拉伸 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>.item1</code>将占据剩余空间，而<code>.item2</code>将根据其内容占据空间，而不会拉伸。使用<code>flex: auto</code>可以方便地实现这种效果，而无需手动设置<code>flex-grow</code>的值。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：Object-fit的用法是什么"><a href="#Q3：Object-fit的用法是什么" class="headerlink" title="Q3：Object-fit的用法是什么"></a>Q3：Object-fit的用法是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>object-fit</code>是一个用于指定替换元素（例如<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>等）的内容如何适应其容器的 CSS 属性。它可以控制替换元素的尺寸、位置以及是否裁剪。</p><ol><li><p><strong><code>object-fit: fill;</code>：</strong></p><ul><li>使替换元素的内容完全填充容器，不保持宽高比例。内容可能会变形以适应容器。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>object-fit: contain;</code>：</strong></p><ul><li>保持内容的宽高比例，确保整个内容都能完整显示在容器内，可能在容器内有留白。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>object-fit: cover;</code>：</strong></p><ul><li>保持内容的宽高比例，使内容填充整个容器，可能会裁剪内容。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>object-fit: scale-down;</code>：</strong></p><ul><li><code>contain</code>和<code>cover</code>的结合，选择更小的尺寸，以保持内容完整显示在容器内。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: scale-down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>inherit</code>：</strong></p><ul><li>继承父元素的 <code>object-fit</code> 属性值。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>initial</code>：</strong></p><ul><li>将 <code>object-fit</code> 属性重置为默认值，即 <code>fill</code>。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>revert</code>：</strong></p><ul><li>如果元素有继承的值，则等同于 <code>inherit</code>；否则等同于 <code>initial</code>。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: revert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>revert-layer</code>：</strong></p><ul><li>与 <code>revert</code> 类似，但是更适用于多层嵌套的场景，用于在继承时恢复之前的层级关系。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: revert-layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>unset</code>：</strong></p><ul><li>将 <code>object-fit</code> 属性重置为其父元素的属性值，如果没有继承值，则等同于 <code>initial</code>。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：transition和animation的属性分别有哪些？"><a href="#Q4：transition和animation的属性分别有哪些？" class="headerlink" title="Q4：transition和animation的属性分别有哪些？"></a>Q4：transition和animation的属性分别有哪些？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>transition</code> 和 <code>animation</code> 是用于实现 CSS 动画效果的两个属性，它们有一些共同点，但也有一些不同之处。</p><p><strong><code>transition</code> 属性：</strong></p><p><code>transition</code> 属性是用于在元素状态改变时平滑过渡效果的 CSS 属性。它需要指定以下几个关键属性：</p><ul><li><strong><code>property</code>：</strong> 规定要过渡的 CSS 属性的名称。</li><li><strong><code>duration</code>：</strong> 规定过渡效果的持续时间（以秒或毫秒为单位）。</li><li><strong><code>timing-function</code>：</strong> 规定过渡效果的时间曲线。</li><li><strong><code>delay</code>：</strong> 规定过渡效果何时开始。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 例子 */</span><br><span class="line">.element &#123;</span><br><span class="line">  transition: property duration timing-function delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>animation</code> 属性：</strong></p><p><code>animation</code> 属性允许你创建自定义的动画效果，它需要指定以下几个关键属性：</p><ul><li><strong><code>name</code>：</strong> 规定 <code>@keyframes</code> 动画的名称。</li><li><strong><code>duration</code>：</strong> 规定动画的持续时间（以秒或毫秒为单位）。</li><li><strong><code>timing-function</code>：</strong> 规定动画的时间曲线。</li><li><strong><code>delay</code>：</strong> 规定动画何时开始。</li><li><strong><code>iteration-count</code>：</strong> 规定动画播放的次数。</li><li><strong><code>direction</code>：</strong> 规定是否轮流反向播放动画。</li><li><strong><code>fill-mode</code>：</strong> 规定在动画之前和之后如何将样式应用于元素。</li><li><strong><code>play-state</code>：</strong> 规定动画是运行还是暂停。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 例子 */</span><br><span class="line">.element &#123;</span><br><span class="line">  animation: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些属性的详细说明如下：</p><ul><li><strong><code>property</code> (transition)：</strong> 规定要过渡的 CSS 属性的名称，如 <code>width</code>、<code>height</code> 等。</li><li><strong><code>duration</code> (transition/animation)：</strong> 规定过渡或动画效果的持续时间。</li><li><strong><code>timing-function</code> (transition/animation)：</strong> 规定过渡或动画效果的时间曲线，例如 <code>ease</code>、<code>linear</code> 等。</li><li><strong><code>delay</code> (transition/animation)：</strong> 规定过渡或动画效果何时开始。</li><li><strong><code>name</code> (animation)：</strong> 规定 <code>@keyframes</code> 动画的名称。</li><li><strong><code>iteration-count</code> (animation)：</strong> 规定动画播放的次数，可以使用 <code>infinite</code> 无限播放。</li><li><strong><code>direction</code> (animation)：</strong> 规定是否轮流反向播放动画，可选值有 <code>normal</code>、<code>reverse</code>、<code>alternate</code>、<code>alternate-reverse</code>。</li><li><strong><code>fill-mode</code> (animation)：</strong> 规定在动画之前和之后如何将样式应用于元素，可选值有 <code>none</code>、<code>forwards</code>、<code>backwards</code>、<code>both</code>。</li><li><strong><code>play-state</code> (animation)：</strong> 规定动画是运行还是暂停，可选值有 <code>running</code>、<code>paused</code>。</li></ul><p><strong>区别点</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th><code>transition</code></th><th><code>animation</code></th></tr></thead><tbody><tr><td>触发时机</td><td>元素状态变化时触发，如悬停、获得焦点等</td><td>任意时间点都可触发</td></tr><tr><td>适用性</td><td>适用于简单的状态变化，如颜色、位置、大小等</td><td>适用于复杂的、连续的动画效果</td></tr><tr><td>定义方式</td><td>指定状态变化属性和过渡时间，不需要关键帧</td><td>通过定义关键帧（keyframes）描述整个动画过程</td></tr><tr><td>循环播放</td><td>默认执行一次，不支持循环</td><td>可以通过设置<code>animation-iteration-count</code>属性实现循环</td></tr><tr><td>性能</td><td>相对较轻量，适用于简单状态变化</td><td>在复杂动画可能更耗费性能</td></tr><tr><td>控制</td><td>可以通过JavaScript改变元素的类或样式触发</td><td>通过JavaScript可以更精细地控制动画</td></tr><tr><td>示例</td><td><code>transition: width 1s ease;</code></td><td><code>animation: myAnimation 2s infinite;</code></td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：-before跟-after这两个选择器有两个冒号跟一个冒号有什么区别跟作用？"><a href="#Q5：-before跟-after这两个选择器有两个冒号跟一个冒号有什么区别跟作用？" class="headerlink" title="Q5：::before跟::after这两个选择器有两个冒号跟一个冒号有什么区别跟作用？"></a>Q5：::before跟::after这两个选择器有两个冒号跟一个冒号有什么区别跟作用？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>::before</code> 和 <code>::after</code> 是 CSS 伪元素选择器，它们用于在元素的内容前面和后面生成虚拟的元素，并通过样式进行装饰或添加内容。</p><ol><li><strong>冒号数量：</strong><ul><li><code>:before</code> 和 <code>:after</code> 是 CSS2 中引入的伪元素选择器。</li><li><code>::before</code> 和 <code>::after</code> 是 CSS3 中引入的双冒号语法，用于明确区分伪元素和伪类，增加语法的规范性。</li></ul></li><li><strong>区别：</strong><ul><li>在实际使用中，单冒号和双冒号在大多数浏览器中可以互换使用，因为现代浏览器已经广泛支持双冒号语法。</li><li>双冒号语法是为了与伪类区分，更明确表示它们是伪元素而不是伪类。</li></ul></li><li><strong>作用：</strong><ul><li><code>::before</code> 用于在元素内容前生成一个虚拟元素。</li><li><code>::after</code> 用于在元素内容后生成一个虚拟元素。</li></ul></li></ol><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 使用单冒号语法 */</span><br><span class="line">.element:before &#123;</span><br><span class="line">  content: &quot;Before&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 使用双冒号语法 */</span><br><span class="line">.element::after &#123;</span><br><span class="line">  content: &quot;After&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>.element</code> 元素的前面生成一个包含文本 “Before” 的虚拟元素，后面生成一个包含文本 “After” 的虚拟元素。使用单冒号或双冒号的效果是一样的，但为了符合最新的规范，推荐使用双冒号语法。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：z-index什么情况下会失效？"><a href="#Q6：z-index什么情况下会失效？" class="headerlink" title="Q6：z-index什么情况下会失效？"></a>Q6：z-index什么情况下会失效？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>z-index</code> 是用于控制元素的层叠顺序的 CSS 属性，但有一些情况下它可能表现得不如预期，失效的情况主要与文档流的特性和元素的定位方式有关：</p><ol><li><p><strong>未定位元素：</strong> <code>z-index</code> 只对定位元素（相对定位、绝对定位、固定定位）有效。如果一个元素没有被定位，设置 <code>z-index</code> 不会产生层叠效果。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.unpositioned</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999</span>; <span class="comment">/* 不会生效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>父元素 <code>z-index</code> 影响子元素：</strong> 如果子元素的 <code>z-index</code> 大于父元素的 <code>z-index</code>，在父元素的范围内仍然无法超越父元素的层叠顺序。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 1;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> <span class="attr">style</span>=<span class="string">&quot;z-index: 999;&quot;</span>&gt;</span> <span class="comment">&lt;!-- 不会超越父元素的层叠顺序 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>普通流中的元素：</strong> <code>z-index</code> 只对定位元素有效，对于普通流中的元素，即使设置了 <code>z-index</code>，也无法改变其默认的层叠顺序。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.normal-flow</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999</span>; <span class="comment">/* 不会生效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>定位方式为 <code>static</code>：</strong> 如果元素的定位方式是 <code>static</code>（默认值），即使设置了 <code>z-index</code> 也不会生效。需要将元素的定位方式改为相对定位、绝对定位或固定定位。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.static-position</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">999</span>; <span class="comment">/* 不会生效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：position-fixed一定是根据浏览器窗口去定位的吗？"><a href="#Q7：position-fixed一定是根据浏览器窗口去定位的吗？" class="headerlink" title="Q7：position:fixed一定是根据浏览器窗口去定位的吗？"></a>Q7：position:fixed一定是根据浏览器窗口去定位的吗？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>position: fixed;</code> 不一定是根据浏览器窗口去定位的，它是相对于最近的具有定位（非 static）属性的父元素进行定位的。如果没有符合条件的父元素，那么它将相对于初始包含块进行定位，而初始包含块通常是浏览器视口。</p><p>所以，<code>position: fixed;</code> 的定位参考点可能是：</p><ol><li><p><strong>最近的具有定位（非 static）属性的父元素：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; top: 10px; left: 10px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果没有符合条件的父元素，相对于初始包含块：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; top: 10px; left: 10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：css选择器有哪一些？它们的优先级顺序是什么？有什么属性是可以继承的？什么属性是不可以继承的？"><a href="#Q8：css选择器有哪一些？它们的优先级顺序是什么？有什么属性是可以继承的？什么属性是不可以继承的？" class="headerlink" title="Q8：css选择器有哪一些？它们的优先级顺序是什么？有什么属性是可以继承的？什么属性是不可以继承的？"></a>Q8：css选择器有哪一些？它们的优先级顺序是什么？有什么属性是可以继承的？什么属性是不可以继承的？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>元素选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.classname</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ID 选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#idname</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[attribute=<span class="string">&quot;value&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>伪类选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>伪元素选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>子元素选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">parent &gt; child &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>相邻兄弟选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">element + element &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通用选择器：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>CSS 选择器的优先级顺序如下：</p><ol><li><strong>内联样式（Inline styles）：</strong> 优先级最高，直接在元素上使用 <code>style</code> 属性设置的样式。</li><li><strong>ID 选择器（#id）：</strong> 优先级高于类选择器和元素选择器。</li><li><strong>类选择器（.class）、属性选择器、伪类选择器：</strong> 优先级相同，按照出现的顺序计算。</li><li><strong>元素选择器、伪元素选择器、子元素选择器、相邻兄弟选择器：</strong> 优先级相同，按照出现的顺序计算。</li><li><strong>通用选择器（*）、继承：</strong> 优先级最低，只有在前面的规则没有设置样式时才会应用。</li></ol><p>属性可继承的特性包括：</p><ul><li>字体系列（font-family）</li><li>字体大小（font-size）</li><li>字重（font-weight）</li><li>行高（line-height）</li><li>字体样式（font-style）</li><li>颜色（color）</li><li>文本缩进（text-indent）</li></ul><p>属性不可继承的特性包括：</p><ul><li>边框（border）</li><li>外边距（margin）</li><li>内边距（padding）</li><li>宽度（width）</li><li>高度（height）</li><li>背景（background）</li><li>定位属性（position）</li><li>浮动属性（float）</li><li>清除浮动（clear）</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：为什么有时候用translate来改变元素位置而不是position"><a href="#Q9-：为什么有时候用translate来改变元素位置而不是position" class="headerlink" title="Q9 ：为什么有时候用translate来改变元素位置而不是position"></a>Q9 ：为什么有时候用translate来改变元素位置而不是position</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>使用<code>translate</code>来改变元素位置相比于<code>position</code>属性具有一些优势，主要体现在性能和动画效果方面：</p><ol><li><strong>硬件加速：</strong> 使用<code>translate</code>可以触发硬件加速，这意味着浏览器会使用GPU来处理元素的变换，从而提高动画的性能。相比之下，使用<code>position</code>属性可能触发软件渲染，性能较差。</li><li><strong>不影响文档流：</strong> <code>translate</code>对文档流没有影响，元素的位置变化不会引起文档重新布局（reflow），因此在动画过程中不会触发性能消耗较大的重排操作。</li><li><strong>更平滑的动画效果：</strong> 由于<code>translate</code>是在合成阶段进行的，相对于使用<code>position</code>的动画效果更加平滑，没有闪烁或抖动。</li><li><strong>更容易实现复杂动画：</strong> 使用<code>translate</code>可以方便地实现复杂的动画效果，例如平移、旋转、缩放等可以同时进行的变换，而不需要使用多个<code>position</code>属性来实现。</li><li><strong>响应式设计：</strong> <code>translate</code>可以更方便地应用于响应式设计，因为它不依赖于具体的像素值，而是相对于元素自身或其父元素的尺寸。</li></ol><p>尽管<code>translate</code>在某些情况下更有优势，但在一些需要精准控制布局的场景下，使用<code>position</code>可能更为合适</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：下面这段代码class为content的div高度是多少"><a href="#Q10：下面这段代码class为content的div高度是多少" class="headerlink" title="Q10：下面这段代码class为content的div高度是多少"></a>Q10：下面这段代码class为content的div高度是多少</h3><p>难度：⭐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">flex-direction</span>: column;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: black;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>首先，content元素的 height 设置为 “100%”，在父级的高度为固定值时，直接继承该高度，也就是600px。</p><p>但父级设置了 display:flex ，在高度固定的前提下，子元素的高度会按比例进行缩放，所以content元素最后的高度应该是 600 * (600/(200+600+200)) = 360px</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>600px</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：P标签的背景色是什么？"><a href="#Q11：P标签的背景色是什么？" class="headerlink" title="Q11：P标签的背景色是什么？"></a>Q11：P标签的背景色是什么？</h3><p>难度：⭐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-id">#parent</span> <span class="selector-tag">p</span> &#123; <span class="attribute">background-color</span>: red;  &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> <span class="selector-class">.a</span><span class="selector-class">.b</span><span class="selector-class">.c</span><span class="selector-class">.d</span><span class="selector-class">.e</span><span class="selector-class">.f</span><span class="selector-class">.g</span><span class="selector-class">.h</span><span class="selector-class">.i</span><span class="selector-class">.j</span><span class="selector-class">.k</span> <span class="selector-tag">p</span>&#123; <span class="attribute">background-color</span>: green;  </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a b c d e f g h i j k&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>权重是按优先级进行比较的，而不是相加规则。</p><p>red</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：下面的样式都作用域同一个span，哪个会生效？"><a href="#Q12：下面的样式都作用域同一个span，哪个会生效？" class="headerlink" title="Q12：下面的样式都作用域同一个span，哪个会生效？"></a>Q12：下面的样式都作用域同一个span，哪个会生效？</h3><p>难度：⭐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span><span class="selector-id">#god</span> <span class="selector-tag">div</span><span class="selector-class">.dad</span> <span class="selector-tag">span</span><span class="selector-class">.son</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-id">#god</span> <span class="selector-tag">span</span><span class="selector-id">#test</span> &#123;<span class="attribute">width</span>: <span class="number">250px</span>;&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ul><li>先比较高权重位，即第一个样式的高权重为 <code>#god</code> = 100</li><li>第二个样式的高权重为 <code>#god</code> + <code>#text</code> = 200</li><li>100 &lt; 200</li><li>所以最终计算结果是取 <code>width: 250px;</code></li><li>若两个样式的高权重数量一样的话，则需要比较下一较高权重！</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>width: 250px;</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：第二个子元素高度是多少？"><a href="#Q13：第二个子元素高度是多少？" class="headerlink" title="Q13：第二个子元素高度是多少？"></a>Q13：第二个子元素高度是多少？</h3><p>难度：⭐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;min-height: 10px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>Flex 布局会默认：</p><ul><li>把所有子项变成水平排列。</li><li>默认不自动换行。</li><li>让子项与其内容等宽，并把所有子项的高度变为最高子项的高度。</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>100px</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：如何从html元素继承box-sizing？"><a href="#Q14：如何从html元素继承box-sizing？" class="headerlink" title="Q14：如何从html元素继承box-sizing？"></a>Q14：如何从html元素继承box-sizing？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>要从 HTML 元素继承 <code>box-sizing</code> 属性，可以使用全局选择器，将 <code>box-sizing</code> 应用到所有元素。以下是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy codehtml &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*, *::before, *::after &#123;</span><br><span class="line">  box-sizing: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，首先将 <code>html</code> 元素的 <code>box-sizing</code> 设置为 <code>border-box</code>，表示所有元素的宽度和高度都包含内边距和边框。然后，通过 <code>*</code> 通用选择器，以及 <code>::before</code> 和 <code>::after</code> 伪元素选择器，将 <code>box-sizing</code> 继承设置为 <code>inherit</code>，确保所有元素及其伪元素都继承了相同的 <code>box-sizing</code> 值。</p><p>这样设置可以确保整个页面中的所有元素都采用相同的 <code>box-sizing</code> 规则，方便进行一致的布局计算。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：position：absolute绝对定位是相对于谁的定位？"><a href="#Q15：position：absolute绝对定位是相对于谁的定位？" class="headerlink" title="Q15：position：absolute绝对定位是相对于谁的定位？"></a>Q15：position：absolute绝对定位是相对于谁的定位？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>position: absolute;</code> 绝对定位是相对于其最近的非 <code>static</code> 定位的祖先元素进行定位的。如果不存在这样的祖先元素，则相对于初始包含块（通常是视口）进行定位。</p><p>简而言之，绝对定位的元素会找到离它最近的具有定位属性（非 <code>static</code>）的祖先元素，然后相对于该祖先元素进行定位。如果没有找到这样的祖先元素，它将相对于初始包含块进行定位。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：display有哪些取值？"><a href="#Q16：display有哪些取值？" class="headerlink" title="Q16：display有哪些取值？"></a>Q16：display有哪些取值？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>block（块级元素）</strong>：</p><ul><li>元素生成一个块级框。</li><li>块级元素会在新行上开始，并占据其父容器的整个宽度。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: block;</span><br></pre></td></tr></table></figure></li><li><p><strong>inline（行内元素）</strong>：</p><ul><li>元素生成一个行内框。</li><li>行内元素不会开始新行，仅占据其内容的宽度。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline;</span><br></pre></td></tr></table></figure></li><li><p><strong>inline-block（行内块级元素）</strong>：</p><ul><li>元素生成一个行内块级框。</li><li>行内块级元素可以设置宽度和高度，同时保持在同一行。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-block;</span><br></pre></td></tr></table></figure></li><li><p><strong>flex（弹性容器）</strong>：</p><ul><li>元素成为一个弹性容器。</li><li>子元素成为弹性项目，可以通过<code>flex</code>属性进行布局。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br></pre></td></tr></table></figure></li><li><p><strong>grid（网格容器）</strong>：</p><ul><li>元素成为一个网格容器。</li><li>子元素成为网格项，可以通过<code>grid</code>属性进行布局。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid;</span><br></pre></td></tr></table></figure></li><li><p><strong>inline-flex（行内弹性容器）</strong>：</p><ul><li>元素成为一个行内弹性容器。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-flex;</span><br></pre></td></tr></table></figure></li><li><p><strong>inline-grid（行内网格容器）</strong>：</p><ul><li>元素成为一个行内网格容器。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline-grid;</span><br></pre></td></tr></table></figure></li><li><p><strong>none（隐藏元素）</strong>：</p><ul><li>元素不会在页面中生成框，完全不可见。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: none;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：CSS中的flex：1是什么意思？"><a href="#Q17：CSS中的flex：1是什么意思？" class="headerlink" title="Q17：CSS中的flex：1是什么意思？"></a>Q17：CSS中的flex：1是什么意思？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在CSS中，<code>flex: 1</code>是用于设置Flexbox布局中flex项的缩放比例的一种简写形式。具体来说，它是<code>flex-grow</code>, <code>flex-shrink</code>, 和 <code>flex-basis</code>这三个属性的缩写。</p><ul><li><code>flex-grow</code>: 决定了flex项在主轴上的扩展比例。如果所有的flex项都设置了<code>flex-grow</code>，它们的值将决定它们相对于其他项在可用空间中的分配比例。<code>flex-grow</code>默认值为0，表示不进行扩展。</li><li><code>flex-shrink</code>: 决定了flex项在主轴上的收缩比例。如果所有的flex项都设置了<code>flex-shrink</code>，它们的值将决定它们相对于其他项在空间不足时的收缩比例。<code>flex-shrink</code>默认值为1，表示可以进行收缩。</li><li><code>flex-basis</code>: 指定了flex项在主轴上的初始大小。它可以是一个长度值（如像素或百分比）或关键字<code>auto</code>。<code>flex-basis</code>默认值为<code>auto</code>。</li></ul><p>因此，<code>flex: 1</code>等同于设置<code>flex: 1 1 0</code>，表示该flex项会根据可用空间进行扩展和收缩，初始大小为0。这通常用于让flex项平均分配可用空间。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：CSS3新增的伪类有哪些？"><a href="#Q18：CSS3新增的伪类有哪些？" class="headerlink" title="Q18：CSS3新增的伪类有哪些？"></a>Q18：CSS3新增的伪类有哪些？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS3新增的伪类有很多，以下是一些常用的CSS3新增伪类：</p><ol><li><strong>:nth-child(n)</strong>：选择父元素下的第n个子元素。</li><li><strong>:nth-last-child(n)</strong>：选择父元素下的倒数第n个子元素。</li><li><strong>:nth-of-type(n)</strong>：选择父元素下的特定类型的第n个子元素。</li><li><strong>:nth-last-of-type(n)</strong>：选择父元素下的特定类型的倒数第n个子元素。</li><li><strong>:first-child</strong>：选择父元素下的第一个子元素。</li><li><strong>:last-child</strong>：选择父元素下的最后一个子元素。</li><li><strong>:first-of-type</strong>：选择父元素下的特定类型的第一个子元素。</li><li><strong>:last-of-type</strong>：选择父元素下的特定类型的最后一个子元素。</li><li><strong>:only-child</strong>：选择父元素下是唯一子元素的元素。</li><li><strong>:only-of-type</strong>：选择父元素下是唯一特定类型子元素的元素。</li><li><strong>:empty</strong>：选择没有子元素的元素。</li><li><strong>:not(selector)</strong>：选择除了指定选择器匹配的元素之外的所有元素。</li><li><strong>:target</strong>：选择当前活动的目标元素。</li><li><strong>:checked</strong>：选择表单中被选中的radio或checkbox元素。</li><li><strong>:enabled</strong>：选择表单中可用的元素。</li><li><strong>:disabled</strong>：选择表单中不可用的元素。</li><li><strong>:required</strong>：选择表单中必填的元素。</li><li><strong>:optional</strong>：选择表单中非必填的元素。</li><li><strong>:hover</strong>：选择鼠标悬停的元素。</li><li><strong>:focus</strong>：选择获取焦点的元素。</li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h3 id="Q1：单行文本怎么实现两端对齐？"><a href="#Q1：单行文本怎么实现两端对齐？" class="headerlink" title="Q1：单行文本怎么实现两端对齐？"></a>Q1：单行文本怎么实现两端对齐？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>使用 <code>text-align: justify;</code>：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: justify;</span><br><span class="line">  <span class="attribute">text-align-last</span>: justify;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用伪元素 <code>::after</code>：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用弹性盒子（Flexbox）：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用网格布局（Grid）：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：怎么让浏览器支持小于12px的字"><a href="#Q2：怎么让浏览器支持小于12px的字" class="headerlink" title="Q2：怎么让浏览器支持小于12px的字"></a>Q2：怎么让浏览器支持小于12px的字</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>使用相对单位 <code>rem</code> 或 <code>em</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy codebody &#123;</span><br><span class="line">  font-size: 16px; /* 设置基本字体大小 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.small-text &#123;</span><br><span class="line">  font-size: 0.75em; /* 相对于基本字体大小的相对单位 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>font-smooth</code> CSS 属性：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.small-text &#123;</span><br><span class="line">  font-size: 11px;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用字体重置或规范化工具：</strong> 在 HTML 文件中引入 Normalize.css 或其他类似的工具，以确保浏览器默认样式更一致。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!-- 引入 Normalize.css --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用浏览器默认样式：</strong> 对于某些浏览器，默认字体大小可能已经支持小于 12px。在没有明显问题的情况下，可以尝试使用浏览器默认样式。</p></li><li><p><strong>使用图标字体或 SVG：</strong> 对于小尺寸的图标或文本，考虑使用图标字体或 SVG 图片，而不是小字体。这有助于确保清晰度和可读性。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：怎么实现两栏布局，右侧或者左侧自适应？三栏布局中间自适应？这两种布局分别由多少种不同的实现方法？"><a href="#Q3：怎么实现两栏布局，右侧或者左侧自适应？三栏布局中间自适应？这两种布局分别由多少种不同的实现方法？" class="headerlink" title="Q3：怎么实现两栏布局，右侧或者左侧自适应？三栏布局中间自适应？这两种布局分别由多少种不同的实现方法？"></a>Q3：怎么实现两栏布局，右侧或者左侧自适应？三栏布局中间自适应？这两种布局分别由多少种不同的实现方法？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>两栏布局（右侧或左侧自适应）</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span>左侧栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span>主内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>使用浮动布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 左侧栏宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用flex布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 自适应剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用grid布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr; <span class="comment">/* 左侧栏宽度和剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>三栏布局（中间自适应）</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-left&quot;</span>&gt;</span>左侧栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span>主内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-right&quot;</span>&gt;</span>右侧栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>使用浮动布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar-left</span>,</span><br><span class="line"><span class="selector-class">.sidebar-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 左侧栏宽度 */</span></span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>; <span class="comment">/* 右侧栏宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用flex布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar-left</span>,</span><br><span class="line"><span class="selector-class">.sidebar-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 自适应剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用grid布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">200px</span>; <span class="comment">/* 左侧栏宽度、剩余空间、右侧栏宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：怎么实现样式隔离？"><a href="#Q4：怎么实现样式隔离？" class="headerlink" title="Q4：怎么实现样式隔离？"></a>Q4：怎么实现样式隔离？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>样式隔离是指在Web开发中，确保一个组件的样式不会影响到其他组件，以避免全局污染和样式冲突的问题。以下是几种实现样式隔离的方法：</p><ol><li><strong>命名约定：</strong><ul><li><strong>原理：</strong> 通过为每个组件或模块定义独特的类名或ID，确保样式选择器的命名具有足够的唯一性。</li><li><strong>优点：</strong> 简单易行，不需要额外的工具或技术。</li><li><strong>缺点：</strong> 依赖于命名规范的严格性，容易出现冲突。</li></ul></li><li><strong>BEM（Block Element Modifier）：</strong><ul><li><strong>原理：</strong> 使用BEM命名约定，将组件分解为块（Block）、元素（Element）、修饰符（Modifier）三个部分，形成类名的层级结构，提高命名的唯一性。</li><li><strong>优点：</strong> 易于维护，提高了样式命名的可读性和可维护性。</li><li><strong>缺点：</strong> 类名相对较长，可能造成HTML文件的冗余。</li></ul></li><li><strong>CSS Modules：</strong><ul><li><strong>原理：</strong> 使用CSS Modules工具，可以将CSS文件中的类名和选择器进行局部作用域的绑定，确保只在当前组件中生效。</li><li><strong>优点：</strong> 实现了真正的样式隔离，避免了全局命名冲突。</li><li><strong>缺点：</strong> 需要构建工具的支持，如Webpack。</li></ul></li><li><strong>Scoped CSS：</strong><ul><li><strong>原理：</strong> 使用一些前端框架提供的scoped或module化的样式功能，例如Vue的<code>&lt;style scoped&gt;</code>或React的<code>styled-components</code>。</li><li><strong>优点：</strong> 框架内置，使用方便，可以避免手动处理样式隔离。</li><li><strong>缺点：</strong> 依赖于具体的前端框架，可能不够灵活。</li></ul></li><li><strong>Shadow DOM：</strong><ul><li><strong>原理：</strong> 使用Web标准中的Shadow DOM技术，创建一个封闭的、隔离的DOM子树，其中的样式只在Shadow DOM内部生效。</li><li><strong>优点：</strong> 提供了真正的DOM和样式隔离，适用于Web组件。</li><li><strong>缺点：</strong> 目前在所有浏览器中的兼容性还不完全，需要谨慎使用。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：怎么实现单行-多行文本溢出的省略样式？"><a href="#Q5：怎么实现单行-多行文本溢出的省略样式？" class="headerlink" title="Q5：怎么实现单行/多行文本溢出的省略样式？"></a>Q5：怎么实现单行/多行文本溢出的省略样式？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>单行文本溢出省略：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;single-line&quot;</span>&gt;</span></span><br><span class="line">  This is a long single-line text that will be truncated with an ellipsis.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;         <span class="comment">/* 禁止换行 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;            <span class="comment">/* 溢出内容隐藏 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;     <span class="comment">/* 显示省略号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多行文本溢出省略：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;multi-line&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a long multi-line text that will be truncated with an ellipsis after three lines.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.multi-line</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;         <span class="comment">/* 将元素作为弹性伸缩盒模型显示 */</span></span><br><span class="line">  -webkit-box-orient: vertical; <span class="comment">/* 垂直方向排列 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;             <span class="comment">/* 溢出内容隐藏 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;      <span class="comment">/* 显示省略号 */</span></span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>;        <span class="comment">/* 限制行数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多行文本溢出的情况下，使用 <code>-webkit-line-clamp</code> 可以指定最大行数，但该属性目前仅在 WebKit 内核的浏览器（如 Chrome 和 Safari）中支持。在其他浏览器中，你可能需要使用一些 JavaScript 或其他方法来实现多行文本的溢出省略效果。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：css有什么方式可以隐藏页面元素？这几种方式都有什么区别？"><a href="#Q6：css有什么方式可以隐藏页面元素？这几种方式都有什么区别？" class="headerlink" title="Q6：css有什么方式可以隐藏页面元素？这几种方式都有什么区别？"></a>Q6：css有什么方式可以隐藏页面元素？这几种方式都有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>display: none;</code>：</strong></p><ul><li>完全从布局中移除元素，不占据任何空间。</li><li>元素及其子元素都不可见，不会渲染。</li><li>通过修改<code>display</code>属性可以重新显示元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.hidden-element &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>visibility: hidden;</code>：</strong></p><ul><li>元素仍占据布局空间，但变为不可见。</li><li>元素及其子元素在页面中仍有位置，但内容不可见。</li><li>通过修改<code>visibility</code>属性可以重新显示元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.hidden-element &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>opacity: 0;</code>：</strong></p><ul><li>元素保留其位置和布局，但变为完全透明。</li><li>元素及其子元素在页面中仍占据空间，但内容不可见。</li><li>通过修改<code>opacity</code>属性可以重新显示元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.hidden-element &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>position: absolute;</code> + <code>left: -9999px;</code>：</strong></p><ul><li>将元素移动到视口之外，但仍保留其布局。</li><li>元素及其子元素在页面中仍占据空间，但位置在视口之外。</li><li>通过修改<code>left</code>属性可以重新显示元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.hidden-element &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: -9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>clip-path: polygon(0 0, 0 0, 0 0, 0 0);</code>：</strong></p><ul><li>使用裁剪路径将元素剪裁为一个不可见的区域。</li><li>元素及其子元素在页面中仍占据空间，但被裁剪为不可见形状。</li><li>通过修改<code>clip-path</code>属性可以重新显示元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.hidden-element &#123;</span><br><span class="line">  clip-path: polygon(0 0, 0 0, 0 0, 0 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>选择隐藏方式取决于具体的需求。如果要完全从布局中移除元素，可以使用 <code>display: none;</code>。如果需要保留布局但使元素不可见，可以使用 <code>visibility: hidden;</code> 或 <code>opacity: 0;</code></p><div class="table-container"><table><thead><tr><th>方式</th><th>布局</th><th>可见性</th><th>重新显示</th></tr></thead><tbody><tr><td><code>display: none;</code></td><td>完全移除</td><td>不可见</td><td>修改 <code>display</code> 属性</td></tr><tr><td><code>visibility: hidden;</code></td><td>保留布局空间</td><td>不可见</td><td>修改 <code>visibility</code> 属性</td></tr><tr><td><code>opacity: 0;</code></td><td>保留布局位置</td><td>不可见</td><td>修改 <code>opacity</code> 属性</td></tr><tr><td><code>position: absolute;</code><br><code>left: -9999px;</code></td><td>移动到视口外</td><td>保留布局空间</td><td>修改 <code>left</code> 属性</td></tr><tr><td><code>clip-path: polygon(0 0, 0 0, 0 0, 0 0);</code></td><td>保留布局空间</td><td>部分可见，被裁剪</td><td>修改 <code>clip-path</code> 属性</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：使用css实现一个无限循环动画"><a href="#Q7：使用css实现一个无限循环动画" class="headerlink" title="Q7：使用css实现一个无限循环动画"></a>Q7：使用css实现一个无限循环动画</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>要创建一个无限循环的 CSS 动画，你可以使用 <code>@keyframes</code> 规则和 <code>animation</code> 属性。以下是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code@keyframes rotate &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotate(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.infinite-rotation &#123;</span><br><span class="line">  animation: rotate 5s infinite linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 <code>rotate</code> 的关键帧动画，使元素在 0% 处和 100% 处的状态下旋转 360 度。然后，我们将这个动画应用于类名为 <code>infinite-rotation</code> 的元素，使其在5秒内以线性的方式无限循环旋转。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：怎么实现一个宽高自适应的正方形"><a href="#Q8：怎么实现一个宽高自适应的正方形" class="headerlink" title="Q8：怎么实现一个宽高自适应的正方形"></a>Q8：怎么实现一个宽高自适应的正方形</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>方法一：使用相对单位和 <code>padding</code> 百分比</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vmin</span>; <span class="comment">/* 或其他百分比值，相对于视口宽度或高度中较小的那个 */</span></span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">50vmin</span>; <span class="comment">/* 50% 相对于视口宽度或高度中较小的那个 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: red; <span class="comment">/* 为了演示效果，可以添加背景色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：使用百分比设置宽高和 <code>padding</code> 百分比</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue; <span class="comment">/* 为了演示效果，可以添加背景色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：使用 <code>::before</code> 伪元素</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.square-3</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square-3</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square-3-content</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green; <span class="comment">/* 为了演示效果，可以添加背景色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种方法都利用了百分比或相对单位以及 <code>padding</code> 百分比的特性，确保宽度和高度保持一致，从而实现宽高自适应的正方形。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：怎么做移动端的样式适配？"><a href="#Q9-：怎么做移动端的样式适配？" class="headerlink" title="Q9 ：怎么做移动端的样式适配？"></a>Q9 ：怎么做移动端的样式适配？</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在移动端，由于不同手机屏幕尺寸、分辨率、横竖屏等因素的影响，需要考虑到不同情况下的展示效果，因此需要进行移动端适配。以下是一些基本知识点：</p><ol><li><strong>像素单位：</strong><ul><li>设备像素（device pixels）是显示器上的真实像素。</li><li>设备分辨率描述的是显示器的宽和高分别是多少个设备像素。</li><li>设备独立像素（device independent pixels）是操作系统定义的一种像素单位，用于在应用程序和设备像素之间建立关系，以适应不同屏幕参数。</li><li>CSS像素用于在CSS中表示长度，如<code>width: 128px</code>。</li></ul></li><li><strong>Viewport：</strong><ul><li>布局视口（layout viewport）是网页布局的区域，用于展示整个页面，使用CSS像素衡量尺寸。</li><li>视觉视口（visual viewport）是实际可见的网页区域，随着缩放和窗口调整而改变，但不影响布局视口。</li><li>理想视口（ideal viewport）是移动设备的最适合的视口，宽度等于设备的屏幕宽度。</li></ul></li><li><strong>Viewport控制：</strong><ul><li>使用<code>&lt;meta&gt;</code>标签控制viewport，常见设置为<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</code>。</li><li><code>width=device-width</code>设置layout viewport的宽度等于设备的宽度。</li><li><code>initial-scale</code>设置页面的初始缩放值。</li><li><code>user-scalable</code>控制是否允许用户手动缩放。</li></ul></li></ol><p>适配方案的核心是理解不同像素单位之间的关系，以及通过设置viewport来实现适配不同屏幕的效果。这对于确保在移动设备上呈现出良好的用户体验至关重要。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>1. 使用CSS的媒体查询@media</strong></p><p>基于CSS的媒体查询属性<code>@media</code>可以为不同屏幕尺寸的移动设备编写不同尺寸的CSS属性。然而，这种方法存在一些问题：</p><ul><li>所有元素都需要在不同的<code>@media</code>中定义不同的尺寸，代价较高。</li><li>随着屏幕尺寸的增加，需要添加更多的<code>@media</code>查询块。</li></ul><p>示例代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">62.5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">53.3333px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用rem单位</strong></p><p><code>rem</code>（根元素字体大小的单位）是相对于根元素的字体大小的单位。虽然可以使用<code>rem</code>解决移动设备适配问题，但需要借助<code>@media</code>属性为不同大小的设备设置不同的<code>font-size</code>，存在一些繁琐的计算。</p><p>示例代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">375px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">375px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">360px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">360px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">320px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">320px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">180rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. Flexible适配方案</strong></p><p>Flexible方案对<code>rem</code>进行改进，通过JS动态设置根字体大小。它可以模拟<code>vw</code>特性适配多种屏幕尺寸，但存在一些缺陷：</p><ul><li>对于视频播放器的样式在不同dpr的设备上可能存在差异。</li><li>不再兼容@media的响应式布局。</li><li>在某些时期可能存在兼容性不友好。</li></ul><p><strong>4. Viewport适配方案</strong></p><p>基于<code>viewport</code>的适配方案被广泛采用。使用<code>vw</code>作为布局单位，解决了不同尺寸屏幕的适配问题。可以使用<code>postcss-px-to-viewport</code>插件将<code>px</code>自动转换为<code>vw</code>。</p><p><em>4.1 设置meta标签</em></p><p>在HTML头部设置meta标签，使当前<code>viewport</code>的宽度等于设备的宽度，同时不允许用户手动缩放。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>4.2 px自动转换为vw</em></p><p>使用<code>postcss-px-to-viewport</code>插件将<code>px</code>自动转换为<code>vw</code>，配置相关参数。</p><p><em>4.3 标注不需要转换的属性</em></p><p>如果某些场景不需要自适配，可以使用插件的Ignoring特性标注不需要转换的CSS属性。</p><p><em>4.4 Retina屏预留坑位</em></p><p>考虑Retina屏场景，可以通过判断dpr并设置<code>data-dpr</code>，在CSS中根据不同的dpr写不同的样式类。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><strong>行内样式的场景：</strong><ul><li>postcss-px-to-viewport 插件无法处理行内样式中的px单位转换。</li><li>最佳实践是通过添加、修改、删除 className 处理，不直接操作行内样式，符合js和css隔离的实践。</li></ul></li><li><strong>1px问题解决方案：</strong><ul><li>Retina屏下1px问题常见，需特殊处理。</li><li>常用方法：<ul><li><code>transform: scale(0.5)</code>：通过缩放解决1px线条问题，但边框处理较复杂。</li><li><code>transform: scale(0.5) + :before/:after</code>：结合伪元素解决1px问题，通用性好。</li><li><code>box-shadow</code>：利用阴影模拟边框，存在阴影问题。</li></ul></li></ul></li><li><strong>其他1px问题处理方法（不推荐）：</strong><ul><li>缩小页面viewport。</li><li>使用border-image切图模拟。</li><li>使用background-image切图模拟。</li><li>使用linear-gradient通过渐变实现。</li><li>使用SVG矢量图形。</li></ul></li><li><strong>图片高清问题：</strong><ul><li>针对Retina屏预留dpr方案，根据不同dpr使用对应图片。</li></ul></li><li><strong>iPhone X适配方案：</strong><ul><li>了解新知识：<ul><li>安全区域：确保页面可视、可操作区域在安全区域内，不受设备特性影响。</li><li>viewport-fit：新增属性，设置网页在可视窗口的布局方式。</li><li>env()和constant()：CSS函数，设定安全区域与边界距离。</li></ul></li><li>适配步骤：<ul><li>设置viewport-fit=cover。</li><li>处理fixed元素的底部适配，考虑安全区域。</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：css垂直居中有几种方式？"><a href="#Q10：css垂直居中有几种方式？" class="headerlink" title="Q10：css垂直居中有几种方式？"></a>Q10：css垂直居中有几种方式？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>垂直居中是在网页布局中常见的需求，有多种方式可以实现。以下是几种常见的CSS垂直居中方式：</p><ol><li><p><strong>使用Flexbox（弹性盒子布局）：</strong> 使用Flexbox是一种简单而强大的方式，特别适用于垂直和水平居中。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Grid（网格布局）：</strong> Grid布局同样提供了简单的居中方式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  place-items: center; <span class="comment">/* 垂直和水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用position和transform：</strong> 利用绝对定位和transform属性可以实现垂直居中。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用line-height：</strong> 对于单行文本，可以使用line-height属性。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>; <span class="comment">/* 与容器高度相同 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用表格布局：</strong> 利用表格布局可以实现垂直和水平居中。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用伪元素和absolute定位：</strong> 利用伪元素进行占位，然后绝对定位可以实现居中。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：怎么让flex布局最后一行列表左对齐？"><a href="#Q11：怎么让flex布局最后一行列表左对齐？" class="headerlink" title="Q11：怎么让flex布局最后一行列表左对齐？"></a>Q11：怎么让flex布局最后一行列表左对齐？</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24%</span>; <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/01/18/TpO37v6iCQukPmc.png" alt="image-20240118162615644"></p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>方法一：模拟space-between和间隙</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    width: 24%; </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.list:not(:nth-child(4n)) &#123;</span><br><span class="line">    margin-right: calc(4% / 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Flex布局设置<code>flex-wrap: wrap</code>，使子项可以换行。</li><li>通过<code>:not(:nth-child(4n))</code>选择器排除每行的第4、8、12…个元素，然后给它们添加右侧的margin，模拟space-between效果。</li></ul><p><strong>方法二：根据个数最后一个元素动态margin</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    width: 24%; </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.list:last-child:nth-child(4n - 1) &#123;</span><br><span class="line">    margin-right: calc(24% + 4% / 3);</span><br><span class="line">&#125;</span><br><span class="line">.list:last-child:nth-child(4n - 2) &#123;</span><br><span class="line">    margin-right: calc(48% + 8% / 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Flex布局设置<code>justify-content: space-between</code>，实现两端对齐。</li><li>通过<code>:last-child:nth-child(4n - 1)</code>和<code>:last-child:nth-child(4n - 2)</code>选择器选择最后一行的第3和第2个元素，分别添加动态的右侧margin。</li></ul><p><strong>方法三：最后一项margin-right:auto</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.list:last-child &#123;</span><br><span class="line">    margin-right: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Flex布局设置<code>justify-content: space-between</code>，实现两端对齐。</li><li>给最后一个子项使用<code>margin-right: auto</code>，使其占据剩余空间，实现左对齐效果。</li></ul><p><strong>方法四：创建伪元素并设置flex:auto或flex:1</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.container::after &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    flex: auto;    /* 或者flex: 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Flex布局设置<code>justify-content: space-between</code>，实现两端对齐。</li><li>创建伪元素<code>::after</code>，设置<code>flex:auto</code>或<code>flex:1</code>，使其占据剩余空间，实现左对齐效果。</li></ul><p><strong>方法五：Grid布局</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">    grid-gap: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    width: 100px; </span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin-top: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Grid布局设置<code>justify-content: space-between</code>，实现两端对齐。</li><li>使用<code>grid-template-columns: repeat(auto-fill, 100px)</code>定义自动填充的列，实现左对齐效果。</li></ul><p><strong>方法六：使用足够的空白标签进行填充占位</strong></p><p><em>CSS代码：</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    margin-right: -10px;</span><br><span class="line">&#125;</span><br><span class="line">.list &#123;</span><br><span class="line">    width: 100px; </span><br><span class="line">    height:100px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    margin: 15px 10px 0 0;</span><br><span class="line">&#125;</span><br><span class="line">.container &gt; i &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>实现原理：</em></p><ul><li>使用Flex布局设置<code>justify-content: space-between</code>，实现两端对齐。</li><li>使用伪元素<code>&lt;i&gt;</code>进行占位，通过<code>margin</code>调整宽度和右侧间隙，实现左对齐效果。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：相邻的两个inline-block节点为什么会出现间隔？怎么解决？"><a href="#Q12：相邻的两个inline-block节点为什么会出现间隔？怎么解决？" class="headerlink" title="Q12：相邻的两个inline-block节点为什么会出现间隔？怎么解决？"></a>Q12：相邻的两个inline-block节点为什么会出现间隔？怎么解决？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在处理相邻的<code>inline-block</code>节点之间的间隔时，有一些常见的方法，包括一些特殊的CSS技巧。以下是一些常见的解决方法，总共有9种：</p><ol><li><p><strong>删除HTML代码中的空白字符：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline-block-element&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline-block-element&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用注释清除空白：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline-block-element&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline-block-element&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置父容器字体大小为0：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block-element</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>letter-spacing</code>：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: -<span class="number">0.31em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用<code>word-spacing</code>：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">word-spacing</span>: -<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>设置负<code>margin</code>：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inline-block-element</span> + <span class="selector-class">.inline-block-element</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">4px</span>; <span class="comment">/* 负margin值等于两个元素间隔的宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Flex布局：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Flexbox的<code>gap</code>属性：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">gap</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Grid布局：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="built_in">minmax</span>(<span class="number">0</span>, <span class="number">1</span>fr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：css怎么实现移动端禁用页面左右滑动手势"><a href="#Q13：css怎么实现移动端禁用页面左右滑动手势" class="headerlink" title="Q13：css怎么实现移动端禁用页面左右滑动手势"></a>Q13：css怎么实现移动端禁用页面左右滑动手势</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>使用 <code>touch-action</code> 属性：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  touch-action: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者通过指定元素的宽度和 overflow 来实现：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>overscroll-behavior</code> 属性：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  overscroll-behavior: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>position: fixed</code> 固定定位：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：怎么检测浏览器支持的最小字体大小？"><a href="#Q14：怎么检测浏览器支持的最小字体大小？" class="headerlink" title="Q14：怎么检测浏览器支持的最小字体大小？"></a>Q14：怎么检测浏览器支持的最小字体大小？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>要检测浏览器支持的最小字体大小，你可以使用 JavaScript 来获取浏览器的最小字体大小设置。下面是一个简单的方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;1px&#x27;</span>; <span class="comment">// 设置一个很小的字体大小</span></span><br><span class="line">div.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computedFontSize = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(div).<span class="property">fontSize</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(div);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;浏览器支持的最小字体大小：&#x27;</span>, computedFontSize);</span><br></pre></td></tr></table></figure><p>此代码创建一个隐藏的 <code>div</code> 元素，将其字体大小设置为1px，然后通过 <code>getComputedStyle</code> 获取计算后的样式，包括最小字体大小。最后，移除该 <code>div</code> 元素。</p><p>请注意，这只是获取当前样式表中设置的最小字体大小，并不一定代表浏览器的默认最小字体大小。某些浏览器可能对最小字体大小有硬性限制，无法通过 CSS 直接设置。此方法适用于获取当前页面样式表中的最小字体大小设置。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：iconfont的实现原理是什么"><a href="#Q15：iconfont的实现原理是什么" class="headerlink" title="Q15：iconfont的实现原理是什么"></a>Q15：iconfont的实现原理是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Iconfont（字体图标）的实现原理主要基于字体文件（通常是.ttf或.woff格式）。以下是实现原理的主要步骤：</p><ol><li><strong>图标设计：</strong> 首先，需要设计所需的图标，这些图标通常以矢量图形的形式存在。设计师可以使用矢量图形工具（如Illustrator、Sketch等）创建这些图标。</li><li><strong>字体制作：</strong> 将设计好的图标通过专门的工具（如阿里巴巴矢量图标库的在线制作工具）转换为字体文件。这个字体文件包含了每个图标对应的字符编码，每个字符对应一个图标。</li><li><strong>引入字体文件：</strong> 将生成的字体文件引入到项目中。通常，开发者可以通过CSS的<code>@font-face</code>规则将字体文件嵌入到网页中。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code@font-face &#123;</span><br><span class="line">  font-family: &#x27;iconfont&#x27;;</span><br><span class="line">  src: url(&#x27;iconfont.woff2&#x27;) format(&#x27;woff2&#x27;),</span><br><span class="line">       url(&#x27;iconfont.woff&#x27;) format(&#x27;woff&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用字体图标：</strong> 在HTML或CSS中使用字体图标，通过指定相应的字符编码即可显示对应的图标。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;i class=&quot;iconfont&quot;&gt;&amp;#xe001;&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>上述代码中，<code></code> 是字体文件中某个图标对应的字符编码，浏览器会根据这个编码找到对应的图标进行显示。</p><ol><li><strong>样式调整：</strong> 可以通过CSS来调整字体图标的样式，比如颜色、大小等。</li></ol><p>字体图标的优势在于它是矢量的，可以无损放大缩小而不失真，并且只需要加载一份字体文件即可使用多个图标，减小了网络请求的数量。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：css种的1像素问题是什么？要怎么解决？"><a href="#Q16：css种的1像素问题是什么？要怎么解决？" class="headerlink" title="Q16：css种的1像素问题是什么？要怎么解决？"></a>Q16：css种的1像素问题是什么？要怎么解决？</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在移动端开发中，1像素问题是指在高像素密度的设备上（如Retina屏幕），使用1像素的边框或线条在显示时会过于粗细，影响视觉效果。这是因为在Retina屏幕上，一个CSS像素对应多个物理像素，导致1像素的边框在物理像素上被拉伸，显得较粗。</p><p>解决1像素问题的常见方法包括：</p><ol><li><p><strong>使用viewport单位：</strong> 使用<code>vw</code>（视窗宽度单位）或<code>vh</code>（视窗高度单位）来设置边框或线条的宽度，以相对于视窗大小的方式进行定义，而不是使用固定的像素值。例如，<code>border: 0.01vw solid #000;</code>。</p></li><li><p><strong>使用媒体查询：</strong> 利用媒体查询检测设备的像素比（device pixel ratio，通常为2或3），然后根据像素比调整边框或线条的样式。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (min-resolution: 2dppx) &#123;</span><br><span class="line">    /* 高像素密度设备的样式 */</span><br><span class="line">    .element &#123;</span><br><span class="line">        border: 0.5px solid #000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用伪元素和transform：</strong> 通过使用伪元素和<code>transform: scaleY(0.5);</code>来实现边框的缩放，使得1像素边框在Retina屏幕上看起来更细。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element::after &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    height: 1px;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用box-shadow：</strong> 利用<code>box-shadow</code>属性模拟边框效果，可以在不同的方向上添加阴影来实现1像素线条。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.element &#123;</span><br><span class="line">    box-shadow: 0 1px 0 0 #000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：CSS优化跟提高性能的方法有哪些？"><a href="#Q17：CSS优化跟提高性能的方法有哪些？" class="headerlink" title="Q17：CSS优化跟提高性能的方法有哪些？"></a>Q17：CSS优化跟提高性能的方法有哪些？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>优化CSS以提高性能是一个重要的前端任务，以下是一些常见的CSS优化和性能提高的方法：</p><ol><li><strong>减少HTTP请求：</strong><ul><li>将多个CSS文件合并成一个文件，减少HTTP请求次数。</li><li>使用CSS Sprites将多个小图标合并成一张大图，减少图片的HTTP请求。</li></ul></li><li><strong>精简和压缩CSS：</strong><ul><li>移除不必要的空格、注释和换行。</li><li>使用CSS压缩工具，如UglifyCSS、cssnano等。</li></ul></li><li><strong>使用字体图标：</strong><ul><li>替代使用图片的小图标，使用字体图标（如Font Awesome、Material Icons）减少图片请求。</li></ul></li><li><strong>避免使用@import：</strong><ul><li>使用<link>标签引入CSS文件，而不是使用@import，因为@import会增加页面加载时间。</li></ul></li><li><strong>减少选择器的嵌套和复杂性：</strong><ul><li>避免过度嵌套选择器，以减小CSS文件的大小。</li><li>简化选择器，避免使用过于复杂的选择器，提高匹配速度。</li></ul></li><li><strong>使用缓存：</strong><ul><li>使用适当的缓存策略，确保浏览器可以缓存CSS文件，减少重复加载。</li></ul></li><li><strong>使用合适的单位：</strong><ul><li>使用相对单位（如em、rem）而不是绝对单位（如px），以便更好地适应不同屏幕大小和分辨率。</li></ul></li><li><strong>避免使用昂贵的属性和选择器：</strong><ul><li>尽量避免使用性能较差的属性和选择器，如使用<code>position: fixed</code>或<code>box-shadow</code>等。</li></ul></li><li><strong>懒加载CSS：</strong><ul><li>根据页面的需要，延迟加载不是首要渲染的CSS文件，以提高首次加载性能。</li></ul></li><li><strong>使用GPU加速：</strong><ul><li>使用可以利用GPU加速的CSS属性，如transform和opacity，以提高动画性能。</li></ul></li><li><strong>使用媒体查询：</strong><ul><li>使用媒体查询在不同的屏幕尺寸和设备上提供不同的样式表，以优化移动端和桌面端的显示。</li></ul></li><li><strong>避免使用!important：</strong><ul><li>尽量避免使用!important，因为它会增加样式的优先级，使得后续的修改更加困难。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：为什么会出现浮动？什么时候要清除浮动？有什么清除方式？"><a href="#Q18：为什么会出现浮动？什么时候要清除浮动？有什么清除方式？" class="headerlink" title="Q18：为什么会出现浮动？什么时候要清除浮动？有什么清除方式？"></a>Q18：为什么会出现浮动？什么时候要清除浮动？有什么清除方式？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>浮动（float）是一种常见的CSS布局技术，用于控制元素在父元素内的位置。浮动的元素会从文档流中脱离，并向左或向右移动，直到它的边缘碰到包含元素或另一个浮动元素的边缘。</p><p>浮动元素引起的主要问题是可能导致父元素的高度塌陷（高度塌陷指父元素无法包含浮动元素而导致高度为零的情况）。在这种情况下，需要清除浮动。</p><p>何时需要清除浮动：</p><ol><li><strong>父元素包含浮动子元素：</strong> 如果一个元素的子元素都是浮动的，而这个父元素没有设置高度，就会导致高度塌陷，这时需要清除浮动。</li><li><strong>在两个块级元素之间浮动：</strong> 当两个块级元素之间有浮动元素时，后续的块级元素可能会受到浮动元素的影响而位置错乱。</li></ol><p>清除浮动的方式：</p><ol><li><p><strong>使用空元素清除浮动：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.clearfix::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要清除浮动的父元素上添加一个空的块级元素，并应用clearfix类。这个方法适用于大多数浏览器。</p></li><li><p><strong>使用overflow属性：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.clearfix &#123;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给父元素设置 overflow: auto; 或 overflow: hidden;，这样也可以清除浮动，但可能影响盒模型。</p></li><li><p><strong>使用伪元素清除浮动：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code.clearfix::after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用伪元素方式，类似于空元素清除浮动，但不需要在HTML中添加额外的元素。</p></li><li><p><strong>使用BFC（块级格式上下文）：</strong> 父元素设置 <code>overflow: hidden;</code> 或 <code>display: flow-root;</code> 可以创建BFC，从而清除浮动。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19-：如何使用css完成视觉差滚动效果？"><a href="#Q19-：如何使用css完成视觉差滚动效果？" class="headerlink" title="Q19 ：如何使用css完成视觉差滚动效果？"></a>Q19 ：如何使用css完成视觉差滚动效果？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>1. background-attachment: fixed;</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parallax-container</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;background.jpg&#x27;</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过设置 <code>background-attachment: fixed;</code>，可以让背景图保持固定，当页面滚动时，背景图不会随之滚动，从而产生视觉差效果。这是一种简单直观的实现方式。</p><p><strong>2. transform: translate3D;</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parallax-layer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layer1</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;layer1.jpg&#x27;</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">120%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3D</span>(<span class="number">0</span>, -<span class="number">20%</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.layer2</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;layer2.jpg&#x27;</span>);</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3D</span>(<span class="number">0</span>, -<span class="number">25%</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过利用 <code>transform: translate3D;</code> 属性，将图层在垂直方向上进行位移，产生不同层之间的滚动速度差异，从而实现视觉差效果。需要注意调整图层的高度和位移的百分比，以获得理想的效果。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：如何用css画一个三角形？"><a href="#Q20：如何用css画一个三角形？" class="headerlink" title="Q20：如何用css画一个三角形？"></a>Q20：如何用css画一个三角形？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>方法一：利用边框</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">87px</span> solid <span class="number">#3498db</span>; <span class="comment">/* 可自定义颜色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过设置 <code>border-left</code>、<code>border-right</code>、<code>border-bottom</code> 的值，可以绘制一个等边三角形。需要注意的是，三角形的高度可以根据勾股定理计算，这里设定 <code>border-bottom</code> 为 87px 是一个常见的值。</p><p><strong>方法二：利用伪元素</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">50px</span> <span class="number">87px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#3498db</span> transparent; <span class="comment">/* 可自定义颜色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里同样通过设置 <code>border-width</code> 和 <code>border-color</code> 来实现，利用 <code>transparent</code> 使得三角形的一边是透明的。</p>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《Vue 面试题》</title>
    <url>/posts/376fa3ef/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><br/></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="Q1：Vue的scoped的原理是什么"><a href="#Q1：Vue的scoped的原理是什么" class="headerlink" title="Q1：Vue的scoped的原理是什么?"></a>Q1：Vue的scoped的原理是什么?</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Vue 的 <code>scoped</code> 样式原理主要是通过在编译阶段给每个标签生成唯一的哈希标识符，并将这个哈希标识符添加到样式类名中，以实现样式的局部作用域。这样，样式只会影响到具有相同哈希标识符的元素。</p><p>具体原理步骤如下：</p><ol><li><strong>生成唯一标识符：</strong> 在编译时，Vue 会给每个标签生成唯一的哈希标识符（通常是基于文件路径的哈希值）。</li><li><strong>添加到样式类名：</strong> 将生成的唯一标识符添加到每个样式类名前缀，形成类似 <code>.scoped-xxxxxx .your-class</code> 的格式。</li><li><strong>应用样式：</strong> 在渲染时，Vue 会动态地将这个唯一标识符附加到组件的根元素上，并使得样式只对具有相同唯一标识符的元素生效。</li></ol><p>这样做的好处是，样式类名的唯一性确保了样式的局部性，不会污染全局样式。这对于组件化开发非常有用，防止了样式冲突的问题。</p><p>例如，如果原本的样式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 全局样式 */</span><br><span class="line">.your-class &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 <code>scoped</code> 处理后，变成了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cssCopy code/* 编译后的样式 */</span><br><span class="line">.scoped-xxxxxx .your-class &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>.your-class</code> 样式只会影响到拥有相同哈希标识符的元素。这就是 Vue 的 <code>scoped</code> 样式的基本原理</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：虚拟dom渲染到页面的时候，框架会做哪些处理"><a href="#Q2：虚拟dom渲染到页面的时候，框架会做哪些处理" class="headerlink" title="Q2：虚拟dom渲染到页面的时候，框架会做哪些处理?"></a>Q2：虚拟dom渲染到页面的时候，框架会做哪些处理?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>当虚拟 DOM 渲染到页面时，框架通常会执行以下主要处理步骤：</p><ol><li><strong>比对更新</strong>：<ul><li>框架会将虚拟 DOM 与上一次渲染的虚拟 DOM 进行比对，找出发生变化的部分。这一过程通常称为“虚拟 DOM 的 diff 操作”。</li><li>比对的目的是找出需要更新的部分，以便最小化实际 DOM 的操作次数，提高渲染效率。</li></ul></li><li><strong>生成更新补丁</strong>：<ul><li>比对完成后，框架会根据发生变化的部分生成更新补丁（patch）。</li><li>更新补丁通常包含了需要对实际 DOM 进行的操作，比如新增节点、删除节点、修改节点属性等。</li></ul></li><li><strong>应用更新补丁</strong>：<ul><li>框架会根据生成的更新补丁，按照一定的顺序依次对实际 DOM 进行操作。</li><li>这些操作会被批量执行，以提高性能。</li></ul></li><li><strong>更新组件状态</strong>：<ul><li>如果在渲染过程中需要更新组件的状态（比如状态驱动的框架中），框架会执行相应的状态更新操作。</li><li>这可能会触发组件的重新渲染过程，从而形成一个渲染循环。</li></ul></li><li><strong>触发生命周期钩子</strong>：<ul><li>在更新完成后，框架会触发相应的生命周期钩子，通知应用程序更新完成或者执行其他操作。</li><li>这些生命周期钩子可以用于执行一些额外的逻辑，比如在更新完成后执行一些副作用操作。</li></ul></li></ol><p>总的来说，当虚拟 DOM 渲染到页面时，框架会通过比对更新、生成更新补丁、应用更新补丁等步骤来实现页面的渲染更新。这一过程通常是高效的，因为它尽量减少了对实际 DOM 的直接操作，从而提高了性能和渲染效率。</p>
              </div>
            </details>
<p><br/></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><br/></p>
<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><p><br/></p>
<h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><p><br/></p>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><br/></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《Html 面试题》</title>
    <url>/posts/556519a1/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：html为什么要语义化"><a href="#Q1：html为什么要语义化" class="headerlink" title="Q1：html为什么要语义化"></a>Q1：html为什么要语义化</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <blockquote><p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 HTML元素是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。</p></blockquote><ol><li>标签语义化有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取。简单来说。</li><li>有利于不同设备的解析（屏幕阅读器，盲人阅读器等）</li><li>有利于构建清晰的机构，有利于团队的开发、维护</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：html、xml、xhtml有什么区别？"><a href="#Q2：html、xml、xhtml有什么区别？" class="headerlink" title="Q2：html、xml、xhtml有什么区别？"></a>Q2：html、xml、xhtml有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong>HTML（Hypertext Markup Language）：</strong><ul><li>HTML 是一种标记语言，用于描述网页的结构。</li><li>HTML 4 是最早的 HTML 版本，主要基于 SGML（Standard Generalized Markup Language）。</li><li>HTML 5 是最新版本，引入了很多新特性，如语义元素、多媒体支持、本地存储等。</li></ul></li><li><strong>XML（eXtensible Markup Language）：</strong><ul><li>XML 是一种通用的标记语言，设计用于传输和存储数据。</li><li>XML 强调文档的结构和数据的独立性，没有预定义的标签，允许用户定义自己的标签。</li><li>XML 用途广泛，用于配置文件、数据交换、Web 服务等。</li></ul></li><li><strong>XHTML（eXtensible Hypertext Markup Language）：</strong><ul><li>XHTML 是 HTML 的一个基于 XML 的扩展，属于 XML 家族的一部分。</li><li>XHTML 1.0 是在 HTML 4 的基础上以 XML 语法进行了改进，更加严格，要求标签闭合、小写等。</li><li>XHTML 2.0 曾经是 W3C（World Wide Web Consortium）提出的标准，但由于缺乏支持，未被广泛采用。目前 HTML5 已经成为主流标准，XHTML 2.0 的发展被中止</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>特性</th><th>HTML</th><th>XML</th><th>XHTML</th></tr></thead><tbody><tr><td><strong>语法严谨性</strong></td><td>容错性较强，允许一些不规范写法</td><td>强调 XML 的语法规范，要求严格</td><td>强调 XML 的语法规范，要求标签闭合</td></tr><tr><td><strong>文档结构</strong></td><td>用于描述网页结构和展示</td><td>用于传输和存储数据，无预定义标签</td><td>在 HTML 的基础上以 XML 语法改进</td></tr><tr><td><strong>应用领域</strong></td><td>用于构建网页和 Web 应用</td><td>用于数据传输、配置文件等</td><td>-</td></tr><tr><td><strong>发展历史</strong></td><td>HTML 4 是基于 SGML 的第四版</td><td>独立发展，由 W3C 制定</td><td>XHTML 是 HTML 的 XML 版本</td></tr></tbody></table></div><p>HTML 用于构建网页结构，XML 用于数据传输和存储，而 XHTML 是 HTML 在语法上更加严谨的版本</p><p>HTML5 成为了当前主流的标准，对之前 HTML 和 XHTML 的差异进行了一些调和</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：渐进式jpg了解过吗？"><a href="#Q3：渐进式jpg了解过吗？" class="headerlink" title="Q3：渐进式jpg了解过吗？"></a>Q3：渐进式jpg了解过吗？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>渐进式 JPEG（Progressive JPEG）是一种渐进式加载的 JPEG 图像格式。与标准的基线 JPEG 不同，渐进式 JPEG 允许图像在加载过程中逐渐呈现出更清晰的图像效果。这对于网络上的图像加载来说具有一定的优势。</p><p>以下是渐进式 JPEG 的一些特点和优势：</p><ol><li><strong>逐步加载：</strong> 渐进式 JPEG 可以通过在图像文件中存储多个扫描（scans）来实现逐步加载。这意味着浏览器可以在图像加载的早期阶段显示模糊或低分辨率的预览图像，并随着更多的数据加载而逐渐提高清晰度。</li><li><strong>用户体验：</strong> 渐进式加载改善了用户体验，因为用户可以在图像加载的过程中逐渐看到图像变得更加清晰。这对于网速较慢的情况下尤为有益。</li><li><strong>渐进式渲染：</strong> 渐进式 JPEG 不仅仅对整体图像进行渐进加载，而且对每个扫描的图像部分也可以逐步渲染。这使得即使在整个图像加载之前，用户也能够看到部分图像的内容。</li><li><strong>网络效率：</strong> 对于一些网络情况，渐进式 JPEG 可以提供更好的表现，因为它在整个图像数据未完全加载之前就能够呈现图像的初步效果。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：什么是渐进增强跟优雅降级？"><a href="#Q4：什么是渐进增强跟优雅降级？" class="headerlink" title="Q4：什么是渐进增强跟优雅降级？"></a>Q4：什么是渐进增强跟优雅降级？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>渐进增强（Progressive Enhancement）</strong> 和 <strong>优雅降级（Graceful Degradation）</strong> 是两种前端设计方法，用于处理不同浏览器或设备环境下的网页性能和用户体验。</p><ol><li><strong>渐进增强（Progressive Enhancement）：</strong><ul><li>渐进增强的理念是从一个基本但足够功能完备的版本开始，然后逐步增加功能，以适应更先进的浏览器或设备。</li><li>在渐进增强中，首先确保网站的核心功能在所有环境中都能正常工作，然后针对支持更高级特性的环境，逐步添加额外的样式、交互和功能。</li><li>这种方法强调基本内容的可访问性和可用性，确保用户在任何环境中都能够获得核心体验。</li></ul></li><li><strong>优雅降级（Graceful Degradation）：</strong><ul><li>优雅降级的理念是先创建一个功能丰富的网站，然后逐步适应较低级别的浏览器或设备。</li><li>在优雅降级中，首先针对先进的浏览器或设备构建丰富的用户体验，然后通过适应性和后备方案，确保在不支持这些特性的环境中仍然提供合理的用户体验。</li><li>这种方法关注的是高级浏览器或设备上的最佳体验，但确保在较低级别的环境中仍然能够提供某种形式的功能。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li>渐进增强着眼于基本功能，通过逐步增加特性来提高用户体验，确保在所有环境中都能正常运行。</li><li>优雅降级则从一个功能丰富的网站开始，逐步适应较低级别的环境，以确保在先进环境中提供最佳体验。</li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h3 id="Q1：常用的meta标签有哪些"><a href="#Q1：常用的meta标签有哪些" class="headerlink" title="Q1：常用的meta标签有哪些"></a>Q1：常用的meta标签有哪些</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>元素标签是提供有关HTML文档的元数据，元数据不会显示在页面上，但是能够被机器识别。</p><p>总而言之, meta标签是用来让机器识别的，同时它对SEO起着重要的作用。</p><ol><li><p>charset</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定了html文档的编码格式，常用的是utf-8(Unicode的字符编码)，还有ISO-8859-1(拉丁字母的字符编码)。当然还有其他的，但是一般不常用也就不介绍了</p></li><li><p>name &amp; content</p><p>指定元数据的名称(这部分对SEO非常有用)</p><ul><li><p>author——定义了页面的作者</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Tony&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>keywords——为搜索引擎提供关键字</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML, CSS, JavaScript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>description——对网页整体的描述</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;My tutorials on HTML, CSS and JavaScript&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>viewport——对页面视图相关进行定义</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">width=device-width——将页面宽度设置为跟随屏幕宽度变化而变化 </span><br><span class="line"></span><br><span class="line">initial-scale=1.0——设置浏览器首次加载页面时的初始缩放比例(0.0-10.0正数) </span><br><span class="line"></span><br><span class="line">maximum-scale=1.0——允许用户缩放的最大比例(0.0-10.0正数)，必须大于等于minimum-scale </span><br><span class="line"></span><br><span class="line">minimum-scale=1.0——允许用户缩放的最小比例(0.0-10.0正数)，必须小于等于maximum-scale </span><br><span class="line"></span><br><span class="line">user-scalable=no——是否允许用户手动缩放(yes或者no)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minmum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>generator——包含生成页面软件的标识符</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Hexo 3.8.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>theme-color——定义主题颜色</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#222&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>http-equiv &amp; content</p><p>Provides an HTTP header for the information/value of the content attribute</p></li><li><p>refresh——每30s刷新一次文档</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>X-UA-Compatible——告知浏览器以何种版本渲染界面。下面的例子有限使用IE最新版本</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Cache-Control——请求和响应遵循的缓存机制，可以声明缓存的内容，修改过期时间，可多次声明</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-transform&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>property &amp; content</p><p>可以让网页成为一个富媒体对象，同意网页内容被其他网站引用，同时在应用的时候不会只是一个链接，会提取相应的信息展现给用户</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;website&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:url&quot;</span> <span class="attr">content</span>=<span class="string">&quot;https://zjgyb.github.io/index.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">property</span>=<span class="string">&quot;og:site_name&quot;</span> <span class="attr">content</span>=<span class="string">&quot;tony&#x27;s blog&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何关闭a标签跳转页面或定位链接"><a href="#Q2：如何关闭a标签跳转页面或定位链接" class="headerlink" title="Q2：如何关闭a标签跳转页面或定位链接"></a>Q2：如何关闭a标签跳转页面或定位链接</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>标签属性href，使其指向空或不返回任何内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> &gt;</span>点此无反应javascript:void(0)<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> &gt;</span>点此无反应javascript:<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>从标签事件入手，阻止其默认行为</p><ul><li><p>html方法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span>return false;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return false;&quot;</span>&gt;</span>return false;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>js阻止默认点击事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Event</span>.<span class="title function_">preventDefault</span>()</span><br></pre></td></tr></table></figure></li><li><p>css</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>: none;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：canvas元素在标签上面设置宽高跟在style里面设置宽高有什么区别"><a href="#Q3：canvas元素在标签上面设置宽高跟在style里面设置宽高有什么区别" class="headerlink" title="Q3：canvas元素在标签上面设置宽高跟在style里面设置宽高有什么区别"></a>Q3：canvas元素在标签上面设置宽高跟在style里面设置宽高有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>canvas标签的width和height是画布实际宽度和高度，绘制的图形都是在这个上面</p><p>而style的width和height是canvas在浏览器中被渲染的高度和宽度</p><p>如果canvas的width和height没指定或值不正确，就被设置成默认值</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：iframe是什么？有哪些优缺点"><a href="#Q4：iframe是什么？有哪些优缺点" class="headerlink" title="Q4：iframe是什么？有哪些优缺点"></a>Q4：iframe是什么？有哪些优缺点</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>iframe</code> 是 HTML 中的一个元素，用于在页面中嵌套另外一个 HTML 文档。<code>iframe</code> 表示内联框架（Inline Frame）</p><div class="table-container"><table><thead><tr><th>优点</th><th>内容</th></tr></thead><tbody><tr><td><strong>嵌套内容</strong></td><td>最明显的优势是允许将一个 HTML 文档嵌套到另一个中。这对于在页面中显示其他网页、广告、地图等内容非常有用</td></tr><tr><td><strong>并行加载</strong></td><td><code>iframe</code> 允许页面异步加载，因为它的内容可以在主页面加载的同时加载</td></tr><tr><td><strong>独立文档</strong></td><td><code>iframe</code> 中的内容是独立的文档，它有自己的 HTML、CSS 和 JavaScript，不受主页面的影响，这有助于实现一些模块化的设计</td></tr><tr><td><strong>实现跨域通信</strong></td><td>在某些情况下，<code>iframe</code> 可以用于实现跨域通信，尤其是在同源策略限制的情况下</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>缺点</th><th>内容</th></tr></thead><tbody><tr><td><strong>性能问题</strong></td><td>使用过多的 <code>iframe</code> 可能会影响页面性能，因为每个 <code>iframe</code> 都需要加载和渲染独立的文档</td></tr><tr><td><strong>难以维护</strong></td><td><code>iframe</code> 中的内容是独立的，可能需要单独维护。在大型应用中，过多的 <code>iframe</code> 可能导致代码维护变得复杂</td></tr><tr><td><strong>SEO 难度</strong></td><td>搜索引擎可能不会对 <code>iframe</code> 中的内容进行索引，这可能对网站的搜索引擎优化产生影响</td></tr><tr><td><strong>安全性问题</strong></td><td>如果 <code>iframe</code> 中的内容来自不受信任的来源，可能存在安全风险。点击劫持和其他安全漏洞可能成为问题</td></tr><tr><td><strong>不适用于移动端</strong></td><td>在移动端设备上，<code>iframe</code> 的使用可能不太友好，因为它可能导致滚动问题和触摸事件的不一致性</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：DOCTYPE标签有什么用"><a href="#Q5：DOCTYPE标签有什么用" class="headerlink" title="Q5：DOCTYPE标签有什么用"></a>Q5：DOCTYPE标签有什么用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>DOCTYPE</code>（文档类型声明）是一种用于指定 HTML 或 XML 文档类型和版本的标签。它位于文档的开头，位于 <code>&lt;html&gt;</code> 标签之前。<code>DOCTYPE</code> 帮助浏览器正确地解析文档，确保在渲染页面时采用正确的标准</p><p>HTML5 推荐使用简化的 <code>&lt;!DOCTYPE html&gt;</code>，而不再需要详细指定版本和 DTD（文档类型定义）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>主要用途</th><th></th></tr></thead><tbody><tr><td><strong>指定文档类型</strong></td><td><code>DOCTYPE</code> 声明告诉浏览器使用哪个 HTML 或 XML 规范来解析文档。不同的文档类型可能有不同的规范，如 HTML4、HTML5 等</td></tr><tr><td><strong>影响浏览器渲染模式</strong></td><td><code>DOCTYPE</code> 声明可以触发不同的渲染模式，例如怪异模式（Quirks Mode）和标准模式（Standards Mode）。在标准模式下，浏览器会更严格地遵循规范，而在怪异模式下，会模拟更早期的浏览器行为</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：html标签中测src跟href有什么区别"><a href="#Q6：html标签中测src跟href有什么区别" class="headerlink" title="Q6：html标签中测src跟href有什么区别"></a>Q6：html标签中测src跟href有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong><code>src</code> 属性：</strong></p><ul><li><code>src</code> 是 “source”（源）的缩写，主要用于指定外部资源的地址，如图像、音频、视频或嵌入的框架（如 <code>&lt;iframe&gt;</code>）等。</li><li>用于标签如 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code> 等，用来指定这些元素加载的外部资源。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;page.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>href</code> 属性：</strong></p><ul><li><code>href</code> 是 “hypertext reference”（超文本引用）的缩写，主要用于创建超链接，指定链接的目标地址。</li><li>通常用于 <code>&lt;a&gt;</code>（锚点）、<code>&lt;link&gt;</code>（外部样式表）、<code>&lt;area&gt;</code>（图像映射区域）等标签。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span>&gt;</span>Visit Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;34,44,270,350&quot;</span> <span class="attr">href</span>=<span class="string">&quot;page.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>区别</th><th>src</th><th>href</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>用于指定元素加载的外部资源</td><td>用于创建超链接，指定链接的目标地址</td></tr><tr><td><strong>标签适用性</strong></td><td>通常用于嵌入的元素，如图像、脚本、框架等</td><td>通常用于创建超链接，指定链接的目标地址</td></tr><tr><td><strong>加载方式</strong></td><td>使用 <code>src</code> 的元素通常会加载并显示指定的资源</td><td>使用 <code>href</code> 的元素通常会创建一个超链接，用户可以点击跳转到指定的目标</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：html5有哪些新特性，分别有什么作用"><a href="#Q7：html5有哪些新特性，分别有什么作用" class="headerlink" title="Q7：html5有哪些新特性，分别有什么作用"></a>Q7：html5有哪些新特性，分别有什么作用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>语义元素</strong></td><td style="text-align:center">引入了新的语义化元素，如 <code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;nav&gt;</code> 等，使页面结构更清晰，对搜索引擎友好。</td></tr><tr><td style="text-align:center"><strong>Canvas 绘图</strong></td><td style="text-align:center"><code>&lt;canvas&gt;</code> 元素提供了一种通过 JavaScript 绘制图形的方法，用于创建图表、游戏等动态图形。</td></tr><tr><td style="text-align:center"><strong>本地存储</strong></td><td style="text-align:center">引入了 <code>localStorage</code> 和 <code>sessionStorage</code>，用于在客户端存储数据，提供更好的离线应用体验。</td></tr><tr><td style="text-align:center"><strong>表单增强</strong></td><td style="text-align:center">新的表单输入类型（如 <code>date</code>、<code>email</code>、<code>number</code>）和属性（如 <code>placeholder</code>、<code>required</code>），提供更好的表单交互和验证。</td></tr><tr><td style="text-align:center"><strong>新的 API</strong></td><td style="text-align:center">引入了一系列新的 JavaScript API，如 Geolocation、Web Workers、WebSocket 等，增强了 Web 应用的功能。</td></tr><tr><td style="text-align:center"><strong>拖放 API</strong></td><td style="text-align:center">提供了用于处理拖放操作的 API，使用户界面的实现更直观，包括拖放元素和文件。</td></tr><tr><td style="text-align:center"><strong>新的解析规则</strong></td><td style="text-align:center">新的解析规则使浏览器能够更容易地处理不规范的文档，提高了容错性。</td></tr><tr><td style="text-align:center"><strong>Web 存储</strong></td><td style="text-align:center">提供了 <code>localStorage</code> 和 <code>sessionStorage</code>，用于在客户端存储键值对，代替传统的 Cookie。</td></tr><tr><td style="text-align:center"><strong>Web Workers</strong></td><td style="text-align:center">允许在后台运行脚本，提高了 Web 应用的性能，允许执行耗时操作而不影响用户界面的响应。</td></tr><tr><td style="text-align:center"><strong>WebSocket</strong></td><td style="text-align:center">提供了全双工通信通道，使客户端和服务器能够进行实时通信，用于实现实时更新和通知。</td></tr><tr><td style="text-align:center"><strong>跨文档消息通信</strong></td><td style="text-align:center">提供了 <code>postMessage</code> 方法，用于在不同文档或窗口之间进行安全的跨域通信。</td></tr><tr><td style="text-align:center"><strong>新的表格元素</strong></td><td style="text-align:center">引入了 <code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>、<code>&lt;th&gt;</code> 等新的表格元素，提高了表格的语义化和可访问性。</td></tr><tr><td style="text-align:center"><strong>动态页面更新</strong></td><td style="text-align:center">通过新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，使得在不刷新页面的情况下更新浏览器地址栏和历史记录成为可能，支持单页面应用（SPA）。</td></tr><tr><td style="text-align:center"><strong>拍照和摄像</strong></td><td style="text-align:center">增加了 <code>&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; capture=&quot;camera&quot;&gt;</code>，支持通过移动设备的摄像头直接拍照或录制视频。</td></tr><tr><td style="text-align:center"><strong>WebRTC</strong></td><td style="text-align:center">Web 实时通信技术，支持浏览器之间的实时音频、视频和数据传输，用于实现视频会议和在线聊天等应用。</td></tr><tr><td style="text-align:center"><strong>模块化脚本</strong></td><td style="text-align:center">支持使用 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code> 标签，使得脚本文件可以以模块的方式加载，提高代码的可维护性和复用性。</td></tr><tr><td style="text-align:center"><strong>新的媒体元素属性</strong></td><td style="text-align:center"><code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 元素新增了一些属性，如 <code>controls</code>、<code>autoplay</code>、<code>loop</code>，方便对音频和视频进行控制。</td></tr><tr><td style="text-align:center"><strong>自定义数据属性</strong></td><td style="text-align:center"><code>data-*</code> 属性可以用于在 HTML 元素上存储自定义数据，提供了一种灵活的方式来与 JavaScript 进行交互。</td></tr><tr><td style="text-align:center"><strong>图形和效果</strong></td><td style="text-align:center">引入了一些新的图形和效果元素，如 <code>&lt;svg&gt;</code>（用于矢量图形）、<code>&lt;canvas&gt;</code>（用于位图图形）、<code>&lt;progress&gt;</code>（用于显示任务进度）等。</td></tr><tr><td style="text-align:center"><strong>ContentEditable</strong></td><td style="text-align:center">允许用户编辑页面内容，可用于实现富文本编辑器等功能。</td></tr><tr><td style="text-align:center"><strong>改进的表单控件</strong></td><td style="text-align:center">新的输入类型和属性，如 <code>color</code>、<code>range</code>、<code>placeholder</code>、<code>required</code> 等，提升了表单的交互体验。</td></tr><tr><td style="text-align:center"><strong>Shadow DOM</strong></td><td style="text-align:center">允许将元素的样式和行为封装到独立的作用域中，用于创建可重用的自定义组件。</td></tr><tr><td style="text-align:center"><strong>Web Components</strong></td><td style="text-align:center">一组标准化的 Web 技术，包括 Shadow DOM、Custom Elements、HTML Templates 等，用于创建可重用的自定义组件。</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：标签上的title跟alt属性有什么区别"><a href="#Q8：标签上的title跟alt属性有什么区别" class="headerlink" title="Q8：标签上的title跟alt属性有什么区别"></a>Q8：标签上的title跟alt属性有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong><code>title</code> 属性：</strong></p><ul><li><p>通常用于 <code>&lt;a&gt;</code>、<code>&lt;abbr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;button&gt;</code> 和 <code>&lt;td&gt;</code> 等元素。</p></li><li><p>提供有关元素的附加信息，通常通过浏览器的工具提示（tooltip）显示。</p></li><li><p>在链接中，<code>title</code> 属性可以提供与链接关联的描述，以提供更多信息给用户。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Visit Example Website&quot;</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Example Image&quot;</span> <span class="attr">title</span>=<span class="string">&quot;This is an example image&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>alt</code> 属性：</strong></p><ul><li><p>主要用于 <code>&lt;img&gt;</code>、<code>&lt;area&gt;</code> 和 <code>&lt;input&gt;</code>（type=”image”）等元素，用于提供图像的替代文本。</p></li><li><p>当图像无法加载时，<code>alt</code> 属性的文本将被显示，同时对于一些辅助技术，如屏幕阅读器，也提供了对图像的描述。</p></li><li><p>在表单中的图像按钮，<code>alt</code> 属性还可以用作提交表单时的值。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Example Image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;submit.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Submit Form&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>alt</code> 是为了在图片未能正常显示时（屏幕阅读器）给予文字说明。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。</p><p><code>title</code> 属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：行内元素有哪些？块级元素有哪些？空元素有哪些？"><a href="#Q9：行内元素有哪些？块级元素有哪些？空元素有哪些？" class="headerlink" title="Q9：行内元素有哪些？块级元素有哪些？空元素有哪些？"></a>Q9：行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>行内元素（Inline Elements）：</strong></p><ol><li><code>&lt;span&gt;</code> - 用于在行内包裹文本或其他行内元素。</li><li><code>&lt;a&gt;</code> - 行内超链接。</li><li><code>&lt;strong&gt;</code> - 表示强调的文本，通常显示为加粗。</li><li><code>&lt;em&gt;</code> - 表示强调的文本，通常显示为斜体。</li><li><code>&lt;img&gt;</code> - 行内图片。</li><li><code>&lt;br&gt;</code> - 换行。</li><li><code>&lt;abbr&gt;</code> - 缩写。</li><li><code>&lt;code&gt;</code> - 行内代码。</li><li><code>&lt;cite&gt;</code> - 引用标题。</li><li><code>&lt;time&gt;</code> - 表示时间。</li></ol><p><strong>块级元素（Block-level Elements）：</strong></p><ol><li><code>&lt;div&gt;</code> - 用于组合其他 HTML 元素的容器。</li><li><code>&lt;p&gt;</code> - 段落。</li><li><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code> - 标题。</li><li><code>&lt;ul&gt;</code> - 无序列表。</li><li><code>&lt;ol&gt;</code> - 有序列表。</li><li><code>&lt;li&gt;</code> - 列表项。</li><li><code>&lt;table&gt;</code> - 表格。</li><li><code>&lt;form&gt;</code> - 表单。</li><li><code>&lt;header&gt;</code> - 头部区域。</li><li><code>&lt;footer&gt;</code> - 底部区域。</li></ol><p><strong>空元素：</strong></p><p>空元素是指没有内容的元素，通常是自闭合的元素，不需要闭合标签。</p><ol><li><code>&lt;img&gt;</code> - 行内图片。</li><li><code>&lt;br&gt;</code> - 换行。</li><li><code>&lt;hr&gt;</code> - 水平线。</li><li><code>&lt;input&gt;</code> - 输入框。</li><li><code>&lt;meta&gt;</code> - 元信息。</li></ol><p>需要注意的是，虽然 <code>&lt;img&gt;</code> 和 <code>&lt;input&gt;</code> 等元素在 HTML 中被认为是行内元素，但它们是空元素，因为它们通常是自闭合的，没有内容。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：meta标签中的viewport有什么用"><a href="#Q10：meta标签中的viewport有什么用" class="headerlink" title="Q10：meta标签中的viewport有什么用"></a>Q10：meta标签中的viewport有什么用</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><meta> 标签中的 viewport 属性用于控制移动设备上网页的视口（viewport）的大小和缩放级别。移动设备的屏幕尺寸和分辨率各不相同，因此视口的设置能够确保网页在不同设备上的正常显示和用户体验。<br>作用：</p><ol><li><strong>响应式布局：</strong><ul><li>使用 <code>viewport</code> 可以让网页根据设备的屏幕尺寸自动调整布局，以适应不同大小的屏幕。</li><li>支持响应式设计，提供更好的用户体验。</li></ul></li><li><strong>控制缩放：</strong><ul><li>可以通过设置 <code>viewport</code> 来控制用户是否能够缩放页面。这对于移动设备上的网页浏览体验很重要。</li><li>通过 <code>user-scalable</code> 属性可以控制用户是否允许手动缩放。</li></ul></li></ol><p>常见设置：</p><p>常见的 <code>viewport</code> 设置如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>width=device-width</code>：</strong><ul><li>将视口的宽度设置为设备的屏幕宽度。这确保网页的宽度与设备的宽度相匹配。</li></ul></li><li><strong><code>initial-scale=1.0</code>：</strong><ul><li>设置初始缩放级别为 1.0。这确保网页在加载时以原始大小显示，而不进行缩放。</li></ul></li></ul><p>其他属性：</p><ul><li><code>user-scalable</code>：<ul><li>控制用户是否能够手动缩放页面。</li><li>如果将其设置为 <code>yes</code>，用户可以手动缩放；如果设置为 <code>no</code>，则禁止手动缩放。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：label标签有什么用"><a href="#Q11：label标签有什么用" class="headerlink" title="Q11：label标签有什么用"></a>Q11：label标签有什么用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>&lt;label&gt;</code> 标签用于定义 HTML 表单中的标签（label）。它通常与表单元素的 id 属性关联，以创建更好的用户体验和可访问性。以下是 <code>&lt;label&gt;</code> 标签的主要用途：</p><ol><li><p><strong>表单元素的标记：</strong> <code>&lt;label&gt;</code> 标签可用于标记表单元素，提供对表单元素的描述。通过与表单元素关联，用户点击标签文本时，关联的表单元素就会获得焦点或触发特定的操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，点击 “Username:” 文本时，文本框就会获得焦点。</p></li><li><p><strong>增加可访问性：</strong> 使用 <code>&lt;label&gt;</code> 标签可以提升网站的可访问性。屏幕阅读器等辅助技术能够读取与表单元素关联的 <code>&lt;label&gt;</code> 文本，帮助视觉障碍用户更好地理解表单的结构和用途。</p></li><li><p><strong>点击扩大触发区域：</strong> 通过将 <code>&lt;label&gt;</code> 与表单元素关联，用户不仅可以点击表单元素本身，还可以点击与之关联的 <code>&lt;label&gt;</code> 文本来触发表单元素。这有助于扩大可点击区域，提高用户体验。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;label&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;subscribe&quot;&gt; Subscribe to newsletter</span><br><span class="line">&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，用户可以点击 “Subscribe to newsletter” 文本或复选框本身来切换选中状态。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：img标签的srcset属性的作用是什么"><a href="#Q12：img标签的srcset属性的作用是什么" class="headerlink" title="Q12：img标签的srcset属性的作用是什么"></a>Q12：img标签的srcset属性的作用是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>srcset</code> 属性是 <code>&lt;img&gt;</code> 标签的一个属性，用于提供一组备选图像源，以帮助浏览器在不同设备和屏幕尺寸下选择合适的图像。这可以有助于提高页面的性能和用户体验</p><p>主要作用包括：</p><ol><li><p><strong>响应式图像：</strong> <code>srcset</code> 允许在不同的视口宽度或设备像素密度下使用不同分辨率的图像。浏览器会根据设备的特性自动选择合适的图像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line">&lt;img src=&quot;image-1x.jpg&quot; srcset=&quot;image-1x.jpg 1x, image-2x.jpg 2x, image-3x.jpg 3x&quot; alt=&quot;Responsive Image&quot;&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，浏览器会根据设备的像素密度（1x、2x、3x）选择对应的图像。</p></li><li><p><strong>带宽控制：</strong> <code>srcset</code> 还可以帮助减小对带宽的需求。浏览器在选择图像时可以根据设备的屏幕大小和像素密度，选择合适的图像，从而减少页面加载时需要下载的数据量。</p></li><li><p><strong>提高加载性能：</strong> 使用 <code>srcset</code> 可以确保页面加载时，浏览器选择适合用户设备的最佳图像，从而提高页面加载性能，尤其是在移动设备和高分辨率屏幕上。</p></li><li><p><strong><code>sizes</code> 属性结合使用：</strong> <code>srcset</code> 可以与 <code>sizes</code> 属性结合使用，提供关于图像在不同屏幕尺寸下的显示尺寸的信息，以更精确地选择合适的图像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image-320w.jpg&quot; srcset=&quot;image-320w.jpg 320w, image-480w.jpg 480w, image-800w.jpg 800w&quot; sizes=&quot;(max-width: 320px) 280px, (max-width: 480px) 440px, 800px&quot; alt=&quot;Responsive Image&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol><p><code>srcset</code> 是一种优化图像加载的方式，使得页面可以根据用户设备的特性提供最佳的视觉体验，同时减小对带宽的压力</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：canvas跟svg有什么区别？"><a href="#Q12：canvas跟svg有什么区别？" class="headerlink" title="Q12：canvas跟svg有什么区别？"></a>Q12：canvas跟svg有什么区别？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>特性</th><th>Canvas</th><th>SVG</th></tr></thead><tbody><tr><td>描述</td><td>位图图形，像素基础</td><td>矢量图形，基于 XML</td></tr><tr><td>渲染方式</td><td>像素操作，适合复杂的绘图和图像处理</td><td>矢量路径，适合图形和图表</td></tr><tr><td>分辨率依赖</td><td>分辨率依赖，位图在不同分辨率下可能失真</td><td>分辨率无关，图形在不同分辨率下保持清晰</td></tr><tr><td>交互性</td><td>像素级别的交互，复杂交互相对复杂</td><td>DOM 元素级别的交互，容易实现事件处理</td></tr><tr><td>动画</td><td>动画相对较复杂，依赖帧刷新</td><td>动画相对简单，使用 CSS 或 JavaScript</td></tr><tr><td>复杂度</td><td>适合处理复杂的图像、游戏等</td><td>适合处理图形、图表、地图等</td></tr><tr><td>文本渲染</td><td>文本渲染较简单，有限的文本样式控制</td><td>文本渲染灵活，支持复杂的文本样式</td></tr><tr><td>缩放</td><td>缩放会导致图像失真</td><td>缩放不会导致图像失真</td></tr><tr><td>使用场景</td><td>游戏、图像处理、位图图形</td><td>图表、图形、图标、动画</td></tr><tr><td>代码复杂度</td><td>相对简单</td><td>相对复杂，XML 格式描述图形结构</td></tr></tbody></table></div><p>Canvas 适用于处理复杂的图像和游戏等场景</p><p>而 SVG 更适用于绘制图形、图表和具有交互性的图形元素</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：H5有哪些跟drag相关的API"><a href="#Q13：H5有哪些跟drag相关的API" class="headerlink" title="Q13：H5有哪些跟drag相关的API"></a>Q13：H5有哪些跟drag相关的API</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>拖拽事件：</strong></p><ol><li><strong>dragstart：</strong><ul><li>当用户开始拖拽某个元素时触发。</li><li>可以在此事件处理程序中设置拖拽的数据（如文本或URL）。</li></ul></li><li><strong>drag：</strong><ul><li>在元素被拖拽的过程中持续触发。</li><li>可以在此事件处理程序中执行一些动作，例如更新拖拽元素的位置。</li></ul></li><li><strong>dragenter：</strong><ul><li>当拖拽元素进入可拖放区域时触发。</li><li>可以在此事件处理程序中改变可拖放区域的样式或执行其他操作。</li></ul></li><li><strong>dragover：</strong><ul><li>在拖拽元素在可拖放区域内移动时持续触发。</li><li>可以在此事件处理程序中阻止默认行为并执行一些操作。</li></ul></li><li><strong>dragleave：</strong><ul><li>当拖拽元素离开可拖放区域时触发。</li></ul></li><li><strong>drop：</strong><ul><li>当拖拽元素在可拖放区域内释放时触发。</li><li>在此事件处理程序中可以处理拖放操作，获取拖放的数据并进行相应的处理。</li></ul></li><li><strong>dragend：</strong><ul><li>当拖拽操作结束时触发，无论是成功还是取消。</li><li>在此事件处理程序中可以进行清理操作。</li></ul></li></ol><p><strong>拖拽 API：</strong></p><ol><li><p><strong>DataTransfer 对象：</strong></p><ul><li>在 <code>dragstart</code> 事件中的 <code>event.dataTransfer</code> 属性用于设置拖拽的数据，供 <code>drop</code> 事件中使用。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;dragstart&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, <span class="string">&#x27;Hello, World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>draggable 属性：</strong></p><ul><li>通过将元素的 <code>draggable</code> 属性设置为 <code>true</code> 或 <code>false</code> 来启用或禁用元素的拖拽功能。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>Drag me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>dropEffect 和 effectAllowed 属性：</strong></p><ul><li><code>dropEffect</code> 属性用于指定拖拽元素被释放时的反馈效果。</li><li><code>effectAllowed</code> 属性用于指定被拖拽元素允许的操作。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.<span class="property">dataTransfer</span>.<span class="property">dropEffect</span> = <span class="string">&#x27;copy&#x27;</span>;</span><br><span class="line">event.<span class="property">dataTransfer</span>.<span class="property">effectAllowed</span> = <span class="string">&#x27;copyMove&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><h3 id="Q1：html页面渲染过程"><a href="#Q1：html页面渲染过程" class="headerlink" title="Q1：html页面渲染过程"></a>Q1：html页面渲染过程</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTML 页面的渲染过程是浏览器将 HTML、CSS 和 JavaScript 转换成用户可以看到和与之交互的可视化页面的过程</p><ol><li>解析 HTML（构建 DOM）：<ul><li>浏览器从服务器获取 HTML 文件。</li><li>解析器开始解析 HTML 标记，构建 DOM 树，表示文档的结构。</li><li>解析过程中遇到外部资源（如图片、样式表、脚本），会触发新的网络请求。</li></ul></li><li>解析 CSS（构建 CSSOM）：<ul><li>浏览器解析样式表，构建 CSS 对象模型（CSSOM）。</li><li>CSSOM 包含了每个样式规则及其对应的元素。</li><li>浏览器将 DOM 和 CSSOM 结合起来，构建渲染树。</li></ul></li><li>构建渲染树：<ul><li>渲染树由可见的文档内容构成，包括所有可见的元素及其样式信息。</li><li>渲染树不包含不需要显示的元素，例如 <code>&lt;head&gt;</code>、<code>display: none</code> 的元素等。</li><li>渲染树的构建考虑到每个元素的样式，从而确保正确的布局和绘制。</li></ul></li><li>布局（回流）：<ul><li>渲染树中的每个可见元素都进行布局，计算其在屏幕上的准确位置和大小。</li><li>布局是计算元素的几何属性，包括宽度、高度、位置等。</li><li>由于布局涉及到元素的几何属性，可能触发多次回流。</li></ul></li><li>绘制：<ul><li>浏览器遍历渲染树，将每个元素绘制到屏幕上。</li><li>绘制过程包括绘制文本、颜色、图像等。</li><li>绘制是相对独立的步骤，可以在布局之后进行。</li></ul></li><li>交互与动画（JavaScript 执行）：<ul><li>如果页面包含 JavaScript，浏览器执行脚本。</li><li>JavaScript 可能会修改 DOM 结构或样式，触发重新布局和绘制。</li><li>用户交互和动画效果可能会引发浏览器执行相应的脚本。</li></ul></li><li>渲染完成：<ul><li>所有的步骤完成后，用户可以看到最终的页面。</li><li>页面上的元素已经处于可交互状态，用户可以与之进行交互</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>重排（Reflow）</strong> 和 <strong>重绘（Repaint）</strong> 是两个与页面渲染性能相关的概念，它们都涉及到页面布局和绘制。</p><ol><li>重排（Reflow）：<ul><li>重排是指浏览器必须重新计算元素的几何属性（例如位置、大小），然后重新布局整个页面。</li><li>重排会导致渲染树的重新构建，影响整个页面的布局。</li><li>常见的触发重排的操作包括改变窗口大小、添加或删除 DOM 元素、修改元素的几何属性、改变字体大小等。</li></ul></li><li>重绘（Repaint）：<ul><li>重绘是指浏览器根据新的样式或元素的可见性等信息重新绘制页面的部分区域，而不涉及布局的改变。</li><li>重绘不会引起页面的重新布局，只会重新绘制受影响的部分。</li><li>触发重绘的操作包括改变元素的颜色、背景等，而不影响元素的几何属性。</li></ul></li></ol><p><strong>如何减少重排和重绘，从而提高性能优化：</strong></p><ol><li>使用 <code>transform</code> 和 <code>opacity</code> 进行动画：<ul><li>使用 <code>transform</code> 属性进行动画，因为它不会触发重排，而只涉及重绘。</li><li>使用 <code>opacity</code> 属性进行淡入淡出动画，也只触发重绘。</li></ul></li><li>避免频繁的 DOM 操作：<ul><li>避免频繁地添加、删除、修改 DOM 元素，这会导致多次重排和重绘。</li><li>将多个 DOM 操作合并成一次，减少对 DOM 结构的修改。</li></ul></li><li>使用文档片段（DocumentFragment）：<ul><li>当需要多次插入新元素时，可以先将它们添加到文档片段中，再一次性插入到文档中，减少重排次数。</li></ul></li><li>使用 <code>display: none</code> 替代 <code>visibility: hidden</code>：<ul><li>将元素隐藏时，使用 <code>display: none</code> 而不是 <code>visibility: hidden</code>，前者会触发重排，但后者只触发重绘。</li></ul></li><li>减少获取布局信息的操作：<ul><li>避免频繁获取元素的几何属性，比如使用 <code>offsetTop</code>、<code>offsetLeft</code> 等，这会触发强制同步布局。</li></ul></li><li>优化 CSS 选择器：<ul><li>使用高效的 CSS 选择器，减少渲染树的规模，提高布局和绘制的速度。</li></ul></li><li>使用 CSS 动画而不是 JavaScript 动画：<ul><li>CSS 动画通常会使用硬件加速，性能更好，且不容易触发重排。</li></ul></li><li>合理使用 CSS <code>will-change</code>：<ul><li>使用 <code>will-change</code> 属性告知浏览器某个元素可能会发生变化，使浏览器在布局阶段优化这些元素，减少重排的代价</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：页面导入样式的时候，link跟-import有什么区别"><a href="#Q2：页面导入样式的时候，link跟-import有什么区别" class="headerlink" title="Q2：页面导入样式的时候，link跟@import有什么区别"></a>Q2：页面导入样式的时候，link跟@import有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>&lt;link&gt;</code> 元素更常用，尤其在需要性能优化和更灵活的加载方式时</p><p><code>@import</code> 规则在某些情况下可能会有一些限制，但在一些特定的场景仍然是有效的</p><div class="table-container"><table><thead><tr><th>特性</th><th><code>&lt;link&gt;</code> 元素</th><th><code>@import</code> 规则</th></tr></thead><tbody><tr><td><strong>加载方式</strong></td><td>并行加载，不阻塞页面渲染</td><td>在 HTML 解析到它时开始加载，可能阻塞页面渲染</td></tr><tr><td><strong>浏览器支持</strong></td><td>所有主流浏览器</td><td>所有主流浏览器（IE8+）支持，但对并行加载有限制</td></tr><tr><td><strong>异步加载</strong></td><td>可以通过设置 <code>async</code> 属性实现异步加载</td><td>不支持异步加载</td></tr><tr><td><strong>媒体查询</strong></td><td>可以使用媒体查询指定样式表的加载条件</td><td>不支持媒体查询</td></tr><tr><td><strong>兼容性</strong></td><td>更好的兼容性，适用于大型项目</td><td>较旧的浏览器版本对 <code>@import</code> 支持可能有限</td></tr><tr><td><strong>权重</strong></td><td>具有较高的权重，会覆盖 <code>@import</code> 规则</td><td>具有较低的权重，可能被其他样式表覆盖</td></tr><tr><td><strong>适用场景</strong></td><td>适用于所有情况，特别是对性能有要求的场景</td><td>在一些特定情况下可能会用于条件加载样式</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：style标签写在body前跟后有什么区别"><a href="#Q3：style标签写在body前跟后有什么区别" class="headerlink" title="Q3：style标签写在body前跟后有什么区别"></a>Q3：style标签写在body前跟后有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong><code>&lt;style&gt;</code> 标签写在 <code>&lt;head&gt;</code> 中（body前）：</strong><ul><li>样式表会在整个页面内容加载之前加载和解析。</li><li>页面渲染可能会等待样式表加载完成，可能导致 FOUC（Flash of Unstyled Content）问题。</li><li>一般来说，这种方式有助于避免 FOUC，但可能影响页面的首次渲染速度。</li></ul></li><li><strong><code>&lt;style&gt;</code> 标签写在 <code>&lt;body&gt;</code> 中（body后）：</strong><ul><li>样式表会在整个页面内容加载后加载和解析。</li><li>页面渲染可能会在样式表加载之前开始，但是在加载和应用样式表时可能导致页面的重新渲染，可能出现 FOUC 问题。</li><li>在一些情况下，将样式表放在文档底部可能会导致性能方面的优势，但需要注意潜在的 FOUC 问题。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：CSSOM树跟DOM树是同时解析的吗"><a href="#Q4：CSSOM树跟DOM树是同时解析的吗" class="headerlink" title="Q4：CSSOM树跟DOM树是同时解析的吗"></a>Q4：CSSOM树跟DOM树是同时解析的吗</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>并行解析：</strong> 浏览器在渲染页面时，并行解析 HTML 文档和 CSS 样式表，构建 DOM 树和 CSSOM 树。</li><li><strong>异步加载：</strong> HTML 文档的解析和 CSS 样式表的解析是异步的，它们之间可以并行进行。</li><li><strong>JavaScript 阻塞：</strong> 当浏览器遇到 <code>&lt;script&gt;</code> 标签时，如果 JavaScript 代码依赖于 CSS 样式信息，可能会等待 CSSOM 树构建完成，导致 HTML 解析阻塞。</li><li><strong>解决方案：</strong> 为了减轻 JavaScript 对 HTML 解析的阻塞，可以将 <code>&lt;script&gt;</code> 放在 <code>&lt;body&gt;</code> 底部，使 HTML 解析不被 JavaScript 阻塞，或者使用 <code>async</code> 或 <code>defer</code> 属性异步加载和执行 JavaScript 文件。</li><li><strong>注意事项：</strong> 虽然 CSSOM 树和 DOM 树的构建是并行的，但由于 JavaScript 的阻塞特性，可能会导致部分阻塞情况，需要在实践中权衡不同因素以优化性能和用户体验。</li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h3 id="Q1：websocket怎么兼容低版本浏览器？"><a href="#Q1：websocket怎么兼容低版本浏览器？" class="headerlink" title="Q1：websocket怎么兼容低版本浏览器？"></a>Q1：websocket怎么兼容低版本浏览器？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>WebSocket 是一种在浏览器和服务器之间建立持久连接的通信协议</p><p>WebSocket 的标准化工作主要在 HTML5 时期进行，因此较早版本的浏览器可能不直接支持 WebSocket</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>使用 Flash 插件：</strong><ul><li>使用类库如 Socket.IO 和 Kaazing WebSocket Gateway，它们提供了对 WebSocket 的模拟支持，通过 Flash 插件实现。</li><li>这种方法能够在不支持原生 WebSocket 的浏览器上提供类似 WebSocket 的实时通信体验。</li></ul></li><li><strong>使用长轮询（Long Polling）：</strong><ul><li>长轮询是一种模拟实时通信的方法，在不支持 WebSocket 的浏览器中可作为替代方案。</li><li>客户端发送请求到服务器，服务器保持请求打开直到有新的消息，然后响应给客户端，客户端收到响应后立即再次发起请求。</li></ul></li><li><strong>Polyfill 库：</strong><ul><li>使用 WebSocket 的 Polyfill 库，这些库会在不支持 WebSocket 的浏览器中模拟 WebSocket 的行为。</li><li>例如，SockJS 是一个提供跨浏览器 WebSocket 兼容性的库，它可以在支持 WebSocket 的浏览器上直接使用 WebSocket，在不支持的浏览器上使用其他技术。</li></ul></li><li><strong>升级浏览器版本：</strong><ul><li>鼓励用户升级浏览器版本，以获得对 WebSocket 的原生支持。</li><li>在一些情况下，可能需要向用户提供提示，鼓励其使用现代浏览器以获得更好的体验</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：页面统计数据中的pv跟uv分别是指什么"><a href="#Q2：页面统计数据中的pv跟uv分别是指什么" class="headerlink" title="Q2：页面统计数据中的pv跟uv分别是指什么"></a>Q2：页面统计数据中的pv跟uv分别是指什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong>PV（Page View）：</strong><ul><li>PV 表示页面浏览量，它是指用户在访问网站或页面时的每一次有效浏览页面的记录。每一次刷新或加载页面都被视为一个 PV。</li><li>PV 反映了页面被访问的总次数，即用户对页面的点击、刷新、加载等操作次数的总和。</li><li>例如，如果一个用户访问了网站的某个页面，并刷新了该页面两次，那么 PV 将记录为3。</li></ul></li><li><strong>UV（Unique Visitor）：</strong><ul><li>UV 表示独立访客数，它是指访问网站或页面的不同用户的数量。UV 计数是根据用户的设备或浏览器等信息进行识别的，用于判断用户的唯一性。</li><li>UV 反映了访问网站的实际用户数量，而不考虑用户对页面的多次访问。</li><li>例如，如果同一用户在一天内访问了网站的某个页面10次，UV 计数仍然为1。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li>PV 衡量页面的流量和热度，反映用户对页面的浏览次数。</li><li>UV 衡量实际的独立用户数量，反映有多少不同的用户访问了页面。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：iconfont是什么？有什么优点？有什么缺点？"><a href="#Q3：iconfont是什么？有什么优点？有什么缺点？" class="headerlink" title="Q3：iconfont是什么？有什么优点？有什么缺点？"></a>Q3：iconfont是什么？有什么优点？有什么缺点？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>Iconfont 是什么？</strong></p><p>Iconfont 是一种将图标制作成字体的技术，通过使用字体文件中的特定字符代表图标，以字体的形式嵌入网页。这样的做法能够提供矢量图标，方便缩放和使用，同时减少了 HTTP 请求，提高页面性能。</p><p><strong>优点：</strong></p><ol><li><strong>灵活性：</strong> 字体图标是矢量图形，可以随意缩放而不失真，适应不同屏幕和分辨率。</li><li><strong>可缩放性：</strong> 通过调整 <code>font-size</code> 属性，可以轻松地更改图标的大小，而无需额外的图像资源。</li><li><strong>减少 HTTP 请求：</strong> 将多个图标整合到一个字体文件中，减少页面加载时的 HTTP 请求次数，有助于提高性能。</li><li><strong>易于使用和定制：</strong> 提供简单的 CSS 使用方式，通过 <code>font-family</code> 和 <code>content</code> 属性使用图标，同时可以自定义颜色、大小等样式。</li><li><strong>兼容性：</strong> 在现代浏览器和移动设备上有良好的兼容性，确保一致的显示效果。</li><li><strong>文件大小较小：</strong> 字体文件相对于同等数量的独立图像文件来说，通常具有更小的文件大小。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>单色图标：</strong> 字体图标通常是单色的，难以实现多彩的效果。</li><li><strong>设计局限性：</strong> 字体图标受限于字体的设计，某些复杂或细致的图标可能不如独立图像清晰。</li><li><strong>Unicode 冲突：</strong> 字体图标使用了 Unicode 字符集中的一部分，可能会与已有的字符冲突，需要谨慎选择字符。</li><li><strong>依赖字体文件：</strong> 使用字体图标需要加载字体文件，如果字体文件未能正确加载，图标可能无法显示。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：如何禁止input显示输入历史记录？"><a href="#Q4：如何禁止input显示输入历史记录？" class="headerlink" title="Q4：如何禁止input显示输入历史记录？"></a>Q4：如何禁止input显示输入历史记录？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>为了禁止浏览器显示输入历史记录，可以通过设置 <code>autocomplete</code> 属性为 “off” 来实现。这个属性可以应用于 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、和 <code>&lt;form&gt;</code> 元素。</p><p><strong>在单个输入框中禁用历史记录：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在整个表单中禁用历史记录：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;submit-form.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 表单内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li><strong>浏览器支持：</strong> 大多数现代浏览器都支持 <code>autocomplete</code> 属性，但有些浏览器可能会忽略这个属性或对其行为有所不同。</li><li><strong>敏感信息：</strong> 尽管可以禁用历史记录，但对于敏感信息（如密码），最好使用 <code>type=&quot;password&quot;</code> 来确保更高的安全性。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：input上传文件可以同时选择多张吗？怎么设置？"><a href="#Q5：input上传文件可以同时选择多张吗？怎么设置？" class="headerlink" title="Q5：input上传文件可以同时选择多张吗？怎么设置？"></a>Q5：input上传文件可以同时选择多张吗？怎么设置？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files[]&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>multiple</code> 属性告诉浏览器允许选择多个文件</p><p><code>name=&quot;files[]&quot;</code> 中的 <code>files[]</code> 是在提交表单时用于标识上传文件的字段名称，这样可以在服务器端处理多个文件</p><p>在实际使用中，用户可以按住 Ctrl（在 Windows 或 Linux 上）或 Command（在 macOS 上）键，然后点击文件选择对话框中的多个文件，以便同时选择多个文件上传</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>&lt;input&gt;</code> 元素可以用于上传多个文件。为了启用多文件选择，你需要设置 <code>multiple</code> 属性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：使用input标签上传图片时，怎么触发默认拍照功能？"><a href="#Q6：使用input标签上传图片时，怎么触发默认拍照功能？" class="headerlink" title="Q6：使用input标签上传图片时，怎么触发默认拍照功能？"></a>Q6：使用input标签上传图片时，怎么触发默认拍照功能？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong>“camera”（摄像头）：</strong> 指定使用设备的摄像头，以触发拍照功能。</li><li><strong>“microphone”（麦克风）：</strong> 指定使用设备的麦克风，以触发录音功能。</li><li><strong>“camcorder”（摄像机）：</strong> 指定使用设备的摄像机，以触发录制视频功能。</li><li><strong>“user”：</strong> 指定使用前置摄像头，通常用于自拍照片。</li><li><strong>“environment”：</strong> 指定使用后置摄像头，通常用于拍摄环境中的照片或视频。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;camera&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>type=&quot;file&quot;</code>：</strong> 这定义了一个文件上传的输入框，允许用户选择文件。</li><li><strong><code>accept=&quot;image/\*&quot;</code>：</strong> 这个属性指定了文件对话框应该仅接受图像文件。这并不会阻止用户选择其他文件类型，但会过滤出非图像文件。</li><li><strong><code>capture=&quot;camera&quot;</code>：</strong> 这是触发默认拍照功能的关键。当设置为 “camera” 时，它告诉浏览器使用设备的摄像头。这样，用户点击文件输入框时，系统会调用默认的拍照功能而不是文件选择器。</li></ul><p>这个设置在移动设备上的浏览器中通常更为有效</p><p>在桌面浏览器上，它可能不会触发摄像头，而是仅限制用户选择图像文件</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：H5的离线储存是怎么用的？它的工作原理是什么"><a href="#Q7：H5的离线储存是怎么用的？它的工作原理是什么" class="headerlink" title="Q7：H5的离线储存是怎么用的？它的工作原理是什么"></a>Q7：H5的离线储存是怎么用的？它的工作原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTML5 提供了一种离线储存的机制，称为应用缓存（Application Cache），它允许 web 应用在离线时继续访问和运行。应用缓存通过一个包含应用所需文件的清单文件来工作，这个清单文件被称为应用缓存清单（或者简称为缓存清单）。以下是使用应用缓存的基本步骤以及工作原理：</p><p><strong>使用步骤：</strong></p><ol><li><p><strong>创建应用缓存清单文件：</strong></p><ul><li>创建一个文本文件，以 <code>.appcache</code> 为扩展名，例如 <code>example.appcache</code>。</li><li>在清单文件中列出需要离线访问的文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appcacheCopy codeCACHE MANIFEST</span><br><span class="line"># 版本号</span><br><span class="line"># Comment line</span><br><span class="line">/css/styles.css</span><br><span class="line">/js/scripts.js</span><br><span class="line">/images/logo.png</span><br></pre></td></tr></table></figure></li><li><p><strong>将清单文件关联到 HTML 页面：</strong></p><ul><li>在 HTML 页面的 <code>&lt;html&gt;</code> 标签中添加 <code>manifest</code> 属性，指向应用缓存清单文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htmlCopy code&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html manifest=&quot;example.appcache&quot;&gt;</span><br><span class="line">&lt;!-- 页面内容 --&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>服务器配置：</strong></p><ul><li>确保服务器正确配置，允许浏览器缓存清单文件。</li></ul></li></ol><p><strong>工作原理：</strong></p><ol><li><strong>应用缓存清单下载：</strong><ul><li>当用户第一次访问页面时，浏览器会下载清单文件并缓存它。</li></ul></li><li><strong>资源缓存：</strong><ul><li>根据清单文件中列出的资源，浏览器下载并缓存这些资源。</li></ul></li><li><strong>离线访问：</strong><ul><li>当用户离线时，浏览器会使用缓存的资源来渲染页面，而不是从服务器重新下载。</li></ul></li></ol><p><strong>注意事项：</strong></p><ul><li>应用缓存只有在第一次访问页面时才会被下载和缓存，之后只有在清单文件发生变化时才会重新下载。</li><li>使用缓存清单的资源需要跨足同一域名。</li><li>缓存清单中可以包含注释以及注释行（以 <code>#</code> 开头）。</li></ul><p>应用缓存虽然提供了一种在离线时继续访问和运行 web 应用的方式，但它也有一些限制和问题，例如缓存更新问题和缺乏细粒度的控制。由于这些限制，现在更多的开发者转向使用 Service Workers 来实现更强大和灵活的离线支持。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：浏览器如何对H5的离线储存资源进行管理跟加载？"><a href="#Q8：浏览器如何对H5的离线储存资源进行管理跟加载？" class="headerlink" title="Q8：浏览器如何对H5的离线储存资源进行管理跟加载？"></a>Q8：浏览器如何对H5的离线储存资源进行管理跟加载？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTML5 的离线储存（Application Cache）是一种浏览器缓存机制，用于使 web 应用能够在离线时访问资源。浏览器对离线储存资源的管理和加载遵循以下原则：</p><p><strong>离线储存资源的管理：</strong></p><ol><li><strong>清单文件下载：</strong><ul><li>浏览器在访问 web 应用时，会下载与页面关联的清单文件（缓存清单）。</li><li>清单文件中列出了需要被缓存的资源。</li></ul></li><li><strong>缓存清单更新：</strong><ul><li>清单文件中有一个注释行可以包含版本号或其他标识符，用于检测清单文件是否发生变化。</li><li>如果清单文件有更新，浏览器将重新下载和缓存清单中列出的资源。</li></ul></li></ol><p><strong>离线储存资源的加载：</strong></p><ol><li><strong>在线模式：</strong><ul><li>当用户在线时，浏览器会正常从服务器请求页面和资源。</li></ul></li><li><strong>离线模式：</strong><ul><li>当用户离线时，浏览器会尝试从本地缓存加载页面和资源。</li><li>如果清单文件及其列出的资源已经被缓存，浏览器将使用缓存的资源来渲染页面。</li></ul></li><li><strong>更新机制：</strong><ul><li>浏览器会定期检查清单文件是否有更新，如果有更新，它会重新下载清单文件及其列出的资源。</li><li>在有清单更新的情况下，即使用户在线，浏览器也会尝试重新下载清单中列出的资源，以确保使用最新的版本。</li></ul></li></ol><p><strong>注意事项与问题：</strong></p><ol><li><strong>缓存问题：</strong><ul><li>缓存清单一旦被下载，它将一直存在于用户浏览器中，即使清单文件内容已经更新。因此，清单文件的更新需要搭配版本号或其他标识符来确保及时生效。</li></ul></li><li><strong>Manifest Mismatch 错误：</strong><ul><li>在清单文件更新时，可能会出现 Manifest Mismatch 错误，这可能是由于浏览器仍然使用旧版本的清单文件导致的。</li></ul></li></ol><p>由于 HTML5 离线储存存在一些限制和问题，推荐使用更现代的 Service Workers 来实现更为强大和灵活的离线支持。 Service Workers 提供了更细粒度的控制，并且可以处理离线时的请求、动态缓存等更高级的功能。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：SEO原理是什么"><a href="#Q9：SEO原理是什么" class="headerlink" title="Q9：SEO原理是什么"></a>Q9：SEO原理是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>SEO（Search Engine Optimization）是一种通过改进网站内容和结构，以及增加外部引用来提高网站在搜索引擎中排名的过程。SEO 的原理涉及多个方面，包括网站内容、链接质量、用户体验等。</p><p><strong>原理：</strong></p><ol><li><strong>搜索引擎蜘蛛爬行：</strong> 搜索引擎通过派遣蜘蛛或机器人在网上发现新网页，抓取文件。蜘蛛从已知的网页开始，通过访问链接不断抓取新的网页，这个过程称为爬行。</li><li><strong>索引：</strong> 搜索引擎将蜘蛛抓取的网页文件分解、分析，并存入数据库，形成索引。索引包含了网页的文字内容、关键词位置、字体、颜色等相关信息。</li><li><strong>搜索词处理：</strong> 用户在搜索引擎输入关键词后，搜索引擎对输入的搜索词进行处理，如中文分词、去除停止词、检查拼写错误等。</li><li><strong>排序：</strong> 搜索引擎排序程序根据处理后的搜索词，从索引数据库中找出所有包含搜索词的网页，并根据排名算法计算哪些网页应该在前面显示。排名算法考虑了关键词的相关性、网页的质量、链接的权威性等因素。</li></ol><p>SEO的原理在于理解搜索引擎的工作流程，通过优化网站内容、结构、链接等因素，提高网站在搜索引擎中的排名，从而增加有针对性的流量。优化的目标是使网站更容易被搜索引擎发现，同时提高在与目标关键词相关的搜索结果中的排名。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：如何实现SEO优化？"><a href="#Q10：如何实现SEO优化？" class="headerlink" title="Q10：如何实现SEO优化？"></a>Q10：如何实现SEO优化？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>关键字研究与使用：</strong><ul><li>进行关键字研究，确定与业务相关且有搜索量的关键字。在网站的标题、正文、标签等位置合理使用关键字，但要避免过度堆砌。</li></ul></li><li><strong>高质量内容：</strong><ul><li>创建高质量、原创、有价值的内容，满足用户需求。确保内容清晰、易于理解，避免重复内容。</li></ul></li><li><strong>网站结构优化：</strong><ul><li>优化网站结构，使其易于导航和理解。确保每个页面都有一个清晰的主题，并使用清晰的 URL 结构。</li></ul></li><li><strong>内部链接：</strong><ul><li>使用内部链接连接相关页面，帮助搜索引擎理解网站的层次结构。确保每个页面都可以通过内部链接访问。</li></ul></li><li><strong>外部链接建设：</strong><ul><li>获得高质量、相关性强的外部链接。这可以通过创建有吸引力的内容、参与社交媒体、合作关系等方式实现。</li></ul></li><li><strong>网站速度优化：</strong><ul><li>提高网站加载速度，优化图片、文件压缩、启用浏览器缓存等措施。速度对用户体验和搜索引擎排名都有影响。</li></ul></li><li><strong>移动优先设计：</strong><ul><li>优化网站以适应不同移动设备，确保在移动端的用户体验良好。搜索引擎越来越注重移动优先。</li></ul></li><li><strong>使用合适的标签：</strong><ul><li>使用合适的 HTML 标签，如标题标签、meta 标签等，以提高搜索引擎对页面内容的理解。</li></ul></li><li><strong>社交媒体参与：</strong><ul><li>积极参与社交媒体，分享网站内容，增加社交媒体信号。这也可以增加网站的曝光和流量。</li></ul></li><li><strong>定期更新：</strong><ul><li>定期更新网站内容，确保网站保持新鲜度。搜索引擎更倾向于显示更新频繁的网站。</li></ul></li><li><strong>网站安全性：</strong><ul><li>提供安全的网站环境，使用 HTTPS 协议，这也是搜索引擎考虑的一个因素。</li></ul></li><li><strong>SEO工具与分析：</strong><ul><li>使用 SEO 工具进行网站分析，了解搜索引擎索引情况、关键字排名等，根据数据调整优化策略。</li></ul></li><li><strong>合理的网站地图：</strong><ul><li>创建并提交网站地图，帮助搜索引擎更好地索引网站中的页面。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：SPA应用怎么实现SEO优化？"><a href="#Q11：SPA应用怎么实现SEO优化？" class="headerlink" title="Q11：SPA应用怎么实现SEO优化？"></a>Q11：SPA应用怎么实现SEO优化？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>SPA（Single Page Application）是一种通过JavaScript动态更新页面内容，而不需要重新加载整个页面的应用程序。由于SPA在初始加载时只加载一个HTML文件，其内容主要通过JavaScript动态生成，这可能导致搜索引擎在爬取和索引SPA时遇到一些挑战。然而，有一些方法可以帮助实现SPA的SEO优化：</p><ol><li><strong>服务器端渲染（SSR）：</strong><ul><li>使用服务器端渲染的框架，例如Next.js（React）、Nuxt.js（Vue）、Angular Universal（Angular）等，可以在服务端生成初始HTML，并将其发送给客户端。这有助于搜索引擎在初始渲染时获取页面内容，提高索引效率。</li></ul></li><li><strong>预渲染（Prerendering）：</strong><ul><li>对于一些静态内容较多的页面，可以考虑使用预渲染技术。在构建时生成HTML文件，并提供给搜索引擎爬虫。这样，搜索引擎可以更容易地索引内容，而用户访问时仍然可以享受SPA的动态交互。</li></ul></li><li><strong>服务端渲染和预渲染结合：</strong><ul><li>对于一些关键页面，可以选择使用服务端渲染，而对于其他页面，使用预渲染。这样可以在关键页面保持动态性的同时，提供给搜索引擎已渲染的HTML。</li></ul></li><li><strong>使用合适的meta标签：</strong><ul><li>使用合适的meta标签，特别是描述页面内容的meta标签，以帮助搜索引擎理解页面内容。例如，<code>&lt;meta name=&quot;description&quot; content=&quot;Your page description&quot;&gt;</code>。</li></ul></li><li><strong>Sitemap文件：</strong><ul><li>提供一个sitemap.xml文件，其中包含站点的所有重要页面。这可以帮助搜索引擎了解站点的结构和内容。</li></ul></li><li><strong>使用路由：</strong><ul><li>在SPA中使用路由，确保每个页面都有唯一的URL。这有助于搜索引擎正确索引不同的页面。</li></ul></li><li><strong>合理的链接结构：</strong><ul><li>使用合理的链接结构，确保内部链接和导航能够被爬虫正确解析。SPA应用可以使用虚拟DOM和路由等技术来实现。</li></ul></li><li><strong>社交媒体优化：</strong><ul><li>确保社交媒体分享时能够正确显示页面信息。为每个页面添加Open Graph和Twitter Card等社交媒体标签。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：怎么实现点击回到顶部功能？"><a href="#Q12：怎么实现点击回到顶部功能？" class="headerlink" title="Q12：怎么实现点击回到顶部功能？"></a>Q12：怎么实现点击回到顶部功能？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>使用锚点链接：</strong></p><ul><li><p>在页面顶部设置一个带有id属性的锚点，然后通过链接到这个锚点来实现回到顶部。例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在页面顶部设置的锚点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;top&quot;</span>&gt;</span>顶部内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这种方式通过原生的锚点跳转，可以在点击时平滑滚动到顶部。</p></li></ul></li><li><p><strong>使用JavaScript滚动事件：</strong></p><ul><li><p>通过监听页面滚动事件，当滚动距离超过一定值时显示回到顶部按钮，点击按钮时回到顶部。示例代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;scrollToTop&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> scrollToTopButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;scrollToTop&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> &gt; <span class="number">20</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &gt; <span class="number">20</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      scrollToTopButton.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      scrollToTopButton.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  scrollToTopButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="number">0</span>; <span class="comment">// For Safari</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>; <span class="comment">// For Chrome, Firefox, IE, and Opera</span></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上述代码通过监听滚动事件，在滚动距离超过一定值时显示回到顶部按钮，并在点击按钮时平滑滚动到页面顶部。</p></li></ul></li><li><p><strong>使用CSS动画：</strong></p><ul><li><p>利用CSS的动画效果，通过将按钮的位置从底部平滑移动到顶部，实现回到顶部的效果。示例代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;scrollToTop&quot;</span> <span class="attr">class</span>=<span class="string">&quot;scrollToTop&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.scrollToTop</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">bottom</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">right</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">transition</span>: bottom <span class="number">0.3s</span> ease-in-out;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.scrollToTop</span><span class="selector-class">.show</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">bottom</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JavaScript代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> scrollToTopButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;scrollToTop&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> &gt; <span class="number">20</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &gt; <span class="number">20</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      scrollToTopButton.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      scrollToTopButton.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;show&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  scrollToTopButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="number">0</span>; <span class="comment">// For Safari</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>; <span class="comment">// For Chrome, Firefox, IE, and Opera</span></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上述代码通过CSS的<code>transition</code>属性实现了平滑的动画效果，按钮在滚动时显示或隐藏。</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：假设我要上传图片，我要怎么在选择图片之后通过浏览器预览待上传的图片？"><a href="#Q13：假设我要上传图片，我要怎么在选择图片之后通过浏览器预览待上传的图片？" class="headerlink" title="Q13：假设我要上传图片，我要怎么在选择图片之后通过浏览器预览待上传的图片？"></a>Q13：假设我要上传图片，我要怎么在选择图片之后通过浏览器预览待上传的图片？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>window.URL.createObjectURL</code>：</strong></p><ul><li><p>这个方法创建一个包含文件内容的 URL，这个 URL 可以被用于在浏览器中直接显示文件，比如在 <code>&lt;img&gt;</code> 元素的 <code>src</code> 属性中。它创建的 URL 是一个 Blob URL，对应于一个二进制数据块。</p></li><li><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">previewImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imageInput&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imagePreview&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">files</span> &amp;&amp; input.<span class="property">files</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">const</span> imageUrl = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(input.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">    preview.<span class="property">src</span> = imageUrl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>FileReader</code>：</strong></p><ul><li><p>这是一种更灵活的方式，通过 <code>FileReader</code> 对象读取文件的内容，并以不同的格式（比如DataURL）表示。这样可以实现更多的自定义操作，例如将文件内容显示在页面上或进行其他处理。</p></li><li><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">previewImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imageInput&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> preview = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;imagePreview&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">files</span> &amp;&amp; input.<span class="property">files</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">    reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      preview.<span class="property">src</span> = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(input.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：如何控制input输入框的字数"><a href="#Q14：如何控制input输入框的字数" class="headerlink" title="Q14：如何控制input输入框的字数"></a>Q14：如何控制input输入框的字数</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>maxlength</code> 属性用于定义输入框的最大字符数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;textInput&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;10&quot;</span> <span class="attr">oninput</span>=<span class="string">&quot;limitInputLength(this)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>客户端的控制不能完全保证字数不会超出，因为用户可以通过浏览器开发者工具或其他手段绕过这些限制。在实际应用中，通常还需要在服务器端进行验证。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：什么是SSG？有什么实现方式？有什么优点跟缺点？"><a href="#Q15：什么是SSG？有什么实现方式？有什么优点跟缺点？" class="headerlink" title="Q15：什么是SSG？有什么实现方式？有什么优点跟缺点？"></a>Q15：什么是SSG？有什么实现方式？有什么优点跟缺点？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>静态站点生成（SSG）</strong> 是一种构建网站的方法，它在构建时预先生成整个网站的静态页面，而不是在每次请求时动态生成。以下是关于静态站点生成的一些详细信息：</p><p><strong>实现方式：</strong></p><ol><li><strong>使用静态生成工具：</strong> 使用专门的静态生成工具或框架，如 Gatsby、Next.js、Hugo 等。这些工具提供了开发者友好的方式来创建、构建和部署静态站点。</li><li><strong>Markdown 文件：</strong> 很多静态生成工具使用 Markdown 文件来管理内容，然后将其转换成静态页面。</li></ol><p><strong>优点：</strong></p><ol><li><strong>性能优越：</strong> 静态站点的性能通常较高，因为所有页面都是预先生成的，并可以通过 CDN 进行分发。</li><li><strong>安全性：</strong> 由于没有服务器端逻辑，静态站点通常更安全，减少了一些潜在的安全风险。</li><li><strong>简化部署：</strong> 静态文件可以轻松地部署到各种托管服务上，而不需要服务器端的特殊配置。</li><li><strong>独立托管：</strong> 静态站点可以独立于后端技术，因为它们不依赖于服务器端的动态生成。</li><li><strong>适用于内容较为静态：</strong> 对于内容不经常更改的网站，静态站点生成是一个理想的选择。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>不适用于动态内容：</strong> 对于需要实时更新的动态内容，静态站点生成可能不太适用，因为它需要重新构建整个站点。</li><li><strong>构建时间较长：</strong> 对于较大的网站，构建整个站点的时间可能较长。</li><li><strong>不适用于个性化内容：</strong> 对于需要个性化内容的网站，静态站点生成可能需要更复杂的解决方案。</li><li><strong>复杂度：</strong> 对于初学者来说，配置和使用静态生成工具可能需要一些学习成本。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>主要特点和工作流程包括：</strong></p><ol><li><strong>预先生成：</strong> 在构建过程中，所有的页面内容都被提前生成成静态文件。这包括页面的 HTML、CSS、JavaScript 等。</li><li><strong>提高性能：</strong> 由于所有页面都是静态的，它们可以被缓存并由 CDN（内容分发网络）分发。这降低了每个用户请求的响应时间，提高了性能。</li><li><strong>安全性：</strong> 静态站点通常更安全，因为它们没有服务器端逻辑，没有与数据库的实时交互。这减少了一些潜在的安全漏洞。</li><li><strong>部署简单：</strong> 静态文件可以轻松地部署到各种托管服务上，而无需复杂的服务器设置。</li><li><strong>独立托管：</strong> 静态站点可以独立于特定的后端技术，因为它们不依赖于服务器端的动态生成。</li><li><strong>支持前端框架：</strong> 许多现代的前端框架，如 Next.js、Nuxt.js 等，支持静态站点生成作为其工作流的一部分。</li></ol><p>SSG 在现代 Web 开发中变得越来越流行，特别是对于内容较为静态或变化不频繁的网站。一些流行的静态站点生成工具和框架包括 Gatsby、Next.js、Hugo 等。这些工具提供了开发者友好的方式来构建、部署和管理静态站点。</p>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《前端工程化 面试题》</title>
    <url>/posts/75cf67a1/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：npm-是什么"><a href="#Q1：npm-是什么" class="headerlink" title="Q1：npm 是什么?"></a>Q1：npm 是什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>npm</code> 是 Node.js 的包管理器（Node Package Manager），是 Node.js 生态系统中用于管理和共享代码包（包括库、工具、框架等）的官方工具</p><p>它是开发者在 Node.js 环境中获取、安装、发布和管理代码包的首选工具之一</p><p>以下是 <code>npm</code> 的主要功能和特点：</p><ol><li><p><strong>包管理</strong></p><p><code>npm</code> 提供了一个庞大的包仓库，其中包含了数以万计的开源代码包，涵盖了几乎所有领域的需求</p><p>开发者可以通过 <code>npm</code> 来查找、安装和管理这些代码包</p></li><li><p><strong>依赖管理</strong></p><p><code>npm</code> 可以帮助开发者管理项目依赖，包括生产环境和开发环境中使用的依赖</p><p>开发者可以在项目中使用 <code>npm install</code> 命令来安装项目所需的所有依赖</p></li><li><p><strong>版本控制</strong></p><p><code>npm</code> 支持语义化版本控制（Semantic Versioning），开发者可以在安装包时指定版本号，以确保代码的稳定性和兼容性</p></li><li><p><strong>脚本执行</strong></p><p><code>npm</code> 允许开发者在 <code>package.json</code> 文件中定义各种自定义脚本，例如构建、测试、部署等脚本，并通过 <code>npm run</code> 命令来执行这些脚本</p></li><li><p><strong>发布和分享</strong></p><p>开发者可以使用 <code>npm publish</code> 命令将自己的代码包发布到 <code>npm</code> 仓库，从而与其他开发者分享自己的代码和项目</p></li><li><p><strong>管理工具</strong></p><p>除了包管理之外，<code>npm</code> 还提供了一些其他实用的命令和工具，例如 <code>npm outdated</code>、<code>npm audit</code>、<code>npm dedupe</code> 等，用于检查过期依赖、安全漏洞、依赖冗余等</p></li></ol><p>总的来说，<code>npm</code> 是一个功能强大、易用的包管理工具，为 Node.js 生态系统的发展和推广提供了重要的支持，使得开发者能够更加轻松地构建、共享和维护自己的 JavaScript 代码</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：对-webpack5-模块联邦的了解（Module-Federation）"><a href="#Q2：对-webpack5-模块联邦的了解（Module-Federation）" class="headerlink" title="Q2：对 webpack5 模块联邦的了解（Module Federation）"></a>Q2：对 webpack5 模块联邦的了解（Module Federation）</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Webpack 5 的模块联邦（Module Federation）是 Webpack 5 中引入的一个强大的新功能，它允许不同的应用程序共享代码和依赖</p><p>模块联邦提供了在应用之间动态加载和运行模块的能力，并且可以实现远程模块加载</p><p>这使得前端开发人员能够更好地构建微前端架构，解决大型应用程序的拆分和协作开发问题</p><p><strong>基本概念</strong></p><ol><li><strong>模块联邦</strong>：<ul><li>模块联邦允许一个应用程序（容器应用）加载另一个应用程序的模块（远程模块），并在其内部使用</li><li>这使得应用程序之间能够共享代码和依赖</li></ul></li><li><strong>容器（Container）</strong>：<ul><li>容器应用是一个配置了 <code>ModuleFederationPlugin</code> 插件的 Webpack 构建</li><li>容器应用可以加载远程模块并将其作为自己的模块来使用</li></ul></li><li><strong>远程模块（Remote Module）</strong>：<ul><li>远程模块是由另一个 Webpack 构建生成的模块，可以通过模块联邦加载并使用</li><li>远程模块可以在不同应用程序之间共享代码和组件</li></ul></li><li><strong>共享依赖</strong>：<ul><li>模块联邦允许应用程序之间共享依赖，例如：React、Lodash 等第三方库</li><li>共享依赖可以减少重复的库加载，提高效率</li></ul></li></ol><p><strong>优势和挑战</strong></p><ol><li><strong>优点</strong>：<ul><li>在不同应用程序之间共享代码和依赖，提高复用性</li><li>支持动态加载远程模块，增强应用的灵活性</li><li>有助于实现微前端架构，分割大型应用</li></ul></li><li><strong>挑战</strong>：<ul><li>共享依赖的版本一致性问题需要注意</li><li>远程模块加载可能会遇到性能和安全问题</li><li>错误处理和调试可能较为复杂</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>配置和使用</strong></p><ol><li><strong>ModuleFederationPlugin 插件</strong>：<ul><li><code>ModuleFederationPlugin</code> 是模块联邦的核心插件，通过配置该插件来启用模块联邦</li><li>配置选项包括 <code>name</code>（容器应用的名称）、<code>remotes</code>（定义远程模块）、<code>exposes</code>（定义本地模块供远程加载）、<code>shared</code>（定义共享依赖）</li></ul></li><li><strong>配置选项</strong>：<ul><li><code>name</code>：容器应用的名称，唯一标识</li><li><code>remotes</code>：定义可以远程加载的模块，格式为 <code>{远程模块名称: &quot;远程容器地址&quot;}</code></li><li><code>exposes</code>：定义本地模块暴露给其他容器使用，格式为 <code>{本地模块路径: &quot;本地模块名称&quot;}</code></li><li><code>shared</code>：定义共享依赖，例如 <code>{库名称: {singleton: true}}</code> 表示共享的依赖使用单例模式</li></ul></li></ol><p><strong>使用</strong></p><ol><li><strong>加载远程模块</strong>：<ul><li>使用动态 <code>import</code> 语法加载远程模块。例如：<code>const RemoteComponent = React.lazy(() =&gt; import(&quot;远程模块名称/模块路径&quot;));</code></li></ul></li><li><strong>错误处理</strong>：<ul><li>模块联邦可能会遇到远程模块加载失败等问题。可以使用错误边界和 <code>try-catch</code> 块进行错误处理</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：介绍tree-shaking-及其工作原理"><a href="#Q3：介绍tree-shaking-及其工作原理" class="headerlink" title="Q3：介绍tree shaking 及其工作原理"></a>Q3：介绍tree shaking 及其工作原理</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Tree shaking 是一种在打包过程中移除 JavaScript 项目中未引用代码（即“死代码”）的技术</p><p>这个概念来源于 ES2015 模块的静态结构特性，它允许工具在编译时间静态分析出哪些导出和导入是真正被使用的</p><p>通过这种方式，可以显著减少最终打包文件的大小，提高应用的加载速度和性能</p><p><strong>工作原理</strong></p><p>Tree shaking 的工作原理基于 ES modules（即 ES6 的模块化语法），因为 ES modules 是静态的，这使得在编译阶段就能确定模块之间的依赖关系。具体来说，其工作流程分为下面几个步骤：</p><ol><li><p><strong>导入分析</strong></p><p>工具如 Webpack、Rollup 或其他模块打包器在处理应用程序代码时，会分析模块间的导入（<code>import</code>）和导出（<code>export</code>）语句，建立起模块之间的依赖图（Dependency Graph）</p></li><li><p><strong>未使用代码标记</strong></p><p>在建立完依赖图后，打包工具会遍历这个图，标记所有实际被使用（即被其他模块导入）的代码</p><p>同时，那些未被引用的导出（如函数、类、变量等）会被标记为未使用</p></li><li><p><strong>移除死代码</strong></p><p>在最后生成打包文件的阶段，打包器会去除那些被标记为未使用的代码</p><p>这一步骤通常需要压缩工具（如 Terser）的协助，因为 ES6 模块的导入和导出语句通常不会被直接修改</p></li></ol><p><strong>注意事项</strong></p><ul><li><p><strong>ES Modules</strong></p><p>目前，tree shaking 主要适用于使用 ES6 模块语法（即 <code>import</code> 和 <code>export</code>）的代码</p><p>对于 CommonJS 或其他非 ES6 模块系统，由于它们是动态的，这使得静态分析变得更复杂，tree shaking 的效果可能会大打折扣</p></li><li><p><strong>副作用（Side Effects）</strong></p><p>有些模块执行时可能会有副作用（例如，修改全局变量或立即执行的逻辑），即使这些模块没有导出或被其他模块直接引用</p><p>打包工具不能简单地移除这些代码，因为它可能改变程序的行为</p><p>为了处理这种情况，一些打包工具提供了配置选项（如 Webpack 的 <code>sideEffects</code> 标志），让开发者指明哪些文件是“无副作用”（即可以安全地移除未被引用的导出）</p></li></ul><p>Tree shaking 是现代前端工程化工具中一个重要的性能优化手段，可以有效地减小应用的体积和提升加载速度</p><p>理解它的工作原理和合理地利用它，可以让我们的应用更加高效</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：pnpm是什么"><a href="#Q4：pnpm是什么" class="headerlink" title="Q4：pnpm是什么"></a>Q4：pnpm是什么</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>pnpm</code>是一个高效的包管理器，用于JavaScript和Node.js，旨在解决一些<code>npm</code>及<code>Yarn</code>在使用过程中可能遇到的问题</p><p>它与<code>npm</code>和<code>Yarn</code>类似，用于自动化Node.js项目的依赖项管理和包安装过程</p><p>pnpm的主要特点包括：</p><ol><li><p><strong>节省磁盘空间和提高安装速度</strong></p><p>pnpm通过使用硬链接和符号链接的方式在多个项目之间共享相同的包版本，从而节省磁盘空间</p><p>一旦一个包版本被下载到全局存储，就可以被多个项目使用而不需要重复下载</p></li><li><p><strong>严格的依赖项隔离</strong></p><p>pnpm创建一个虚拟的<code>node_modules</code>目录，使得每个项目只能访问声明在其<code>package.json</code>文件中的依赖项，从而减少因依赖项错误配置而引起的问题</p></li><li><p><strong>支持并行操作</strong></p><p>pnpm能够同时运行多个操作，例如安装多个包，这可以显著提升性能</p></li><li><p><strong>钩子和自定义脚本</strong></p><p>允许用户执行自定义的脚本或创建钩子，在不同的包安装阶段进行额外的操作。</p></li><li><p><strong>兼容性</strong></p><p>尽管pnpm使用不同的链接方式和存储结构，它仍然与包含在<code>npm</code>生态中的包兼容，而且可以使用<code>package.json</code>文件以及相应的锁文件</p></li><li><p><strong>锁文件</strong></p><p>与<code>npm</code>的<code>package-lock.json</code>和<code>Yarn</code>的<code>yarn.lock</code>类似，pnpm使用<code>pnpm-lock.yaml</code>文件来确保依赖项在不同环境中的一致安装</p></li></ol><p>pnpm致力于提供一个更快、更高效且安全地处理依赖项的方法</p><p>它可以通过Node.js的包管理器（如<code>npm</code>）安装，命令通常是<code>npm install -g pnpm</code></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>pnpm</code>主要解决的一些<code>npm</code>和<code>Yarn</code>可能遇到的问题包括：</p><ol><li><p><strong>磁盘空间使用过多</strong></p><p>使用<code>npm</code>或<code>Yarn</code>管理的每个项目都会在本地存储一个<code>node_modules</code>文件夹，里面包含着该项目的所有依赖包</p><p>这意味着，如果多个项目使用同一个包，这个包会被复制存储多次，导致了磁盘空间的浪费</p><p>而<code>pnpm</code>采用一个全局存储方式，多个项目共享同一个包，这极大地节省了磁盘空间</p></li><li><p><strong>严格的依赖项管理</strong></p><p><code>npm</code>和<code>Yarn</code>的<code>node_modules</code>结构可能导致一些隐藏问题，如未在<code>package.json</code>中声明但实际上项目中用到的包，或者依赖的版本与<code>package.json</code>中声明的版本不符合</p><p>这是因为<code>npm</code>和<code>Yarn</code>的依赖解析方式可能会导致一个包可以访问并使用到它并未直接依赖的包，而这可能带来一些不明确的行为和难以追踪的错误</p><p>pnpm`则提供了严格的包隔离，每个包只能使用明确声明的依赖</p></li><li><p><strong>文件系统链接</strong></p><p>不同于<code>npm</code>或<code>Yarn</code>，<code>pnpm</code>通过硬链接和符号链接对依赖进行管理，这让它在安装速度和磁盘空间使用上更具优势</p><p>在<code>npm</code>或<code>Yarn</code>中，每当在项目中安装一个依赖，系统都需要完全复制该依赖包的内容，无论是否已经存在相同版本的依赖包</p><p>而<code>pnpm</code>可以通过链接重用已经安装的依赖包，而无需进行复制</p></li></ol><p>三者之间的区别：</p><div class="table-container"><table><thead><tr><th style="text-align:left">特性 / 工具</th><th style="text-align:left">npm</th><th style="text-align:left">Yarn</th><th style="text-align:left">pnpm</th></tr></thead><tbody><tr><td style="text-align:left">依赖安装速度</td><td style="text-align:left">一般</td><td style="text-align:left">快（通过并行下载加快）</td><td style="text-align:left">快（共享存储空间）</td></tr><tr><td style="text-align:left">磁盘空间利用</td><td style="text-align:left">低（每个项目的依赖被复制存储）</td><td style="text-align:left">低（每个项目的依赖被复制存储）</td><td style="text-align:left">高（通过硬链接和符号链接共享）</td></tr><tr><td style="text-align:left">依赖隔离</td><td style="text-align:left">不存在（允许非直接依赖的包被使用）</td><td style="text-align:left">不存在（允许非直接依赖的包被使用）</td><td style="text-align:left">存在（只允许使用明确声明的依赖）</td></tr><tr><td style="text-align:left">锁定文件</td><td style="text-align:left">存在（<code>package-lock.json</code>）</td><td style="text-align:left">存在（<code>yarn.lock</code>）</td><td style="text-align:left">存在（<code>pnpm-lock.yaml</code>）</td></tr><tr><td style="text-align:left">并行安装</td><td style="text-align:left">不支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">交互式工具</td><td style="text-align:left">有限</td><td style="text-align:left">丰富（如交互式升级工具）</td><td style="text-align:left">有限</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：AST语法树是什么"><a href="#Q5：AST语法树是什么" class="headerlink" title="Q5：AST语法树是什么"></a>Q5：AST语法树是什么</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>构成</p><p>抽象语法树（AST）由节点组成</p><p>每个节点代表源代码中的一个构造，如表达式、语句、声明等</p><p>节点之间存在父子关系，反映了源代码中不同构造之间的嵌套关系</p><ul><li><p><strong>根节点</strong></p><p>代表了整个源代码文件或一段代码的最外层</p></li><li><p><strong>内部节点</strong></p><p>代表了源代码中的结构性元素，如循环、条件判断、函数声明等</p></li><li><p><strong>叶子节点</strong></p><p>代表了源代码中的最基本元素，如变量名、常量、操作符等</p></li></ul></li><li><p>作用</p><p>AST在编程语言的编译器或解释器中扮演至关重要的角色</p><p>它使得代码的分析、优化与转换变得可行</p><p>在现代开发实践中，AST广泛应用于：</p><ul><li><p><strong>代码编译与转换</strong></p><p>编译器将源代码转换成AST，再进一步转换成目标代码或中间代码</p></li><li><p><strong>代码优化</strong></p><p>在AST上应用各种优化策略，如消除无效代码，优化循环等</p></li><li><p><strong>静态代码分析</strong></p><p>通过分析AST来识别代码中的问题，如潜在的bug、性能瓶颈等</p></li><li><p><strong>代码格式化与重构</strong></p><p>通过修改AST来改变代码的格式化风格或进行重构</p></li></ul></li><li><p>工作原理</p><p>将源代码转换成AST的过程一般分为几个步骤：</p><ol><li><p><strong>词法分析（Lexical Analysis）</strong></p><p>将源代码分解为一系列的符号（tokens），如关键字、标识符、字面量等</p></li><li><p><strong>语法分析（Syntactic Analysis）</strong></p><p>将这些符号构造成AST</p><p>这一步骤涉及到语法规则的应用，判断哪些符号可以组成有效的语言构造</p></li><li><p><strong>语义分析（Semantic Analysis）</strong>（在某些场景中）</p><p>确保AST遵守语言的语义规则，如类型检查、作用域解析等</p></li></ol></li><li><p>例子</p><p>以JavaScript为例，源代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致对应的AST结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FunctionDeclaration</span><br><span class="line">  |--- Identifier (name=&quot;add&quot;)</span><br><span class="line">  |--- Parameters</span><br><span class="line">       |--- Identifier (name=&quot;x&quot;)</span><br><span class="line">       |--- Identifier (name=&quot;y&quot;)</span><br><span class="line">  |--- BlockStatement</span><br><span class="line">       |--- ReturnStatement</span><br><span class="line">            |--- BinaryExpression</span><br><span class="line">                 |--- Identifier (name=&quot;x&quot;)</span><br><span class="line">                 |--- &quot;+&quot; Operator</span><br><span class="line">                 |--- Identifier (name=&quot;y&quot;)</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：package-json-文件中的-devDependencies-和dependencies-对象有什么区别"><a href="#Q6：package-json-文件中的-devDependencies-和dependencies-对象有什么区别" class="headerlink" title="Q6：package,json 文件中的 devDependencies 和dependencies 对象有什么区别"></a>Q6：package,json 文件中的 devDependencies 和dependencies 对象有什么区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>dependencies</code></p><ul><li><p><strong>用途</strong></p><p><code>dependencies</code> 对象用于列出项目在运行时所需的依赖包</p><p>这些包是你的应用在生产环境中正常运行所必需的</p></li><li><p><strong>安装命令</strong></p><p>当你运行 <code>npm install</code> 或 <code>yarn install</code> 时，这些依赖会被安装</p></li><li><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^17.0.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.21.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>devDependencies</code></p><ul><li><p><strong>用途</strong></p><p><code>devDependencies</code> 对象用于列出项目在开发时所需的依赖包</p><p>这些包通常包括测试框架、构建工具、代码格式化工具等，它们在生产环境中并不需要</p></li><li><p><strong>安装命令</strong></p><p>当你运行 <code>npm install</code> 或 <code>yarn install</code> 时，这些依赖也会被安装</p><p>不过，如果你只想安装生产依赖，可以使用 <code>npm install --production</code> 或 <code>yarn install --production</code>，这时 <code>devDependencies</code> 中的包不会被安装</p></li><li><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.24.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.2.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.23.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^26.6.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>主要区别</strong></p><ol><li><strong>用途不同</strong>：<ul><li><code>dependencies</code>：生产环境和开发环境都需要的包</li><li><code>devDependencies</code>：仅在开发环境中需要的包</li></ul></li><li><strong>安装时机不同</strong>：<ul><li>默认情况下，运行 <code>npm install</code> 或 <code>yarn install</code> 时会安装所有依赖</li><li>使用 <code>npm install --production</code> 或 <code>yarn install --production</code> 时，只会安装 <code>dependencies</code> 中的包</li></ul></li><li><strong>影响打包</strong>：<ul><li>在打包或部署应用时，通常只会包含 <code>dependencies</code> 中的包，以减小包的大小和提高性能</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：webpack5-的主要升级点有哪些"><a href="#Q7：webpack5-的主要升级点有哪些" class="headerlink" title="Q7：webpack5 的主要升级点有哪些"></a>Q7：webpack5 的主要升级点有哪些</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>模块联邦（Module Federation）</p><ul><li><p><strong>功能</strong>：允许多个独立构建的应用程序在运行时共享代码。这对于微前端架构特别有用</p></li><li><p><strong>优势</strong>：简化了代码共享，减少了重复代码，提高了应用的可维护性</p></li></ul></li><li><p>持久化缓存（Persistent Caching）</p><ul><li><p><strong>功能</strong>：Webpack 5 引入了持久化缓存，以提高构建性能</p></li><li><p><strong>优势</strong>：通过缓存生成的模块和 chunks，后续构建速度显著提升</p></li></ul></li><li><p>更好的 Tree Shaking</p><ul><li><p><strong>功能</strong>：改进了对未使用代码的检测和删除</p></li><li><p><strong>优势</strong>：减少了输出文件的大小，提升了应用的性能</p></li></ul></li><li><p>内置文件系统缓存（File System Cache）</p><ul><li><p><strong>功能</strong>：允许将缓存写入文件系统，以便在重启构建时读取</p></li><li><p><strong>优势</strong>：加快了开发和构建过程，特别是在大型项目中</p></li></ul></li><li><p>改进的代码拆分（Code Splitting）</p><ul><li><p><strong>功能</strong>：增强了代码拆分的策略和配置选项</p></li><li><p><strong>优势</strong>：更灵活地管理代码拆分，提高了应用的加载性能</p></li></ul></li><li><p>默认开启的长期缓存（Long-Term Caching）</p><ul><li><p><strong>功能</strong>：Webpack 5 默认启用了更好的长期缓存策略</p></li><li><p><strong>优势</strong>：通过内容哈希（content hashing）等技术，确保浏览器能够有效地缓存资源，从而减少加载时间</p></li></ul></li><li><p>内置的 WebAssembly 支持</p><ul><li><p><strong>功能</strong>：提供了对 WebAssembly 的更好支持</p></li><li><p><strong>优势</strong>：简化了 WebAssembly 模块的集成和使用</p></li></ul></li><li><p>更好的兼容性和迁移工具</p><ul><li><p><strong>功能</strong>：提供了迁移工具和文档，帮助开发者从 Webpack 4 迁移到 Webpack 5</p></li><li><p><strong>优势</strong>：减少了迁移过程中的摩擦，确保了向后兼容性</p></li></ul></li><li><p>移除了 Node.js Polyfills</p><ul><li><p><strong>功能</strong>：Webpack 5 不再自动为 Node.js 核心模块提供 polyfills</p></li><li><p><strong>优势</strong>：减少了打包后的代码大小，开发者需要手动引入所需的 polyfills</p></li></ul></li><li><p>改进的插件和 Loader API</p><ul><li><p><strong>功能</strong>：增强了插件和 loader 的 API，使其更为强大和灵活</p></li><li><p><strong>优势</strong>：开发自定义插件和 loader 更加容易，扩展性更强</p></li></ul></li><li><p>更好的性能和内存优化</p><ul><li><p><strong>功能</strong>：通过多项优化措施，Webpack 5 提升了整体性能和内存使用效率</p></li><li><p><strong>优势</strong>：构建速度更快，内存占用更低，特别适合大型项目</p></li></ul></li><li><p>更好的错误和警告信息</p><ul><li><p><strong>功能</strong>：改进了错误和警告信息的输出，使其更为清晰和易于理解</p></li><li><p><strong>优势</strong>：帮助开发者更快地定位和解决问题</p></li></ul></li><li><p>实验性功能</p><ul><li><p><strong>功能</strong>：引入了一些实验性功能，如模块热替换（HMR）的改进等</p></li><li><p><strong>优势</strong>：开发者可以提前试用新特性，并提供反馈</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：与webpack类似的工具还有哪些-区别是什么"><a href="#Q8：与webpack类似的工具还有哪些-区别是什么" class="headerlink" title="Q8：与webpack类似的工具还有哪些?区别是什么"></a>Q8：与webpack类似的工具还有哪些?区别是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>Parcel</strong>：<ul><li><strong>特点</strong>：零配置，开箱即用，快速的打包速度</li><li><strong>区别</strong>：相比于Webpack，Parcel更注重简化配置，适合快速原型开发和小型项目。它自动处理大多数常见的配置，减少了开发者的学习曲线</li></ul></li><li><strong>Rollup</strong>：<ul><li><strong>特点</strong>：专注于ES模块的打包，生成更小、更优化的包</li><li><strong>区别</strong>：Rollup主要用于库的打包，它生成的代码更简洁，适合于需要发布为npm包的库。相比Webpack，Rollup的配置更简单，但功能也更专注于模块打包</li></ul></li><li><strong>Gulp</strong>：<ul><li><strong>特点</strong>：基于流的自动化构建工具，使用代码来定义任务</li><li><strong>区别</strong>：Gulp更像是一个任务运行器，适合用来处理文件转换、压缩等任务。与Webpack的模块打包不同，Gulp更灵活，但需要手动配置更多的任务</li></ul></li><li><strong>Browserify</strong>：<ul><li><strong>特点</strong>：将Node.js风格的模块系统带到浏览器端</li><li><strong>区别</strong>：Browserify专注于将CommonJS模块打包到浏览器中，适合于从Node.js迁移到前端的项目。相比Webpack，它的功能更单一，但也更简单</li></ul></li><li><strong>Vite</strong>：<ul><li><strong>特点</strong>：基于ES模块的开发服务器和构建工具，快速启动和热模块替换</li><li><strong>区别</strong>：Vite利用现代浏览器的原生ES模块支持，提供更快的开发体验。相比Webpack，Vite的启动速度更快，适合现代框架如Vue 3和React</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：loader跟plugin的区别是什么"><a href="#Q9：loader跟plugin的区别是什么" class="headerlink" title="Q9：loader跟plugin的区别是什么"></a>Q9：loader跟plugin的区别是什么</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Loader</code></p><p><strong>定义</strong></p><p>Loader 是用于对模块的源代码进行转换的工具</p><p>它们可以在 <code>import</code> 或 <code>require</code> 模块时对模块的内容进行预处理，从而使 Webpack 能够理解和处理非 JavaScript 文件（例如，CSS、图片、字体、TypeScript 等）</p><p><strong>作用</strong></p><ul><li><p><strong>文件转换</strong></p><p>将一种文件类型转换为另一种文件类型</p><p>例如，将 TypeScript 转换为 JavaScript，将 SCSS 转换为 CSS</p></li><li><p><strong>预处理</strong></p><p>在模块被打包之前对其进行预处理</p><p>例如，代码压缩、代码检查（Linting）等</p></li></ul><p><strong>使用方法</strong></p><p>Loader 在 Webpack 配置文件中的 <code>module.rules</code> 字段中进行配置</p><p>每个规则包含一个或多个 loader，用于指定如何处理特定类型的文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">// 匹配 .css 文件</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>], <span class="comment">// 使用 style-loader 和 css-loader</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="comment">// 匹配 .ts 文件</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>, <span class="comment">// 使用 ts-loader</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Plugin</code></p><p><strong>定义</strong></p><p>Plugin 是用于扩展 Webpack 功能的工具</p><p>它们可以在 Webpack 构建过程的不同阶段执行任务，从而实现更复杂的功能</p><p>插件可以访问 Webpack 的整个编译过程，并对其进行干预和扩展</p><p><strong>作用</strong></p><ul><li><strong>打包优化</strong>：优化打包输出，例如代码拆分、压缩、去除重复代码等</li><li><strong>资源管理</strong>：管理和处理静态资源，例如生成 HTML 文件、复制文件、生成清单文件等</li><li><strong>环境变量</strong>：定义环境变量，注入到构建过程中，以便在代码中使用</li></ul><p><strong>使用方法</strong></p><p>Plugin 在 Webpack 配置文件中的 <code>plugins</code> 字段中进行配置</p><p>每个插件通常是一个类的实例，需要通过 <code>new</code> 关键字来创建</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, <span class="comment">// 使用模板生成 HTML 文件</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(), <span class="comment">// 清理输出目录</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>区别</strong></p><ol><li><strong>目的不同</strong>：<ul><li><strong>Loader</strong>：用于转换模块的源代码，使 Webpack 能够理解和处理不同类型的文件</li><li><strong>Plugin</strong>：用于扩展 Webpack 的功能，能够在构建过程的不同阶段执行任务</li></ul></li><li><strong>使用位置不同</strong>：<ul><li><strong>Loader</strong>：配置在 <code>module.rules</code> 中，通过 <code>test</code> 和 <code>use</code> 字段指定</li><li><strong>Plugin</strong>：配置在 <code>plugins</code> 中，通过实例化插件类来使用</li></ul></li><li><strong>处理范围不同</strong>：<ul><li><strong>Loader</strong>：处理单个文件或模块的内容</li><li><strong>Plugin</strong>：可以访问和操作 Webpack 的整个编译过程，具有更广泛的影响力</li></ul></li><li><strong>实现方式不同</strong>：<ul><li><strong>Loader</strong>：通常是一个函数，接受源代码作为输入，返回转换后的代码</li><li><strong>Plugin</strong>：通常是一个类，通过 Webpack 提供的钩子机制进行工作</li></ul></li></ol><p><strong>总结</strong></p><ol><li><strong>Loader</strong>：用于模块的源代码转换，配置在 <code>module.rules</code> 中</li><li><strong>Plugin</strong>：用于扩展 Webpack 功能，配置在 <code>plugins</code> 中</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：webpack编译生命周期"><a href="#Q9：webpack编译生命周期" class="headerlink" title="Q9：webpack编译生命周期"></a>Q9：webpack编译生命周期</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>初始化阶段</p><p>在这个阶段，Webpack 读取配置文件，解析配置项，并初始化各种内部插件和外部插件</p><ul><li><strong>读取配置</strong>：从 <code>webpack.config.js</code> 文件中读取配置</li><li><strong>初始化插件</strong>：实例化配置中定义的插件，并调用插件的 <code>apply</code> 方法，将 Webpack 的 compiler 实例传递给插件</li></ul></li><li><p>编译阶段</p><p>在这个阶段，Webpack 会从入口点开始递归地解析依赖关系，并生成依赖图</p><ul><li><strong>确定入口点</strong>：根据配置找到所有的入口点</li><li><strong>递归解析模块</strong>：从入口点开始，递归解析所有依赖的模块和子模块</li><li><strong>应用 loader</strong>：在解析模块的过程中，应用配置的 loader 对模块进行转换</li><li><strong>生成 AST</strong>：将解析的模块代码转换成抽象语法树（AST）</li></ul></li><li><p>构建阶段</p><p>在这个阶段，Webpack 会根据依赖图生成每个模块的最终代码，并将其打包成一个或多个文件</p><ul><li><strong>生成模块代码</strong>：根据 AST 生成每个模块的最终代码</li><li><strong>打包模块</strong>：根据配置将模块打包成一个或多个文件</li></ul></li><li><p>输出阶段</p><p>在这个阶段，Webpack 会将打包好的文件输出到指定的目录</p><ul><li><strong>写入文件</strong>：将打包好的文件写入到输出目录（通常是 <code>dist</code> 文件夹）</li><li><strong>生成 source map</strong>：如果配置了 source map，会在这个阶段生成对应的 source map 文件</li></ul></li></ol><p><strong>Webpack 编译周期的详细步骤</strong></p><ol><li><strong>环境准备</strong><ul><li>初始化参数：合并 Shell 传入的参数、配置文件中的参数以及默认配置</li><li>加载配置文件：读取并解析 Webpack 配置文件</li></ul></li><li><strong>创建 Compiler 对象</strong><ul><li>初始化 Compiler 对象：根据合并后的参数初始化 Compiler 对象</li><li>加载插件：调用插件的 <code>apply</code> 方法，将 Compiler 对象传递给插件</li></ul></li><li><strong>配置解析</strong><ul><li>确定入口：根据配置找到所有的入口文件</li><li>初始化 Compilation 对象：创建 Compilation 对象，管理模块的编译过程</li></ul></li><li><strong>编译模块</strong><ul><li>从入口文件开始递归解析模块：使用 loader 处理模块，生成 AST</li><li>解析依赖：递归解析模块的依赖，生成依赖图</li><li>生成模块代码：将 AST 转换为最终的模块代码</li></ul></li><li><strong>生成依赖图</strong><ul><li>根据解析的模块和依赖关系生成依赖图。</li><li>优化依赖图：应用各种优化策略，如代码分割、去重等</li></ul></li><li><strong>生成 Chunk</strong><ul><li>根据依赖图生成 Chunk：将模块分组，生成 Chunk</li><li>优化 Chunk：应用各种优化策略，如代码分割、去重等</li></ul></li><li><strong>生成输出文件</strong><ul><li>根据 Chunk 生成输出文件：将 Chunk 转换为最终的输出文件</li><li>生成 source map：如果配置了 source map，会在这个阶段生成对应的 source map 文件</li></ul></li><li><strong>写入文件系统</strong><ul><li>将生成的文件写入输出目录：将打包好的文件写入到配置的输出目录</li></ul></li><li><strong>完成编译</strong><ul><li>触发 done 钩子：通知所有插件编译完成</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：webpack生命周期的钩子"><a href="#Q10：webpack生命周期的钩子" class="headerlink" title="Q10：webpack生命周期的钩子"></a>Q10：webpack生命周期的钩子</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">environment</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;环境配置加载之前&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">afterEnvironment</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;环境配置加载之后&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">entryOption</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">context, entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;入口选项处理之后&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">beforeRun</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compiler, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译器运行之前&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compiler, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译器运行时&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译开始时&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">thisCompilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建 compilation 对象时&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;compilation 对象创建之后&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">make</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;从入口点开始解析依赖时&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">afterCompile</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译完成之后&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生成输出文件之前&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">afterEmit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生成输出文件之后&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">done</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">stats</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译完成时&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">failed</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;编译失败时&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">watchRun</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compiler, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听模式下，编译器运行时&#x27;</span>);</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">watchClose</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听模式下，编译器停止时&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPlugin</span>;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Environment Hooks</code></p><ul><li><p><strong>environment</strong>: 在环境配置加载之前触发</p></li><li><p><strong>afterEnvironment</strong>: 在环境配置加载之后触发</p></li></ul></li><li><p><code>Entry Option Hooks</code></p><ul><li><strong>entryOption</strong>: 在入口选项（entry options）被处理之后触发。通常用于插件初始化</li></ul></li><li><p><code>Initialization Hooks</code></p><ul><li><strong>initialize</strong>: 在 Compiler 初始化时触发</li></ul></li><li><p><code>Before Run Hooks</code></p><ul><li><p><strong>beforeRun</strong>: 在编译器运行之前触发</p></li><li><p><strong>run</strong>: 在编译器运行时触发</p></li></ul></li><li><p><code>Compilation Hooks</code></p><ul><li><p><strong>beforeCompile</strong>: 在编译开始之前触发</p></li><li><p><strong>compile</strong>: 在编译开始时触发</p></li><li><p><strong>thisCompilation</strong>: 在创建 <code>compilation</code> 对象时触发</p></li><li><p><strong>compilation</strong>: 在 <code>compilation</code> 对象创建之后触发</p></li></ul></li><li><p><code>Make Hooks</code></p><ul><li><strong>make</strong>: 在从入口点开始解析依赖时触发</li></ul></li><li><p><code>After Compile Hooks</code></p><ul><li><strong>afterCompile</strong>: 在编译完成之后触发</li></ul></li><li><p><code>Emit Hooks</code></p><ul><li><p><strong>emit</strong>: 在生成输出文件之前触发</p></li><li><p><strong>afterEmit</strong>: 在生成输出文件之后触发</p></li></ul></li><li><p><code>Done Hooks</code></p><ul><li><p><strong>done</strong>: 在编译完成时触发</p></li><li><p><strong>failed</strong>: 在编译失败时触发</p></li></ul></li><li><p><code>Watch Hooks</code></p><ul><li><p><strong>watchRun</strong>: 在监听模式下，编译器运行时触发</p></li><li><p><strong>watchClose</strong>: 在监听模式下，编译器停止时触发</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：webpack-dev-server-的原理"><a href="#Q11：webpack-dev-server-的原理" class="headerlink" title="Q11：webpack-dev-server 的原理"></a>Q11：webpack-dev-server 的原理</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>webpack-dev-server</code> 是一个开发服务器，它与 Webpack 配合使用，为开发者提供实时重新加载、热模块替换（HMR）等功能</p><p>其工作原理主要包括以下几个方面：</p><ol><li><p><strong>静态文件服务</strong></p><p><code>webpack-dev-server</code> 使用 <code>express</code> 或其他类似的 HTTP 服务器来提供静态文件服务</p><p>当你启动 <code>webpack-dev-server</code> 时，它会在内存中编译你的 Webpack 配置，并将编译后的文件存储在内存中，而不是写入磁盘</p><p>这使得文件的读取和写入速度更快，从而提高了开发效率</p></li><li><p><strong>实时重新加载</strong></p><p><code>webpack-dev-server</code> 使用 <code>webpack-dev-middleware</code> 和 <code>webpack-hot-middleware</code> 来实现实时重新加载和热模块替换</p><ul><li><p><strong>webpack-dev-middleware</strong></p><p>该中间件将 Webpack 编译后的文件保存在内存中，并通过 <code>express</code> 提供服务</p><p>它监听文件的变化，当源代码发生变化时，它会重新编译并将新的编译结果提供给客户端</p></li><li><p><strong>webpack-hot-middleware</strong></p><p>该中间件实现了热模块替换（HMR），允许在不刷新整个页面的情况下替换、添加或删除模块</p><p>它通过 WebSocket 与客户端进行通信，当检测到代码变化时，发送更新信息给客户端</p></li></ul></li><li><p><strong>热模块替换（HMR）</strong></p><p>HMR 是 <code>webpack-dev-server</code> 的核心功能之一</p><p>它使得在不刷新整个页面的情况下，动态地替换、添加或删除模块。HMR 的工作流程如下：</p><ol><li><strong>编译和打包</strong>: Webpack 编译源代码，并生成模块的哈希值</li><li><strong>监听文件变化</strong>: <code>webpack-dev-server</code> 监听文件变化，当检测到变化时，重新编译受影响的模块。</li><li><strong>通知客户端</strong>: 通过 WebSocket 连接，服务器将更新信息发送给客户端</li><li><strong>更新模块</strong>: 客户端接收到更新信息后，通过 HMR API 更新模块。对于 JavaScript 模块，HMR 会调用模块的 <code>accept</code> 方法，替换旧的模块。如果是 CSS 模块，HMR 会直接替换样式表</li></ol></li><li><p><strong>代理请求</strong></p><p><code>webpack-dev-server</code> 可以配置代理，将特定请求转发到其他服务器</p><p>这在开发环境中非常有用，特别是当前端和后端分离时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>设置和配置</strong></p><p><code>webpack-dev-server</code> 提供了多种配置选项，可以通过 Webpack 配置文件或命令行参数进行设置</p><p>例如，可以设置开发服务器的端口、启用 HTTPS、配置静态文件目录等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>),</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>中间件和插件</strong></p><p><code>webpack-dev-server</code> 还支持使用中间件和插件来扩展其功能</p><p>例如，可以使用 <code>connect-history-api-fallback</code> 中间件来支持 HTML5 历史 API 路由</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> history = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">before</span>: <span class="keyword">function</span>(<span class="params">app, server</span>) &#123;</span><br><span class="line">      app.<span class="title function_">use</span>(<span class="title function_">history</span>());</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p><code>webpack-dev-server</code> 通过内存编译、实时重新加载、热模块替换、代理请求等机制，极大地提升了开发体验和效率</p><p>它的核心原理在于利用 Webpack 的编译能力和中间件机制，提供一个高效、灵活的开发服务器环境</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：webpack的module、bundle和chunk分别指什么"><a href="#Q12：webpack的module、bundle和chunk分别指什么" class="headerlink" title="Q12：webpack的module、bundle和chunk分别指什么"></a>Q12：webpack的module、bundle和chunk分别指什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 Webpack 中，<code>module</code>、<code>bundle</code> 和 <code>chunk</code> 是三个核心概念</p><p>它们在 Webpack 的打包和构建过程中扮演着不同的角色</p><p>以下是对它们的详细解释：</p><ol><li><p>Module（模块）</p><p><strong>模块</strong>是 Webpack 的基本构建单元</p><p>每个文件（JavaScript、CSS、图片等）都可以被视为一个模块</p><p>Webpack 使用各种加载器（loaders）来处理不同类型的文件，并将它们转换为 JavaScript 模块</p><ul><li><strong>JavaScript 模块</strong>：通过 <code>import</code> 或 <code>require</code> 引入的文件</li><li><strong>CSS 模块</strong>：通过 <code>css-loader</code> 和 <code>style-loader</code> 处理的 CSS 文件</li><li><strong>其他资源</strong>：如图片、字体等，通过相应的加载器处理后也会被视为模块</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// example.js</span><br><span class="line">import &#x27;./style.css&#x27;;</span><br><span class="line">import image from &#x27;./image.png&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Hello, Webpack!&#x27;);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>example.js</code>、<code>style.css</code> 和 <code>image.png</code> 都是模块</p></li><li><p>Bundle（包）</p><p><strong>包</strong>是 Webpack 打包后的输出文件</p><p>它包含了应用程序的所有模块以及 Webpack 运行时代码</p><p>通常，一个 Webpack 配置会生成一个或多个包</p><ul><li><strong>单入口点</strong>：一个入口点会生成一个包</li><li><strong>多入口点</strong>：多个入口点会生成多个包</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个配置中，Webpack 会将所有依赖的模块打包到 <code>bundle.js</code> 中</p></li><li><p>Chunk（块）</p><p><strong>块</strong>是 Webpack 在构建过程中的中间产物</p><p>一个块可以包含一个或多个模块</p><p>块的概念主要用于代码分割（Code Splitting）和按需加载（Lazy Loading）</p><p>Webpack 会根据配置和依赖关系生成多个块，并将它们打包到最终的包中</p><ul><li><strong>入口块</strong>：由入口点生成的块</li><li><strong>异步块</strong>：通过动态导入（<code>import()</code>）或 <code>require.ensure</code> 生成的块</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import(&#x27;./moduleA&#x27;).then(module =&gt; &#123;</span><br><span class="line">  module.default();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].bundle.js&#x27;,</span><br><span class="line">    chunkFilename: &#x27;[name].chunk.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>index.js</code> 是入口块，而 <code>moduleA</code> 是异步块</p><p>最终会生成两个文件：<code>main.bundle.js</code> 和 <code>moduleA.chunk.js</code></p></li></ol><p><strong>总结</strong></p><ul><li><strong>Module（模块）</strong>：Web 应用程序中的独立文件，如 JavaScript、CSS、图片等</li><li><strong>Bundle（包）</strong>：Webpack 打包后的输出文件，包含所有模块和运行时代码</li><li><strong>Chunk（块）</strong>：Webpack 在构建过程中生成的中间产物，用于代码分割和按需加载</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：什么是CI-CD"><a href="#Q13：什么是CI-CD" class="headerlink" title="Q13：什么是CI/CD"></a>Q13：什么是CI/CD</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CI/CD 是软件开发中的一种实践和方法论，旨在提高软件开发和交付的效率、质量和可靠性</p><p>CI/CD 分为两个主要部分：</p><ol><li>持续集成（Continuous Integration，CI）</li><li>持续交付/部署（Continuous Delivery/Deployment，CD）</li></ol><p>以下是对这两个部分的详细解释：</p><ol><li><p>持续集成（CI）</p><p><strong>持续集成</strong>是一种软件开发实践，开发人员频繁地将代码更改集成到共享代码库中</p><p>每次集成后，自动化构建和测试过程都会运行，以便尽早发现和解决问题</p><ul><li><strong>频繁提交代码</strong>：开发人员频繁地将代码提交到版本控制系统（如 Git）</li><li><strong>自动化构建</strong>：每次提交代码后，CI 服务器会自动拉取代码并进行构建</li><li><strong>自动化测试</strong>：在构建过程中，自动运行单元测试、集成测试等，以确保代码的正确性和质量</li><li><strong>快速反馈</strong>：开发人员可以快速得到构建和测试的结果，及时修复问题</li></ul><p>常见的 CI 工具有 Jenkins、Travis CI、CircleCI、GitLab CI 等</p></li><li><p>持续交付（CD）和持续部署（CD）</p><p><strong>持续交付</strong>和<strong>持续部署</strong>是持续集成的延续，进一步自动化了软件的发布过程</p><ul><li><p>持续交付（Continuous Delivery）</p><p>持续交付的目标是使代码在任何时候都可以安全地发布到生产环境</p><p>虽然发布过程是自动化的，但最终的发布决策通常是手动的</p><ul><li><strong>自动化部署</strong>：代码通过持续集成后，会自动部署到测试环境或预生产环境中</li><li><strong>发布准备</strong>：确保每个版本都经过充分测试，并且可以随时发布到生产环境</li><li><strong>手动发布</strong>：最终将代码发布到生产环境的决策是手动的，通常由开发团队或运维团队决定</li></ul></li><li><p>持续部署（Continuous Deployment）</p><p>持续部署是持续交付的进一步扩展，目标是每次通过自动化测试的代码更改都会自动发布到生产环境中</p><ul><li><strong>完全自动化</strong>：从代码提交到发布到生产环境的整个过程都是自动化的</li><li><strong>快速发布</strong>：每次代码更改都会尽快发布到生产环境，使新功能和修复能够迅速交付给用户</li><li><strong>高可靠性</strong>：要求高水平的自动化测试和监控，以确保每次发布都是安全和可靠的</li></ul></li></ul></li></ol><p><strong>CI/CD 的好处</strong></p><ul><li><strong>提高开发效率</strong>：自动化构建、测试和部署过程，减少人为干预</li><li><strong>提高代码质量</strong>：频繁集成和测试，及时发现和修复问题</li><li><strong>快速交付</strong>：缩短从代码提交到发布的时间，使新功能和修复能够更快地交付给用户</li><li><strong>降低风险</strong>：自动化测试和构建过程，减少发布过程中的人为错误和风险</li></ul><p><strong>总结</strong></p><ul><li><strong>持续集成（CI）</strong>：频繁集成代码，自动化构建和测试，快速反馈和修复问题</li><li><strong>持续交付（CD）</strong>：自动化部署到测试或预生产环境，手动决策发布到生产环境</li><li><strong>持续部署（CD）</strong>：完全自动化，从代码提交到发布到生产环境，确保每次代码更改都能快速、安全地交付</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：什么是SSG"><a href="#Q14：什么是SSG" class="headerlink" title="Q14：什么是SSG"></a>Q14：什么是SSG</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>SSG（Static Site Generation，静态网站生成）是指在构建时预先生成静态页面，并将这些页面部署到 CDN 或者其他存储服务中，以提升 Web 应用的性能和用户体验</p><p>具体来说，SSG 的实现方式通常包括以下几个步骤：</p><ol><li>在开发阶段，使用模板引擎等技术创建静态页面模板</li><li>将需要展示的数据从后台 API 中获取或者通过其他渠道获取，并将其填充到静态页面模板中，生成完整的 HTML 页面</li><li>使用构建工具（例如 Gatsby、Next.js 等）对静态页面进行构建，生成静态 HTML、CSS 和 JavaScript 文件</li><li>部署生成好的静态文件到服务器或者 CDN 上，以供用户访问</li></ol><p>相比于传统的动态网页，SSG 具有如下优势：</p><ol><li>加载速度快：由于不需要每次请求都动态地渲染页面，SSG 可以减少页面加载时间，从而提高用户体验和搜索引擎排名</li><li>安全性高：由于没有后台代码和数据库，SSG 不容易受到 SQL 注入等攻击</li><li>成本低：由于不需要动态服务器等设备，SSG 可以降低网站的运维成本和服务器负担</li></ol><p>需要注意的是，SSG 不适用于频繁更新的内容和动态交互等场景，但对于内容较为稳定和更新较少的网站则是一个性能优化的好选择</p>
              </div>
            </details>
<p><br/></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h3 id="Q1：Babel-是什么？"><a href="#Q1：Babel-是什么？" class="headerlink" title="Q1：Babel 是什么？"></a>Q1：Babel 是什么？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Babel 是一个流行的 JavaScript 编译器，用于将 ECMAScript 2015+（ES6+）或者其他较新版本的 JavaScript 代码转换成向后兼容的 JavaScript 代码，以便在当前和旧版本的浏览器或者环境中运行</p><p>Babel 可以帮助开发者在使用最新的 JavaScript 特性的同时，确保其代码在各种环境中的兼容性</p><p>主要功能和特点包括：</p><ol><li><strong>转换新特性</strong>：Babel 可以将 ECMAScript 2015+（ES6+）及其以上版本的代码转换成 ES5 或者其他较旧版本的 JavaScript 代码。这包括箭头函数、解构赋值、模板字符串、类、模块等等。</li><li><strong>插件系统</strong>：Babel 使用插件来实现不同的转换功能。它提供了大量的插件，开发者可以根据自己的需要选择并配置所需的插件。此外，Babel 还支持自定义插件，使得开发者可以根据特定需求定制转换规则。</li><li><strong>集成工具链</strong>：Babel 可以与各种构建工具和框架（如Webpack、Rollup、Gulp等）无缝集成，使得开发者可以方便地将其包含在自己的项目中，构建出符合需求的 JavaScript 代码。</li><li><strong>源映射支持</strong>：Babel 支持生成源映射（Source Maps），可以方便地在调试时将转换后的代码映射回原始源代码，提高了调试的效率。</li><li><strong>支持 JSX 转换</strong>：Babel 还支持将 JSX（JavaScript XML）语法转换成普通的 JavaScript 代码，使得开发者可以在不同的环境中使用 React 或者其他支持 JSX 的库。</li></ol><p>总的来说，Babel 是一个非常强大的 JavaScript 编译器，可以帮助开发者轻松地使用和转换最新的 JavaScript 特性，并确保其代码在各种环境中的兼容性和稳定性。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：webpack-proxy工作原理是什么-为什么能解决跨域"><a href="#Q2：webpack-proxy工作原理是什么-为什么能解决跨域" class="headerlink" title="Q2：webpack proxy工作原理是什么?为什么能解决跨域?"></a>Q2：webpack proxy工作原理是什么?为什么能解决跨域?</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Webpack 的代理（proxy）功能通常通过 <code>devServer.proxy</code> 选项来配置，它主要用于在开发环境中解决跨域请求问题</p><p>以下是它的工作原理和为什么能解决跨域问题的解释：</p><p><strong>工作原理</strong></p><ol><li><p><strong>开发服务器</strong>：</p><ul><li>Webpack DevServer 是一个小型的 Node.js 服务器，主要用于开发环境</li><li>当你启动 Webpack DevServer 时，它会在本地运行一个服务器，默认情况下监听 <code>localhost</code> 和指定的端口（例如 <code>localhost:8080</code>）</li></ul></li><li><p><strong>代理配置</strong>：</p><ul><li><p>在 <code>webpack.config.js</code> 文件中，通过 <code>devServer.proxy</code> 选项配置代理规则</p></li><li><p>代理规则定义了哪些请求需要被转发到其他服务器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他配置项</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://backend.server.com&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>请求转发：</p><ul><li><p>当浏览器向 Webpack DevServer 发起请求时，DevServer 根据代理配置检查请求路径</p></li><li><p>如果请求路径匹配代理规则，DevServer 会将该请求转发到目标服务器（<code>target</code>）</p></li><li><p>例如，上述配置中，所有以 <code>/api</code> 开头的请求都会被转发到 <code>http://backend.server.com</code></p></li></ul></li></ol><p><strong>为什么能解决跨域问题</strong></p><p>跨域请求问题通常是由于浏览器的同源策略（Same-Origin Policy）引起的，这种策略限制了从一个源（协议、域名、端口）加载的网页对另一个源的资源进行请求</p><p>Webpack DevServer 的代理功能通过以下方式解决了跨域问题：</p><ol><li><strong>同源请求</strong>：<ul><li>浏览器向 Webpack DevServer 发起请求时，源是相同的（例如 <code>localhost:8080</code>），因此不会触发跨域限制</li></ul></li><li><strong>服务器端代理</strong>：<ul><li>Webpack DevServer 作为一个中间代理，将请求转发到目标服务器（例如 <code>http://backend.server.com</code>）</li><li>由于这是服务器到服务器的请求，不受浏览器的同源策略限制</li></ul></li><li><strong>响应转发</strong>：<ul><li>目标服务器的响应会被 Webpack DevServer 接收，然后再转发回浏览器</li><li>对于浏览器来说，响应仍然来自同一源（<code>localhost:8080</code>），因此不会触发跨域问题</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：webpack-热更新工作原理是什么？实现原理是什么？怎么做到的"><a href="#Q3：webpack-热更新工作原理是什么？实现原理是什么？怎么做到的" class="headerlink" title="Q3：webpack 热更新工作原理是什么？实现原理是什么？怎么做到的"></a>Q3：webpack 热更新工作原理是什么？实现原理是什么？怎么做到的</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p><p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p><p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p><p><strong>工作原理</strong></p><ol><li><strong>监视文件变化</strong>：<ul><li>Webpack 在编译过程中会监视项目中的文件变化</li><li>当文件发生变化时，Webpack 会重新编译受影响的模块</li></ul></li><li><strong>通知客户端</strong>：<ul><li>Webpack DevServer 使用 WebSocket 与客户端（浏览器）通信</li><li>当文件变化时，DevServer 会通过 WebSocket 向客户端发送更新通知</li></ul></li><li><strong>获取更新</strong>：<ul><li>客户端接收到更新通知后，会向 DevServer 请求更新的模块</li><li>DevServer 会返回更新后的模块代码和更新信息</li></ul></li><li><strong>替换模块</strong>：<ul><li>客户端使用更新后的模块代码替换应用程序中的旧模块</li><li>如果模块实现了 HMR 接口（例如，通过 <code>module.hot.accept</code>），它可以进行自定义的更新处理</li></ul></li></ol><p><strong>实现原理</strong></p><p><img src="https://s2.loli.net/2024/05/23/YvBHrc1SGIFLxky.png" alt="image-20240523120406167"></p><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>上面图中，可以分成两个阶段：</p><ul><li>启动阶段为上图 1 - 2 - A - B</li></ul><p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle</code>文件，传输给<code>Bundle Server</code> 静态资源服务器</p><ul><li>更新阶段为上图 1 - 2 - 3 - 4</li></ul><p>当某一个文件或者模块发生变化时，<code>webpack</code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash</code>值用来作为下一次热更新的标识</p><p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId</code>，用来说明变化的内容）和<code>chunk.js</code> 模块</p><p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p><p>在浏览器接受到这条消息之前，浏览器已经在上一次<code>socket</code> 消息中已经记住了此时的<code>hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p><p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p><p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p><p><strong>关于<code>webpack</code>热模块更新的总结如下</strong>：</p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：怎么编写loader跟plugin"><a href="#Q4：怎么编写loader跟plugin" class="headerlink" title="Q4：怎么编写loader跟plugin"></a>Q4：怎么编写loader跟plugin</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>编写自定义Loader</p><p>一个 Webpack loader 是一个导出为函数的 JavaScript 模块</p><p>这个函数会在 Webpack 处理模块时被调用，并接受模块的源代码作为参数</p><p>它需要返回处理后的代码</p><p><strong>示例：编写一个将所有字母转换为大写的 loader</strong></p><ol><li><p><strong>创建 loader 文件</strong></p><p>创建一个名为 <code>uppercase-loader.js</code> 的文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">// `source` 是模块的源代码</span></span><br><span class="line">  <span class="keyword">const</span> transformedSource = source.<span class="title function_">toUpperCase</span>(); <span class="comment">// 将源代码中的所有字母转换为大写</span></span><br><span class="line">  <span class="keyword">return</span> transformedSource;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置 Webpack 使用自定义 loader</strong></p><p>在 <code>webpack.config.js</code> 中配置使用这个自定义 loader：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="comment">// 匹配所有 .txt 文件</span></span><br><span class="line">        <span class="attr">use</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;uppercase-loader.js&#x27;</span>), <span class="comment">// 使用自定义 loader</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>高级功能</strong></p><p>如果你需要更复杂的功能，loader 还可以使用 Webpack 提供的一些实用工具，比如 <code>this.cacheable</code>、<code>this.async</code> 等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cacheable</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">cacheable</span>(); <span class="comment">// 标记结果是可缓存的</span></span><br><span class="line">  <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>(); <span class="comment">// 获取异步回调函数</span></span><br><span class="line">  <span class="comment">// 模拟异步处理</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transformedSource = source.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, transformedSource);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>编写自定义Plugin</p><p><strong>Plugin 基本结构</strong></p><p>一个 Webpack plugin 是一个包含 <code>apply</code> 方法的 JavaScript 类</p><p>这个 <code>apply</code> 方法在 Webpack 构建过程中会被调用，并传入一个 <code>compiler</code> 对象</p><p>你可以使用 <code>compiler</code> 对象提供的各种钩子来执行特定的操作</p><p><strong>示例：编写一个在构建开始时打印消息的 plugin</strong></p><ol><li><p><strong>创建 plugin 文件</strong></p><p>创建一个名为 <code>MyPlugin.js</code> 的文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 Webpack 提供的钩子</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">compile</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The webpack build process is starting!!!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPlugin</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置 Webpack 使用自定义 plugin</strong></p><p>在 <code>webpack.config.js</code> 中配置使用这个自定义 plugin：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;./MyPlugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyPlugin</span>(), <span class="comment">// 使用自定义插件</span></span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>高级功能</strong></p><p>你可以使用 Webpack 提供的各种钩子来执行更复杂的操作</p><p>例如，你可以在 <code>emit</code> 阶段修改输出文件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 修改输出的文件内容</span></span><br><span class="line">      compilation.<span class="property">assets</span>[<span class="string">&#x27;output.txt&#x27;</span>] = &#123;</span><br><span class="line">        <span class="attr">source</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;This is the new content!&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">size</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">source</span>().<span class="property">length</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPlugin</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ol><li><p><strong>Loader</strong></p><p>是一个函数，接受源代码作为输入，返回转换后的代码</p><p>可以在 <code>module.rules</code> 中配置</p><p>Loader 可以是同步的也可以是异步的</p></li><li><p><strong>Plugin</strong></p><p>是一个类，需要包含一个 <code>apply</code> 方法，通过 Webpack 提供的钩子机制进行工作</p><p>可以在 <code>plugins</code> 中配置</p><p>Plugin 可以在 Webpack 构建的不同阶段执行各种操作</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：webpack5常使用的plugin有哪些"><a href="#Q5：webpack5常使用的plugin有哪些" class="headerlink" title="Q5：webpack5常使用的plugin有哪些"></a>Q5：webpack5常使用的plugin有哪些</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>内置插件</strong></p><ol><li><p><strong>DefinePlugin</strong></p><ul><li><p><strong>作用</strong>：定义全局常量，可以在代码中使用这些常量替换相应的值</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="string">&#x27;production&#x27;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>HotModuleReplacementPlugin</strong></p><ul><li><p><strong>作用</strong>：启用模块热替换（HMR），在应用程序运行时替换、添加或删除模块，而无需重新加载整个页面</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>HtmlWebpackPlugin</strong></p><ul><li><p><strong>作用</strong>：简化 HTML 文件的创建，自动注入生成的 JavaScript 和 CSS 文件</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>MiniCssExtractPlugin</strong></p><ul><li><p><strong>作用</strong>：将 CSS 提取到独立的文件中，而不是嵌入到 JavaScript 中</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;[name].css&#x27;</span>,</span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&#x27;[id].css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>CleanWebpackPlugin</strong></p><ul><li><p><strong>作用</strong>：在每次构建之前清理输出目录（如 <code>dist</code> 文件夹）</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>第三方插件</strong></p><ol><li><p><strong>CopyWebpackPlugin</strong></p><ul><li><p><strong>作用</strong>：将文件或文件夹从一个地方复制到构建目录</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="string">&#x27;source&#x27;</span>, <span class="attr">to</span>: <span class="string">&#x27;dest&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="string">&#x27;other&#x27;</span>, <span class="attr">to</span>: <span class="string">&#x27;public&#x27;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>CompressionWebpackPlugin</strong></p><ul><li><p><strong>作用</strong>：使用 gzip 或 Brotli 压缩生成的文件，以减少文件大小</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$|\.css$|\.html$/</span>,</span><br><span class="line">      <span class="attr">threshold</span>: <span class="number">10240</span>,</span><br><span class="line">      <span class="attr">minRatio</span>: <span class="number">0.8</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>BundleAnalyzerPlugin</strong></p><ul><li><p><strong>作用</strong>：可视化 Webpack 输出文件的大小，帮助你优化构建</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>TerserWebpackPlugin</strong></p><ul><li><p><strong>作用</strong>：使用 Terser 压缩和混淆 JavaScript 代码</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserWebpackPlugin</span>()],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>WebpackManifestPlugin</strong></p><ul><li><p><strong>作用</strong>：生成一个 manifest 文件，映射源文件到输出文件</p></li><li><p>示例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">WebpackManifestPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-manifest-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">WebpackManifestPlugin</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：webpack5常使用的loader有哪些"><a href="#Q6：webpack5常使用的loader有哪些" class="headerlink" title="Q6：webpack5常使用的loader有哪些"></a>Q6：webpack5常使用的loader有哪些</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>babel-loader</strong>:</p><p>主要用于将现代 JavaScript（ES6+）代码转换为向后兼容的 JavaScript（ES5），以确保在旧浏览器中运行</p></li><li><p><strong>ts-loader</strong>:</p><p>用于将 TypeScript 编译为 JavaScript</p></li><li><p><strong>css-loader</strong>:</p><p>允许你在 JavaScript 中 <code>import</code> CSS 文件，并解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code> 语法</p></li><li><p><strong>style-loader</strong>:</p><p>将 CSS 插入到 DOM 中的 <code>&lt;style&gt;</code> 标签中</p></li><li><p><strong>sass-loader</strong>:</p><p>将 SCSS/SASS 文件编译为 CSS</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：webpack解决了什么问题"><a href="#Q7：webpack解决了什么问题" class="headerlink" title="Q7：webpack解决了什么问题"></a>Q7：webpack解决了什么问题</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>模块化开发</strong></p><ul><li><p><strong>问题</strong>: 在没有模块化工具的情况下，管理和组织大量的 JavaScript 文件变得非常困难，特别是在大型项目中</p></li><li><p><strong>解决方案</strong>: Webpack 支持各种模块化标准（例如 ES6 模块、CommonJS、AMD），允许开发者将代码拆分成小的、可重用的模块</p></li></ul></li><li><p><strong>依赖管理</strong></p><ul><li><p><strong>问题</strong>: 手动管理依赖关系非常繁琐，容易出错</p></li><li><p><strong>解决方案</strong>: Webpack 自动解析模块之间的依赖关系，生成一个依赖图，从而确保所有依赖项都能正确加载</p></li></ul></li><li><p><strong>资源打包</strong></p><ul><li><p><strong>问题</strong>: 在现代前端开发中，不仅仅是 JavaScript，CSS、图片、字体等资源也需要打包和优化</p></li><li><p><strong>解决方案</strong>: Webpack 提供了各种 loader 和插件，可以处理不同类型的资源文件（如 CSS、SCSS、图片、字体等），并将它们打包到一起</p></li></ul></li><li><p><strong>代码拆分</strong></p><ul><li><p><strong>问题</strong>: 单个大的 JavaScript 文件会导致页面加载速度慢，影响用户体验</p></li><li><p><strong>解决方案</strong>: Webpack 支持代码拆分（Code Splitting），允许将代码拆分成多个小块，以便按需加载，提高页面加载速度和性能</p></li></ul></li><li><p><strong>开发体验</strong></p><ul><li><p><strong>问题</strong>: 传统的开发流程缺乏实时反馈，调试和测试不便</p></li><li><p><strong>解决方案</strong>: Webpack Dev Server 提供了热模块替换（Hot Module Replacement, HMR）功能，可以在代码修改后实时更新浏览器中的内容，而不需要手动刷新页面</p></li></ul></li><li><p><strong>优化和压缩</strong></p><ul><li><p><strong>问题</strong>: 未优化的代码会导致较大的文件体积，影响性能</p></li><li><p><strong>解决方案</strong>: Webpack 提供了多种优化插件，可以对代码进行压缩、去除无用代码（Tree Shaking）、代码分割等优化操作，减少文件体积，提高加载速度</p></li></ul></li><li><p><strong>跨平台兼容</strong></p><ul><li><p><strong>问题</strong>: 不同浏览器和平台之间的兼容性问题</p></li><li><p><strong>解决方案</strong>: 通过使用 Babel 等工具，Webpack 可以将现代 JavaScript 代码转换为向后兼容的代码，确保在不同浏览器和平台上的兼容性</p></li></ul></li></ol><p>总的来说，Webpack 通过模块化、依赖管理、资源打包、代码拆分、优化和提升开发体验等多个方面，极大地简化了现代前端开发流程，提高了开发效率和代码质量</p>
              </div>
            </details>
<p><br/></p>
<h1 id="流程策略"><a href="#流程策略" class="headerlink" title="流程策略"></a>流程策略</h1><h3 id="Q1：sourcemap的原理是什么"><a href="#Q1：sourcemap的原理是什么" class="headerlink" title="Q1：sourcemap的原理是什么"></a>Q1：sourcemap的原理是什么</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Source Map 是一个信息文件，它包含一些映射信息，使得调试工具在调试以源码进行编译、打包、压缩、混淆等操作后的代码时，依然能够像调试源码一样进行调试</p><p>例如，当我们使用Babel或者TypeScript这样的编译器把ES6或者TypeScript代码编译为ES5代码后，或者使用Webpack等工具对代码进行打包压缩后，代码的结构和内容都会大幅度地改变，这时候如果没有Source Map，调试工具（例如Chrome的开发者工具）只能展示编译/打包/压缩后的代码，这会大大降低我们的调试效率</p><p>而如果有了Source Map，即使代码被修改过，我们依然能找到代码执行时对应的原始源码位置</p><p><strong>实现原理</strong></p><p>创建Source Map的过程，可以理解为将编译、打包、压缩后的代码，重新逆向映射回源码的过程</p><ol><li><p>首先，我们会有一个源代码（Source）的文件，例如<code>index.js</code></p></li><li><p>在编译、打包、压缩后，我们会得到一个经过处理的代码文件，例如<code>index.min.js</code></p></li><li><p>然后，在生成<code>index.min.js</code>的同时，编译/打包/压缩工具（Babel/Webpack/UglifyJS等）也会创建一个Source Map文件，例如<code>index.min.js.map</code></p><p>这个Source Map文件中，记录了<code>index.min.js</code>中的每一个位置，对应<code>index.js</code>中的什么位置</p></li><li><p>当我们使用调试工具打开<code>index.min.js</code>并进行调试时，调试工具会自动读取<code>index.min.js.map</code>，找到对应的源代码位置，并展示在我们的调试界面上</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如果线上除了事故级别的问题，大批量的用户不能提交了，如何去处理"><a href="#Q2：如果线上除了事故级别的问题，大批量的用户不能提交了，如何去处理" class="headerlink" title="Q2：如果线上除了事故级别的问题，大批量的用户不能提交了，如何去处理"></a>Q2：如果线上除了事故级别的问题，大批量的用户不能提交了，如何去处理</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>处理线上大批量用户提交失败的问题需要一个结构化的方法来快速定位并解决问题，同时确保用户的影响最小化</p><p>以下是解决这类问题的一般步骤：</p><ol><li><p><strong>紧急响应机制启动</strong></p><ul><li>立即启动紧急响应队伍，确保所有相关团队成员（如开发、运维、客服）都在通知范围内并准备好响应</li><li>在必要时，启用服务的维护状态或错误页面，通知用户正在处理问题</li></ul></li><li><p><strong>问题定位</strong></p><ul><li><p>检查监控系统和报警，快速定位问题的范围和可能性区域</p><p>重点检查新近部署的代码更改、第三方服务、数据库性能、网络问题或服务器负载</p></li><li><p>查看日志文件和错误报告，尝试找到问题模式或特定的错误信息</p></li><li><p>如果可能，尝试与用户沟通以收集更多问题描述和现象</p></li></ul></li><li><p><strong>快速修复或回滚</strong></p><ul><li><p>根据问题的性质，决定是立即修复还是回滚到稳定的版本</p><p>在决策时要权衡变更的风险和影响</p></li><li><p>如果采取回滚，请确保理解回滚的影响，尤其是对于数据一致性的影响</p></li></ul></li><li><p><strong>沟通更新</strong></p><ul><li><p>定期向内部团队和用户更新进展情况，即使是告诉大家目前还在调查中也好</p><p>避免让用户感到被忽略</p></li><li><p>如果有客户支持团队，确保他们了解情况和沟通策略，可以正确且一致地响应用户询问</p></li></ul></li><li><p><strong>问题解决</strong></p><ul><li>一旦问题被修复，确保全面测试并监控服务恢复情况</li><li>逐步放开流量，观察系统表现，确认问题彻底解决</li></ul></li><li><p><strong>事后复盘</strong></p><ul><li>事故结束后，组织一个事故复盘会议，包括所有参与解决问题的成员</li><li>详细记录事故发生的原因、解决过程、采取的措施和未来预防此类问题的改进措施</li><li>改进监控、报警、部署流程等，以减少未来此类事件的发生</li></ul></li><li><p><em>*对外沟通</em></p><ul><li>根据情况，可能需要对外发布事故报告，包括事故原因、影响、解决措施和预防措施</li></ul></li></ol><p>整个过程中，保持冷静、迅速响应、清晰沟通是非常关键的</p><p>对用户展示出你们正认真对待问题，并采取一切必要措施以尽快解决，这对维护用户信任和品牌声誉至关重要</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：webpack优化前端性能的手段有哪些"><a href="#Q3：webpack优化前端性能的手段有哪些" class="headerlink" title="Q3：webpack优化前端性能的手段有哪些"></a>Q3：webpack优化前端性能的手段有哪些</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>代码分割（Code Splitting）</strong></p><ul><li><p><strong>动态导入</strong>：使用 <code>import()</code> 语法进行动态导入，按需加载模块</p></li><li><p><strong>多入口文件</strong>：配置多个入口文件，生成多个 bundle</p></li><li><p><strong>分离第三方库</strong>：使用 <code>SplitChunksPlugin</code> 将第三方库和应用代码分离</p></li></ul></li><li><p><strong>Tree Shaking</strong></p><ul><li><p><strong>描述</strong>：移除未使用的代码</p></li><li><p><strong>实现</strong>：确保使用 ES6 模块语法（<code>import</code> 和 <code>export</code>），Webpack 会自动进行 tree shaking</p></li></ul></li><li><p><strong>代码压缩（Minification）</strong></p><ul><li><p><strong>TerserPlugin</strong>：使用 Terser 插件来压缩 JavaScript 代码</p></li><li><p><strong>CSS Minification</strong>：使用 <code>css-minimizer-webpack-plugin</code> 来压缩 CSS 代码</p></li></ul></li><li><p><strong>缓存（Caching）</strong></p><ul><li><p><strong>内容哈希</strong>：使用 <code>contenthash</code> 生成文件名，这样当文件内容改变时，文件名也会改变，从而实现缓存</p></li><li><p><strong>持久化缓存</strong>：启用 Webpack 5 的持久化缓存功能，减少重新构建时间</p></li></ul></li><li><p><strong>预加载和预获取（Preloading and Prefetching）</strong></p><ul><li><p><strong>Preload</strong>：使用 <code>webpackPreload</code> 指令，告诉浏览器尽早加载某些资源</p></li><li><p><strong>Prefetch</strong>：使用 <code>webpackPrefetch</code> 指令，告诉浏览器在空闲时间加载资源</p></li></ul></li><li><p><strong>图片优化</strong></p><ul><li><p><strong>Image Compression</strong>：使用 <code>image-webpack-loader</code> 等插件压缩图片资源</p></li><li><p><strong>Lazy Loading</strong>：使用 <code>loading=&quot;lazy&quot;</code> 属性实现图片懒加载</p></li></ul></li><li><p><strong>使用更快的解析和打包工具</strong></p><ul><li><p><strong>Thread-loader</strong>：使用 <code>thread-loader</code> 在多线程环境中处理繁重的任务</p></li><li><p><strong>缓存加载器</strong>：使用 <code>cache-loader</code> 缓存编译结果，提升二次构建速度</p></li></ul></li><li><p><strong>减少编译范围</strong></p><ul><li><p><strong>Include/Exclude</strong>：在 loader 配置中使用 <code>include</code> 和 <code>exclude</code> 选项，限制处理文件的范围</p></li><li><p><strong>Resolve Aliases</strong>：使用 <code>resolve.alias</code> 配置简化模块路径解析</p></li></ul></li><li><p><strong>Bundle 分析</strong></p><ul><li><strong>Webpack Bundle Analyzer</strong>：使用 <code>webpack-bundle-analyzer</code> 插件生成包大小报告，识别和优化过大的模块</li></ul></li><li><p><strong>DLLPlugin</strong></p><ul><li><p><strong>描述</strong>：预编译特定的第三方库，减少每次构建时的打包时间</p></li><li><p><strong>实现</strong>：使用 <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 配置</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：Vite-和-Webpack-的区别"><a href="#Q4：Vite-和-Webpack-的区别" class="headerlink" title="Q4：Vite 和 Webpack 的区别"></a>Q4：Vite 和 Webpack 的区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Vite 和 Webpack 都是前端打包工具，它们的作用类似，但实现方式和使用方法有所不同</p><p>以下是它们之间的一些区别：</p><ol><li><p><strong>构建速度</strong></p><p>Vite 的构建速度比 Webpack 更快</p><p>因为 Vite 在开发环境下使用了浏览器原生的 ES 模块加载</p><p>而不是像 Webpack 一样使用打包后的文件进行模块加载</p><p>在 Vite 中，每个模块都可以独立地进行编译和缓存，这意味着它只需要重新编译修改过的模块，而不是整个应用程序</p><p>这使得 Vite 开发起来更加高效</p></li><li><p><strong>配置复杂度</strong></p><p>Vite 的配置相对更简单，因为它无需进行大量的配置，只需指定一些基本的选项就可以开始开发</p><p>Webpack 的配置更加复杂，需要针对具体项目进行不同的配置，且需要理解各种插件、Loader 等概念</p></li><li><p><strong>生态环境</strong></p><p>Webpack 的生态环境更加成熟，在社区中拥有广泛的支持和丰富的插件库。而 Vite 尚处于发展阶段，尽管其已经获得了很多关注，但其生态系统仍然不太完善。</p></li><li><p><strong>功能特性</strong></p><p>Webpack 是一个功能更加全面的打包工具</p><p>支持各种 Loader 和插件，可以处理多种类型的文件和资源</p><p>而 Vite 的设计初衷是专注于开发环境下的快速构建，因此其对一些高级特性的支持相对较少</p></li></ol><p>综上所述，Vite 更适合用于开发环境下的快速构建，而 Webpack 则更适合用于生产环境下的复杂应用程序的打包处理</p>
              </div>
            </details>
<p><br/></p>
<h1 id="新技术趋势"><a href="#新技术趋势" class="headerlink" title="新技术趋势"></a>新技术趋势</h1><h3 id="Q1：微前端中的应用隔离是什么，一般怎么实现的"><a href="#Q1：微前端中的应用隔离是什么，一般怎么实现的" class="headerlink" title="Q1：微前端中的应用隔离是什么，一般怎么实现的"></a>Q1：微前端中的应用隔离是什么，一般怎么实现的</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>微前端是一种类似于微服务的架构，它将不同的前端应用（通常由不同的团队开发和维护）集成在同一用户界面中。每个应用作为一个独立的整体存在，可以各自独立部署、升级，互不干扰</p><p>在微前端架构中，”应用隔离”是一个重要的概念</p><p>应用隔离主要指的是在微前端的环境下，各个子应用需要在运行时保持状态和生命周期的隔离，防止相互之间的干扰</p><p>主要体现在以下三个方面：</p><ol><li><p><strong>JS隔离</strong></p><p>避免各个应用之间的全局变量、事件等资源的冲突</p><ul><li>可以通过 JavaScript 的闭包或者 IIFE（立即执行函数表达式）来实现变量的隔离</li><li>另外也可以通过使用 Webpack 打包，把全局变量封装在模块作用域中，防止全局污染</li></ul></li><li><p><strong>CSS隔离</strong></p><p>防止子应用的CSS样式之间的污染</p><ul><li>可以使用CSS Modules，CSS in JS等技术，把样式限制在组件或者模块作用域内</li><li>另外，Shadow DOM也是一种可以实现样式隔离的方式，但在一些老的或者特定的浏览器环境下可能会存在兼容性问题</li></ul></li><li><p><strong>DOM隔离</strong></p><p>每个子应用有自己独立的根节点，防止不同子应用间DOM操作相互干扰</p></li></ol>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《React 面试题》</title>
    <url>/posts/f967bad7/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：React-Portals-有什么用"><a href="#Q1：React-Portals-有什么用" class="headerlink" title="Q1：React Portals 有什么用"></a>Q1：React Portals 有什么用</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Portals 是 React 提供的一种机制，用于将子组件渲染到父组件 DOM 层次结构之外的位置</p><p>它在处理一些特殊情况下的 UI 布局或交互时非常有用</p><p>以下是一些使用 React Portals 的常见情况：</p><ol><li><p><strong>在模态框中使用</strong></p><p> 当你需要在应用的根 DOM 结构之外显示模态框（对话框）时，React Portals 可以帮助你将模态框的内容渲染到根 DOM 之外的地方，而不影响布局</p></li><li><p><strong>处理 z-index 问题</strong></p><p> 在一些复杂的布局中，可能存在 z-index 的层级关系导致组件无法按照预期的方式叠加显示</p><p>使用 React Portals 可以将组件渲染到具有更高 z-index 的容器中，以解决这些问题</p></li><li><p><strong>在全局位置显示组件</strong></p><p> 如果你希望某个组件在页面的固定位置显示，而不受父组件的定位影响，React Portals 可以将该组件渲染到 body 或其他容器中</p></li><li><p><strong>在动画中使用</strong> </p><p>当你需要在页面中的某个位置执行动画时，React Portals 可以帮助你将动画的内容渲染到离该位置更近的 DOM 结构中，以提高动画性能</p></li></ol><p><strong>基本使用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">function MyPortalComponent() &#123;</span><br><span class="line">  return ReactDOM.createPortal(</span><br><span class="line">    // 子组件的内容</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      This is rendered using a portal!</span><br><span class="line">    &lt;/div&gt;,</span><br><span class="line">    // 渲染目标的 DOM 元素</span><br><span class="line">    document.getElementById(&#x27;portal-root&#x27;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在应用的根组件中渲染 MyPortalComponent</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;/* 此处的内容在正常的 DOM 结构中 */&#125;</span><br><span class="line">      &lt;p&gt;This is a normal component.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &#123;/* 使用 React Portals 渲染到 &#x27;portal-root&#x27; 元素外 */&#125;</span><br><span class="line">      &lt;MyPortalComponent /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：React18有哪些更新"><a href="#Q2：React18有哪些更新" class="headerlink" title="Q2：React18有哪些更新"></a>Q2：React18有哪些更新</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>并发模式（Concurrent Mode）</strong>:<br>并发模式是 React 的一个大型功能更新，它允许 React 在渲染时更好地管理优先级和资源</p><p>并发模式可以让 React 在长时间渲染的过程中保持应用的响应性，通过中断渲染工作和重新开始的能力，可以优化性能并减少延迟</p></li><li><p><strong>更新 render API</strong>:<br>React 18 中的新<code>render</code> AI 被设计来支持并发功能</p><p>换句话说，通过使用新的 <code>createRoot</code> API 替代 <code>ReactDOM.render</code>, 可以开启 React 应用的并发特性</p></li><li><p><strong>自动批处理（Automatic Batching）</strong>:<br>批处理是一种合并多个状态更新，以减少多余渲染次数的优化技术</p><p>在 React 18 中，所有的状态更新（无论它们源自事件处理、Promises、setTimeout等）都会自动批处理，而在以前，React 只会在合成事件和生命周期函数中自动批处理更新</p></li><li><p><strong>Suspense 支持 SSR（Suspense for Server Side Rendering）</strong>:<br>在 React 18 中，<code>Suspense</code> 组件得到了 SSR 的官方支持</p><p>这意味着你现在可以使用 <code>Suspense</code> 来延迟渲染组件的一部分，直到必要的数据加载完成，即便这个组件是在服务器端渲染的</p></li><li><p><strong>startTransition</strong>:<br><code>startTransition</code> 是一个调度一个不紧急更新的新方法</p><p>这可以告诉 React 某些更新可以延后执行，让用户不会感受到卡顿，并且保证更重要的更新（如输入）可以优先处理</p></li><li><p><strong>useTransition</strong>:<br><code>useTransition</code> 钩子允许你在组件中标记状态更新和组件转换</p><p>你可以使用它来通知 React，某些更新具有较低的优先级。它返回一个数组，其中第一个值是一个布尔值，指示低优先级更新是否正在发生，第二个值是 <code>startTransition</code> 的包装函数</p></li><li><p><strong>useDeferredValue</strong>:<br>这个钩子接受一个值，并返回一个延迟版本的该值</p><p>这对于保持大型列表或表格的响应性非常有用，即使在我们等待这些渲染数据时，用户仍然能够继续做其他操作，如输入</p></li><li><p><strong>useId</strong>:<br><code>useId</code> 是一个钩子，用来生成稳定、服务端和客户端都能保持同步的唯一标识符，这个功能主要解决在服务端渲染的应用中处理 ID 生成的问题</p></li><li><p><strong>提供给第三方库的 Hook</strong>:<br>React 18 引入了一些新的钩子，如 <code>useSyncExternalStore</code> 和 <code>useInsertionEffect</code> 等，专为第三方库设计，以便更好地集成并发模式和新特性</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li>并发模式</li><li>更新 render API</li><li>自动批处理</li><li>Suspense 支持 SSR</li><li>startTransition</li><li>useTransition</li><li>useDeferredValue</li><li>useId</li><li>提供给第三方库的 Hook</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：react-和-react-dom-是什么关系"><a href="#Q3：react-和-react-dom-是什么关系" class="headerlink" title="Q3：react 和 react-dom 是什么关系"></a>Q3：react 和 react-dom 是什么关系</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>react</code> 和 <code>react-dom</code> 是 React 库的两个主要部分，它们分别负责处理不同的事务</p><p>它们之间的关系可以理解为：</p><ol><li><p><strong><code>react</code></strong></p><p>这是 React 库的核心部分，包含了 React 的核心功能，如组件、状态、生命周期等</p><p>它提供了构建用户界面所需的基本构建块</p><p>当你编写 React 组件时，你实际上是在使用 <code>react</code> 包</p></li><li><p><strong><code>react-dom</code></strong> </p><p>这是 React 专门为 DOM 环境提供的包，它包含了与浏览器 DOM 相关的功能</p><p>react-dom<code>提供了用于在浏览器中渲染 React 组件的方法，包括</code>ReactDOM.render</p><p><code>在 Web 开发中，</code>react-dom` 被用于将 React 应用渲染到浏览器的 DOM 中</p></li></ol><p>基本上，<code>react</code> 和 <code>react-dom</code> 是为了分离 React 的核心功能，以便更好地处理不同的环境和平台</p><p>这种分离使得 React 更加灵活，可以适应不同的渲染目标，而不仅仅局限于浏览器环境。</p><p>在使用 React 开发 Web 应用时，通常会同时安装和引入这两个包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react react-dom</span><br></pre></td></tr></table></figure><p>然后在代码中引入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, React!&lt;/h1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>react</code> 库提供了 <code>App</code> 组件的定义，而 <code>react-dom</code> 库提供了 <code>ReactDOM.render</code> 方法，用于将组件渲染到 HTML 页面中</p><p>这种分工让 React 在不同平台上能够更灵活地适应各种渲染目标</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：为什么-react-需要-fiber-架构，而-Vue-却不需要"><a href="#Q4：为什么-react-需要-fiber-架构，而-Vue-却不需要" class="headerlink" title="Q4：为什么 react 需要 fiber 架构，而 Vue 却不需要"></a>Q4：为什么 react 需要 fiber 架构，而 Vue 却不需要</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 和 Vue 都是现代前端开发中非常流行的库/框架，它们以不同的方式实现更新和渲染机制，以提供高效且响应式的用户界面</p><p>React 的 Fiber 架构和 Vue 的响应式系统设计理念在解决特定问题和优化渲染机制上有着各自的目标和策略</p><p>下面，我们来探讨为什么 React 需要引入 Fiber 架构，而 Vue 没有采用类似的方案。</p><ol><li><p>React 的 Fiber 架构</p><p>Fiber 架构是 React 16 中引入的一个重大更新，旨在解决大型应用的性能问题以及一些与异步渲染相关的挑战</p><p>Fiber 架构的关键目标包括：</p><ul><li><p><strong>增强组件的渲染和更新性能：</strong></p><p>通过实现任务的分割和优先级调度，Fiber 架构使得 React 能够暂停、中断、恢复和重用渲染工作</p><p>这对于提高复杂应用的性能，特别是在动画、布局和手势等需要快速响应的场景中，非常关键</p></li><li><p><strong>提升应用的响应性：</strong></p><p>通过引入异步渲染能力，React 可以在长时间的渲染任务中更好地控制主线程，避免界面卡顿，从而保持应用流畅并快速响应用户输入</p></li><li><p><strong>更灵活的架构：</strong></p><p>Fiber 架构给 React 带来了更多的可能性，如并发模式、Suspense 等，这些特性进一步提升了开发体验和用户体验</p></li></ul></li><li><p>Vue 的响应式系统</p><p>与此同时，Vue 采用的是响应式系统，Vue 3 中的响应式系统通过 Proxy 对象重写，该机制允许 Vue 检测到任何嵌套属性的变化，从而实现更为精准和高效的更新</p><p>Vue 的核心目标包括：</p><ul><li><p><strong>简洁的 API 和易于上手：</strong></p><p>Vue 重视开发体验，并致力于提供简单且强大的模板语法和计算属性，让开发者快速构建高效的应用</p></li><li><p><strong>细粒度的更新机制：</strong></p><p>Vue 的响应式系统能够精确地追踪依赖变化，保证只有相关的组件会重新渲染，从而提高性能</p></li><li><p><strong>优化的打包大小和运行性能：</strong></p><p>Vue 3 引入 Composition API，促进了代码的组织性，同时也使得 Vue 的核心更轻量，提升了运行时性能</p></li></ul></li></ol><p><strong>为什么 React 需要 Fiber，而 Vue 不需要？</strong></p><ul><li><p><strong>不同的更新策略和焦点：</strong></p><p>React 的 Fiber 架构主要解决的是长时间的、阻塞式更新所带来的性能问题，以及实现异步渲染的能力</p><p>而 Vue 通过其响应式系统和细粒度的更新机制，关注的是依赖追踪和高效的组件更新</p></li><li><p><strong>核心设计理念的差异：</strong></p><p>React 通过 JSX 和组件树构建应用，强调组件的状态管理和更新</p><p>Vue 则侧重于模板和响应式数据绑定，提供一种更直观的开发方式</p><p>这些核心的设计理念导致了它们在技术实现和优化方向上的不同选择</p></li></ul><p>总的来说，React 的 Fiber 架构和 Vue 的响应式系统分别体现了这两个框架针对性能优化和开发体验的不同策略和重点。每种方式都有其适用的场景和优点，而选择使用哪一个往往取决于项目的需求、团队的熟悉度以及个人偏好。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：JSX是什么，它和JS有什么区别"><a href="#Q5：JSX是什么，它和JS有什么区别" class="headerlink" title="Q5：JSX是什么，它和JS有什么区别"></a>Q5：JSX是什么，它和JS有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JSX（JavaScript XML）是 JavaScript 的一个语法扩展，最常用于 React 组件中描述 UI 结构</p><p>JSX 使得你可以在 JavaScript 代码中写类似于 HTML 的标记，从而创建 React 元素</p><p>虽然 JSX 在视觉上看起来与 HTML 相似，但它在底层完全是 JavaScript</p><p>当编译这些 JSX 代码时（通常是使用 Babel 这样的转译器），它们会被转换成 <code>React.createElement</code> 调用</p><p>以下是一些主要的区别：</p><ol><li><p><strong>语法形式</strong></p><p>JSX 是一种混合的语法，允许 HTML 和 JavaScript 混合编写</p><p>而在纯 JavaScript 中，你需要显式地通过 JavaScript 方法来创建和操作 DOM</p></li><li><p><strong>执行环境</strong></p><p>在浏览器中直接运行纯 JS 没有问题，但 JSX 代码需要先经过转译，才能被浏览器理解</p></li><li><p><strong>表达能力</strong></p><p>JSX 提供了一种更加声明式的方式来描述 UI 组件的结构和呈现逻辑，而不是在 JavaScript 中手动地创建和管理 DOM 元素</p></li></ol><p>JSX代码如下：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>它转换为以下JS代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：为什么在本地开发时，组件会渲染两次"><a href="#Q6：为什么在本地开发时，组件会渲染两次" class="headerlink" title="Q6：为什么在本地开发时，组件会渲染两次"></a>Q6：为什么在本地开发时，组件会渲染两次</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 严格模式会在开发环境中触发一些额外的检查和警告，以帮助开发者发现潜在的问题</p><p>具体来说，严格模式会在以下情况下触发组件的额外渲染：</p><ol><li><p><strong>识别副作用</strong></p><p>React 会在严格模式下对某些生命周期方法和 Hooks 进行双重调用，以便更容易地发现副作用</p><p>例如，<code>useEffect</code> 中的副作用会被调用两次，以确保副作用是幂等的（即多次调用不会产生不同的结果）</p></li><li><p><strong>检测不安全的生命周期方法</strong></p><p>严格模式会检测一些不安全的生命周期方法，如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code>，并给出警告</p></li><li><p><strong>确保一致性</strong></p><p>通过双重调用构造函数、渲染方法和某些生命周期方法，React 可以确保组件在不同环境下的一致性</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>如何确认是否是严格模式引起的</strong></p><p>你可以检查你的代码是否使用了严格模式</p><p>严格模式通常通过 <code>&lt;React.StrictMode&gt;</code> 包裹你的应用根组件来启用，如下所示：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>如何避免双重渲染</strong></p><p>严格模式的双重渲染仅在开发环境中启用，并不会影响生产环境</p><p>因此，通常不需要担心这种行为在生产环境中会带来性能问题</p><p>如果你确实需要在开发过程中避免双重渲染（例如，为了调试某些特定问题），你可以暂时移除 <code>&lt;React.StrictMode&gt;</code> 包裹，但请注意，这只是一个临时解决方案，不建议长期使用，因为严格模式提供了许多有价值的检查和警告</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：虚拟-dom-有什么优点？真实-dom-和虚拟-dom，谁快"><a href="#Q7：虚拟-dom-有什么优点？真实-dom-和虚拟-dom，谁快" class="headerlink" title="Q7：虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快"></a>Q7：虚拟 dom 有什么优点？真实 dom 和虚拟 dom，谁快</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>虚拟DOM（Virtual DOM）是一个编程概念，其中UI的表示形式保留在内存中，并与“实际”的DOM（Document Object Model）同步</p><p>这个过程称为调和(reconciliation)</p><p>虚拟DOM提供几个关键优点：</p><ol><li><p>高效的更新</p><p>虚拟DOM可以快速的在内存中重新渲染UI，因为它不立即操作真实的DOM</p><p>只有当虚拟DOM和真实DOM之间的差异计算完成后，真实DOM的必要部分才会更新，从而减少了直接操作真实DOM的次数</p></li><li><p>批量更新和最小化DOM操作</p><p>操作真实DOM相比操作JavaScript对象要慢得多</p><p>虚拟DOM使React能够批量更新，将多个更改放在一起，然后一次性将它们应用到真实DOM上，从而最小化DOM操作次数</p></li><li><p>抽象层</p><p>虚拟DOM作为一个抽象层，使得开发者不需要直接与DOM交互，简化了编程模型并提高了UI更新的效率和性能</p></li><li><p>跨平台</p><p>虚拟DOM不仅可以工作在浏览器环境，也可以用在其他环境（如服务器端渲染SSR、原生移动应用React Native）上，因为它是独立的</p></li></ol><p><strong>真实DOM与虚拟DOM比较</strong></p><ol><li><p>真实DOM：</p><ul><li><p>直接操作真实DOM会导致浏览器频繁重绘界面和回流，消耗性能较大</p></li><li><p>DOM操作是破坏性的，简单的更新操作可能会引发整个子树的重新渲染</p></li></ul></li><li><p>虚拟DOM：</p><ul><li><p>更新是在JavaScript内存中进行的，消耗较低</p></li><li><p>React等框架会智能计算出最小的DOM操作次数，仅修改需要更新的部分</p></li></ul></li></ol><p>所以在多数情况下，虚拟DOM都会比真实DOM更快，因为它减少了昂贵的DOM操作并在必要时才进行批处理更新</p><p>但是需要注意的是，在某些简单的操作或者超小的DOM结构的情况下，直接操作真实DOM可能会更快，因为引入虚拟DOM涉及到的差异比对(Diffing)算法和更新计划也有一定代价</p><p>总的来说，虚拟DOM并不是在所有情况下都绝对“快过”真实DOM</p><p>它的优势在于，对于大型和复杂的应用，它可以通过智能的更新策略大幅度提高效率</p><p>真实DOM的优势在于简单场景下的快速响应和直观操作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：什么是合成事件，与原生事件有什么区别"><a href="#Q8：什么是合成事件，与原生事件有什么区别" class="headerlink" title="Q8：什么是合成事件，与原生事件有什么区别"></a>Q8：什么是合成事件，与原生事件有什么区别</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，事件处理机制是通过合成事件（Synthetic Events）实现的</p><p>理解合成事件与原生事件之间的区别对开发 React 应用程序非常重要</p><p><strong>合成事件（Synthetic Events）</strong></p><p>合成事件是 React 实现的一种跨浏览器的事件系统，它封装了浏览器的原生事件，提供了一致的 API</p><p>React 使用合成事件来确保在不同浏览器中具有相同的行为</p><p><strong>合成事件与原生事件的区别</strong></p><ol><li><p><strong>跨浏览器兼容性</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 通过合成事件提供了一个跨浏览器的事件系统，确保在不同浏览器中具有一致的行为</p></li><li><p><strong>原生事件</strong></p><p>浏览器的原生事件在不同浏览器中可能会有不同的行为和 API</p></li></ul></li><li><p><strong>事件委托</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 使用事件委托（Event Delegation）模式，将所有的事件处理器都绑定到根元素上（如 <code>document</code> 或 <code>root</code> 元素）</p><p>当事件触发时，React 会通过事件冒泡机制找到相应的组件并调用其事件处理器</p></li><li><p><strong>原生事件</strong></p><p>原生事件处理器通常直接绑定到具体的 DOM 元素上</p></li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>由于事件处理器是绑定在根元素上的，React 可以通过事件委托减少内存消耗和提高性能，尤其是在有大量事件处理器的情况下</p></li><li><p><strong>原生事件</strong></p><p>直接绑定在具体 DOM 元素上的事件处理器，可能会在有大量事件处理器时导致性能问题</p></li></ul></li><li><p><strong>事件对象</strong>：</p><ul><li><p><strong>合成事件</strong></p><p>React 提供的事件对象是 <code>SyntheticEvent</code>，它是对原生事件对象的封装</p><p><code>SyntheticEvent</code> 提供了一致的接口，并且在事件处理后会被回收以提高性能</p></li><li><p><strong>原生事件</strong></p><p>浏览器提供的事件对象，接口在不同浏览器中可能会有所不同</p></li></ul></li></ol><p><strong>示例：合成事件和原生事件</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个合成事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent:&#x27;</span>, event);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent type:&#x27;</span>, event.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原生事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;NativeEvent:&#x27;</span>, event.<span class="property">nativeEvent</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;NativeEvent type:&#x27;</span>, event.<span class="property">nativeEvent</span>.<span class="property">type</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中，当按钮被点击时，<code>handleClick</code> 方法会被调用：</p><ol><li><code>event</code> 是一个合成事件对象 (<code>SyntheticEvent</code>)</li><li><code>event.nativeEvent</code> 是原生事件对象</li></ol><p><strong>主要特性</strong></p><ol><li><p><strong>自动清理</strong></p><p>合成事件对象会在事件处理函数执行完毕后被清理，以提高性能</p><p>这意味着你不能异步访问合成事件对象的属性</p><p>如果需要异步访问，可以调用 <code>event.persist()</code> 方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">persist</span>(); <span class="comment">// 防止事件对象被回收</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;SyntheticEvent:&#x27;</span>, event);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>一致性</strong></p><p>合成事件提供了一致的 API，解决了不同浏览器之间的差异。</p></li></ol><p><strong>总结</strong></p><ul><li><strong>合成事件</strong> 是 React 提供的一种跨浏览器的事件系统，封装了原生事件，提供了一致的 API，并通过事件委托提高性能</li><li><strong>原生事件</strong> 是浏览器提供的事件系统，不同浏览器可能存在差异，事件处理器通常直接绑定在具体的 DOM 元素上</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：数据如何在React组件中流动"><a href="#Q9：数据如何在React组件中流动" class="headerlink" title="Q9：数据如何在React组件中流动"></a>Q9：数据如何在React组件中流动</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>React组件通信</strong></p><p><strong>react组件通信方式有哪些</strong></p><p>组件通信的方式有很多种，可以分为以下几种：</p><ol><li>父组件向子组件通信</li><li>子组件向父组件通信</li><li>兄弟组件通信</li><li>父组件向后代组件通信</li><li>无关组件通信</li></ol><p><strong>父组件向子组件通信</strong></p><ul><li><strong>props传递</strong>，利用React单向数据流的思想，通过props传递</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;props.name&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span>	</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Parent</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;我是儿子&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>子组件向父组件通信</strong></p><ul><li><strong>回调函数</strong></li></ul><p>父组件向子组件传递一个函数，通过函数回调，拿到子组件传过来的值</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">scala复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">price</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getPrice</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">price</span>:val</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span>&gt;</span>价格:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;value&quot;</span>&gt;</span>&#123;this.state.price&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">getPrice</span>=<span class="string">&#123;this.getPrice.bind(this)&#125;/</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">getItemPrice</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getPrice</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getItemPrice.bind(this)&#125;</span>&gt;</span>廓形大衣<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.getItemPrice.bind(this)</span>&gt;</span>牛仔裤<span class="tag">&lt;/<span class="name">button</span>&gt;</span>	</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>	</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>事件冒泡</strong></li></ul><p>点击子组件的button按钮，事件会冒泡到父组件上</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">ini复制代码<span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">sayName</span> = name =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> sayName(&#x27;lyllovelemon&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Ref</strong></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">scala复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span>=<span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="title function_">changeVal</span>(<span class="string">&#x27;lyllovelemon&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">changeVal</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>兄弟组件通信</strong></p><p>实际上就是通过父组件中转数据的，子组件a传递给父组件，父组件再传递给子组件b</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildOne</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildTwo</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父组件向后代组件通信</strong></p><p><strong>Context</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PriceContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&quot;price&quot;</span>) </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">PriceContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;200&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">PriceContext</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="title class_">PriceContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">        &#123; <span class="function"><span class="params">price</span>=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>price:&#123;price&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &#125;</span><br><span class="line">      &lt;/<span class="title class_">PriceContext</span>.<span class="property">Consumner</span>&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HOC</strong></p><p><strong>Redux</strong></p><p>ref，useRef，forwardRef，useImperativeHandle</p><p>作者：lyllovelemon<br>链接：<a href="https://juejin.cn/post/7182382408807743548">https://juejin.cn/post/7182382408807743548</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：fiber架构"><a href="#Q10：fiber架构" class="headerlink" title="Q10：fiber架构"></a>Q10：fiber架构</h3><p>难度：⭐⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是fiber，fiber解决了什么问题</strong></p><p>在React16以前，React更新是通过<strong>树的深度优先遍历</strong>完成的，遍历是不能中断的，当树的层级深就会产生栈的层级过深，页面渲染速度变慢的问题，为了解决这个问题引入了fiber，React fiber就是虚拟DOM，它是一个链表结构，返回了return、children、siblings，分别代表父fiber，子fiber和兄弟fiber，随时可中断</p><p><strong>Fiber是纤程，比线程更精细，表示对渲染线程实现更精细的控制</strong></p><p><strong>应用目的</strong><br> 实现增量渲染，增量渲染指的是把一个渲染任务分解为多个渲染任务，而后将其分散到多个帧里。增量渲染是为了实现任务的可中断、可恢复，并按优先级处理任务，从而达到更顺滑的用户体验</p><p><strong>Fiber的可中断、可恢复怎么实现的</strong></p><p><strong><em>fiber</em></strong>是协程，是比线程更小的单元，可以被人为中断和恢复，当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务</p><p>fiber是一个链表结构，它有三个指针，分别记录了当前节点的下一个兄弟节点，子节点，父节点。当遍历中断时，它是可以恢复的，只需要保留当前节点的索引，就能根据索引找到对应的节点</p><p><strong>Fiber更新机制</strong></p><p><strong>初始化</strong></p><ol><li>创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)</li><li>进入beginWork</li></ol><p><strong>workInProgress</strong>:正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树</p><p><strong>current</strong>:正在视图层渲染的树叫current fiber树</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> = workInProgressFiber</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> = currentFiber</span><br></pre></td></tr></table></figure><ol><li>深度调和子节点，渲染视图</li></ol><p>在新建的alternate树上，完成整个子节点的遍历，包括fiber的创建，最后会以workInProgress树最为最新的渲染树，fiberRoot的current指针指向workInProgress使其变成current fiber，完成初始化流程</p><p><strong>更新</strong></p><ol><li>重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress</li></ol><p>渲染完成后，workInProgress树又变成current树</p><p><strong>双缓冲模式</strong></p><p>话剧演出中，演员需要切换不同的场景，以一个一小时话剧来说，在舞台中切换场景，时间来不及。一般是准备两个舞台，切换场景从左边舞台到右边舞台演出</p><p>在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉的抖动甚至卡顿。</p><p>react的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗</p><p><strong>React渲染流程</strong></p><p>如图，React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。vdom转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM，这个过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d05402136ac44f87971d9f0b89466911~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=992&amp;h=408&amp;s=19711&amp;e=jpg&amp;b=faf4e7" alt="img"></p><p>vdom（React Element对象）中只记录了子节点，没有记录兄弟节点，因此渲染不可打断</p><p>fiber（fiberNode对象）是一个链表，它记录了父节点、兄弟节点、子节点，因此是可以打断的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：React的设计思想"><a href="#Q11：React的设计思想" class="headerlink" title="Q11：React的设计思想"></a>Q11：React的设计思想</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>组件化</strong></p><p>每个组件都符合开放-封闭原则，封闭是针对渲染工作流来说的</p><p>指的是组件内部的状态都由自身维护，只处理内部的渲染逻辑</p><p>开放是针对组件通信来说的，指的是不同组件可以通过props（单项数据流）进行数据交互</p></li><li><p><strong>数据驱动视图</strong></p><p>UI=f(data)</p><p>通过上面这个公式得出，如果要渲染界面，不应该直接操作DOM，而是通过修改数据(state或prop)，数据驱动视图更新</p></li><li><p><strong>虚拟DOM</strong></p><p>由浏览器的渲染流水线可知，DOM操作是一个昂贵的操作，很耗性能，因此产生了虚拟DOM。虚拟DOM是对真实DOM的映射，React通过新旧虚拟DOM对比，得到需要更新的部分，实现数据的增量更新</p></li></ol><p><a href="https://juejin.cn/post/7007214462813863950">React设计模式</a></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：类组件和函数式组件有何不同"><a href="#Q12：类组件和函数式组件有何不同" class="headerlink" title="Q12：类组件和函数式组件有何不同"></a>Q12：类组件和函数式组件有何不同</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>类组件（Class Components）和函数式组件（Function Components）是 React 中定义组件的两种主要方式</p><p>它们各有特点和适用场景</p><p>以下是它们的主要不同点：</p><ol><li><p>定义方式</p><ul><li><p>类组件</p><p>类组件使用 ES6 类语法，并继承自 <code>React.Component</code></p><p>它们需要定义一个 <code>render</code> 方法来返回 JSX</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello from Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyClassComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件是 JavaScript 函数，它们直接返回 JSX</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello from Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyFunctionComponent</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>状态管理</p><ul><li><p>类组件</p><p>类组件使用 <code>this.state</code> 来管理状态，并通过 <code>this.setState</code> 更新状态</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件使用 React Hooks（如 <code>useState</code>）来管理状态</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>生命周期方法</p><ul><li><p>类组件</p><p>类组件有一系列生命周期方法，如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>，用于在组件的不同阶段执行代码</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component updated&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件使用 <code>useEffect</code> Hook 来处理副作用，相当于组合了 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyFunctionComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted or updated&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组作为依赖项，表示只在挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>性能优化</p><ul><li><p>类组件</p><p>类组件可以使用 <code>shouldComponentUpdate</code> 方法或 <code>PureComponent</code> 来优化性能</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数式组件</p><p>函数式组件可以使用 <code>React.memo</code> 来优化性能</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyFunctionComponent</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Function Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>可读性和简洁性</p><p>函数式组件通常更简洁、更易读，尤其是在使用 Hooks 后</p><p>它们更接近于纯函数的概念，使得代码更容易理解和测试</p></li></ol><p><strong>总结</strong></p><ul><li><strong>类组件</strong>：适合需要使用生命周期方法和复杂状态管理的场景</li><li><strong>函数式组件</strong>：更简洁，推荐用于大多数场景，特别是在引入 Hooks 之后</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：mobx和-redux-有什么区别"><a href="#Q13：mobx和-redux-有什么区别" class="headerlink" title="Q13：mobx和 redux 有什么区别"></a>Q13：mobx和 redux 有什么区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>设计理念</p><ul><li><p><strong>Redux</strong></p><ul><li><p><strong>单一状态树</strong>：Redux 使用单一的全局状态树来管理应用状态，这意味着所有的状态都存储在一个对象中</p></li><li><p><strong>不可变性</strong>：Redux 强调状态的不可变性，每次状态更新都会返回一个新的状态对象，而不是直接修改原有状态</p></li><li><p><strong>纯函数</strong>：Redux 的状态更新逻辑是通过纯函数（reducers）来实现的，这些函数接收当前状态和动作（action），然后返回新的状态</p></li><li><p><strong>可预测性</strong>：由于使用纯函数和不可变状态，Redux 的状态管理非常可预测和可调试</p></li></ul></li><li><p><strong>MobX</strong></p><ul><li><p><strong>多状态树</strong>：MobX 允许使用多个状态树（observables）来管理应用状态，可以根据需要将状态分散在不同的对象中</p></li><li><p><strong>可变性</strong>：MobX 允许直接修改状态对象，更新状态时不需要返回新的状态对象，状态变化是自动追踪和响应的</p></li><li><p><strong>响应式编程</strong>：MobX 采用响应式编程模型，通过观察（observables）和反应（reactions）来自动追踪和响应状态变化</p></li><li><p><strong>简洁性</strong>：MobX 的 API 和使用方式更简洁，适合快速开发和迭代</p></li></ul></li></ul></li><li><p>使用方式</p><ul><li><p><strong>Redux</strong></p><ol><li><strong>定义状态和动作</strong>：<ul><li>使用 <code>createStore</code> 创建全局状态树</li><li>定义动作类型（action types）和动作创建器（action creators）</li></ul></li><li><strong>定义 reducer</strong>：<ul><li>使用纯函数定义 reducer，根据动作类型返回新的状态</li></ul></li><li><strong>连接组件</strong>：<ul><li>使用 <code>connect</code> 高阶组件将 Redux 状态和动作绑定到 React 组件</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = initialState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params">&#123; count, increment &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">count</span>: state.<span class="property">count</span> &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, &#123; increment &#125;)(<span class="title class_">Counter</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>MobX</strong></p><ol><li><strong>定义状态和动作</strong>：<ul><li>使用 <code>observable</code> 定义状态</li><li>使用 <code>action</code> 定义状态更新逻辑</li></ul></li><li><strong>观察状态</strong>：<ul><li>使用 <code>observer</code> 高阶组件将 MobX 状态绑定到 React 组件</li></ul></li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterStore</span> &#123;</span><br><span class="line">  @observable count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  @action increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterStore = <span class="keyword">new</span> <span class="title class_">CounterStore</span>();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterStore <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="title function_">observer</span>(<span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;counterStore.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counterStore.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>特性对比</p><ul><li><strong>状态管理方式</strong>：<ul><li>Redux：单一状态树，不可变状态，纯函数</li><li>MobX：多状态树，可变状态，响应式编程</li></ul></li><li><strong>学习曲线</strong>：<ul><li>Redux：相对较陡，需要理解不可变性、纯函数和中间件等概念</li><li>MobX：相对较平缓，更加直观和简洁</li></ul></li><li><strong>生态系统和社区</strong>：<ul><li>Redux：有一个庞大的生态系统和活跃的社区，提供了丰富的中间件和工具</li><li>MobX：社区和生态系统相对较小，但也有一些有用的工具和扩展</li></ul></li><li><strong>可调试性</strong>：<ul><li><strong>Redux</strong>：由于状态不可变和使用纯函数，Redux 的状态变化是可预测的，配合 Redux DevTools 等工具，可以方便地进行状态跟踪和时间旅行调试（time-travel debugging）</li><li><strong>MobX</strong>：MobX 的状态变化是响应式的，虽然也有调试工具（如 MobX DevTools），但由于状态是可变的，调试和跟踪状态变化可能没有 Redux 那么直观</li></ul></li><li><strong>性能</strong>：<ul><li><strong>Redux</strong>：由于状态变化需要通过纯函数和不可变对象，Redux 在处理大规模状态更新时可能会有性能开销，特别是在深层嵌套的状态结构中</li><li><strong>MobX</strong>：MobX 通过响应式编程和细粒度的观察机制，可以高效地追踪和响应状态变化，避免了不必要的重新渲染，性能通常较好</li></ul></li><li><strong>代码组织</strong>：<ul><li><strong>Redux</strong>：Redux 通常需要将状态、动作和 reducer 分开组织，代码结构相对清晰，但在大型应用中可能会导致样板代码（boilerplate）较多</li><li><strong>MobX</strong>：MobX 的代码组织更灵活，可以将状态和动作集中在一个类中，代码量通常较少，开发体验更加简洁</li></ul></li><li><strong>中间件和扩展</strong>：<ul><li><strong>Redux</strong>：Redux 有丰富的中间件（如 redux-thunk、redux-saga）和扩展工具，可以方便地处理异步操作和复杂的状态逻辑</li><li><strong>MobX</strong>：MobX 本身不需要中间件来处理异步操作，可以直接在 action 中使用异步函数，扩展性相对简单</li></ul></li></ul></li></ol><p><strong>选择指南</strong></p><ul><li><strong>选择 Redux</strong>：如果你的应用需要严格的状态管理、可预测性和强大的调试工具，特别是在团队协作和大型项目中，Redux 是一个不错的选择</li><li><strong>选择 MobX</strong>：如果你更倾向于简洁的代码、快速开发和响应式编程，MobX 可能更适合你，特别是在中小型项目或快速迭代的开发环境中</li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="Q1：简述React的生命周期"><a href="#Q1：简述React的生命周期" class="headerlink" title="Q1：简述React的生命周期"></a>Q1：简述React的生命周期</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，生命周期方法是指在组件的不同阶段（如挂载、更新和卸载）执行的特定方法。对于函数式组件，我们主要依赖于 Hooks 来管理这些生命周期事件。以下是 React 组件的生命周期阶段及其对应的 Hooks。</p><ol><li><p>挂载（Mounting）</p><p>当组件首次插入到 DOM 中时，会经历以下阶段：</p><ul><li><p><strong>构造函数（Constructor）</strong>：</p><ul><li>仅适用于类组件，用于初始化状态和绑定事件处理函数</li></ul></li><li><p><strong><code>getDerivedStateFromProps</code></strong>：</p><ul><li>适用于类组件，用于在渲染前更新状态</li></ul></li><li><p><strong><code>render</code></strong>：</p><ul><li>类组件和函数组件都会执行此方法，用于返回要渲染的元素</li></ul></li><li><p><strong><code>componentDidMount</code></strong>：</p><ul><li>类组件特有的方法，在组件挂载后立即调用</li><li>对应的 Hook：<code>useEffect</code>，可以通过传递空数组 <code>[]</code> 作为第二个参数来模拟 <code>componentDidMount</code></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件挂载后的逻辑</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>更新（Updating）</p><p>组件的状态或属性发生变化时，会经历以下阶段：</p><ul><li><p><strong><code>getDerivedStateFromProps</code></strong>：</p><ul><li>类组件特有的方法，用于在渲染前更新状态</li></ul></li><li><p><strong><code>shouldComponentUpdate</code></strong>：</p><ul><li>类组件特有的方法，用于控制组件是否需要重新渲染</li></ul></li><li><p><strong><code>render</code></strong>：</p><ul><li>类组件和函数组件都会执行此方法，用于返回要渲染的元素</li></ul></li><li><p><strong><code>getSnapshotBeforeUpdate</code></strong>：</p><ul><li>类组件特有的方法，用于在更新前获取一些信息</li></ul></li><li><p><strong><code>componentDidUpdate</code></strong>：</p><ul><li>类组件特有的方法，在组件更新后立即调用</li><li>对应的 Hook：<code>useEffect</code>，可以通过传递依赖数组来模拟 <code>componentDidUpdate</code></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件更新后的逻辑</span></span><br><span class="line">&#125;, [依赖项]);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>卸载（Unmounting）</p><p>组件从 DOM 中移除时，会经历以下阶段：</p><ul><li><p><strong><code>componentWillUnmount</code></strong>：</p><ul><li>类组件特有的方法，用于在组件卸载前执行清理操作</li><li>对应的 Hook：<code>useEffect</code>，可以通过返回一个清理函数来模拟 <code>componentWillUnmount</code></li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件卸载前的清理逻辑</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>错误处理（Error Handling）</p><p>当组件渲染过程中发生错误时，会经历以下阶段：</p><ul><li><code>componentDidCatch</code>：<ul><li>类组件特有的方法，用于捕获错误并处理</li><li>对应的 Hook：<code>useErrorBoundary</code>（在一些第三方库中提供）</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：并发模式是如何执行的"><a href="#Q2：并发模式是如何执行的" class="headerlink" title="Q2：并发模式是如何执行的"></a>Q2：并发模式是如何执行的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>并发模式是什么</strong></p><p>并发模式是React 18引入的一组新特性，用于使React能够更高效地处理大量更新，并提供更流畅的用户体验</p><p>并发模式允许React在不阻塞主线程的情况下执行渲染工作，从而使应用程序能够更好地响应用户交互</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 中的<code>并发</code>，并不是指同一时刻同时在做多件事情</p><p>因为 js 本身就是单线程的（同一时间只能执行一件事情），而且还要跟 UI 渲染竞争主线程</p><p>若一个很耗时的任务占据了线程，那么后续的执行内容都会被阻塞</p><p>为了避免这种情况，React 就利用 fiber 结构和时间切片的机制，将一个大任务分解成多个小任务，然后按照任务的优先级和线程的占用情况，对任务进行调度</p><p><strong>执行方式</strong></p><ol><li><p><strong>时间切片（Time Slicing）</strong></p><ul><li><p>React可以将渲染工作分成多个小的任务，并在任务之间进行切换</p><p>这使得React可以在处理昂贵的渲染工作时，仍然能够响应用户输入和其他高优先级的任务</p></li><li><p>例如，React可能会暂停一个低优先级的渲染任务，以便处理一个高优先级的用户输入事件</p></li></ul></li><li><p><strong>优先级调度（Priority Scheduling）</strong></p><ul><li><p>React会根据任务的重要性来分配优先级</p><p>高优先级的任务（如用户输入）会被优先处理，而低优先级的任务（如数据加载后的渲染）会被延后处理</p></li><li><p>这确保了用户的交互可以得到及时响应，而不必等待所有渲染工作完成</p></li></ul></li><li><p><strong>可中断渲染（Interruptible Rendering）</strong></p><ul><li><p>在并发模式下，React的渲染过程是可中断的</p><p>如果有更高优先级的任务需要处理，React可以暂停当前的渲染任务，处理完高优先级任务后再继续未完成的渲染任务</p></li></ul></li><li><p><strong>Suspense</strong></p><ul><li><p><code>Suspense</code>是并发模式中的一个重要特性，它允许组件在等待异步数据时显示备用内容（如加载指示器）</p><p>当异步数据加载完成后，React会自动更新组件</p></li><li><p>例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./MyComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>启用方式</strong></p><p>在React 18中，可以通过使用新的<code>createRoot</code> API来启用并发模式：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(container); <span class="comment">// 使用 createRoot 启用并发模式</span></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：useEffect-的清除机制是什么？在什么时候执行"><a href="#Q3：useEffect-的清除机制是什么？在什么时候执行" class="headerlink" title="Q3：useEffect()的清除机制是什么？在什么时候执行"></a>Q3：useEffect()的清除机制是什么？在什么时候执行</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useEffect</code> 是 React 中用于在函数组件中执行副作用的 Hook</p><p>了解它的清除机制对于管理副作用和避免内存泄漏非常重要</p><p>下面是对 <code>useEffect</code> 清除机制的详细解释</p><ol><li><p><code>useEffect</code> 清除机制</p><p><code>useEffect</code> 接受一个函数作为参数，这个函数可以返回一个清除函数（cleanup function）</p><p>这个清除函数将在以下几种情况下执行：</p><ul><li><p><strong>组件卸载时</strong></p><p>当组件从 DOM 中被移除时，React 会执行清除函数</p><p>这有助于清理定时器、取消网络请求或清除任何其他副作用</p></li><li><p><strong>依赖项变化时</strong></p><p>如果 <code>useEffect</code> 的依赖项（通过第二个参数传递的数组）发生变化，React 会在执行新的副作用之前先执行清除函数</p><p>这确保了在副作用重新执行之前，任何之前的副作用都被正确清理</p></li></ul></li><li><p>示例：清除定时器</p><p>下面是一个使用 <code>useEffect</code> 设置和清除定时器的示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除函数：在组件卸载或依赖项变化时清除定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组表示只在组件挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Timer</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong></p><ul><li><strong>设置副作用</strong>：在 <code>useEffect</code> 中，我们设置了一个定时器，每秒钟更新一次 <code>count</code> 状态</li><li><strong>清除函数</strong>：返回的清除函数会在组件卸载时执行，清除定时器以避免内存泄漏</li><li><strong>依赖项数组</strong>：空数组 <code>[]</code> 作为第二个参数，表示这个 <code>useEffect</code> 只在组件挂载和卸载时执行一次</li></ul></li><li><p><strong>清除函数执行时机</strong></p><ul><li><p><strong>组件卸载时</strong>：当组件从 DOM 中被移除时，清除函数会执行。例如，用户导航到另一个页面或条件渲染导致组件被移除时</p></li><li><p><strong>依赖项变化时</strong>：如果 <code>useEffect</code> 的依赖项数组中包含的值发生变化，清除函数会在重新运行副作用之前执行例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect ran&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cleanup ran&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [dependency]);</span><br></pre></td></tr></table></figure><p>每当 <code>dependency</code> 变化时，清除函数会先执行，然后 <code>useEffect</code> 会重新运行</p></li></ul></li></ul></li><li><p>总结</p><ul><li><strong>清除函数的作用</strong>：确保在组件卸载或副作用重新运行之前，清理任何可能导致内存泄漏或不必要行为的副作用</li><li><strong>执行时机</strong>：在组件卸载时或依赖项变化时执行</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：多次执行-useState-，会触发多次更新吗"><a href="#Q4：多次执行-useState-，会触发多次更新吗" class="headerlink" title="Q4：多次执行 useState()，会触发多次更新吗"></a>Q4：多次执行 useState()，会触发多次更新吗</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，调用 <code>useState</code> 更新状态会触发组件重新渲染</p><p>每次调用 <code>setState</code> 方法（<code>useState</code> 返回的更新函数）都会触发一次重渲染</p><p>然而，React 会对多次状态更新进行批处理，以优化性能</p><ol><li><p>多次调用 <code>useState</code> 的行为</p><p>假设你有以下代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>increment</code> 函数调用了三次 <code>setCount</code></p><p>你可能期望 <code>count</code> 会增加 3，但实际上只会增加 1</p><p>这是因为在同一个事件处理函数中，React 会对状态更新进行批处理</p></li><li><p>使用函数式更新</p><p>要确保每次调用 <code>setCount</code> 都基于最新的状态，你可以使用函数式更新：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setCount</code> 的参数是一个函数，该函数接收之前的状态值 <code>prevCount</code> 并返回新的状态值</p><p>这样，每次调用 <code>setCount</code> 都会基于最新的状态值进行更新，因此 <code>count</code> 将正确增加 3</p></li><li><p>状态更新批处理</p><p>React 在事件处理函数中会对状态更新进行批处理，以优化性能</p><p>这意味着在同一个事件处理函数中多次调用 <code>setState</code>，React 可能会合并这些更新并只进行一次重渲染</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 这里的 count 可能还是旧值</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在 <code>increment</code> 函数内部的 <code>console.log(count)</code> 可能会输出旧的 <code>count</code> 值，因为状态更新是异步的，且在事件处理函数结束之前不会立即反映出来</p></li><li><p>总结</p><ul><li><p><strong>多次调用 <code>setState</code></strong></p><p>在同一个事件处理函数中多次调用 <code>setState</code>，React 会进行批处理，只触发一次重渲染</p></li><li><p><strong>函数式更新</strong></p><p>使用函数式更新可以确保每次状态更新都基于最新的状态值</p></li><li><p><strong>批处理优化</strong></p><p>React 会对状态更新进行批处理，以优化性能</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：React-的-diff-过程"><a href="#Q5：React-的-diff-过程" class="headerlink" title="Q5：React 的 diff 过程"></a>Q5：React 的 diff 过程</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 diff 过程是 React 用来高效更新 DOM 的核心机制之一</p><p>这个过程被称为 “reconciliation”（协调），其核心算法被称为 “diffing algorithm”</p><p>React 通过 diff 算法比较新旧虚拟 DOM 树（Virtual DOM）之间的差异，并只更新实际需要变更的部分，从而实现高效的更新</p><p><strong>Diff 算法的基本原则</strong></p><p>React 的 diff 算法主要基于以下三个基本原则：</p><ol><li><strong>不同类型的元素会产生不同的树</strong>：<ul><li>如果两个元素类型不同，React 会销毁旧的树并创建新的树</li><li>例如，从 <code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>，React 会移除 <code>&lt;div&gt;</code> 及其子节点，并创建新的 <code>&lt;span&gt;</code> 及其子节点</li></ul></li><li><strong>相同类型的元素会保留 DOM 节点，仅更新属性</strong>：<ul><li>如果两个元素类型相同，React 会保留现有的 DOM 节点，仅更新其属性</li><li>例如，从 <code>&lt;div className=&quot;old&quot;&gt;</code> 变为 <code>&lt;div className=&quot;new&quot;&gt;</code>，React 只会更新 <code>className</code> 属性</li></ul></li><li><strong>通过 key 属性来识别列表中的元素</strong>：<ul><li>对于列表中的元素，React 通过 <code>key</code> 属性来识别每个元素</li><li>如果 <code>key</code> 发生变化，React 会认为元素发生了变化，从而销毁旧的并创建新的</li><li>使用 <code>key</code> 可以帮助 React 更高效地更新列表</li></ul></li></ol><p><strong>Diff 算法的具体步骤</strong></p><ol><li><strong>比较根节点</strong>：<ul><li>React 首先比较根节点。如果根节点类型不同，React 会直接替换整个节点树</li></ul></li><li><strong>比较子节点</strong>：<ul><li>如果根节点类型相同，React 会递归比较子节点</li><li>如果子节点是文本节点，React 会直接更新文本内容</li><li>如果子节点是元素节点，React 会比较属性并更新变化的部分</li></ul></li><li><strong>列表的比较</strong>：<ul><li>对于列表，React 使用 <code>key</code> 属性来跟踪每个元素。如果 <code>key</code> 发生变化，React 会重新创建元素</li><li>React 会尝试最小化 DOM 操作，通过移动、插入和删除节点来更新列表</li></ul></li></ol><p><strong>示例</strong></p><p>以下是一个简单的示例，展示了 React 如何通过 diff 算法更新 DOM：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = <span class="title function_">useState</span>([<span class="string">&#x27;Item 1&#x27;</span>, <span class="string">&#x27;Item 2&#x27;</span>, <span class="string">&#x27;Item 3&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateItems</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setItems</span>([<span class="string">&#x27;Item 1&#x27;</span>, <span class="string">&#x27;Item 3&#x27;</span>, <span class="string">&#x27;Item 4&#x27;</span>]); <span class="comment">// 更新列表</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;items.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;updateItems&#125;</span>&gt;</span>Update Items<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中，当点击 <code>Update Items</code> 按钮时，React 会使用 <code>key</code> 属性来比较新旧列表，并只更新变化的部分：</p><ul><li><code>Item 1</code> 保持不变</li><li><code>Item 2</code> 被移除</li><li><code>Item 3</code> 保持不变，但位置发生变化</li><li><code>Item 4</code> 被添加</li></ul><p><strong>总结</strong></p><p>React 的 diff 过程通过以下方式实现高效的 DOM 更新：</p><ul><li><strong>不同类型的元素会产生不同的树</strong>：类型不同直接替换</li><li><strong>相同类型的元素会保留 DOM 节点，仅更新属性</strong>：类型相同只更新变化的属性</li><li><strong>通过 key 属性来识别列表中的元素</strong>：使用 <code>key</code> 来高效更新列表</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Redux-遵循的三个原则是什么"><a href="#Q6：Redux-遵循的三个原则是什么" class="headerlink" title="Q6：Redux 遵循的三个原则是什么"></a>Q6：Redux 遵循的三个原则是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Redux 是一个用于 JavaScript 应用的状态管理库，特别适用于 React 应用</p><p>Redux 遵循三个核心原则，这些原则帮助开发者构建可预测、易于调试和维护的应用状态管理系统</p><ol><li><p>单一数据源（Single Source of Truth）</p><p>在 Redux 中，整个应用的状态被存储在一个单一的对象树（state tree）中，这个对象树被存储在一个单一的 store 中</p><p>这个原则确保了应用的状态是集中管理的，从而使得状态变得更可预测和容易调试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const initialState = &#123;</span><br><span class="line">  user: null,</span><br><span class="line">  posts: [],</span><br><span class="line">  comments: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer, initialState);</span><br></pre></td></tr></table></figure></li><li><p>状态是只读的（State is Read-Only）</p><p>唯一改变应用状态的方法是触发一个 action</p><p>Action 是一个描述事件的普通 JavaScript 对象，它们必须具有一个 <code>type</code> 属性来指明事件的类型</p><p>这个原则确保了状态的不可变性，从而使得状态变更可追踪和可调试</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_POST&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;My First Post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(action)</span><br></pre></td></tr></table></figure></li><li><p>使用纯函数来执行修改（Changes are Made with Pure Functions）</p><p>为了描述 action 如何改变 state 树，你需要编写纯函数</p><p>纯函数是指相同的输入总是会产生相同的输出，并且没有副作用</p><p>在 Redux 中，这些纯函数被称为 reducers。Reducer 接收当前的 state 和 action，并返回一个新的 state</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postsReducer</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_POST&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [...state, action.<span class="property">payload</span>];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  <span class="attr">posts</span>: postsReducer,</span><br><span class="line">  <span class="comment">// 其他 reducers</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p>Redux 的三个核心原则是：</p><ol><li><strong>单一数据源（Single Source of Truth）</strong>：整个应用的状态被存储在一个单一的 store 中</li><li><strong>状态是只读的（State is Read-Only）</strong>：唯一改变状态的方法是触发一个 action</li><li><strong>使用纯函数来执行修改（Changes are Made with Pure Functions）</strong>：reducers 是纯函数，用于描述状态如何根据 action 改变</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：你对“单一事实来源”有什么理解"><a href="#Q7：你对“单一事实来源”有什么理解" class="headerlink" title="Q7：你对“单一事实来源”有什么理解"></a>Q7：你对“单一事实来源”有什么理解</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“单一事实来源”（Single Source of Truth, SSOT）是软件设计中的一个重要原则，特别是在状态管理和数据管理领域</p><p>这个原则的核心思想是系统中的所有数据都应该有一个唯一的、权威的来源</p><p>这种方法有助于避免数据的不一致性，简化数据管理，并提高系统的可维护性和可预测性</p><p><strong>在 Redux 中的应用</strong></p><p>在 Redux 中，单一事实来源的原则体现在整个应用的状态被存储在一个单一的对象树（state tree）中，这个对象树被存储在一个唯一的 Redux store 中</p><p>以下是这个原则的一些具体好处和实现方式：</p><p><strong>好处</strong></p><ol><li><p><strong>数据一致性</strong></p><p>当所有状态都集中在一个地方时，数据的一致性更容易维护</p><p>你不需要担心不同组件或模块之间的数据不同步问题</p></li><li><p><strong>可预测性</strong></p><p>由于状态集中管理，应用的行为变得更加可预测</p><p>你可以通过查看 store 来了解应用的当前状态</p></li><li><p><strong>易于调试</strong></p><p>使用单一的 store，可以很容易地跟踪状态的变化</p><p>Redux DevTools 等工具可以帮助开发者查看和回溯状态的变化历史</p></li><li><p><strong>简化开发</strong></p><p>集中管理状态使得应用的结构更加清晰，开发者可以更容易地理解和维护代码</p></li></ol><p><strong>实现方式</strong></p><p>在 Redux 中，实现单一事实来源的步骤包括：</p><ol><li><p><strong>创建 Redux Store</strong></p><p>使用 <code>createStore</code> 函数创建一个 Redux store，这个 store 将包含整个应用的状态</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer);</span><br></pre></td></tr></table></figure></li><li><p><strong>定义 State Tree</strong></p><p>应用的状态被定义为一个对象树，可以包含多个属性，每个属性代表应用的一个部分状态</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">user</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">posts</span>: [],</span><br><span class="line">  <span class="attr">comments</span>: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Reducers 管理状态</strong></p><p>reducers 是纯函数，用于描述状态如何根据 action 改变</p><p>所有的状态变更都通过 reducers 来处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rootReducer</span>(<span class="params">state = initialState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_POST&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">posts</span>: [...state.<span class="property">posts</span>, action.<span class="property">payload</span>]</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="comment">// 其他 case</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 Actions 修改状态</strong></p><p>唯一修改状态的方法是通过 dispatch actions</p><p>actions 是描述状态变更的普通 JavaScript 对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addPostAction = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_POST&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;My First Post&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(addPostAction);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><p>“单一事实来源”原则在 Redux 中的应用确保了整个应用的状态是集中管理的，从而使得状态变得更可预测、更一致，并且更容易调试和维护</p><p>这种方法不仅适用于 Redux，也可以应用于其他需要管理复杂状态和数据的一些系统和框架中</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Redux-有哪些优点"><a href="#Q8：Redux-有哪些优点" class="headerlink" title="Q8：Redux 有哪些优点"></a>Q8：Redux 有哪些优点</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>单一状态树</strong></p><p>Redux 使用单一的状态树（State Tree）来存储整个应用的状态</p><p>这意味着所有的状态都集中在一个地方，使得应用的状态管理更加清晰和可预测</p></li><li><p><strong>可预测的状态管理</strong></p><p>Redux 强调状态是不可变的，所有的状态变更必须通过纯函数（Reducers）来处理</p><p>这种方式使得状态变更的过程变得透明和可预测，便于调试和测试</p></li><li><p><strong>易于调试</strong></p><p>Redux 提供了强大的调试工具，如 Redux DevTools，可以帮助开发者查看状态的变化、回溯状态历史、时间旅行调试等</p><p>这些工具极大地提高了开发和调试的效率</p></li><li><p><strong>中间件支持</strong></p><p>Redux 具有强大的中间件机制，可以在 action 被发送到 reducer 之前进行处理</p><p>常见的中间件如 Redux Thunk 和 Redux Saga，可以处理异步操作、日志记录、错误报告等</p></li><li><p><strong>与 React 的良好集成</strong></p><p>Redux 与 React 紧密集成，通过 <code>react-redux</code> 库提供的 <code>Provider</code> 和 <code>connect</code> 方法，可以方便地将 Redux 的状态和方法注入到 React 组件中，使得组件间的状态共享和通信变得简单</p></li><li><p><strong>社区和生态系统</strong></p><p>Redux 拥有庞大的社区和丰富的生态系统，提供了大量的插件和工具，如 Redux Form、Redux Persist、Redux Toolkit 等，帮助开发者更高效地构建应用</p></li><li><p><strong>可扩展性和可维护性</strong></p><p>Redux 的设计模式使得应用的状态管理逻辑高度模块化和可扩展</p><p>随着应用的增长，Redux 的结构可以轻松地扩展和维护，而不需要对现有代码进行大规模的重构</p></li><li><p><strong>一致的数据流</strong></p><p>Redux 采用单向数据流的设计，即 action -&gt; reducer -&gt; state 的数据流动方向</p><p>这种设计使得数据流动更加简单和直观，减少了双向绑定带来的复杂性和潜在问题</p></li><li><p><strong>支持服务器渲染</strong></p><p>Redux 可以很好地支持服务器端渲染（SSR），通过在服务器端初始化和预填充状态，可以显著提高应用的性能和用户体验</p></li><li><p><strong>强类型支持</strong></p><p>对于使用 TypeScript 的项目，Redux 提供了良好的类型支持，可以显著减少运行时错误，提高开发效率和代码质量</p></li></ol><p><strong>示例代码</strong></p><p>以下是一个简单的 Redux 示例，展示了如何创建 store、定义 action 和 reducer，并在 React 组件中使用 Redux 状态：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">type</span>: <span class="string">&#x27;DECREMENT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer.js</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state = initialState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterReducer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span>, useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：React事件机制"><a href="#Q9：React事件机制" class="headerlink" title="Q9：React事件机制"></a>Q9：React事件机制</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是合成事件</strong></p><p><strong>React基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等</strong></p><p>React事件的设计动机(作用)：</p><ul><li><strong>在底层磨平不同浏览器的差异，React实现了统一的事件机制，我们不再需要处理浏览器事件机制方面的兼容问题，在上层面向开发者暴露稳定、统一的、与原生事件相同的事件接口</strong></li><li><strong>React把握了事件机制的主动权，实现了对所有事件的中心化管控</strong></li><li><strong>React引入事件池避免垃圾回收，在事件池中获取或释放事件对象，避免频繁的创建和销毁</strong></li></ul><p><strong>React事件机制和原生DOM事件流有什么区别</strong></p><p><strong>虽然合成事件不是原生DOM事件，但它包含了原生DOM事件的引用，可以通过e.nativeEvent访问</strong></p><hr><p><strong>DOM事件流是怎么工作的</strong>，一个页面往往会绑定多个事件，页面接收事件的顺序叫事件流</p><p>W3C标准事件的传播过程：</p><ol><li>事件捕获</li><li>处于目标</li><li>事件冒泡</li></ol><p>常用的事件处理性能优化手段：<strong>事件委托</strong></p><p><strong>把多个子元素同一类型的监听函数合并到父元素上，通过一个函数监听的行为叫事件委托</strong></p><p><strong>我们写的React事件是绑定在DOM上吗，如果不是绑定在哪里</strong></p><p>React16的事件绑定在document上， React17以后事件绑定在container上,<strong>ReactDOM.render(app,container)</strong></p><p><strong>React事件机制</strong>总结如下：</p><p>事件绑定 事件触发</p><ul><li><strong>React所有的事件绑定在container上</strong>(react17以后),而不是绑定在DOM元素上（作用：减少内存开销，所有的事件处理都在container上，其他节点没有绑定事件）</li><li>React自身实现了一套冒泡机制，不能通过return false阻止冒泡</li><li>React通过<strong>SytheticEvent</strong>实现了<strong>事件合成</strong></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad1c0b6ee9c42578b6fc7b46a3a2e39~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1740&amp;h=1054&amp;s=45104&amp;e=webp&amp;b=2b2a33" alt="img"></p><p><strong>React实现事件绑定的过程</strong></p><p><strong>1.建立合成事件与原生事件的对应关系</strong></p><p><strong>registrationNameModule,</strong> 它建立了React事件到plugin的映射，它包含React支持的所有事件的类型，用于判断一个组件的prop是否是事件类型</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   onBlur:SimpleEventPlugin,</span><br><span class="line">   onClick:SimpleEventPlugin,</span><br><span class="line">   onClickCapture:SimpleEventPlugin,</span><br><span class="line">   onChange:ChangeEventPlugin,</span><br><span class="line">   onChangeCapture:ChangeEventPlugin,</span><br><span class="line">   onMouseEnter:EnterLeaveEventPlugin,</span><br><span class="line">   onMouseLeave:EnterLeaveEventPlugin,</span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>registrationNameDependencies，</strong> 这个对象记录了React事件到原生事件的映射</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  onBlur: [<span class="string">&#x27;blur&#x27;</span>],</span><br><span class="line">  onClick: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">  onClickCapture: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">  onChange: [<span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;keyup&#x27;</span>, <span class="string">&#x27;selectionchange&#x27;</span>],</span><br><span class="line">  onMouseEnter: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">  onMouseLeave: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>plugins对象,</strong> 记录了所有注册的插件列表</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span> = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...]</span><br></pre></td></tr></table></figure><hr><p><strong>为什么针对同一个事件，即使可能存在多次回调，document（container）也只需要注册一次监听</strong></p><p>因为React注册到document(container)上的并不是一个某个DOM节点具体的回调逻辑，而是一个统一的事件分发函数dispatchEvent - &gt; 事件委托思想</p><p><strong>dispatchEvent是怎么实现事件分发的</strong></p><p>事件触发的本质是对dispatchEvent函数的调用</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8b7a2369a943118f865cb9369638b4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1188&amp;h=821&amp;s=205871&amp;e=png&amp;b=ebebeb" alt="img"></p><p><strong>React事件处理为什么要手动绑定this</strong></p><p>react组件会被编译为React.createElement,在createElement中，它的this丢失了，并不是由组件实例调用的，因此需要手动绑定this</p><p>为什么不能通过return false阻止事件的默认行为</p><p>因为React基于浏览器的事件机制实现了一套自己的事件机制，和原生DOM事件不同，它采用了事件委托的思想，通过dispatch统一分发事件处理函数</p><p><strong>React怎么阻止事件冒泡</strong></p><ul><li>阻止合成事件的冒泡用e.stopPropagation()</li><li>阻止合成事件和最外层document事件冒泡，使用e.nativeEvent.stopImmediatePropogation()</li><li>阻止合成事件和除了最外层document事件冒泡，通过判断e.target避免</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">target</span> &amp;&amp; e.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;div.stop&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">active</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：React-Router工作原理"><a href="#Q10：React-Router工作原理" class="headerlink" title="Q10：React-Router工作原理"></a>Q10：React-Router工作原理</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>为什么需要前端路由</strong></p><ol><li>早期：一个页面对应一个路由，路由跳转导致页面刷新，用户体验差</li><li>ajax的出现使得不刷新页面也可以更新页面内容，出现了<em>SPA</em>（单页应用）。<em>SPA</em>不能记住用户操作，只有一个页面对URL做映射，SEO不友好</li><li>前端路由帮助我们在仅有一个页面时记住用户进行了哪些操作</li></ol><p><strong>前端路由解决了什么问题</strong></p><ol><li>当用户刷新页面，浏览器会根据当前URL对资源进行重定向(发起请求)</li><li>单页面对服务端来说就是一套资源，怎么做到不同的URL映射不同的视图内容</li><li>拦截用户的刷新操作，避免不必要的资源请求；感知URL的变化</li></ol><p><strong>react-router-dom有哪些组件</strong></p><p>HashRouter/BrowserRouter 路由器</p><p>Route 路由匹配</p><p>Link 链接，在html中是个锚点</p><p>NavLink 当前活动链接</p><p>Switch 路由跳转</p><p>Redirect 路由重定向</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/home&quot;</span>&gt;<span class="title class_">Home</span>&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/abount&quot;</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React Router核心能力：<strong>跳转</strong></p><p><strong>路由</strong>负责定义路径和组件的映射关系</p><p><strong>导航</strong>负责触发路由的改变<br> 路由器根据Route定义的映射关系为新的路径匹配对应的逻辑</p><p><strong>BrowserRouter</strong>使用的<strong>HTML5</strong>的<strong>history api</strong>实现路由跳转<br> <strong>HashRoute</strong>r使用URL的<strong>hash属性</strong>控制路由跳转</p><p><strong>前端通用路由解决方案</strong></p><ul><li>hash模式</li></ul><blockquote><p>改变URL以#分割的路径字符串，让页面感知路由变化的一种模式,通过<em>hashchange</em>事件触发</p></blockquote><ul><li>history模式</li></ul><blockquote><p>通过浏览器的history api实现,通过<em>popState</em>事件触发</p></blockquote>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：React-Render方法的原理是什么？什么时候会被触发"><a href="#Q11：React-Render方法的原理是什么？什么时候会被触发" class="headerlink" title="Q11：React Render方法的原理是什么？什么时候会被触发"></a>Q11：React Render方法的原理是什么？什么时候会被触发</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 <code>render</code> 方法是 React 框架的核心概念之一，用于描述组件的 UI 结构</p><p>理解 <code>render</code> 方法的原理和触发条件有助于更好地优化和管理 React 应用的性能</p><p>以下是对 <code>render</code> 方法的详细解释：</p><p><strong><code>render</code> 方法的原理</strong></p><p>在 React 中，每个组件都有一个 <code>render</code> 方法（对于类组件）或一个返回 JSX 的函数（对于函数组件）</p><p>这个方法的主要职责是返回一个描述 UI 的 React 元素树</p><p>React 使用这些描述来构建和更新实际的 DOM</p><p><strong>类组件中的 <code>render</code> 方法</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数组件中的 <code>render</code> 方法</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>render</code> 方法的触发条件</strong></p><p><code>render</code> 方法会在以下几种情况下被触发：</p><ol><li><p><strong>组件挂载时</strong></p><p>当组件第一次被添加到 DOM 中时，<code>render</code> 方法会被调用。这是组件的初始渲染阶段。</p></li><li><p><strong>组件状态（state）更新时</strong></p><p>当组件的状态通过 <code>setState</code> 或 <code>useState</code> 更新时，<code>render</code> 方法会被调用，以反映状态的变化</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件接收新的 props 时</strong></p><p>当父组件传递给子组件的 props 发生变化时，<code>render</code> 方法会被调用，以反映新的 props</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ParentComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ChildComponent</span> = (<span class="params">&#123; value &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>强制更新时</strong></p><p>可以通过调用 <code>forceUpdate</code> 方法强制组件重新渲染，但这种做法不常见，应尽量避免</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  forceUpdateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.forceUpdateComponent&#125;</span>&gt;</span>Force Update<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>上下文（context）变化时</strong></p><p>如果组件使用了上下文（context），当上下文的值发生变化时，<code>render</code> 方法也会被触发</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ParentComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ChildComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：对Redux的理解以及它的工作原理以及怎么使用"><a href="#Q12：对Redux的理解以及它的工作原理以及怎么使用" class="headerlink" title="Q12：对Redux的理解以及它的工作原理以及怎么使用"></a>Q12：对Redux的理解以及它的工作原理以及怎么使用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>Redux 的理解</strong></p><p>Redux 是一个用于 JavaScript 应用的状态管理库，通常与 React 一起使用</p><p>它提供了一个集中化的存储来管理应用的状态，使得状态管理变得更加可预测和可维护</p><p><strong>Redux 的工作原理</strong></p><p>Redux 的核心概念包括以下几个部分：</p><ol><li><p><strong>Store</strong></p><p>Redux 应用的整个状态树都存储在一个单一的 store 中</p><p>这个 store 是一个对象，包含了应用的所有状态</p></li><li><p><strong>Action</strong></p><p>Action 是一个描述发生了什么的普通 JavaScript 对象</p><p>每个 action 都必须有一个 <code>type</code> 属性，通常还会包含其他数据</p></li><li><p><strong>Reducer</strong></p><p>Reducer 是一个纯函数，接收当前的 state 和一个 action，并返回一个新的 state</p><p>Reducer 根据 action 的 <code>type</code> 来决定如何更新 state</p></li><li><p><strong>Dispatch</strong></p><p>Dispatch 是一个用于发送 action 的方法</p><p>通过调用 <code>store.dispatch(action)</code>，你可以触发 state 的更新</p></li><li><p><strong>Subscribe</strong></p><p>通过 <code>store.subscribe(listener)</code> 方法，你可以订阅 store 的更新</p><p>当 state 发生变化时，订阅的监听器会被调用</p></li></ol><p><strong>Redux 的使用步骤</strong></p><p>以下是如何在一个 React 应用中使用 Redux 的基本步骤：</p><ol><li><p>创建 Action</p><p>定义 action 类型和 action 创建函数：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">INCREMENT</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">DECREMENT</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建 Reducer</p><p>定义一个 reducer 函数来处理 state 更新：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">INCREMENT</span>, <span class="variable constant_">DECREMENT</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">counterReducer</span> = (<span class="params">state = initialState, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterReducer;</span><br></pre></td></tr></table></figure></li><li><p>创建 Store</p><p>使用 <code>createStore</code> 函数创建 Redux store：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li><li><p>提供 Store</p><p>使用 <code>Provider</code> 组件将 Redux store 提供给 React 应用：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>连接 React 组件</p><p>使用 <code>useSelector</code> 和 <code>useDispatch</code> 钩子在 React 组件中访问 Redux state 和 dispatch actions：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Counter.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用组件</p><p>在应用中使用你的 Redux 连接组件：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Counter</span> <span class="keyword">from</span> <span class="string">&#x27;./Counter&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Redux Counter Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：jsx转换成真实Dom的过程"><a href="#Q13：jsx转换成真实Dom的过程" class="headerlink" title="Q13：jsx转换成真实Dom的过程"></a>Q13：jsx转换成真实Dom的过程</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，JSX 是一种语法糖，它让你可以在 JavaScript 中编写类似 HTML 的代码</p><p>为了在浏览器中渲染这些代码，JSX 需要被转换成真实的 DOM 元素</p><p>这个转换过程可以分为以下几个步骤：</p><ol><li><p>JSX 转换为 JavaScript</p><p>首先，JSX 会被 Babel（一个 JavaScript 编译器）转换成 <code>React.createElement</code> 调用。这一步通常在构建过程中完成。</p><p><strong>示例</strong></p><p>假设有以下 JSX 代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>Babel 会将其转换为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello, world!&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>React.createElement 生成 React 元素</p><p><code>React.createElement</code> 是一个函数，用于创建一个 React 元素。React 元素是一个普通的 JavaScript 对象，描述了你想在屏幕上看到的内容。</p><p><strong>示例</strong></p><p>上面的 <code>React.createElement</code> 调用会生成以下 React 元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>React 元素渲染为虚拟 DOM</p><p>React 使用这个 React 元素来构建一个虚拟 DOM 树。虚拟 DOM 是一个轻量级的 JavaScript 对象树，描述了真实 DOM 的结构。</p><p><strong>示例</strong></p><p>虚拟 DOM 树可能看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> virtualDOM = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>虚拟 DOM 转换为真实 DOM</p><p>React 通过比较虚拟 DOM 和真实 DOM（即“调和”过程），将虚拟 DOM 转换为真实的 DOM 元素，并进行必要的更新。</p><p><strong>示例</strong></p><p>在初次渲染时，React 会创建一个新的 <code>h1</code> 元素，并将其插入到真实的 DOM 中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line">h1.<span class="property">textContent</span> = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>).<span class="title function_">appendChild</span>(h1);</span><br></pre></td></tr></table></figure></li><li><p>更新和调和</p><p>当组件的状态或属性发生变化时，React 会重新生成新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较。这个过程称为“调和”。React 会找出需要更新的部分，并只更新这些部分，从而提高性能。</p><p><strong>示例</strong></p><p>假设状态更新导致文本从“Hello, world!”变为“Hello, React!”：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newElement = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>新的虚拟 DOM 树会是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newVirtualDOM = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, React!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>React 会比较新旧虚拟 DOM 树，发现只有文本内容发生了变化，因此只会更新 <code>h1</code> 元素的文本内容</p></li></ol><p><strong>总结</strong></p><ol><li><strong>JSX 转换</strong>：JSX 被 Babel 转换为 <code>React.createElement</code> 调用</li><li><strong>生成 React 元素</strong>：<code>React.createElement</code> 创建一个描述 UI 的 React 元素对象</li><li><strong>虚拟 DOM</strong>：React 使用 React 元素来构建虚拟 DOM 树</li><li><strong>真实 DOM</strong>：React 将虚拟 DOM 转换为真实 DOM，并插入到页面中</li><li><strong>更新和调和</strong>：当状态或属性变化时，React 通过调和过程只更新必要的部分</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：React服务端渲染怎么做？原理是什么"><a href="#Q14：React服务端渲染怎么做？原理是什么" class="headerlink" title="Q14：React服务端渲染怎么做？原理是什么"></a>Q14：React服务端渲染怎么做？原理是什么</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>实现 React 服务端渲染的步骤</strong></p><ol><li><p>设置项目</p><p>首先，你需要一个基本的 React 项目和一个 Node.js 服务器。你可以使用 <code>create-react-app</code> 来创建一个 React 项目，然后进行一些配置来支持 SSR</p></li><li><p>安装必要的依赖</p><p>你需要安装一些额外的依赖，如 <code>express</code> 和 <code>react-dom/server</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install express react-dom/server</span><br></pre></td></tr></table></figure></li><li><p>创建服务器文件</p><p>创建一个 <code>server.js</code> 文件，用于设置 Express 服务器并处理 SSR</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOMServer</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./src/App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title class_">ReactDOMServer</span>.<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> indexFile = path.<span class="title function_">resolve</span>(<span class="string">&#x27;./build/index.html&#x27;</span>);</span><br><span class="line">  fs.<span class="title function_">readFile</span>(indexFile, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Something went wrong:&#x27;</span>, err);</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;Oops, better luck next time!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(</span><br><span class="line">      data.<span class="title function_">replace</span>(<span class="string">&#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;</span>, <span class="string">`&lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;app&#125;</span>&lt;/div&gt;`</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is listening on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>package.json</code></p><p>在 <code>package.json</code> 中添加一个脚本来启动服务器：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node server.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>构建项目并启动服务器</p><p>首先构建项目，然后启动服务器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></li></ol><p><strong>React 服务端渲染的原理</strong></p><p>服务端渲染的基本原理是将 React 组件在服务器端渲染成 HTML 字符串，然后将其发送到客户端</p><p>客户端接收到 HTML 内容后，再通过 React 进行“同构”或“挂载”，使得 React 可以接管这些已经渲染好的 HTML 元素，继续处理后续的交互和状态更新</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>服务端渲染（<code>Server-Side Rendering</code> ，简称<code>SSR</code>），指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p><p><img src="https://s2.loli.net/2024/05/23/5v8EQn2TRVm4cIx.png" alt="image-20240523105838863"></p><p><strong>优点</strong></p><ol><li><strong>更快的首屏渲染</strong>：SSR 可以在服务器端生成完整的 HTML 页面，减少了客户端首次渲染的时间</li><li><strong>SEO 友好</strong>：搜索引擎可以更容易地抓取和索引服务器端渲染的页面内容</li><li><strong>更好的用户体验</strong>：用户可以更快地看到页面内容，减少了白屏时间</li></ol><p><strong>缺点</strong></p><ol><li><strong>增加了服务器负载</strong>：每次请求都需要在服务器端渲染页面，增加了服务器的负载</li><li><strong>复杂性增加</strong>：SSR 需要更多的配置和代码，增加了开发和维护的复杂性</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：说说你对-React-Hook的闭包陷阱的理解，有哪些解决方案"><a href="#Q15：说说你对-React-Hook的闭包陷阱的理解，有哪些解决方案" class="headerlink" title="Q15：说说你对 React Hook的闭包陷阱的理解，有哪些解决方案"></a>Q15：说说你对 React Hook的闭包陷阱的理解，有哪些解决方案</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Hooks 中的闭包陷阱（Closure Trap）是一个常见的问题，尤其是在处理状态更新和副作用时</p><p>这个问题主要源于 JavaScript 闭包的特性，当你在函数组件中使用 Hooks 时，闭包可能会捕获旧的状态值，从而导致一些意外行为</p><p><strong>问题示例</strong></p><p>假设你有一个计时器组件，每秒钟更新一次计数器：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 这里的 `count` 是初始值 0</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setCount(count + 1)</code> 每次都会捕获初始的 <code>count</code> 值（即 0），因为 <code>useEffect</code> 中的函数只在组件挂载时被创建一次。结果是计数器不会正确更新。</p><p><strong>解决方案</strong></p><ol><li><p><strong>使用函数式更新</strong></p><p>React 提供了一种函数式更新的方式，可以确保你使用的是最新的状态值</p><p>你可以通过传递一个函数给 <code>setState</code> 来实现：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>); <span class="comment">// 使用最新的 `prevCount`</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li><p><strong>依赖数组</strong></p><p>在 <code>useEffect</code> 的依赖数组中添加需要使用的状态或属性，这样每次这些依赖变化时，<code>useEffect</code> 都会重新执行：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, [count]); <span class="comment">// 依赖 `count`</span></span><br></pre></td></tr></table></figure><p>但是这种方法在某些情况下可能会导致不必要的重新渲染，因此应谨慎使用</p></li><li><p><strong>使用 <code>useRef</code> 保存最新的状态</strong></p><p>你可以使用 <code>useRef</code> 来保存最新的状态值，并在副作用中引用它：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> countRef = <span class="title function_">useRef</span>(count);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    countRef.<span class="property">current</span> = count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(countRef.<span class="property">current</span> + <span class="number">1</span>); <span class="comment">// 使用最新的 `countRef.current`</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>自定义 Hook</strong></p><p>你可以创建一个自定义 Hook 来封装计时器逻辑，从而避免重复代码和闭包陷阱：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useInterval</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(callback, delay);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, [callback, delay]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li></ol><p>通过这些方法，你可以有效地避免 React Hooks 中的闭包陷阱，确保你的状态更新和副作用按预期工作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：React-Router有几种模式？实现原理是什么"><a href="#Q16：React-Router有几种模式？实现原理是什么" class="headerlink" title="Q16：React Router有几种模式？实现原理是什么"></a>Q16：React Router有几种模式？实现原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>BrowserRouter</code></p><p><strong>概述</strong></p><p><code>BrowserRouter</code> 使用 HTML5 的 <code>history</code> API 来处理路由</p><p>这种模式下，URL 看起来是干净的路径（例如 <code>/home</code>, <code>/about</code>），而不会带有 <code>#</code> 符号</p><p><strong>实现原理</strong></p><ul><li><p><strong>History API</strong></p><p><code>BrowserRouter</code> 利用 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 事件来管理浏览器历史记录和导航</p></li><li><p><strong>URL 结构</strong></p><p>直接使用路径名（pathname），例如 <code>/home</code></p></li><li><p><strong>服务器配置</strong></p><p>由于 URL 是干净的路径，服务器需要进行相应的配置，以便在用户直接访问某个路径时，服务器能够正确地返回应用的入口文件（通常是 <code>index.html</code>）</p><p>这通常涉及到配置服务器进行 URL 重写（URL Rewriting）</p></li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import Home from &#x27;./Home&#x27;;</span><br><span class="line">import About from &#x27;./About&#x27;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p><code>Hash Router</code></p><p><strong>概述</strong></p><p><code>HashRouter</code> 使用 URL 的 hash 部分（即 <code>#</code> 后面的部分）来管理路由</p><p>这种模式下，URL 会包含 <code>#</code> 符号（例如 <code>#/home</code>, <code>#/about</code>）</p><p><strong>实现原理</strong></p><ul><li><p><strong>Hash Fragment</strong></p><p><code>HashRouter</code> 利用浏览器的 <code>hashchange</code> 事件来检测 URL 变化，并根据 hash 值来导航</p></li><li><p><strong>URL 结构</strong></p><p>使用 hash 部分来表示路径，例如 <code>#/home</code></p></li><li><p><strong>服务器配置</strong>:</p><p>由于 hash 部分不会被发送到服务器，所以不需要进行额外的服务器配置</p><p>这使得 <code>HashRouter</code> 在一些静态文件服务器或不支持 URL 重写的环境中非常有用</p></li></ul><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./About&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li><strong>BrowserRouter</strong>:<ul><li>使用 HTML5 <code>history</code> API</li><li>URL 是干净的路径</li><li>需要服务器配置 URL 重写</li><li>更适合现代单页应用（SPA）</li></ul></li><li><strong>HashRouter</strong>:<ul><li>使用 URL 的 hash 部分</li><li>URL 包含 <code>#</code> 符号</li><li>不需要服务器配置</li><li>适合一些静态文件服务器或不支持 URL 重写的环境</li></ul></li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h3 id="Q1：子组件是一个-Portal，发生点击事件能冒泡到父组件吗"><a href="#Q1：子组件是一个-Portal，发生点击事件能冒泡到父组件吗" class="headerlink" title="Q1：子组件是一个 Portal，发生点击事件能冒泡到父组件吗"></a>Q1：子组件是一个 Portal，发生点击事件能冒泡到父组件吗</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在理解这个问题之前，首先要了解一些基本知识：</p><ol><li><p><strong>React Context</strong>：</p><p>React 使用 context 来存储组件树的一些信息，比如事件处理程序</p><p>当组件使用 Portal 时，Portal 在 React 内部仍然保持在父组件树中，即使在 DOM 上渲染到其他地方</p><p>也就是说，Portal 的 context 依然从其父组件继承而来</p></li><li><p><strong>DOM 事件冒泡</strong>：</p><p>DOM 中的事件（例如点击事件）通常会从触发事件的元素开始，然后逐步向上冒泡到父元素，直到 document 元素</p><p>在这个过程中，事件会按照 DOM 树的层级一层层地向上传递</p></li><li><p><strong>React 的事件代理</strong>：</p><p>React 使用事件代理模式将所有事件都代理到顶层（<code>document</code> 或者 <code>root</code> DOM 节点）进行处理</p><p>这意味着当在子组件中触发一个事件时，无论子组件是否使用了 Portal，React 都会将事件传递到其父组件，然后逐级往上冒泡，直到到达代理事件的顶层</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 的 Portal 通过 React 的 context 和事件冒泡的机制工作</p><p>在 React 中，当一个子组件使用 Portal 将其内容渲染到其他 DOM 节点时，尽管在 DOM 结构上子组件不再是父组件的直接子节点，但在 React 的组件树中，子组件仍然是父组件的子节点。这意味着 React 在监听和处理事件时，会沿着组件树的路径（而不是 DOM 树的路径）冒泡事件。因此，子组件中触发的事件仍然会冒泡到父组件。</p><p>总结：Portal 在 DOM 结构上将子组件渲染到其他位置，但在 React 的组件树中，它仍然是父组件的子组件。这使得事件可以从子组件沿着组件树冒泡到父组件。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：props-的变动，是否会引起-state-hook-中数据的变动"><a href="#Q2：props-的变动，是否会引起-state-hook-中数据的变动" class="headerlink" title="Q2：props 的变动，是否会引起 state hook 中数据的变动"></a>Q2：props 的变动，是否会引起 state hook 中数据的变动</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React 组件的 props 变动，会让组件重新执行，但并不会引起 state 的值的变动</p><p>state 值的变动，只能由 setState() 来触发</p><p>因此若想在 props 变动时，重置 state 的数据，需要监听 props 的变动，如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听 props 的变化，重置 count 的值</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;, [props]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：什么是受控组件和非受控组件"><a href="#Q3：什么是受控组件和非受控组件" class="headerlink" title="Q3：什么是受控组件和非受控组件"></a>Q3：什么是受控组件和非受控组件</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>受控</p><p>在受控组件中，表单元素的值完全由 React 组件的状态（state）来管理</p><p>每当表单元素的值发生变化时，会触发一个事件处理函数来更新状态，从而使表单元素的值与状态保持同步</p><p>特点</p><ul><li>表单元素的值由组件的状态控制</li><li>每次用户输入都会触发 <code>onChange</code> 事件，更新组件的状态</li></ul><p>示例</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ControlledComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [inputValue, setInputValue] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setInputValue</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Submitted value: &#x27;</span> + inputValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Input:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ControlledComponent</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li><li><p>非受控</p><p>在非受控组件中，表单元素的值由 DOM 自身来管理，而不是通过 React 的状态</p><p>你可以使用 <code>ref</code> 来访问 DOM 元素，从而获取或设置其值</p><p>特点</p><ul><li>表单元素的值由 DOM 自身管理</li><li>使用 <code>ref</code> 来直接访问 DOM 元素</li></ul><p>示例</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UncontrolledComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Submitted value: &#x27;</span> + inputRef.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Input:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">UncontrolledComponent</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>何时使用受控组件和非受控组件</strong></p><ol><li><strong>受控组件</strong>：<ul><li>适用于需要即时验证或格式化用户输入的场景</li><li>适合需要与其他组件共享或同步状态的场景</li><li>更符合 React 的单向数据流理念</li></ul></li><li><strong>非受控组件</strong>：<ul><li>适用于简单的表单，尤其是当你不需要对输入进行即时验证或格式化时</li><li>适合需要与第三方库集成的场景，这些库可能直接操作 DOM</li></ul></li></ol><p><strong>关键点总结</strong></p><ol><li><strong>受控组件</strong>：表单元素的值由 React 状态管理，使用 <code>onChange</code> 事件处理函数同步状态</li><li><strong>非受控组件</strong>：表单元素的值由 DOM 自身管理，使用 <code>ref</code> 直接访问 DOM 元素</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：高阶组件是什么"><a href="#Q4：高阶组件是什么" class="headerlink" title="Q4：高阶组件是什么"></a>Q4：高阶组件是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>高阶组件（Higher-Order Component，HOC）是 React 中的一种设计模式，用于复用组件逻辑</p><p>HOC 本质上是一个函数，它接收一个组件作为参数，并返回一个新的组件</p><p>通过这种方式，你可以在多个组件之间共享逻辑，而不需要重复代码</p><ol><li><p><strong>特点</strong></p><ul><li><p><strong>纯函数</strong>：HOC 是纯函数，不会修改传入的组件，而是返回一个新的组件。</p></li><li><p><strong>逻辑复用</strong>：HOC 可以将公共的逻辑抽离出来，在多个组件中复用。</p></li><li><p><strong>装饰器模式</strong>：HOC 类似于装饰器模式，通过增强组件的功能来实现逻辑复用</p></li><li><strong>强化 props</strong>：这个是 HOC 最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的 props,然后混入新的 props,来增强组件的功能。代表作 react-router 中的 withRouter</li><li><strong>赋能组件</strong>：HOC 有一项独特的特性，就是可以给被 HOC 包裹的业务组件，提供一些拓展功能，比如说额外的生命周期，额外的事件，但是这种 HOC，可能需要和业务组件紧密结合。典型案例 react-keepalive-router 中的 keepaliveLifeCycle 就是通过 HOC 方式，给业务组件增加了额外的生命周期</li><li><strong>控制渲染</strong>：劫持渲染是 hoc 一个特性，在 wrapComponent 包装组件中，可以对原来的组件，进行条件渲染，节流渲染，懒加载等功能，后面会详细讲解，典型代表做 react-redux 中 connect 和 dva 中 dynamic 组件懒加载</li></ul></li><li><p>示例</p><p>假设我们有一个需求，需要在多个组件中添加用户认证逻辑。我们可以创建一个 HOC 来实现这个功能</p><ul><li><p>创建 HOC</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件，添加认证逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withAuth</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 模拟认证逻辑</span></span><br><span class="line">      <span class="keyword">const</span> isAuthenticated = <span class="literal">true</span>; <span class="comment">// 这里可以是实际的认证逻辑</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isAuthenticated) &#123;</span><br><span class="line">        <span class="comment">// 如果未认证，重定向到登录页面</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 如果已认证，渲染传入的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withAuth;</span><br></pre></td></tr></table></figure></li><li><p>使用 HOC</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withAuth <span class="keyword">from</span> <span class="string">&#x27;./withAuth&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要认证的组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dashboard</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Dashboard: You are authenticated!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 HOC 包装组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProtectedDashboard</span> = <span class="title function_">withAuth</span>(<span class="title class_">Dashboard</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(rootElement);</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ProtectedDashboard</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>何时使用高阶组件</p><ul><li><p><strong>逻辑复用</strong>：当你需要在多个组件中复用相同的逻辑时，可以考虑使用 HOC</p></li><li><p><strong>代码分离</strong>：HOC 可以帮助你将关注点分离，使组件更专注于自身的逻辑，而将通用逻辑抽离到 HOC 中</p></li><li><p><strong>增强功能</strong>：HOC 可以用于增强组件的功能，例如添加认证、权限控制、数据获取等</p></li></ul></li><li><p>注意事项</p><ul><li><p><strong>不要在 render 方法中使用 HOC</strong>：避免在组件的 <code>render</code> 方法中使用 HOC，因为这会导致每次渲染时都创建新的组件，影响性能</p></li><li><p><strong>静态方法和属性的丢失</strong>：HOC 会返回一个新组件，这可能会导致传入组件的静态方法和属性丢失。可以使用 <code>hoist-non-react-statics</code> 库来解决这个问题</p></li><li><p><strong>refs 转发</strong>：如果需要在 HOC 中访问传入组件的 ref，可以使用 React 的 <code>forwardRef</code> API</p></li></ul></li><li><p>关键点总结</p><ul><li><p><strong>高阶组件</strong>：一个函数，接收一个组件作为参数，并返回一个新的组件</p></li><li><p><strong>逻辑复用</strong>：通过 HOC 可以在多个组件之间共享逻辑，减少重复代码</p></li><li><p><strong>注意事项</strong>：避免在 <code>render</code> 方法中使用 HOC，处理静态方法和属性的丢失，以及使用 <code>forwardRef</code> 转发 refs</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：如何实现组件的懒加载"><a href="#Q5：如何实现组件的懒加载" class="headerlink" title="Q5：如何实现组件的懒加载"></a>Q5：如何实现组件的懒加载</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在React 18及以上版本中，组件的懒加载可以通过<code>React.lazy()</code>函数和<code>Suspense</code>组件实现</p><p>懒加载对于提升应用的启动速度和性能非常有帮助，尤其是在加载大型组件或库时</p><p>它允许组件仅在需要时才加载，而不是在首次加载应用时加载所有组件</p><p><strong>实现步骤</strong></p><ol><li><p><strong>使用<code>React.lazy</code>导入组件</strong>：<br><code>React.lazy</code>函数允许你定义一个动态加载的组件</p><p>这个函数接受一个函数作为其参数，这个函数需要动态调用<code>import()</code>方法，指向你想要懒加载的组件</p><p>返回值是一个<code>Promise</code>，它解析为一个<code>default</code>导出的React组件</p></li><li><p><strong>使用<code>Suspense</code>组件包裹懒加载组件</strong>：<br><code>Suspense</code>组件让你可以在组件树中“等待”某些东西的加载，并且可以指定一个加载指示器（例如加载旋转器），在等待时展示</p></li></ol><p><strong>示例</strong></p><p>假设有一个名为<code>SomeComponent</code>的组件，你希望对其进行懒加载:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用React.lazy和动态import()实现懒加载</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./SomeComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* Suspense 组件用来回退到加载指示器（如Spinner） */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">LazyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p><code>Suspense</code>和<code>React.lazy</code>目前仅支持默认导出的组件</p><p>如果你想要懒加载一个命名导出的组件，你需要在导出组件的文件中创建一个中间组件，将命名导出转换成默认导出</p></li><li><p>目前<code>Suspense</code>在服务端渲染(ssr)中只支持加载数据，不支持懒加载组件</p><p>React团队在未来版本中可能会增加这项支持</p></li><li><p>在使用路由时（如<code>react-router-dom</code>），你也可以结合路由懒加载，以实现按路由划分代码，进一步优化应用性能</p></li></ul><p>通过这种方式，你可以显著减少应用的初始加载时间，提升用户体验</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：常用组件"><a href="#Q6：常用组件" class="headerlink" title="Q6：常用组件"></a>Q6：常用组件</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>错误边界</strong></p><p>React部分组件的错误不应该导致整个应用崩溃，为了解决这个问题，React16引入了错误边界</p><p>使用方法：</p><p>React组件在内部定义了getDerivedStateFromError或者componentDidCatch，它就是一个错误边界。getDerviedStateFromError和componentDidCatch的区别是前者展示降级UI，后者记录具体的错误信息，它只能用于class组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">      <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  staic <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>:<span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">err,info</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err,info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Oops,err<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">from</span> <span class="string">&quot;./components/ErrorBoundary&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&quot;./components/ComponentA&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ComponentA</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentA</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误边界无法捕获自身的错误，也无法捕获事件处理、异步代码(setTimeout、requestAnimationFrame)、服务端渲染的错误</p><p><strong>Portal</strong></p><p>Portal提供了让子组件渲染在除了父组件之外的DOM节点的方式,它接收两个参数，第一个是需要渲染的React元素，第二个是渲染的地方(DOM元素)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child,container)</span><br></pre></td></tr></table></figure><p>用途：弹窗、提示框等</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Ffragments.html%23gatsby-focus-wrapper"><strong>Fragment</strong></a></p><p>Fragment提供了一种将子列表分组又不产生额外DOM节点的方法</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Fcontext.html%23gatsby-focus-wrapper"><strong>Context</strong></a></p><p>常规的组件数据传递是使用props，当一个嵌套组件向另一个嵌套组件传递数据时，props会被传递很多层，很多不需要用到props的组件也引入了数据，会造成数据来源不清晰，多余的变量定义等问题，Context提供了一种跨层级组件数据传递的方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;light&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ToolBar</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ToolBar</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">ThemeButton</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThemeButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-api.html%23suspense">Suspense</a></p><p>Suspense使组件允许在某些操作结束后再进行渲染，比如接口请求,一般与React.lazy一起使用</p><p>Transition</p><p>Transition是React18引入的一个并发特性，允许操作被中断，避免回到可见内容的Suspense降级方案</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：React-Children-map-和-js-的-map-有什么区别"><a href="#Q7：React-Children-map-和-js-的-map-有什么区别" class="headerlink" title="Q7：React.Children.map 和 js 的 map 有什么区别"></a>Q7：React.Children.map 和 js 的 map 有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>React.Children.map</code> 和JavaScript的数组<code>map</code>方法都用于遍历集合并对集合中的每一项应用一个函数，但它们之间存在一些关键的区别，特别是在应用场景和行为方面</p><p><strong>应用场景的区别</strong></p><ul><li><p><strong>JavaScript的<code>map</code>方法</strong></p><p>这是Array原型上的一个方法，用于遍历数组并对数组中的每一项执行给定的函数，最后返回一个新的数组</p><p>它是JavaScript数组操作的一部分，可以用于任何数组对象</p></li><li><p><strong><code>React.Children.map</code>方法</strong></p><p>这是React专门为处理<code>props.children</code>提供的方法</p><p>props.children<code>可能是不透明的数据结构，比如</code>Array<code>、</code>null<code>、</code>undefined<code>或单一的React元素</code></p><p><code>React.Children.map</code>方法解决了直接使用JavaScript数组的<code>map</code>方法处理<code>props.children</code>可能遇到的问题，它能够为我们智能处理这些情况</p></li></ul><p><strong>行为差异</strong></p><ul><li><p><strong>对于<code>null</code>和<code>undefined</code>的处理</strong></p><p>当<code>props.children</code>为<code>null</code>或<code>undefined</code>时，<code>React.Children.map</code>会直接返回<code>null</code>或<code>undefined</code>，而不会尝试进行任何遍历，这意味着它在处理空子节点时更加安全</p><p>相比之下，JavaScript的<code>map</code>方法在接收到<code>null</code>或<code>undefined</code>作为输入时会抛出异常，因为<code>null</code>和<code>undefined</code>并不是数组，也没有<code>map</code>方法</p></li><li><p><strong>键（key）管理</strong></p><p>当在React中处理多个子元素时，每个子元素应该有一个独一无二的“key”属性</p><p>React.Children.map<code>方法在遍历子元素时能够保留这些“key”的唯一性</code></p><p>在普通的JavaScript数组中使用<code>map</code>方法时，开发者需要手动管理这些“key”</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：React项目如何捕获错误"><a href="#Q8：React项目如何捕获错误" class="headerlink" title="Q8：React项目如何捕获错误"></a>Q8：React项目如何捕获错误</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 项目中，捕获和处理错误是确保应用稳定性和用户体验的重要部分</p><p>React 提供了多种方式来处理错误，包括错误边界（Error Boundaries）和使用 JavaScript 的 <code>try-catch</code> 语句</p><p>以下是一些常见的方法来捕获和处理错误</p><ol><li><p>使用错误边界（Error Boundaries）</p><p>错误边界是一个 React 组件，它可以捕获其子组件树中的 JavaScript 错误，并显示一个回退 UI，而不是崩溃整个应用。错误边界只能捕获生命周期方法和构造函数中的错误，不能捕获事件处理函数中的错误。</p><p><strong>创建一个错误边界组件</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 以触发下一次渲染时显示回退 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你可以在这里记录错误信息到日志服务</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error caught by ErrorBoundary:&quot;</span>, error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义回退 UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ErrorBoundary</span>;</span><br></pre></td></tr></table></figure><p><strong>使用错误边界组件</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">from</span> <span class="string">&#x27;./ErrorBoundary&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>捕获事件处理函数中的错误</p><p>错误边界不能捕获事件处理函数中的错误。你需要在事件处理函数中手动使用 <code>try-catch</code> 语句。</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 可能会抛出错误的代码</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error caught in event handler:&#x27;</span>, error);</span><br><span class="line">      <span class="comment">// 你可以在这里显示错误信息或采取其他措施</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>捕获异步代码中的错误</p><p>对于异步代码，如 <code>async</code>/<code>await</code>，你也需要使用 <code>try-catch</code> 语句来捕获错误。</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error caught in async function:&#x27;</span>, error);</span><br><span class="line">      <span class="comment">// 你可以在这里显示错误信息或采取其他措施</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Data will be fetched when component mounts.</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用第三方库</p><p>你还可以使用一些第三方库来捕获和处理错误，例如 Sentry 或者 LogRocket，这些库提供了更强大的错误监控和报告功能。</p><p><strong>示例（使用 Sentry）</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @sentry/react @sentry/tracing</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">&#x27;@sentry/react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Integrations</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@sentry/tracing&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&#x27;YOUR_SENTRY_DSN&#x27;</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">BrowserTracing</span>()],</span><br><span class="line">  <span class="attr">tracesSampleRate</span>: <span class="number">1.0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// Your app code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Sentry</span>.<span class="title function_">withProfiler</span>(<span class="title class_">App</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ol><li><strong>错误边界</strong>：用于捕获组件树中的错误，显示回退 UI</li><li><strong>事件处理函数中的错误</strong>：使用 <code>try-catch</code> 语句</li><li><strong>异步代码中的错误</strong>：使用 <code>try-catch</code> 语句</li><li><strong>第三方库</strong>：如 Sentry，提供更强大的错误监控和报告功能</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：React-memo-和useMemo-的用法是什么有哪些区别"><a href="#Q9：React-memo-和useMemo-的用法是什么有哪些区别" class="headerlink" title="Q9：React.memo()和useMemo()的用法是什么有哪些区别"></a>Q9：React.memo()和useMemo()的用法是什么有哪些区别</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>React.memo()</code></p><p><strong>用法</strong></p><p><code>React.memo()</code> 是一个高阶组件（Higher-Order Component），用于优化函数组件的性能</p><p>它通过对比前后两次的 props 来决定是否重新渲染组件，如果 props 没有变化，组件将不会重新渲染</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering MyComponent&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>MyComponent</code> 的 <code>name</code> prop 没有变化，组件将不会重新渲染。</p><p><strong>用法扩展</strong></p><p>可以通过传递自定义的比较函数来进一步控制渲染逻辑：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(</span><br><span class="line">  <span class="function">(<span class="params">&#123; name, age &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rendering MyComponent&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;! You are &#123;age&#125; years old.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prevProps.<span class="property">name</span> === nextProps.<span class="property">name</span> &amp;&amp; prevProps.<span class="property">age</span> === nextProps.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>useMemo()</code></p><p><strong>用法</strong></p><p><code>useMemo()</code> 是一个 React Hook，用于在组件中缓存计算结果</p><p>它接受一个创建函数和一个依赖数组，当依赖数组中的值发生变化时，创建函数会重新执行并返回新的值；否则，返回缓存的值</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sortedItems = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Sorting items&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">sort</span>();</span><br><span class="line">  &#125;, [items]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;sortedItems.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>sortedItems</code> 只有在 <code>items</code> 发生变化时才会重新计算，从而避免不必要的计算</p></li></ol><p><strong>区别</strong></p><ol><li><strong>用途不同</strong>：<ul><li><code>React.memo()</code>：用于优化整个函数组件的渲染，通过比较 props 来决定是否重新渲染组件</li><li><code>useMemo()</code>：用于在组件内部缓存计算结果，通过依赖数组来控制何时重新计算</li></ul></li><li><strong>使用场景不同</strong>：<ul><li><code>React.memo()</code>：适用于需要防止不必要的重新渲染的函数组件</li><li><code>useMemo()</code>：适用于需要在渲染过程中进行昂贵计算并希望缓存结果的场景</li></ul></li><li><strong>使用方式不同</strong>：<ul><li><code>React.memo()</code>：是一个高阶组件，包裹在函数组件外部</li><li><code>useMemo()</code>：是一个 Hook，使用在函数组件内部</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h1><h3 id="Q1：useCallback-和-useMemo-的使用场景"><a href="#Q1：useCallback-和-useMemo-的使用场景" class="headerlink" title="Q1：useCallback 和 useMemo 的使用场景"></a>Q1：useCallback 和 useMemo 的使用场景</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useCallback</code> 和 <code>useMemo</code> 是 React 的两个钩子（Hooks），它们的目的都是为了优化组件性能，但它们各自的使用场景和目标有所不同</p><ol><li><p><code>useCallback</code></p><p><code>useCallback</code> 钩子用于缓存函数，以便在组件重渲染时不会重新创建函数实例，减少不必要的渲染</p><p><strong>使用场景:</strong></p><ol><li><p>将函数传递给经过优化的子组件，并使用<code>React.memo</code>或<code>shouldComponentUpdate</code>时，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b], // 仅当a或b改变时，才会重新创建这个函数</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在依赖项列表不经常变化，且函数体内有高开销计算时</p></li></ol></li><li><p><code>`useMemo</code></p><p><code>useMemo</code> 钩子用于缓存计算得出的值，这意味着你可以告诉React仅在某些依赖项改变时才重新计算该值。</p><p><strong>使用场景:</strong></p><ol><li><p>高开销计算：当有一个复杂计算且其依赖项不经常变化时，<code>useMemo</code>可以确保只有在依赖项变化时才重新执行计算</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure></li><li><p>避免渲染时的不必要的子组件渲染</p><p>如果计算得到的值是对象、数组、函数等引用类型，并且这个值被用作子组件的<code>props</code>，则可以使用<code>useMemo</code>来保持引用的稳定，避免子组件做无用的渲染</p></li></ol></li><li><p>注意事项</p><ol><li><code>useCallback</code> 和 <code>useMemo</code> 不保证完全的稳定性，React可能会在内存不足的情况下丢弃缓存值</li><li>过度优化：在没有性能问题的情况下使用这些钩子可能会使你的代码更复杂，不一定总是需要它们</li><li>缓存机制并不是免费的，它们本身也有开销，因此不应该滥用</li></ol></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何实现一个定时器的-hook"><a href="#Q2：如何实现一个定时器的-hook" class="headerlink" title="Q2：如何实现一个定时器的 hook"></a>Q2：如何实现一个定时器的 hook</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>实现一个定时器的 Hook 可以帮助你在 React 函数组件中更方便地使用定时器功能，比如 <code>setTimeout</code> 和 <code>setInterval</code></p><p>下面是一个实现定时器 Hook 的示例，名为 <code>useInterval</code>，它允许你在组件中设置和清除定时器</p><p><strong>实现 <code>useInterval</code> Hook</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Custom hook to use setInterval in functional components</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">function</span>&#125; <span class="variable">callback</span> - The callback function to be called at each interval</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">delay</span> - The delay in milliseconds for the interval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useInterval</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> savedCallback = <span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the latest callback</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    savedCallback.<span class="property">current</span> = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up the interval</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">      savedCallback.<span class="title function_">current</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(tick, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useInterval;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>useInterval</code> Hook</strong></p><p>下面是一个使用 <code>useInterval</code> Hook 的示例组件。这个组件每秒更新一次计数器</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useInterval <span class="keyword">from</span> <span class="string">&#x27;./useInterval&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Timer</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li><p><strong>useRef</strong></p><p>我们使用 <code>useRef</code> 来保存最新的回调函数，以便在定时器触发时调用最新的回调</p></li><li><p><strong>useEffect (保存回调)</strong></p><p>在第一个 <code>useEffect</code> 中，我们将最新的回调函数保存到 <code>savedCallback</code> 中</p><p>每当回调函数变化时，这个 <code>useEffect</code> 会被触发，确保 <code>savedCallback</code> 始终是最新的</p></li><li><p><strong>useEffect (设置定时器)</strong></p><p>第二个 <code>useEffect</code> 设置了定时器</p><p>每当 <code>delay</code> 变化时，这个 <code>useEffect</code> 会被触发</p><p>如果 <code>delay</code> 不为 <code>null</code>，我们设置一个新的定时器，并在组件卸载或 <code>delay</code> 变化时清除之前的定时器</p></li></ol><p><strong>注意事项</strong></p><ol><li><p><strong>清除定时器</strong></p><p>在 <code>useEffect</code> 中返回一个清除定时器的函数，以确保在组件卸载或 <code>delay</code> 变化时，定时器被正确清除，避免内存泄漏</p></li><li><p><strong>依赖项</strong></p><p>确保在第二个 <code>useEffect</code> 中将 <code>delay</code> 作为依赖项传递，以便在 <code>delay</code> 变化时重新设置定时器</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：useState-的-state-是否可以直接修改？是否可以引起组件渲染"><a href="#Q3：useState-的-state-是否可以直接修改？是否可以引起组件渲染" class="headerlink" title="Q3：useState()的 state 是否可以直接修改？是否可以引起组件渲染"></a>Q3：useState()的 state 是否可以直接修改？是否可以引起组件渲染</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，<code>useState</code> 提供的状态值是不可变的，不能直接修改</p><p>直接修改状态值不仅违反了 React 的最佳实践，而且不会触发组件的重新渲染</p><p>这是因为 React 依赖于状态的不可变性来检测状态的变化并决定何时重新渲染组件</p><p><strong>为什么不能直接修改状态</strong></p><p>React 需要知道状态何时发生变化，以便重新渲染组件</p><p>如果直接修改状态，React 无法检测到变化，因为它没有办法知道状态的引用是否发生了变化</p><p>这会导致组件的 UI 不会更新，甚至可能引起难以调试的错误</p><p><strong>示例</strong></p><p>假设你有以下代码：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">incrementDirectly</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    count += <span class="number">1</span>; <span class="comment">// 直接修改状态（这是错误的做法）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 这里会显示更新后的 count 值</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">incrementProperly</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 使用 setCount 更新状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementDirectly&#125;</span>&gt;</span>Increment Directly<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementProperly&#125;</span>&gt;</span>Increment Properly<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，点击 <code>Increment Directly</code> 按钮不会导致组件重新渲染，因为直接修改 <code>count</code> 不会通知 React 状态已经改变</p><p>相反，点击 <code>Increment Properly</code> 按钮会正确更新状态并触发组件重新渲染</p><p><strong>正确的状态更新方式</strong></p><p>始终使用 <code>setState</code> 函数（<code>useState</code> 返回的更新函数）来更新状态</p><p>例如：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的状态更新方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li><strong>不可变性</strong>：<code>useState</code> 提供的状态值是不可变的，不能直接修改</li><li><strong>状态更新</strong>：始终使用 <code>setState</code> 函数来更新状态</li><li><strong>组件渲染</strong>：直接修改状态不会触发组件重新渲染，正确的状态更新方式会触发重新渲染</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：SetState是同步还是异步的"><a href="#Q4：SetState是同步还是异步的" class="headerlink" title="Q4：SetState是同步还是异步的"></a>Q4：SetState是同步还是异步的</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>setState是一个异步方法，但是在setTimeout/setInterval等定时器里逃脱了React对它的掌控，变成了同步方法</p><p>实现机制类似于vue的$nextTick和浏览器的事件循环机制，每个setState都会被react加入到任务队列，多次对同一个state使用setState只会返回最后一次的结果，因为它不是立刻就更新，而是先放在队列中，等时机成熟在执行批量更新</p><p>React18以后，使用了createRoot api后，所有setState都是异步批量执行的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：React-Hooks是什么"><a href="#Q5：React-Hooks是什么" class="headerlink" title="Q5：React Hooks是什么"></a>Q5：React Hooks是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Hooks 是 React 16.8 引入的一种新特性，它允许你在函数组件中使用状态和其他 React 特性，而不需要编写类组件</p><p>Hooks 提供了一种更简洁、更直观的方式来管理组件的状态和副作用</p><p>以下是一些常用的 React Hooks：</p><ol><li><p><code>useState</code></p><p><code>useState</code> 是一个 Hook，用于在函数组件中添加状态管理</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useEffect</code></p><p><code>useEffect</code> 是一个 Hook，用于在函数组件中处理副作用，例如数据获取、订阅或手动更改 DOM</p><p>它相当于类组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的组合</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted or updated&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空数组作为依赖项，表示只在挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Example Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useContext</code></p><p><code>useContext</code> 是一个 Hook，用于在函数组件中使用上下文</p><p>它允许你在组件树中传递数据，而不需要显式地通过每一层组件传递 props</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;Hello, World!&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><code>useReducer</code></p><p><code>useReducer</code> 是一个 Hook，用于在函数组件中管理复杂的状态逻辑</p><p>它类似于 Redux 的 reducer 概念</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useRef</code></p><p><code>useRef</code> 是一个 Hook，用于在函数组件中访问 DOM 元素或保存一个可变值，该值在整个组件的生命周期内保持不变</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TextInput</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">focusInput</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputEl.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;focusInput&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>useMemo</code></p><p><code>useMemo</code> 是一个 Hook，用于在函数组件中优化性能，通过记住计算结果，只有在依赖项变化时才重新计算</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ExpensiveCalculation</span> = (<span class="params">&#123; num &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Calculating...&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Result: &#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>`useCallback``</p><p><code>`useCallback</code> 是一个 Hook，用于在函数组件中优化性能，通过记住函数定义，只有在依赖项变化时才重新创建函数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; onClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button rendered&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 useCallback 记住这个回调函数，只有当 count 改变时才重新创建</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：React-事件和原生事件的执行顺序"><a href="#Q6：React-事件和原生事件的执行顺序" class="headerlink" title="Q6：React)事件和原生事件的执行顺序"></a>Q6：React)事件和原生事件的执行顺序</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，事件处理机制与原生 DOM 事件处理机制有一些不同</p><p>这些差异包括事件代理（event delegation）和合成事件（synthetic events）</p><p>理解 React 事件和原生事件的执行顺序有助于更好地调试和优化 React 应用</p><p><strong>React 事件系统</strong></p><p>React 使用合成事件（Synthetic Events）来处理事件</p><p>这种机制在所有浏览器中提供一致的事件行为，并且通过事件代理将所有事件处理程序附加到组件树的根节点上，从而提高性能</p><p><strong>执行顺序</strong></p><p>当一个事件被触发时，React 事件和原生事件的执行顺序如下：</p><ol><li><p><strong>原生事件捕获阶段</strong></p><p>在事件捕获阶段，事件从文档的根节点向下传播到目标元素</p><p>这时，任何在捕获阶段注册的原生事件处理程序都会被执行</p></li><li><p><strong>React 事件捕获阶段</strong></p><p>React 事件处理程序也可以在捕获阶段执行</p><p>如果你在 React 中使用捕获事件处理程序（通过在事件名后加 <code>Capture</code> 例如 <code>onClickCapture</code>），这些处理程序会在原生事件捕获阶段之后执行</p></li><li><p><strong>原生事件目标阶段</strong></p><p>在事件目标阶段，事件在目标元素上被触发，任何在目标元素上注册的原生事件处理程序会被执行</p></li><li><p><strong>React 事件目标阶段</strong></p><p>React 的合成事件处理程序会在目标阶段执行</p><p>这些处理程序会在原生事件处理程序之后执行</p></li><li><p><strong>原生事件冒泡阶段</strong></p><p>在事件冒泡阶段，事件从目标元素向上传播到文档的根节点</p><p>这时，任何在冒泡阶段注册的原生事件处理程序都会被执行</p></li><li><p><strong>React 事件冒泡阶段</strong></p><p>React 事件处理程序也可以在冒泡阶段执行</p><p>如果你在 React 中使用常规事件处理程序（例如 <code>onClick</code>），这些处理程序会在原生事件冒泡阶段之后执行</p></li></ol><p><strong>示例代码</strong></p><p>以下是一个示例，用于演示 React 事件和原生事件的执行顺序：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleNativeClickCapture</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Native Capture&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleNativeClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Native Bubble&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClick);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClickCapture, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClick);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;native-button&#x27;</span>).<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleNativeClickCapture, <span class="literal">true</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleReactClickCapture</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React Capture&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleReactClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;React Bubble&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">id</span>=<span class="string">&quot;native-button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClickCapture</span>=<span class="string">&#123;handleReactClickCapture&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;handleReactClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        Click Me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p><strong>执行顺序解释</strong></p><ol><li><strong>Native Capture</strong>：原生事件捕获阶段</li><li><strong>React Capture</strong>：React 事件捕获阶段</li><li><strong>Native Bubble</strong>：原生事件目标和冒泡阶段</li><li><strong>React Bubble</strong>：React 事件目标和冒泡阶段</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：为什么不能在循环、条件或嵌套函数中调用Hooks"><a href="#Q7：为什么不能在循环、条件或嵌套函数中调用Hooks" class="headerlink" title="Q7：为什么不能在循环、条件或嵌套函数中调用Hooks"></a>Q7：为什么不能在循环、条件或嵌套函数中调用Hooks</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 React 中，Hooks 是一套强大的 API，用于在函数组件中管理状态和副作用</p><p>然而，React 对 Hooks 的使用有一些严格的规则，其中之一就是不能在循环、条件语句或嵌套函数中调用 Hooks</p><p>这是因为 React 需要确保 Hooks 的调用顺序在每次渲染时都是一致的</p><p><strong>原因</strong></p><p>React 依赖于 Hooks 调用顺序来正确地管理状态和副作用</p><p>如果你在循环、条件语句或嵌套函数中调用 Hooks，Hooks 的调用顺序可能会在不同的渲染周期中发生变化，从而导致不可预测的行为和错误</p><p><strong>具体原因如下：</strong></p><ol><li><p><strong>Hooks 的调用顺序</strong></p><p>React 使用一个内部的调用栈来跟踪每个组件中的 Hooks 调用</p><p>如果 Hooks 的调用顺序在不同的渲染周期中发生变化，React 就无法正确地将状态和副作用与相应的组件实例对应起来</p></li><li><p><strong>状态和副作用的管理</strong></p><p>Hooks 是用来管理组件的状态和副作用的</p><p>如果它们的调用顺序不一致，React 可能会错误地更新状态或执行副作用，从而导致应用程序的行为异常</p></li></ol><p><strong>代码示例</strong></p><p>以下是一些违反规则的示例：</p><p><strong>在循环中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在条件语句中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在嵌套函数中调用 Hooks</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someFunction</span>();</span><br></pre></td></tr></table></figure><p><strong>正确的用法</strong></p><p>Hooks 应该在函数组件的顶层调用，确保每次渲染时它们的调用顺序都是一致的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确的用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以在条件语句中使用状态或副作用，但不能在条件语句中调用 Hooks</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行一些逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React 的官方规则</strong></p><p>React 官方提供了两条使用 Hooks 的规则：</p><ol><li><strong>只在最顶层调用 Hooks</strong>：不要在循环、条件语句或嵌套函数中调用 Hooks</li><li><strong>只在 React 函数组件和自定义 Hooks 中调用 Hooks</strong>：不要在普通的 JavaScript 函数中调用 Hooks</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：useRef-ref-forwardsRef-的区别是什么"><a href="#Q8：useRef-ref-forwardsRef-的区别是什么" class="headerlink" title="Q8：useRef/ref/forwardsRef 的区别是什么"></a>Q8：useRef/ref/forwardsRef 的区别是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>useRef</code></p><p><code>useRef</code> 是一个 React Hook，主要用于在函数组件中创建一个可变的引用对象</p><p>它可以用来持久化某个值，或者引用一个 DOM 元素</p><p><strong>用途</strong></p><ol><li>持久化某个值，不会因为组件的重新渲染而丢失</li><li>直接访问 DOM 元素</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ref</code></p><p><code>ref</code> 是一个属性，用于在类组件中创建对 DOM 元素或 React 组件实例的引用</p><p>它可以通过 <code>React.createRef</code> 创建</p><p><strong>用途</strong></p><ol><li>在类组件中引用 DOM 元素或组件实例</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>forwardsRef</code> </p><p><code>forwardRef</code> 是一个高阶组件，用于将 ref 转发到子组件</p><p>它允许父组件通过 ref 直接访问子组件的 DOM 元素或组件实例</p><p><strong>用途</strong></p><ol><li>在高阶组件中转发 ref</li></ol><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以接收 ref 的子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyInput</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，自动聚焦到 input 元素</span></span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ul><li><strong><code>useRef</code></strong>: 用于在函数组件中创建一个可变的引用对象，主要用于持久化某个值或引用 DOM 元素</li><li><strong><code>ref</code></strong>: 用于在类组件中创建对 DOM 元素或组件实例的引用，通过 <code>React.createRef</code> 创建</li><li><strong><code>forwardRef</code></strong>: 用于将 ref 转发到子组件，允许父组件通过 ref 直接访问子组件的 DOM 元素或组件实例</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：useEffect-的第二个参数-传空数组和传依赖数组有什么区别"><a href="#Q9：useEffect-的第二个参数-传空数组和传依赖数组有什么区别" class="headerlink" title="Q9：useEffect 的第二个参数,传空数组和传依赖数组有什么区别"></a>Q9：useEffect 的第二个参数,传空数组和传依赖数组有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>传空数组 (<code>[]</code>)</p><p>当你将一个空数组作为 <code>useEffect</code> 的第二个参数时，意味着这个副作用只会在组件挂载（即第一次渲染）和卸载时执行一次</p><p>它类似于类组件中的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code> 生命周期方法</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component mounted&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>MyComponent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><strong>挂载时</strong>: <code>console.log(&#39;Component mounted&#39;)</code> 会在组件挂载时执行</li><li><strong>卸载时</strong>: 返回的清理函数 <code>console.log(&#39;Component will unmount&#39;)</code> 会在组件卸载时执行</li></ul></li><li><p>传依赖数组（如 <code>[dependency1, dependency2]</code>）</p><p>当你将一个包含依赖项的数组作为 <code>useEffect</code> 的第二个参数时，意味着这个副作用会在组件挂载以及依赖项发生变化时执行</p><p>每次依赖项发生变化时，副作用都会重新执行</p><p><strong>示例</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect executed because count changed&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Cleanup executed because count changed&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><ul><li><strong>挂载时</strong>: <code>console.log(&#39;Effect executed because count changed&#39;)</code> 会在组件挂载时执行</li><li><strong>依赖项变化时</strong>: 当 <code>count</code> 发生变化时，副作用会重新执行</li><li><strong>清理副作用</strong>: 返回的清理函数 <code>console.log(&#39;Cleanup executed because count changed&#39;)</code> 会在组件卸载或依赖项变化之前执行</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>传空数组 (<code>[]</code>)</strong>:<ul><li>副作用只会在组件挂载和卸载时执行一次</li><li>类似于类组件中的 <code>componentDidMount</code> 和 <code>componentWillUnmount</code></li></ul></li><li><strong>传依赖数组（如 <code>[dependency1, dependency2]</code>）</strong>:<ul><li>副作用会在组件挂载时执行，并且在任意一个依赖项发生变化时重新执行</li><li>类似于类组件中的 <code>componentDidUpdate</code>，同时也会在组件卸载时执行清理函数</li></ul></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：实现-个-useTimeout-Hook"><a href="#Q10：实现-个-useTimeout-Hook" class="headerlink" title="Q10：实现-个 useTimeout Hook"></a>Q10：实现-个 useTimeout Hook</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>useTimeout</code> 是可以在函数式组件中，处理 <code>setTimeout</code> 计时器函数</p><p><strong>解决了什么问题？</strong></p><p>如果直接在函数式组件中使用 <code>setTimeout</code> ，会遇到以下问题：</p><ul><li>多次调用setTimeout</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">   <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="number">1</span>);  </span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">       <span class="title function_">setState</span>(state + <span class="number">1</span>);  </span><br><span class="line">   &#125;, <span class="number">3000</span>);  </span><br><span class="line">   <span class="keyword">return</span> (  </span><br><span class="line">       <span class="comment">// 我们原本的目的是在页面渲染完3s后修改一下state，但是你会发现当state+1后，触发了页面的重新渲染，就会重新有一个3s的定时器出现来给state+1，既而变成了每3秒+1。  </span></span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123;state&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">   );  </span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure><ul><li>hooks 的闭包缺陷</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">const</span> [countTimeout, setCountTimeout] = <span class="title function_">useState</span>(<span class="number">0</span>)  </span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">          <span class="title function_">setCountTimeout</span>(count)  </span><br><span class="line">      &#125;, <span class="number">3000</span>)  </span><br><span class="line">      <span class="title function_">setCount</span>(<span class="number">5</span>)  </span><br><span class="line">  &#125;, [])  </span><br><span class="line">  <span class="keyword">return</span> (  </span><br><span class="line">       <span class="comment">//count发生了变化，但是3s后setTimout的count却还是0  </span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          Count: &#123;count&#125;  </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">br</span> /&gt;</span>  </span></span><br><span class="line"><span class="language-xml">          setTimeout Count: &#123;countTimeout&#125;  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">  )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>useTimeout 实现</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTimeout</span>(<span class="params">callback, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memorizeCallback = <span class="title function_">useRef</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    memorizeCallback.<span class="property">current</span> = callback;</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        memorizeCallback.<span class="title function_">current</span>();</span><br><span class="line">      &#125;, delay);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [delay]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>如何使用</strong></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback 回调函数， delay 延迟时间</span></span><br><span class="line"><span class="title function_">useTimeout</span>(callback, delay);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h3 id="Q1：React-中为什么不直接使用requestldleCallback"><a href="#Q1：React-中为什么不直接使用requestldleCallback" class="headerlink" title="Q1：React 中为什么不直接使用requestldleCallback"></a>Q1：React 中为什么不直接使用requestldleCallback</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>requestIdleCallback</code> 是一个允许开发者在主线程空闲时运行低优先级函数的 Web API</p><ol><li><p>一致性问题</p><ul><li><p>由于 <code>requestIdleCallback</code> 的执行时机依赖于浏览器的空闲周期，这会导致在不同浏览器和设备上有不一致的行为</p><p>React 旨在提供一个一致且可预测的性能表现，以确保开发者能够构建跨平台的、具有一致体验的应用</p><p>这种不确定性是 React 选择不直接采用 <code>requestIdleCallback</code> 的一个主要原因</p></li></ul></li><li><p>实时性问题</p><ul><li><p>React 的核心之一是能够快速响应用户输入并立即更新 UI</p><p><code>requestIdleCallback</code> 执行的时间可能不足以满足这种实时性需求，尤其是在高优先级的更新（如动画或响应用户输入）应该立即发生时</p><p>这种潜在的延迟对于保持良好的用户体验来说是不可接受的。</p></li></ul></li><li><p>调度器控制</p><ul><li><p>React 内部实现了一个任务调度器，负责根据任务的优先级来管理和调度它们的执行</p><p>这样的设计允许 React 在保持用户界面响应性的同时进行高效的背景更新</p><p>直接使用 <code>requestIdleCallback</code> 可能会干扰这种精细调度策略，从而引起不可预测的行为</p></li><li><p>为了克服这些挑战，React 引入了 Scheduler 模块</p><p>Scheduler 模块使得 React 能够以更细粒度的方式安排任务的执行，确保关键任务（如用户输入响应）得到及时处理，同时也使得可以在浏览器空闲时执行低优先级任务</p><p>这种方法提供了更高的控制度和一致性，同时也保留了在合适的时机执行后台任务的能力</p></li></ul></li><li><p>总结</p><ul><li><p>综上所述，虽然 <code>requestIdleCallback</code> 提供了在浏览器空闲时执行任务的有趣机制，但对于 React 这样需要高度一致性、响应实时性，并且具有细粒度调度控制要求的库而言，直接使用它并不符合需求</p><p>React 通过实现 Scheduler 模块，提供了一个更加适配其内部机制的解决方案，既保证了应用的响应性和用户体验，也实现了背景任务的有效管理。这种设计选择反映了 React 团队对于性能优化和用户体验优先级的综合考虑</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：React-中为什么要使用-Hook"><a href="#Q2：React-中为什么要使用-Hook" class="headerlink" title="Q2：React 中为什么要使用 Hook"></a>Q2：React 中为什么要使用 Hook</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>简化代码结构</p><p>Hooks 使得函数组件可以处理状态和副作用，从而避免了类组件中复杂的生命周期方法和 <code>this</code> 绑定问题</p><p>函数组件通常更简洁、更直观</p></li><li><p>逻辑复用</p><p>在类组件中，共享状态逻辑通常需要使用高阶组件（HOC）或 Render Props，这可能导致组件层级嵌套过深</p><p>Hooks 允许你通过自定义 Hook 来提取状态逻辑，从而实现更好的逻辑复用和代码组织</p></li><li><p>更好的代码可读性和可维护性</p><p>使用 Hooks 可以将组件的逻辑按功能分块，而不是按生命周期方法分块</p><p>这使得代码更容易理解和维护</p><p>例如，一个自定义 Hook 可以封装数据获取逻辑，而另一个自定义 Hook 可以封装表单处理逻辑</p></li><li><p>避免类组件的复杂性</p><p>类组件中的 <code>this</code> 关键字使用容易出错，特别是对于初学者</p><p>Hooks 通过函数组件完全避免了 <code>this</code> 的使用，从而减少了错误和困惑</p></li><li><p>更细粒度的状态控制</p><p>Hooks 提供了更细粒度的状态控制</p><p>你可以使用多个 <code>useState</code> 或 <code>useReducer</code> Hook 来管理不同的状态变量，而不是将所有状态都放在一个大的 state 对象中</p></li><li><p>更好的性能优化</p><p>Hooks 使得 React 的性能优化（如 <code>useMemo</code> 和 <code>useCallback</code>）更加直观和易于使用，从而减少不必要的重新渲染和性能开销</p></li><li><p>常用的 Hooks</p><ul><li><p><code>useState</code>: 用于在函数组件中添加状态</p></li><li><p><code>useEffect</code>: 用于在函数组件中处理副作用（如数据获取、订阅等）</p></li><li><p><code>useContext</code>: 用于在函数组件中使用 React 的上下文</p></li><li><p><code>useReducer</code>: 用于在函数组件中管理复杂的状态逻辑</p></li><li><p><code>useMemo</code> 和 <code>useCallback</code>: 用于性能优化，避免不必要的计算和函数创建</p></li><li><p><code>useRef</code>: 用于访问 DOM 元素或保持不需要重新渲染的变量</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：key-的作用是什么"><a href="#Q3：key-的作用是什么" class="headerlink" title="Q3：key 的作用是什么"></a>Q3：key 的作用是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在React中，<code>key</code> 是一个特殊的属性，你应该在映射组件的列表时包含它</p><p>它的主要作用是帮助React识别哪些项已经改变、添加或者删除的</p><p>正确使用<code>key</code>可以带来一些重要的性能优化</p><p><strong>作用</strong></p><ol><li><p><strong>唯一性</strong></p><p>React使用<code>key</code>来匹配组件树上的组件实例与重新渲染过程中的新元素</p><p>key`需要是唯一的，以便于区分同一父元素下的不同子元素</p></li><li><p><strong>重用与重排序</strong></p><p>当组件的列表顺序改变时，<code>key</code>可以帮助React确定哪些组件可以保留并重新排序，而不是销毁重新创建</p><p>这可以提高效率和性能</p></li><li><p><strong>状态保留</strong></p><p>如果组件状态需要跨渲染周期保持一致，<code>key</code>用于追踪哪些组件是保持不变的</p><p>这意味着如果组件的<code>key</code>没有改变，它的状态会保持不变</p></li><li><p><strong>避免不必要的重新渲染</strong></p><p>当列表变动时，如果没有<code>key</code>，React将重新渲染整个列表，增加开销</p><p>合适的<code>key</code>确保组件能够正确地被复用，只有变动的部分被重新渲染</p></li></ol><p><strong>错误用法</strong></p><ul><li><p><strong>使用索引作为<code>key</code></strong></p><p>在一些情况下，使用数组索引作为<code>key</code>是可以的，比如静态列表或者不进行排序和修改的列表</p><p>但是如果项的顺序可能会改变，这会导致性能问题甚至错误的行为，因为React依赖于<code>key</code>来识别子元素</p></li><li><p><strong>随机生成的<code>key</code></strong></p><p>如果<code>key</code>是在每次渲染时生成的（如使用<code>Math.random()</code>），这将导致组件的不必要重渲染，因为React会认为<code>key</code>在每次渲染时都是新的</p></li></ul><p>在选择<code>key</code>的时候，最好使用能够代表列表项唯一性的字符串，这通常是来自数据本身的ID或者哈希值</p><p>这样做不仅保证了性能，也保证了组件状态的稳定</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：基于-React-框架的特点，可以有哪些优化措施"><a href="#Q4：基于-React-框架的特点，可以有哪些优化措施" class="headerlink" title="Q4：基于 React 框架的特点，可以有哪些优化措施"></a>Q4：基于 React 框架的特点，可以有哪些优化措施</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React是一个用于构建用户界面的JavaScript库，特别强调了组件化开发和声明式编程</p><p>虽然React自身提供了高效的渲染策略，但在实际开发中我们仍然可以通过多种方式来进一步优化应用性能和用户体验</p><p>以下是一些常用的React应用优化措施：</p><ol><li><p>使用<code>React.memo</code>优化组件渲染</p><p><code>React.memo</code>是一个高阶组件，它仅在组件的props发生变化时才重新渲染组件，从而避免了不必要的渲染</p></li><li><p>懒加载组件</p><p>对于大型应用，采用代码拆分和组件的懒加载非常有效</p><p>可以使用<code>React.lazy</code>和<code>Suspense</code>来按需加载组件，减少初始加载时间</p></li><li><p>使用<code>shouldComponentUpdate</code>或<code>React.PureComponent</code></p><p>在类组件中，通过实现<code>shouldComponentUpdate</code>方法，你可以控制组件是否需要更新</p><p><code>React.PureComponent</code>提供了一个浅比较的<code>shouldComponentUpdate</code>实现方式，如果你的组件渲染完全由props和state决定，这是一个很好的选择</p></li><li><p>键值(Key)优化</p><p>在渲染列表时，合理使用<code>key</code>可以帮助React识别哪些元素改变了、添加或删除</p><p>这可以提高渲染效率，减少重新渲染的开销</p></li><li><p>合理使用状态(State)和副作用(Effect)</p><ul><li>避免在一个组件内部过度使用状态，尤其是当数据可以通过props传递时</li><li>使用<code>useEffect</code>的依赖数组来精确控制副作用的执行时机，避免不必要的执行</li></ul></li><li><p>使用Context提供者和消费者模式优化</p><p>使用React的Context API可以避免<code>props</code>的层层传递，但是若不当使用也可能造成不必要的渲染</p><p>合理使用<code>useContext</code>钩子或<code>Context.Consumer</code>可以优化这一点</p></li><li><p>避免匿名函数和对象字面量作为props</p><p>组件的props中使用匿名函数和对象字面量会在每次父组件渲染时创建新的实例，这可能导致不必要的子组件渲染</p><p>可以通过使用useCallback和useMemo来避免这种情况</p></li><li><p>动态导入库和代码</p><p>利用<code>import()</code>函数可以实现对代码和库的动态导入，进一步减少应用的初始大小。</p></li><li><p>服务端渲染(SSR)</p><p>通过服务端渲染可以提高首屏加载速度，提升SEO性能。React提供了库如Next.js支持服务端渲染</p></li><li><p>使用Webpack优化构建</p><p>使用Webpack进行代码拆分，提取公共库，压缩代码，利用缓存策略等技术可以减少应用的加载时间</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：react-router-和-react-router-dom-的有什么区别"><a href="#Q5：react-router-和-react-router-dom-的有什么区别" class="headerlink" title="Q5：react-router 和 react-router-dom 的有什么区别"></a>Q5：react-router 和 react-router-dom 的有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>React Router 是一个用于在 React 应用中实现路由功能的库，而 <code>react-router-dom</code> 是其专门为浏览器环境设计的一个子包</p><p>为了更好地理解它们之间的区别，下面是详细的解释：</p><p><strong>React Router</strong></p><p><code>react-router</code> 是 React Router 库的核心包，包含了实现路由功能的核心逻辑</p><p>这个包可以在各种环境中使用，如浏览器、React Native、Electron 等</p><p>它提供了基础的路由组件和 API，例如：</p><ul><li><code>Router</code></li><li><code>Route</code></li><li><code>Switch</code></li><li><code>Redirect</code></li><li><code>Link</code></li><li><code>NavLink</code></li></ul><p><strong>React Router DOM</strong></p><p><code>react-router-dom</code> 是专门为浏览器环境设计的一个包，它依赖于 <code>react-router</code>，并在其基础上添加了一些特定于浏览器的功能和组件</p><p>这个包提供了浏览器特有的路由组件和 API，例如：</p><ul><li><code>BrowserRouter</code></li><li><code>HashRouter</code></li><li><code>Link</code></li><li><code>NavLink</code></li><li><code>Prompt</code></li><li><code>Redirect</code></li></ul><p><strong>主要区别</strong></p><ol><li><strong>使用环境</strong>：<ul><li><code>react-router</code> 是核心库，可以在多种环境中使用</li><li><code>react-router-dom</code> 是专门为浏览器环境设计的</li></ul></li><li><strong>组件</strong>：<ul><li><code>react-router</code> 提供了基本的路由组件，如 <code>Route</code>、<code>Switch</code> 等</li><li><code>react-router-dom</code> 在 <code>react-router</code> 的基础上，提供了浏览器特有的组件，如 <code>BrowserRouter</code>、<code>HashRouter</code> 等</li></ul></li><li><strong>依赖关系</strong>：<ul><li><code>react-router-dom</code> 依赖于 <code>react-router</code>，并扩展了其功能</li></ul></li></ol><p><strong>示例</strong></p><p>以下是一个使用 <code>react-router-dom</code> 的简单示例：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">About</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">About</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>BrowserRouter</code> 是 <code>react-router-dom</code> 提供的一个组件，用于在浏览器环境中实现路由</li><li><code>Link</code> 是 <code>react-router-dom</code> 提供的用于导航的组件</li><li><code>Route</code> 和 <code>Switch</code> 是 <code>react-router</code> 提供的基础路由组件</li></ul><p><strong>总结</strong></p><ul><li><strong><code>react-router</code></strong> 是 React Router 的核心包，包含了基础的路由功能，可以在多种环境中使用</li><li><strong><code>react-router-dom</code></strong> 是专门为浏览器环境设计的包，扩展了 <code>react-router</code> 的功能，提供了浏览器特有的路由组件</li></ul>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端输出PDF</title>
    <url>/posts/58a85856/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>项目开发</tag>
      </tags>
  </entry>
  <entry>
    <title>学习ThreeJS汇总</title>
    <url>/posts/b058a725/</url>
    <content><![CDATA[<div class='checkbox gray'><input type="checkbox" />
            <p><a href="">基础环境搭建</a></p>
            </div>
<h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><div class='checkbox gray'><input type="checkbox" />
            <p><a href="">Camara</a></p>
            </div>
<div class='checkbox gray'><input type="checkbox" />
            <p><a href="">Array Camera</a></p>
            </div>
<div class='checkbox gray'><input type="checkbox" />
            <p><a href="">Cinematic Camera</a></p>
            </div>
<div class='checkbox gray'><input type="checkbox" />
            <p><a href="">Logarithmicdepthbuffer Camera</a></p>
            </div>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title>客户服务事项</title>
    <url>/posts/ed91bbf9/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6f436b2c4efbc0fb82817b17b455aed1763c409ff8dd6274f290f895e30e9c26">a2ff4597c1c7c4165c5922327a90033b5ee5225b01df72b96a49a8a3bf7b411a4ae0099bee113b30416252ad82f7841327671a6a9fceaf91e16515383ffd852ac34a6ae094518555e566e6bf739dcf5723115b9d233b1ce5fd817698be2c02ee5576b94230ae098a3a8e802c323fbb33764072bef4d85c5b2f824b0757c8c779a97ed3c38f3a8744af47fd6b42c7cf8b9ed9040fa1421eb72516a41ce7aea4bc49b158f9bf8f50824810fb011a583558db5d585c218b252e097eb12f10c2123ac88434b1b1e5d9340f3e57f1659940e23f1459364bef1987c97ff1b3baba3d83ff260845d385d9277dfd9438d080199ee376eea7d6262a35599de781a43980cbff3279eceab4d3a22a7c83a31c95c6f826c4e02aac28a78c8e14ccda09d9802689856b7472aed674d023f916b3773e9676cb23250ba5b990d42d4e91007183858aaec317a0c81b9981ec80bf7fc98c0f35ff74c088428ab33615328b822092f87b1f29722a88fd0d12096bf61719b0409b0ab5ba5f22212eed21b23a7e932874f8a8cca961b3b6b8ed0539e6028e26d6d62f79809dab4a99f30ee956276081da8866a115bf7b30148fcf652134581bad3ced417451539c6f454c8707b9fb1cf792f535f5ae25dfca79c6440fd2d6f3e1c3a5e3487906f3b9beaa0b21c6d914f4ff911e4be21cc1f28e2cee77b6493253387e482230cbafac054fe882b18c215733b3ec512cc5e3f1b21d2cdfc04a2d00eb3d9fde28cb99b41586d0abdba5520c87cccfda70d7d363277d59cc7dd3f2c6aedc7d5d99b7d8ec26c6e5a4eba6bddf113960ea4241cfdce2f4e811384c749024970badb70cf288640122d314b5bf3717ddeb59cb2d5c5dbc4ee3f184dd7f87f57073dd2deea1f1b826348f1c64b007fcce962179d9302c629624b532a0278f6997db81bd2006720f510941b9f63854b5b01c3e7d65f2775fa4b2a8146fb8cb049150007cb3012dd5d0c3083a04f932b18283fd2d0f961efd118e6fc506c19b64fdb83cb8d0063cc8ec4f6fcef0dfa0672a008c1a50fa6d59459b61fcbc0a4ed0e6f96d39bae913b60ba3d044687d9085ab48d720988b3f2cea492b5f043d91efbba3e944d5dc7ddd6c652a7907064c1ff08d2d5684efc5552f23c80b7cd81de5f16a3c699f201f476f5b3e33a2d9974d399778933572d9983c7ce087199dd6ad66cce0987565597ec166777cc3544217831a7889359b7ba748f569b9efa86c4e89a206793cb67968e189d7352b445b18de559105af60675e8e5dad28537a73d87d241d5a53584528828aec4b8402d68ac5341b1d019eae6021033e512eebe64242ede214b3029939a71e016c14cd57820dae611bdc1d6a5083dbbefd58bbc9fed12287d58d81535db8c74c3ce5ac8fa48fde6b88f5b9e5a9bc89772775e086372cee58b9048c81c94466257ebad73b3d1b9972322336813bd6e58523dbe366ab33ad87fe063c27361c8679d104560a6fc2f468e032248d4cb075523424f788c16f1f1c4a6881b78201b2fd88189cdcb9947408b51dd0e0cd99278f84aeb416c0515b497b7ba324d25cb7efc6a1992d07f36ec9ecb0acb1f71a89d09bac855913bef5d6465b8045f56e31f6341e7a91701555dffce3071e8014a61c665f750cf33fe3937dc7a0034c8a8284e8edd3c9807a911c11e20c9bbe2dd64193c6029f1dfdf2f4659e1374a6f67524b03e44e78a425acf62b59060982f2f8df54c5ee1b4ee0993a7c81b31211f851faf5ea768a8b4fd06ac080dc1c135f7fa85cb844127c846ba3441454fd39f0eeef6ac586be6b97100385ccc354c65b317d0b35fa9750d960554516a4bcac10b8eda7d9466a2da842ba965d766fa1d60af9eb2a8233eb1b2bc8e6585287e0271193f67082b7f9121d1c6d4b719f75e62e43c1d0c273c7fdc7602d47d79bff35b543cbfe26ff3a73a15f3d8004f47081a8118c54e13fa62dd86fca61cf3ee3685cc925a3ca39cb51514ce733c893dca2d2d93ff8b9ad27ba7c7bae51b608dc040aba3c3a3166633249625bca8b3d0feb85c8df2b4e8ac5afaba859fd769e1bc2474f6a2bd451a16393bae07138c8ab4c4eaef50ff58d09d3ed3d95042201271301c7272567247aec064881f5c14123fe4baf1da131307cac7fbe6cecba614940f87e872edc26838e481bde171f90ed2f31f8caf19b7d7dee9783a4e76126dc94037ea2fb4723aa086f87999322c828ed2d9bd0cb62f5ed983d77f1caa98f242e1f7d56f83c75f5f06138fc2d6d55f3309bfe5d8824247ff9ce81c8951e0223e90fac7376710ff9551a35cf939e765626e9d06fab537567f8662096c3e17801d70238a938900a7e5247ce243fe046c45163945b7f2a757cb872f2b99d61dee12c3bbf1cd61302b3c0a3e4604be3a2d2b22ef0b53d4a4007647439f4c53300231f5a1c61dd6740e1b01f6620e3445a8399c3c1401e5990dbb27961535b4c5579b4768edcc7fbfbf75354c952916a25eae1799db9efba45664142d8f1943467ba7906eff814dd82771966a08a5e8a008922a328fd169e42f1d0e3a7749f15541b8b15c96307cf5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my article, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>self</tag>
      </tags>
  </entry>
  <entry>
    <title>《浏览器 &amp;&amp; 计算机网络 面试题》</title>
    <url>/posts/4d830755/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：浏览器的同源策略是什么"><a href="#Q1：浏览器的同源策略是什么" class="headerlink" title="Q1：浏览器的同源策略是什么"></a>Q1：浏览器的同源策略是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>同源策略（Same-Origin Policy）是浏览器中一种关键的安全策略，它定义了浏览器如何限制一个网页文档或脚本从一个源加载的文档或脚本与来自其他源的资源进行交互。同源是指协议、主机和端口号都相同。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>同源策略的主要目的是防止恶意网站通过脚本等手段，访问用户在其他网站上的敏感信息，从而保护用户的隐私和安全。</p><p>同源策略限制了以下操作：</p><ol><li><strong>Cookie、LocalStorage 和 IndexDB：</strong> 一个网页只能访问自己域下的 Cookie、LocalStorage 和 IndexDB，无法访问其他域下的存储。</li><li><strong>DOM：</strong> 不能使用 JavaScript 获取或修改其他网页的 DOM。</li><li><strong>AJAX 请求：</strong> 不能通过 AJAX 请求向其他域发送请求。</li></ol><p>同源策略的例外情况包括：</p><ul><li><strong>跨域资源共享（CORS）：</strong> 服务器可以设置响应头，允许来自其他域的请求访问资源。</li><li><strong>JSONP：</strong> 通过动态创建 <code>&lt;script&gt;</code> 标签，可以加载其他域上的脚本。</li><li><strong>图片、样式、脚本等资源文件：</strong> 可以通过相关标签加载其他域上的资源。</li></ul><p>虽然同源策略提供了一定程度的安全性，但也限制了一些正常的 Web 开发操作。为了实现跨域访问，需要服务器端和客户端进行一些配置，以确保安全的数据交换</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：谈谈你对浏览器中进程和线程的理解"><a href="#Q2：谈谈你对浏览器中进程和线程的理解" class="headerlink" title="Q2：谈谈你对浏览器中进程和线程的理解"></a>Q2：谈谈你对浏览器中进程和线程的理解</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在谈论浏览器中的进程和线程时，我们首先需要明确这两个概念的基本区别。在操作系统中，进程和线程是程序执行的基本单位，但它们在资源管理和执行方式上有所不同。</p><ol><li><p><strong>进程（Process）</strong></p><ul><li>进程是操作系统分配资源和调度的独立单位，每个进程都拥有自己的一套虚拟内存、全局变量等资源</li><li>进程之间是相互独立的，一个进程崩溃不会直接影响到其他进程。为了实现进程间的通信，需要特定的IPC（进程间通信）机制</li><li>在浏览器中，不同的标签页通常运行在不同的进程中（取决于浏览器及其版本）。这种设计可以增强网页的稳定性、安全性和响应性。例如，如果一个标签页崩溃，其他标签页仍可以正常工作</li></ul></li><li><p><strong>线程（Thread）</strong></p><ul><li>线程是进程内的执行单位，同一进程内的线程共享该进程的资源</li><li>线程之间的通信和切换开销比进程之间要小很多，因此在同一个进程内并发执行多个任务时，通常会使用多线程</li><li>浏览器中的进程通常包含多个线程，包括渲染线程、JS执行线程、事件触发线程、网络请求线程等。这些线程共同工作，让我们能够享受流畅且互动性强的网页体验</li></ul></li><li><p><strong>浏览器中进程和线程的交互</strong></p><ul><li><p><strong>渲染进程</strong></p><p>大多数浏览器采用多进程架构，每个标签页一般对应一个渲染进程，这个进程里包含了渲染线程、JS执行线程等</p></li><li><p><strong>JS执行线程</strong></p><p>这是渲染进程中的一个线程，负责执行JS脚本</p><p>值得注意的是，JS执行线程是单线程的，意味着同一时间只能执行一个JS任务</p></li><li><p><strong>事件触发线程</strong></p><p>属于浏览器的事件处理模型，用来控制事件循环，处理用户交互、定时器等异步任务</p></li><li><p><strong>网络请求线程</strong></p><p>浏览器中专门处理网络请求的线程，例如加载网页、下载文件等</p></li></ul></li></ol><p>由于浏览器是多进程的，它可以同时处理多个任务，如打开多个标签页</p><p>而浏览器的多线程能力则确保了在单个进程内可以高效地并行处理渲染、JS执行、事件处理等任务</p><p>这种多进程加多线程的架构让现代浏览器能够提供复杂且响应迅速的网络应用，同时也保证了网页运行的稳定性和安全性</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>浏览器中的进程和线程之间的通信主要通过以下方式进行：</p><ol><li><p>进程间通信（IPC）</p><ul><li><p>进程是独立的运行单元，每个进程拥有自己的资源和内存空间，不同进程的内存空间彼此隔离</p><p>因此为了在进程之间传递信息，浏览器需要使用IPC（Inter-Process Communication，进程间通信）机制</p></li><li><p>IPC可以通过不同的方式实现，例如通过管道（Pipe）、信号（Signal）、套接字（Socket）、消息队列（Message queue）、共享内存等方式进行数据传输</p><p>但是，这种机制通常对于浏览器来说是透明的，浏览器会接管这部分工作，我们在使用浏览器时不需要处理这种底层细节</p></li></ul></li><li><p>线程间通信</p><p>同一进程内的线程共享该进程的内存空间和资源，因此线程间的通信相对简单一些。下面的一些方式可以用于线程间的通信：</p><ul><li><p><strong>共享变量</strong></p><p>由于线程间共享内存，因此可以通过在共享内存中设置变量来进行通信</p><p>但是这种方式需要小心处理并发问题，防止产生死锁、竞态条件等问题</p></li><li><p><strong>使用队列</strong></p><p>可以使用线程安全的队列来进行通信</p><p>一个线程可以将数据放入队列，其他线程则可以从队列中取出数据</p></li></ul></li></ol><p>在浏览器环境中，主线程与Web Workers之间的通信常常通过<code>postMessage</code>和<code>onmessage</code>事件进行</p><p>主线程通过<code>postMessage</code>向Worker发送数据，Worker可以监听<code>onmessage</code>事件来接收这些数据</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：RESTful规范是什么"><a href="#Q3：RESTful规范是什么" class="headerlink" title="Q3：RESTful规范是什么"></a>Q3：RESTful规范是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>RESTful接口规范（Representational State Transfer，表述性状态传递）是一组架构约束条件和原则，它指导着网络应用程序或Web服务的设计和开发</p><p>它由Roy Fielding在他的博士论文中提出，旨在利用现有的Web协议，如HTTP，来创建可读写的Web API</p><p>RESTful不是一种标准，而是一种风格，被广泛应用于网络服务的实现中</p><p>RESTful服务通常有以下特点：</p><ol><li><p>客户端-服务器架构</p><p>客户端和服务器之间的关系通过请求和响应进行沟通</p></li><li><p>无状态</p><p>每个请求都包含了处理该请求所必须的全部信息。服务器不会存储任何客户端请求相关的状态信息</p></li><li><p>可缓存</p><p>为了提升网络效率，服务器响应的数据能够在一定条件下进行缓存</p></li><li><p>统一接口</p><p>通过一致的接口来交互，这提高了不同客户端和服务器之间交互的独立性</p></li><li><p>分层系统</p><p>客户端通常不能直接与后端服务器通信，可能通过一个或多个中介（如负载均衡器、缓存服务器等）进行交互</p></li><li><p>按需代码（可选）</p><p>服务器可以临时扩展客户端的功能，通过发送可执行的代码给客户端（例如JavaScript脚本）</p></li></ol><p>REST通常使用HTTP协议，并遵循其方法来实施操作：</p><ul><li><strong>GET</strong>: 请求指定的资源。GET请求应该只检索数据并且不会产生其他效果</li><li><strong>POST</strong>: 用于提交一个实体到指定的资源，通常导致服务器上的状态变化或副作用</li><li><strong>PUT</strong>: 用于替换目标资源的所有当前表述</li><li><strong>DELETE</strong>: 用于删除指定的资源</li><li><strong>PATCH</strong>: 用于对资源进行部分修改</li><li><strong>HEAD</strong>: 与GET方法相同，但服务器在响应中只返回头信息而不是实际的资源</li><li><strong>OPTIONS</strong>: 用于描述目标资源的通信选项</li><li><strong>CONNECT</strong>: 通常用于SSL加密服务器的HTTP代理连接</li><li><strong>TRACE</strong>: 回显服务器收到的请求，主要用于测试或诊断</li></ul><p>RESTful接口通过URI来表示资源，并利用HTTP的方法来表示对这些资源的操作</p><p>这些资源在请求响应中以JSON或XML等形式的表述层来进行传输和状态表达</p><p>这种方式易于理解和使用，并且利用了Web已有的功能，避免了额外的协议或框架的需求</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：-websocket跟http的区别"><a href="#Q4：-websocket跟http的区别" class="headerlink" title="Q4： websocket跟http的区别"></a>Q4： websocket跟http的区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>协议类型</p><ul><li><p><strong>HTTP</strong>：是一种无状态的请求-响应协议。客户端发送请求，服务器返回响应，通信结束后连接关闭</p></li><li><p><strong>WebSocket</strong>：是一种全双工通信协议，允许客户端和服务器之间进行双向通信，一旦连接建立，通信通道会保持打开状态，直到一方关闭连接</p></li></ul></li><li><p>连接方式</p><ul><li><p><strong>HTTP</strong>：每次请求和响应都是独立的，服务器在响应请求后关闭连接。每个请求都需要重新建立连接</p></li><li><p><strong>WebSocket</strong>：通过一次握手建立连接后，客户端和服务器之间的连接保持打开状态，可以进行持续的双向通信，不需要每次都重新建立连接</p></li></ul></li><li><p>数据传输</p><ul><li><p><strong>HTTP</strong>：数据以请求-响应的形式传输，数据包通常较大，包含头部信息</p></li><li><p><strong>WebSocket</strong>：数据以帧（frame）的形式传输，数据包较小，头部信息少，传输效率高</p></li></ul></li><li><p>通信模式</p><ul><li><p><strong>HTTP</strong>：基于请求-响应模式，客户端发起请求，服务器响应，通信结束</p></li><li><p><strong>WebSocket</strong>：基于事件驱动模式，客户端和服务器都可以主动发送消息，适用于实时通信场景</p></li></ul></li><li><p>使用场景</p><ul><li><p><strong>HTTP</strong>：适用于传统的网页请求、API 调用等需要短暂通信的场景</p></li><li><p><strong>WebSocket</strong>：适用于需要实时双向通信的场景，如在线聊天、实时游戏、股票行情更新等</p></li></ul></li><li><p>连接建立过程</p><ul><li><p><strong>HTTP</strong>：直接通过 TCP/IP 建立连接，发送 HTTP 请求</p></li><li><p><strong>WebSocket</strong>：首先通过 HTTP/HTTPS 协议进行握手（Upgrade 请求），握手成功后切换到 WebSocket 协议进行通信</p></li></ul></li><li><p>状态管理</p><ul><li><p><strong>HTTP</strong>：无状态，每次请求都是独立的，状态管理需要依赖于 cookies、session 等机制</p></li><li><p><strong>WebSocket</strong>：有状态，连接建立后，通信过程中可以保持状态</p></li></ul></li><li><p>资源消耗</p><ul><li><p><strong>HTTP</strong>：每次请求都需要建立和关闭连接，资源消耗较大，适合短暂通信</p></li><li><p><strong>WebSocket</strong>：连接建立后保持打开状态，减少了频繁建立和关闭连接的开销，适合长时间持续通信</p></li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>HTTP</strong>：适合短暂、无状态的请求-响应通信，常用于网页加载和 API 调用</li><li><strong>WebSocket</strong>：适合长时间、双向的实时通信，常用于在线聊天、实时更新等场景</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：http2里面的多路复用原理是什么"><a href="#Q5：http2里面的多路复用原理是什么" class="headerlink" title="Q5：http2里面的多路复用原理是什么"></a>Q5：http2里面的多路复用原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTTP/2 引入了多路复用（Multiplexing）机制，以提高数据传输效率并减少延迟</p><p>多路复用允许多个请求和响应在同一个TCP连接上并行进行，而不是像HTTP/1.x那样每个请求都需要一个单独的TCP连接</p><p>以下是HTTP/2多路复用原理的详细解释：</p><ol><li><p>数据流（Streams）</p><p>在HTTP/2中，数据流是客户端和服务器之间的双向通信通道</p><p>每个数据流都有一个唯一的标识符（Stream ID），并且可以同时存在多个数据流</p></li><li><p>帧（Frames）</p><p>HTTP/2将所有通信数据分割成较小的帧</p><p>每个帧属于一个特定的数据流，并包含流ID</p><p>帧类型包括数据帧、头帧、优先级帧、设置帧等</p></li><li><p>多路复用过程</p><p>多路复用的核心在于在同一个TCP连接上并行传输多个数据流的帧</p><p>以下是多路复用的具体步骤：</p><ul><li><p>建立连接</p><p>客户端和服务器建立一个单一的TCP连接</p></li><li><p>发送请求和响应</p><p>客户端将多个HTTP请求分割成帧，并通过同一个TCP连接发送给服务器</p><p>服务器处理请求后，将响应分割成帧并返回给客户端</p></li><li><p>流的创建和管理</p><p>每个请求和响应被分配到一个独立的数据流。客户端和服务器可以同时创建、使用和关闭多个数据流</p></li><li><p>帧的传输</p><p>帧在TCP连接上传输时，可以按照任意顺序发送和接收</p><p>每个帧包含流ID，接收方可以根据流ID将帧重新组装成完整的请求或响应</p></li></ul></li><li><p>流优先级和依赖</p><p>HTTP/2允许客户端为每个数据流指定优先级和依赖关系</p><p>这样，服务器可以根据优先级来优化资源分配和响应顺序</p></li><li><p>流控制</p><p>为了防止单个数据流占用过多资源，HTTP/2引入了流控制机制，限制每个数据流可以发送的帧数量</p><p>流控制由接收方管理，确保公平资源分配</p></li></ol><p><strong>多路复用的示意图</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">客户端                   服务器</span><br><span class="line">   |                        |</span><br><span class="line">   |  请求1（流ID=1）        |</span><br><span class="line">   |-----------------------&gt;|</span><br><span class="line">   |  请求2（流ID=3）        |</span><br><span class="line">   |-----------------------&gt;|</span><br><span class="line">   |                        |</span><br><span class="line">   |  响应1（流ID=1）        |</span><br><span class="line">   |&lt;-----------------------|</span><br><span class="line">   |  响应2（流ID=3）        |</span><br><span class="line">   |&lt;-----------------------|</span><br></pre></td></tr></table></figure><p><strong>关键点总结</strong></p><ul><li><strong>单一TCP连接</strong>：HTTP/2在单一TCP连接上并行传输多个请求和响应，减少了连接建立和维护的开销</li><li><strong>数据流和帧</strong>：HTTP/2将数据分割成帧，每个帧属于一个特定的数据流。多个数据流的帧可以交错传输</li><li><strong>流优先级和流控制</strong>：HTTP/2支持流优先级和流控制，优化资源分配和响应顺序</li></ul><p>通过多路复用，HTTP/2显著提高了数据传输效率，减少了延迟和资源消耗，改善了网络性能和用户体验</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6："><a href="#Q6：" class="headerlink" title="Q6："></a>Q6：</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><h3 id="Q1：你对以下几个页面生命周期事件的理解DoMContentLoaded-load-beforeunload-unload"><a href="#Q1：你对以下几个页面生命周期事件的理解DoMContentLoaded-load-beforeunload-unload" class="headerlink" title="Q1：你对以下几个页面生命周期事件的理解DoMContentLoaded, load , beforeunload, unload"></a>Q1：你对以下几个页面生命周期事件的理解DoMContentLoaded, load , beforeunload, unload</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>DOMContentLoaded：</strong><ul><li><strong>触发时机：</strong> 当 DOM 树构建完成，即 HTML 文档解析完毕并生成 DOM 树时触发。此时，外部资源（如样式表、图像等）可能仍在加载。</li><li><strong>用途：</strong> 适合执行不依赖外部资源的初始化操作，例如操作 DOM 元素、绑定事件监听器等。在这个阶段，页面结构已经可以被访问，但是资源的加载可能还在进行中。</li></ul></li><li><strong>load：</strong><ul><li><strong>触发时机：</strong> 当整个页面及其依赖资源都加载完成时触发。包括外部样式表、图像等。</li><li><strong>用途：</strong> 适合执行依赖外部资源的操作，如处理图像大小、启动动画等。在这个阶段，所有资源都已加载完毕，页面已完全呈现给用户。</li></ul></li><li><strong>beforeunload：</strong><ul><li><strong>触发时机：</strong> 在用户尝试离开页面或关闭浏览器窗口之前触发。</li><li><strong>用途：</strong> 可以用于防止用户误关闭页面时丢失数据。返回一个字符串将触发浏览器弹出确认框，允许用户取消关闭。</li></ul></li><li><strong>unload：</strong><ul><li><strong>触发时机：</strong> 当页面即将被卸载时触发，可能是用户关闭浏览器、导航到其他页面等。</li><li><strong>用途：</strong> 主要用于执行清理操作，如释放资源、取消定时器等。在这个阶段，页面即将被卸载，执行时间很短。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：输入url到页面显示的过程"><a href="#Q2：输入url到页面显示的过程" class="headerlink" title="Q2：输入url到页面显示的过程"></a>Q2：输入url到页面显示的过程</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>地址栏输入 URL：</strong><ul><li>用户在浏览器地址栏中输入网址（URL）。</li></ul></li><li><strong>DNS 解析：</strong><ul><li>浏览器通过 DNS（域名系统）将域名解析成对应的 IP 地址。</li><li>如果浏览器有缓存中存在对应的 IP 地址，则跳过 DNS 解析。</li></ul></li><li><strong>建立 TCP 连接（三次握手）：</strong><ul><li>浏览器通过 TCP 连接向服务器发起请求。</li><li>在三次握手中，首先客户端发送 SYN（同步）请求到服务器，服务器回复 SYN-ACK（同步-确认），最后客户端发送 ACK（确认）。</li></ul></li><li><strong>发起 HTTP 请求：</strong><ul><li>浏览器向服务器发起 HTTP 请求，请求中包括请求行、请求头、请求体等信息。</li><li>请求行包含请求的方法（GET、POST 等）和请求的资源路径。</li></ul></li><li><strong>服务器处理请求：</strong><ul><li>服务器接收到请求后，根据请求的路径和方法，执行相应的处理。</li><li>服务器可能会处理动态页面，执行服务器端脚本，或者直接返回静态文件。</li></ul></li><li><strong>服务器返回响应：</strong><ul><li>服务器返回 HTTP 响应，响应包括响应状态码、响应头、响应体等信息。</li><li>如果请求成功，响应状态码为 200；如果请求重定向，状态码为 3xx；如果有错误，状态码为 4xx 或 5xx。</li></ul></li><li><strong>浏览器接收响应：</strong><ul><li>浏览器接收到服务器返回的响应，开始解析响应内容。</li><li>如果响应是压缩的（如 gzip），浏览器会进行解压缩。</li></ul></li><li><strong>构建 DOM 和 CSSOM：</strong><ul><li>浏览器根据 HTML 和 CSS 构建 DOM（文档对象模型）和 CSSOM（CSS 对象模型）。</li><li>DOM 表示页面的结构，CSSOM 表示页面的样式。</li></ul></li><li><strong>渲染树构建：</strong><ul><li>浏览器将 DOM 和 CSSOM 合并成渲染树（Render Tree），渲染树包含需要渲染的可见元素及其样式信息。</li></ul></li><li><strong>布局（回流）：</strong><ul><li>浏览器计算渲染树中每个元素的位置和大小，进行布局（回流）。</li></ul></li><li><strong>绘制：</strong><ul><li>浏览器根据布局信息进行绘制，将页面绘制到屏幕上。</li></ul></li><li><strong>TCP 连接关闭（四次挥手）：</strong><ul><li>当浏览器获得页面内容后，开始进行四次挥手以关闭 TCP 连接。</li><li>在四次挥手中，首先浏览器发送 FIN（结束）请求到服务器，服务器回复 ACK（确认），然后服务器发送 FIN 请求到浏览器，最后浏览器回复 ACK。</li></ul></li><li><strong>交互与动画：</strong><ul><li>如果页面包含 JavaScript，浏览器执行脚本，可能会修改 DOM 或触发动画。</li><li>这些更改可能导致重新布局和重绘，特别是在修改影响几何属性的情况下。</li></ul></li><li><strong>渲染完成：</strong><ul><li>最终，用户可以看到完整的页面，页面上的元素处于可交互状态</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>TCP（Transmission Control Protocol）是一种面向连接的协议，使用三次握手建立连接，四次挥手关闭连接。以下是三次握手和四次挥手的详细过程：</p><p><strong>三次握手（建立连接）：</strong></p><ol><li><strong>客户端发送 SYN（同步）请求：</strong><ul><li>客户端向服务器发送一个包含 SYN 标志的请求，表示请求建立连接。</li><li>客户端选择一个初始序列号（ISN，Initial Sequence Number）。</li></ul></li><li><strong>服务器回应 SYN-ACK：</strong><ul><li>服务器接收到 SYN 请求后，回复一个包含 SYN 和 ACK（确认）标志的响应。</li><li>服务器也选择一个初始序列号。</li></ul></li><li><strong>客户端发送 ACK：</strong><ul><li>客户端收到服务器的 SYN-ACK 后，向服务器发送一个带有 ACK 标志的确认。</li><li>这个 ACK 包含服务器发送的序列号加一作为确认。</li></ul></li></ol><p>这样，通过三次握手，连接建立成功，双方都知道彼此已经准备好传输数据。</p><p><strong>四次挥手（关闭连接）：</strong></p><ol><li><p><strong>客户端发送 FIN：</strong></p><ul><li>客户端决定不再发送数据，并向服务器发送一个包含 FIN（结束）标志的请求。</li><li>客户端进入 FIN-WAIT-1 状态。</li></ul></li><li><p><strong>服务器回应 ACK：</strong></p><ul><li>服务器收到客户端的 FIN 后，发送一个带有 ACK 的确认。</li><li>服务器进入 CLOSE-WAIT 状态，此时客户端可以不再接收数据。</li></ul></li><li><p><strong>服务器发送 FIN：</strong></p><ul><li>服务器决定不再发送数据，向客户端发送一个包含 FIN 标志的请求。</li><li>服务器进入 LAST-ACK 状态。</li></ul></li><li><p><strong>客户端回应 ACK：</strong></p><ul><li>客户端接收到服务器的 FIN 后，发送一个带有 ACK 的确认。</li><li>客户端进入 TIME-WAIT 状态，等待可能出现的延迟数据包。</li></ul><blockquote><p>注：TIME-WAIT 状态的目的是等待可能丢失的最后一个 ACK，以确保服务器正确关闭连接。等待时间通常是 2MSL（最大报文存活时间）。</p></blockquote></li></ol><p>连接关闭完成后，双方都知道对方不再发送数据，连接正式关闭。这四个步骤确保了数据的可靠传输和正确的连接关闭</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：DNS预解析是什么？实现方式有哪些？分别有什么优缺点？"><a href="#Q3：DNS预解析是什么？实现方式有哪些？分别有什么优缺点？" class="headerlink" title="Q3：DNS预解析是什么？实现方式有哪些？分别有什么优缺点？"></a>Q3：DNS预解析是什么？实现方式有哪些？分别有什么优缺点？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>是什么：</strong></p><p>DNS 预解析（DNS Prefetching）是一种浏览器优化技术，旨在提前解析与当前页面相关的域名，以便在请求实际资源时减少 DNS 解析的时间，从而加速页面加载。这可以通过浏览器在后台进行域名解析来实现，而不是在资源请求时才进行 DNS 解析</p><p><strong>实现方式：</strong></p><ol><li><p><strong>通过 <code>&lt;link&gt;</code> 标签：</strong></p><ul><li>使用 <code>&lt;link&gt;</code> 标签的 <code>rel</code> 属性设置为 “dns-prefetch”。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>简单易用：</strong> 实现简单，只需在 HTML 中添加相应的 <code>&lt;link&gt;</code> 标签。</li><li><strong>独立性：</strong> 不依赖服务器配置，可直接由前端实现。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>全局生效：</strong> <code>&lt;link&gt;</code> 标签的方式是全局生效的，对所有页面都会生效，无法精确指定特定页面的预解析需求。</li></ul></li><li><p><strong>通过 HTTP 头部信息：</strong></p><ul><li>服务器端可以通过发送 HTTP 头部信息来指示浏览器进行 DNS 预解析。</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Nginx 服务器配置中使用</span></span><br><span class="line"><span class="attribute">add_header</span> Link <span class="string">&quot;&lt;//example.com&gt;; rel=dns-prefetch&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Apache 服务器配置中使用</span></span><br><span class="line"><span class="attribute">Header</span> add Link <span class="string">&quot;&lt;/&gt;; rel=dns-prefetch&quot;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>灵活性：</strong> 可以通过服务器端配置选择性地启用或禁用 DNS 预解析，提高灵活性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>服务器依赖：</strong> 需要服务器端进行配置，前端无法独立实现。</li><li><strong>复杂度：</strong> 在某些情况下，服务器配置可能相对繁琐，需要更多的工作量。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>什么是 DNS Prefetching（DNS 预解析）：</strong></p><p>DNS Prefetching 是一种浏览器优化技术，旨在提高网页加载速度。它通过在用户点击链接之前提前解析可能会用到的域名，将解析结果缓存到系统中。这样，在用户实际点击链接时，DNS 解析时间就可以减少，从而加速页面的加载过程。</p><p><strong>DNS 缓存与 DNS Prefetching 的关系：</strong></p><ol><li><strong>DNS 缓存：</strong><ul><li>浏览器和操作系统会对解析过的域名进行缓存，以避免在后续的请求中重复的进行 DNS 解析。</li></ul></li><li><strong>DNS Prefetching：</strong><ul><li>DNS Prefetching 是一种主动的预解析技术，它在页面加载过程中提前解析可能会用到的域名，将解析结果缓存到系统中，而不是等到实际请求时才触发 DNS 解析。</li></ul></li></ol><p><strong>优点与缺点：</strong></p><p><strong>优点：</strong></p><ol><li><strong>加速页面加载：</strong><ul><li>DNS Prefetching 可以减少实际资源请求时的 DNS 解析时间，从而加速页面的加载速度，特别是对于包含多个域名的页面。</li></ul></li><li><strong>提高用户体验：</strong><ul><li>用户点击链接时，提前解析可能用到的域名，减少了相关资源的加载延迟，提高了用户体验。</li></ul></li></ol><p><strong>缺点：</strong></p><ol><li><strong>额外的网络负担：</strong><ul><li>预解析会在后台触发额外的 DNS 解析请求，可能增加网络负担，尤其是在用户不点击链接的情况下，可能存在一定的资源浪费。</li></ul></li><li><strong>安全性考虑：</strong><ul><li>DNS Prefetching 可能会被用于追踪用户的行为，因为它预先解析了用户可能会访问的域名，从而暴露了用户的浏览意图。</li></ul></li><li><strong>不适用于所有场景：</strong><ul><li>预解析并不是在所有场景下都适用，特别是在一些网络条件下或者对于某些域名，可能并不会带来显著的性能提升。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：导致页面加载时间长白屏的原因有哪一些？分别要怎么解决优化？"><a href="#Q4：导致页面加载时间长白屏的原因有哪一些？分别要怎么解决优化？" class="headerlink" title="Q4：导致页面加载时间长白屏的原因有哪一些？分别要怎么解决优化？"></a>Q4：导致页面加载时间长白屏的原因有哪一些？分别要怎么解决优化？</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>白屏问题通常指的是用户在访问网页时，页面长时间保持空白而没有显示任何内容。导致页面加载时间长白屏的原因可能有很多，以下是一些常见原因以及相应的解决优化方法：</p><ol><li><strong>资源加载慢：</strong><ul><li><strong>解决方法：</strong> 优化静态资源，确保它们被正确压缩、合并，使用适当的缓存策略。使用 CDN（内容分发网络）可以提高资源加载速度。</li></ul></li><li><strong>JavaScript执行时间过长：</strong><ul><li><strong>解决方法：</strong> 检查页面中的 JavaScript 代码，确保它们优化且没有不必要的阻塞。可以将脚本放在页面底部，使用 <code>async</code> 或 <code>defer</code> 属性，或者将不需要阻塞页面加载的脚本进行懒加载。</li></ul></li><li><strong>CSS阻塞渲染：</strong><ul><li><strong>解决方法：</strong> 确保关键的 CSS 文件被尽早加载，使用媒体查询和嵌套样式以提高页面渲染速度。避免使用阻塞渲染的 CSS，将其异步加载或按需加载。</li></ul></li><li><strong>服务端响应慢：</strong><ul><li><strong>解决方法：</strong> 优化服务器端响应时间，确保后端代码运行高效。使用缓存、CDN、负载均衡等技术来改善服务器性能。</li></ul></li><li><strong>大量的DOM操作：</strong><ul><li><strong>解决方法：</strong> 减少不必要的 DOM 操作，尽可能使用文档碎片或直接操作字符串来批量插入元素。使用虚拟DOM或类似的技术来最小化页面重绘和重排。</li></ul></li><li><strong>网络问题：</strong><ul><li><strong>解决方法：</strong> 检查网络连接是否稳定，确保服务器的网络响应时间较短。使用 HTTPS 来加密连接，减少网络请求时间。</li></ul></li><li><strong>页面过大：</strong><ul><li><strong>解决方法：</strong> 减小页面的体积，删除不必要的代码和资源。使用图片压缩、懒加载等技术来降低页面大小。</li></ul></li><li><strong>没有使用浏览器缓存：</strong><ul><li><strong>解决方法：</strong> 启用适当的缓存策略，确保静态资源能够被浏览器缓存，减少重复加载。</li></ul></li><li><strong>第三方脚本或插件问题：</strong><ul><li><strong>解决方法：</strong> 谨慎选择并使用第三方脚本或插件，确保它们不会成为性能瓶颈。使用异步加载或懒加载以减少对第三方资源的阻塞。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>白屏是什么：</strong></p><p>白屏是指用户访问网页时，页面在一定时间内保持空白，没有显示任何内容的状态。在这段时间内，用户无法看到页面的任何可视化元素，这被视为用户体验的一个负面方面。</p><p><strong>为什么要优化白屏时间：</strong></p><p>优化白屏时间是为了提升用户体验和页面加载性能。用户往往期望页面能够迅速展示内容，而长时间的白屏会导致用户感到不耐烦，可能选择离开页面。快速加载页面不仅能提升用户满意度，还有助于提高页面的转化率。</p><p><strong>白屏过程是什么样的：</strong></p><p>白屏过程是指从用户发起页面请求到页面展示内容之间所经历的一系列步骤。以下是一般的白屏过程：</p><ol><li><strong>用户输入 URL：</strong> 用户在浏览器地址栏输入网页的 URL。</li><li><strong>DNS解析：</strong> 浏览器通过DNS解析获取对应的IP地址。</li><li><strong>建立TCP连接：</strong> 浏览器通过IP地址建立与服务器的TCP连接。</li><li><strong>发送HTTP请求：</strong> 浏览器向服务器发送HTTP请求，请求相应的页面资源。</li><li><strong>服务器处理请求：</strong> 服务器接收到请求后，处理并返回相应的HTML、CSS、JavaScript等资源。</li><li><strong>下载资源：</strong> 浏览器接收到响应后开始下载页面所需的资源。</li><li><strong>HTML解析：</strong> 浏览器开始解析HTML，构建DOM树。</li><li><strong>CSS解析：</strong> 解析CSS，构建CSSOM树。</li><li><strong>JavaScript执行：</strong> 执行页面上的JavaScript代码，可能修改DOM树或CSSOM树。</li><li><strong>布局（Reflow）和绘制（Repaint）：</strong> 根据DOM树和CSSOM树计算布局，然后绘制页面。</li></ol><p>在这个过程中，用户会感知到的白屏主要出现在第7和第8步，即HTML和CSS的解析过程。为了减少白屏时间，可以采取以下措施：</p><ul><li><strong>减小资源体积：</strong> 压缩和合并CSS、JavaScript等资源，减小文件大小。</li><li><strong>异步加载：</strong> 使用<code>async</code>和<code>defer</code>属性，将不影响渲染的脚本异步加载。</li><li><strong>懒加载：</strong> 将页面中不是立即需要的资源，如图片等，延迟加载。</li><li><strong>服务端渲染（SSR）：</strong> 在服务器端完成一部分渲染工作，将渲染好的HTML传输给浏览器。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：浏览器的每一帧都会干什么事情"><a href="#Q5：浏览器的每一帧都会干什么事情" class="headerlink" title="Q5：浏览器的每一帧都会干什么事情"></a>Q5：浏览器的每一帧都会干什么事情</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在浏览器的绘制过程中，每一帧的生成都是为了在屏幕上渲染出新的图像</p><p>为了达到流畅动画和交互的效果，现代浏览器通常目标是每秒达到60帧，也就是每帧大约16.67毫秒来完成所有的工作</p><p>每一帧中，浏览器大致会进行以下几个步骤：</p><ol><li><p><strong>处理用户输入</strong></p><p>浏览器会处理用户的交互，如鼠标点击、滚动、键盘输入等。这些输入会触发相应的事件处理程序</p></li><li><p><strong>JavaScript执行</strong></p><p>执行页面中的JavaScript代码</p><p>这包括响应用户的操作（例如，点击事件），或执行任何定时任务（例如，<code>setTimeout</code> 和 <code>requestAnimationFrame</code> 的回调）</p></li><li><p><strong>请求动画帧</strong></p><p>如果有通过<code>requestAnimationFrame</code>注册的动画，此时会执行这些动画的回调函数</p></li><li><p><strong>样式计算</strong></p><p>计算出哪些CSS规则适用于文档中的元素</p><p>这个过程生成了一份元素和它们对应样式的映射表</p></li><li><p><strong>布局</strong></p><p>一旦浏览器知道了哪些规则适用于哪些元素，它就会开始计算每个元素的位置和大小</p><p>这个过程被称为布局（Layout）或重排（Reflow）</p></li><li><p><strong>绘制</strong></p><p>根据计算出的样式和布局信息，浏览器会开始将每个可见元素绘制到一个或多个图层上。这个过程称为绘制（Painting）</p></li><li><p><strong>合成</strong></p><p>最后，浏览器会将各个图层合并（Composite）起来，并显示在屏幕上</p><p>有些情况下，如果页面的某些部分只是移动而没有发生样式变化，浏览器可以只重新合成这些部分，而无需重新布局或绘制，这可以提高性能</p></li></ol><p>每个步骤消耗的时间都可能不同，如果任何一个环节耗时过多，都可能导致帧率下降，从而感觉到卡顿</p><p>因此，为了保持流畅的用户体验，开发者需要关注和优化这个流程中可能导致性能瓶颈的环节，如优化JavaScript执行时间，减少重排和重绘，使用层提升等技术来提高合成的效率</p>
              </div>
            </details>
<p><br/></p>
<h1 id="请求-amp-amp-缓存"><a href="#请求-amp-amp-缓存" class="headerlink" title="请求 &amp;&amp; 缓存"></a>请求 &amp;&amp; 缓存</h1><h3 id="Q1：浏览器有哪几种缓存，各种缓存的优先级是什么样的"><a href="#Q1：浏览器有哪几种缓存，各种缓存的优先级是什么样的" class="headerlink" title="Q1：浏览器有哪几种缓存，各种缓存的优先级是什么样的"></a>Q1：浏览器有哪几种缓存，各种缓存的优先级是什么样的</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>Service Worker</code> 缓存</p><p><code>Service Worker</code> 缓存优先级最高</p><p><code>Service Worker</code> 通过编程的方式处理缓存，它可以捕获请求，也可以将响应直接放入缓存中</p></li><li><p><code>Memory Cache</code> (内存缓存)</p><p><code>Memory Cache</code> 是存储在内存中的资源，主要用于临时缓存</p><p>如用户在浏览器会话期间反复访问相同的页面，或在用户导航页面时（如点击回退按钮、重新加载页面），用于加快页面的加载速度</p><p><code>Memory Cache</code> 的生命周期只在一个标签页（<code>Tab</code>）关闭前有效</p></li><li><p>强缓存/硬盘缓存</p><p>强缓存指的是没有进行版本比对就直接从缓存读取的资源，对应的 <code>HTTP Header</code> 有 <code>Expires</code> 和 <code>Cache-Control（max-age）</code></p><p>浏览器在判断一个 <code>HTTP</code> 请求是否可以用强缓存时，会根据请求的 <code>URL</code> 进行匹配，并确认其有效期</p><p>一旦命中强缓存，浏览器会直接提供缓存数据，不会和服务器发生通信</p></li><li><p>协商缓存</p><p>当强缓存失效时，浏览器会发起 HTTP 请求检查资源是否更新，这就是协商缓存</p><p>对应的 <code>HTTP Header</code> 有 Last-Modified/Etag 和 <code>If-Modified-Since/If-None-Match</code></p></li><li><p><code>Web Storage（LocalStorage/sessionStorage）</code></p><p><code>Web Storage</code> 包括 <code>localStorage</code> 和 <code>sessionStorage</code>，它们用于在浏览器中存储数据</p><p>注意，这些缓存不参与和服务器的通信，也不同于前面讨论的缓存策略</p><p><code>localStorage</code> 数据在浏览器关闭后依然存在，除非用户或者代码删除数据</p><p><code>sessionStorage</code> 的生命周期只在一个浏览器窗口（或者标签页）关闭前有效</p></li><li><p>推测/预加载缓存</p><p>此类缓存通过预测用户可能需要的资源，提前加载到预加载缓存中，用于提升加载性能</p></li><li><p>浏览器历史记录缓存 <code>(Back/Forward Cache</code>)</p><p>当用户操作浏览器的“后退”或“前进”按钮时，浏览器为了更快的加载页面，会将整个页面（包含JS运行的状态）都缓存在内存中，创建一个完成状态的拷贝</p><p>当用户再次访问该页面时，可以直接显示，不需要重新加载和运行JS</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>优先级顺序</strong></p><ol><li><code>Service Worker</code></li><li><code>Memory Cache</code> (内存缓存)</li><li>强缓存/硬盘缓存</li><li>协商缓存</li><li><code>Web Storage（LocalStorage/sessionStorage）</code></li><li>推测/预加载缓存</li><li>浏览器历史记录缓存 (<code>Back/Forward Cache</code>)</li></ol><p>对于优先级，需要注意的是，<code>Service Worker</code>、<code>Memory Cache</code>、强缓存和协商缓存等都是从网络请求的角度出发考虑的，而 <code>Web Storage</code> 则更多的是作为一种在前端进行数据存储的手段</p><p>同时，因浏览器的实现细节和策略可能不同，实际的缓存行为表现可能有所差异</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：https握手的过程"><a href="#Q2：https握手的过程" class="headerlink" title="Q2：https握手的过程"></a>Q2：https握手的过程</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTTPS（HyperText Transfer Protocol Secure）是HTTP的安全版本，通过SSL/TLS协议对数据进行加密，以确保数据在传输过程中不会被窃听或篡改。以下是HTTPS通信的详细过程：</p><ol><li><p>客户端发起HTTPS请求</p><p>当用户在浏览器中输入一个HTTPS网址（例如：<a href="https://example.com）时，浏览器会尝试与服务器建立一个安全连接">https://example.com）时，浏览器会尝试与服务器建立一个安全连接</a></p></li><li><p>服务器响应并发送证书</p><p>服务器接收到客户端的请求后，会返回一个包含公钥的数字证书</p><p>这个证书由可信的证书颁发机构（CA）签署，包含以下信息：</p><ul><li>服务器的公钥</li><li>服务器的域名</li><li>证书的有效期</li><li>证书颁发机构的数字签名</li></ul></li><li><p>客户端验证证书</p><p>客户端（通常是浏览器）会对服务器发送的证书进行验证，验证步骤包括：</p><ul><li>检查证书是否由可信的CA签署</li><li>确认证书的域名与请求的域名匹配</li><li>确认证书在有效期内</li></ul><p>如果证书验证失败，浏览器会显示一个警告，提示用户连接不安全。如果验证成功，进入下一步</p></li><li><p>生成会话密钥</p><p>客户端生成一个随机的会话密钥（对称密钥），并使用服务器的公钥对这个会话密钥进行加密，然后将加密后的会话密钥发送给服务器</p></li><li><p>服务器解密会话密钥</p><p>服务器使用其私钥解密客户端发送的会话密钥</p><p>此时，客户端和服务器都拥有了相同的会话密钥，可以用它来加密和解密后续的通信数据</p></li><li><p>建立加密通信</p><p>客户端和服务器使用会话密钥对后续的HTTP请求和响应进行加密</p><p>这样，数据在传输过程中即使被截获，也无法被解读</p></li><li><p>传输数据</p><p>客户端发送加密的HTTP请求，服务器解密后处理请求，再将加密的响应返回给客户端</p><p>整个通信过程都在加密通道中进行，确保数据的安全性</p></li><li><p>结束会话</p><p>当通信结束时，客户端和服务器可以通过发送“关闭连接”的消息来终止加密会话，释放资源</p></li></ol><p><strong>HTTPS通信过程的示意图</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">客户端                   服务器</span><br><span class="line">   |                        |</span><br><span class="line">   |  发起HTTPS请求         |</span><br><span class="line">   |-----------------------&gt;|</span><br><span class="line">   |                        |</span><br><span class="line">   |  返回证书               |</span><br><span class="line">   |&lt;-----------------------|</span><br><span class="line">   |                        |</span><br><span class="line">   |  验证证书               |</span><br><span class="line">   |                        |</span><br><span class="line">   |  生成会话密钥并加密     |</span><br><span class="line">   |-----------------------&gt;|</span><br><span class="line">   |                        |</span><br><span class="line">   |  解密会话密钥           |</span><br><span class="line">   |                        |</span><br><span class="line">   |  建立加密通信           |</span><br><span class="line">   |&lt;-----------------------&gt;|</span><br><span class="line">   |                        |</span><br><span class="line">   |  传输数据               |</span><br><span class="line">   |&lt;-----------------------&gt;|</span><br><span class="line">   |                        |</span><br><span class="line">   |  结束会话               |</span><br><span class="line">   |-----------------------&gt;|</span><br><span class="line">   |                        |</span><br></pre></td></tr></table></figure><p><strong>关键点总结</strong></p><ul><li><strong>SSL/TLS协议</strong>：HTTPS通过SSL/TLS协议对数据进行加密，确保数据传输的安全性</li><li><strong>数字证书</strong>：服务器通过数字证书向客户端证明其身份，证书由可信的CA签署</li><li><strong>会话密钥</strong>：客户端和服务器使用非对称加密交换会话密钥，之后使用对称加密进行数据传输</li><li><strong>数据加密</strong>：所有传输的数据都经过加密，确保数据的机密性和完整性</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：http报文结构是什么样子的"><a href="#Q3：http报文结构是什么样子的" class="headerlink" title="Q3：http报文结构是什么样子的"></a>Q3：http报文结构是什么样子的</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>HTTP请求报文</p><ul><li><p><strong>请求行（Request Line）</strong>：</p><ul><li><p>包含HTTP方法（如GET、POST）、请求的URL和HTTP版本</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>请求头部（Request Headers）</strong>：</p><ul><li><p>提供关于客户端和请求的附加信息</p></li><li><p>每个头部字段由字段名和字段值组成，字段名和值之间用冒号分隔</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>空行</strong>：</p><ul><li><p>请求头部和请求体之间的空行，用于分隔头部和主体</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">(空行)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>请求体（Request Body）</strong>（可选）：</p><ul><li><p>包含要发送给服务器的数据，仅在POST、PUT等方法中存在</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">username=johndoe<span class="built_in">&amp;</span>password=12345</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>HTTP响应报文</p><ul><li><p><strong>状态行（Status Line）</strong>：</p><ul><li><p>包含HTTP版本、状态码和状态描述。</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>响应头部（Response Headers）</strong>：</p><ul><li><p>提供关于服务器和响应的附加信息。</p></li><li><p>每个头部字段由字段名和字段值组成，字段名和值之间用冒号分隔。</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 138</span><br><span class="line">Server: Apache/2.4.1 (Unix)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>空行</strong>：</p><ul><li><p>响应头部和响应体之间的空行，用于分隔头部和主体。</p></li><li><p>示例：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">(空行)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>响应体（Response Body）</strong>：</p><ul><li><p>包含服务器返回的实际数据，如HTML文档、图片、JSON数据等。</p></li><li><p>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p><strong>示例：完整的HTTP请求报文</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">(空行)</span><br></pre></td></tr></table></figure><p><strong>示例：完整的HTTP响应报文</strong></p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache/2.2.14 (Win32)</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">Content-Length: 88</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Connection: Closed</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>HTTP报文是HTTP协议通信的基础，分为请求报文和响应报文</p><p>请求报文包含请求行、请求头部、空行和请求体（可选）</p><p>响应报文包含状态行、响应头部、空行和响应体</p><p>理解HTTP报文的结构对于调试网络通信和开发Web应用程序非常重要</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：POST-请求的-Content-Type有几种类型"><a href="#Q4：POST-请求的-Content-Type有几种类型" class="headerlink" title="Q4：POST 请求的 Content-Type有几种类型"></a>Q4：POST 请求的 Content-Type有几种类型</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>POST 请求的 Content-Type 可以有多种类型，常见的包括：</p><ol><li><code>application/x-www-form-urlencoded</code>：用于普通的 HTML 表单提交，在请求正文中将表单字段编码为键值对</li><li><code>multipart/form-data</code>：用于上传文件或二进制数据的表单提交，请求正文以多部分形式进行编码</li><li><code>application/json</code>：用于发送 JSON 格式的数据，请求正文中的数据将以 JSON 形式进行传输</li><li><code>text/plain</code>：纯文本格式，适用于发送纯文本数据</li><li><code>application/xml</code>：用于发送 XML 数据</li><li><code>text/html</code>：用于发送 HTML 数据</li><li><code>application/octet-stream</code>：用于发送二进制数据，如文件下载时使用</li><li><code>application/graphql</code>：用于发送 GraphQL 查询或请求</li><li><code>application/x-www-form-urlencoded;charset=UTF-8</code>：类似于 <code>application/x-www-form-urlencoded</code>，但指定了字符编码为 UTF-8</li><li>其他自定义的 Content-Type 类型</li></ol><p>服务器根据 Content-Type 来解析和处理请求数据，具体选择哪种 Content-Type 取决于请求所携带的数据类型和服务器端的要求</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：TCP跟UDP的区别是什么"><a href="#Q5：TCP跟UDP的区别是什么" class="headerlink" title="Q5：TCP跟UDP的区别是什么"></a>Q5：TCP跟UDP的区别是什么</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，它们在数据传输方式、可靠性、速度等方面有显著的区别</p><p>以下是详细的比较：</p><ol><li><p>连接方式</p><ul><li><p><strong>TCP</strong>：面向连接的协议。数据传输前需要建立一个连接（三次握手），传输完毕后需要断开连接（四次挥手）</p></li><li><p><strong>UDP</strong>：无连接的协议。数据传输前不需要建立连接，传输完毕后也不需要断开连接</p></li></ul></li><li><p>可靠性</p><ul><li><p><strong>TCP</strong>：提供可靠的数据传输。通过序列号、确认应答（ACK）、重传机制和流量控制等手段确保数据包按顺序、无错误地到达目标</p></li><li><p><strong>UDP</strong>：不保证数据的可靠传输。没有序列号、确认应答、重传机制和流量控制，数据包可能会丢失、重复或乱序到达</p></li></ul></li><li><p>数据传输方式</p><ul><li><p><strong>TCP</strong>：面向字节流。数据以字节流的形式传输，接收方需要按顺序组装数据</p></li><li><p><strong>UDP</strong>：面向数据报。数据以独立的数据报（Datagram）形式传输，每个数据报是一个完整的消息</p></li></ul></li><li><p>速度和效率</p><ul><li><p><strong>TCP</strong>：由于需要建立连接、确认应答和重传机制，传输速度较慢，开销较大，但保证了可靠性</p></li><li><p><strong>UDP</strong>：由于没有连接建立和确认应答等机制，传输速度较快，开销较小，但可靠性较低</p></li></ul></li><li><p>头部开销</p><ul><li><p><strong>TCP</strong>：头部较大，通常为20字节，包含序列号、确认号、窗口大小、校验和等信息</p></li><li><p><strong>UDP</strong>：头部较小，通常为8字节，仅包含源端口、目的端口、长度和校验和</p></li></ul></li><li><p>适用场景</p><ul><li><p><strong>TCP</strong>：</p><ul><li><strong>文件传输</strong>：如FTP、HTTP/HTTPS等，要求数据完整性和顺序性</li><li><strong>电子邮件</strong>：如SMTP，要求可靠传输</li><li><strong>远程登录</strong>：如SSH、Telnet，要求可靠和有序的数据传输</li></ul></li><li><p><strong>UDP</strong>：</p><ul><li><strong>实时应用</strong>：如视频会议、在线游戏、VoIP等，要求低延迟和快速传输</li><li><strong>广播和多播</strong>：如DNS查询、DHCP等，适用于一次发送多个接收的场景</li><li><strong>简单的请求-响应协议</strong>：如TFTP、SNMP等，数据量小且对可靠性要求不高</li></ul></li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>TCP</strong>：面向连接，可靠传输，适合需要高可靠性的数据传输场景，但传输速度较慢，开销较大</li><li><strong>UDP</strong>：无连接，不保证可靠传输，适合对实时性要求高但对可靠性要求较低的场景，传输速度快，开销</li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h3 id="Q1：浏览器为什么要有跨域限制"><a href="#Q1：浏览器为什么要有跨域限制" class="headerlink" title="Q1：浏览器为什么要有跨域限制?"></a>Q1：浏览器为什么要有跨域限制?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。 如果浏览器没有同源策略，会存在什么样的安全问题呢。</p><p>下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：</p><ol><li><p>如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击： </p><p>做一个假网站，里面用 iframe 嵌套一个银行网站 <a href="http://mybank.com。">http://mybank.com。</a></p><p>把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别</p><p> 这时如果用户输入账号密码，我们的主网站可以跨域访问到 <a href="http://mybank.com">http://mybank.com</a> 的 dom 节点，就可以拿到用户的账户密码了</p></li><li><p>如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击： </p><p>用户登录了自己的银行页面 <a href="http://mybank.com">http://mybank.com</a></p><p><a href="http://mybank.com">http://mybank.com</a> 向用户的 cookie 中添加用户标识</p><p> 用户浏览了恶意页面 <a href="http://evil.com，执行了页面中的恶意">http://evil.com，执行了页面中的恶意</a> AJAX 请求代码。</p><p><a href="http://evil.com">http://evil.com</a> 向 <a href="http://mybank.com">http://mybank.com</a> 发起 AJAX HTTP 请求</p><p>请求会默认把 <a href="http://mybank.com">http://mybank.com</a> 对应 cookie 也同时发送过去</p><p> 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据</p><p>此时数据就泄露了。 而且由于 Ajax 在后台执行，用户无法感知这一过程</p><p> 因此，有了浏览器同源策略，我们才能更安全的上网</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：web常见的攻击方式有哪些"><a href="#Q2：web常见的攻击方式有哪些" class="headerlink" title="Q2：web常见的攻击方式有哪些"></a>Q2：web常见的攻击方式有哪些</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>SQL 注入（SQL Injection）</strong></p><ul><li><p><strong>描述</strong></p><p>攻击者通过输入查询字符串来尝试访问或篡改数据库</p></li><li><p><strong>防御</strong></p><p>使用参数化查询、预编译的SQL语句和ORM工具，避免直接将用户输入嵌入到SQL查询中</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>用户在登录表单的用户名字段中输入 <code>admin&#39; --</code>，攻击者试图注释掉SQL语句的其余部分，来无条件访问管理员帐户</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户在登录表单中输入:</span></span><br><span class="line"><span class="comment">// 用户名: hacker&#x27; --</span></span><br><span class="line"><span class="comment">// 密码: xxx</span></span><br><span class="line"><span class="comment">// 恶意构造的输入用于修改 SQL 查询</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御</strong></p><p>使用参数化查询，如在PHP中使用PDO进行带参数的查询</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> connection = mysql.<span class="title function_">createConnection</span>(&#123; <span class="comment">/*...*/</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;用户输入的用户名&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;用户输入的密码&#x27;</span>;</span><br><span class="line">connection.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users WHERE username = ? AND password = ?&#x27;</span>, [username, password], <span class="keyword">function</span>(<span class="params">error, results, fields</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>跨站脚本攻击（XSS, Cross-Site Scripting）</strong></p><ul><li><p><strong>描述</strong></p><p>攻击者在网页上注入恶意脚本，当其它用户浏览该网页时执行这些脚本</p></li><li><p><strong>防御</strong></p><p>对所有的输入进行适当的过滤或转义，使用CSP（内容安全策略）减少被攻击的风险</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>在评论或消息中加入<code>&lt;script&gt;</code>标签</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户评论</span></span><br><span class="line"><span class="keyword">const</span> userComment = <span class="string">&quot;&lt;script&gt;maliciousCode()&lt;/script&gt;&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>防御</strong></p><p>输入内容转义</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escapeHTML</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">&#x27;&amp;&#x27;</span>: <span class="string">&#x27;&amp;amp;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;&#x27;</span>: <span class="string">&#x27;&amp;lt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;&#x27;</span>: <span class="string">&#x27;&amp;gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&quot;&#x27;</span>: <span class="string">&#x27;&amp;quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;&#x27;&quot;</span>: <span class="string">&#x27;&amp;#039;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> text.<span class="title function_">replace</span>(<span class="regexp">/[&amp;&lt;&gt;&quot;&#x27;]/g</span>, <span class="keyword">function</span>(<span class="params">m</span>) &#123; <span class="keyword">return</span> map[m]; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用转义函数保护输出</span></span><br><span class="line"><span class="keyword">const</span> safeComment = escapeHTML(userComment);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>跨站请求伪造（CSRF, Cross-Site Request Forgery）</strong></p><ul><li><p><strong>描述</strong></p><p>攻击者诱使已登录用户在不知情的情况下执行非本意的操作，如状态改变请求（State-changing request）</p></li><li><p><strong>防御</strong></p><p>使用Anti-CSRF令牌，确保只有来自用户本意的请求才被执行</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>在第三方网站中嵌入执行状态修改操作的请求</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.com/transfer.do?amt=1000&amp;toAccount=hacker&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御</strong></p><p>使用CSRF Token</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务端生成CSRF Token，并在客户端表单中包含它</span></span><br><span class="line">&lt;form action=<span class="string">&quot;/transfer&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;服务器生成的CSRF Token&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="comment">&lt;!-- 其他表单内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在处理请求时检验CSRF Token</span></span><br><span class="line"><span class="keyword">if</span> (request.<span class="property">body</span>.<span class="property">csrf_token</span> !== request.<span class="property">session</span>.<span class="property">csrf_token</span>) &#123;</span><br><span class="line">  <span class="comment">// CSRF Token 不匹配或不存在</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid CSRF token&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>会话劫持（Session Hijacking）</strong></p><ul><li><p><strong>描述</strong></p><p>攻击者尝试窃取或篡改用户的会话令牌来盗用用户的身份</p></li><li><p><strong>防御</strong></p><p>使用HTTPS保持传输层的安全，利用HttpOnly和Secure标志设置Cookie，限制Cookie的访问</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>通过网络嗅探等手段获取用户的Session ID</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 攻击者通过某种手段获得了 victimSessionId</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御</strong></p><p>安全设置Cookie标志</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务器端设置 Cookie 时，使用 HttpOnly 和 Secure 标志</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;sessionId=您的SessionID; HttpOnly; Secure&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>DDOS 攻击（Distributed Denial of Service）</strong></p><ul><li><p><strong>描述</strong></p><p>通过大量恶意流量使网站服务不可用</p></li><li><p><strong>防御</strong></p><p>使用DDoS防护服务，如云服务提供的流量分析和过滤工具</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>DDoS攻击通常由网络机器实施，不通过前端JavaScript实现</p></li><li><p><strong>防御</strong></p><p>配置Web服务器或使用服务商提供的工具</p><p>这是在服务端或网络层进行的配置，通常不是用 JavaScript 代码完成的<br>例如，配置 Nginx 或使用 Cloudflare 等服务</p></li></ul></li></ul></li><li><p><strong>上传漏洞</strong></p><ul><li><p><strong>描述</strong></p><p>攻击者通过上传恶意文件（如脚本）到服务器执行</p></li><li><p><strong>防御</strong></p><p>限制上传文件的类型和大小，对上传的文件进行扫描和验证，不直接在Web根目录下存储或执行用户上传的文件</p></li><li><p><strong>例子</strong></p><ul><li><p><strong>攻击</strong></p><p>上传包含恶意代码的文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 攻击者试图上传一个恶意脚本文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;maliciousFile&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>防御</strong></p><p>服务器端文件验证</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务器端使用 JavaScript 进行文件扩展名检查（以 Node.js 为例）</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fileExtension = path.<span class="title function_">extname</span>(req.<span class="property">files</span>.<span class="property">uploadedFile</span>.<span class="property">name</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">if</span> (fileExtension !== <span class="string">&#x27;.png&#x27;</span> &amp;&amp; fileExtension !== <span class="string">&#x27;.jpg&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 拒绝上传</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;Invalid file type!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 允许上传</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>敏感数据暴露</strong></p><ul><li><p><strong>描述</strong></p><p>敏感信息（如密码、令牌、秘钥）被泄露</p></li><li><p><strong>防御</strong></p><p>使用强加密算法保护数据传输和存储，对敏感数据加密，使用安全的密码散列函数存储密码</p></li></ul></li><li><p><strong>安全配置错误</strong></p><ul><li><p><strong>描述</strong></p><p>错误配置安全头部、错误暴露系统信息、不必要的服务运行在服务器上</p></li><li><p><strong>防御</strong></p><p>遵循安全的默认配置原则，定期进行安全检查和更新，最小化暴露的系统信息</p></li></ul></li><li><p><strong>使用已知的有漏洞的组件</strong></p><ul><li><p><strong>描述</strong></p><p>软件使用了含有已知漏洞的组件或框架</p></li><li><p><strong>防御</strong></p><p>定期使用工具检查和更新依赖项以修补已知漏洞，使用依赖检查工具管理项目的依赖</p></li></ul></li><li><p><strong>不安全的直接对象引用（IDOR, Insecure Direct Object References）</strong></p><ul><li><p><strong>描述</strong></p><p>通过修改URL或表单参数来访问没有权限的数据</p></li><li><p><strong>防御</strong></p><p>实施严格的访问控制检查，确保用户只能访问他们授权的数据</p></li></ul></li></ol><p>每种攻击都有其特定的防御策略，维护Web安全需要持续的努力和更新策略以对抗新出现的威胁。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：什么是DNS劫持"><a href="#Q3：什么是DNS劫持" class="headerlink" title="Q3：什么是DNS劫持"></a>Q3：什么是DNS劫持</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>DNS劫持（DNS Hijacking）是一种网络攻击方式</p><p>攻击者通过篡改域名系统（DNS）的解析过程，将用户对特定域名的请求重定向到错误或恶意的IP地址</p><p>以下是对DNS劫持的详细解释：</p><p><strong>工作原理</strong></p><p>当用户在浏览器中输入一个域名（如example.com）时，DNS会将该域名解析为对应的IP地址，以便浏览器能够连接到目标服务器</p><p>DNS劫持的攻击者通过多种手段篡改这一解析过程，使得用户被引导到错误或恶意的服务器</p><p><strong>常见的DNS劫持方法</strong></p><ol><li><p><strong>本地劫持</strong>：</p><p>攻击者在用户的计算机或路由器上安装恶意软件，篡改本地的DNS设置，使用户的DNS请求被重定向到攻击者控制的DNS服务器</p></li><li><p><strong>路由劫持</strong>：</p><p>攻击者通过篡改网络路由器或交换机的设置，拦截并修改DNS请求和响应数据包</p></li><li><p><strong>DNS服务器劫持</strong>：</p><p>攻击者直接入侵DNS服务器，篡改其上的DNS记录，使得用户的DNS请求返回错误的IP地址</p></li><li><p><strong>中间人攻击（MITM）</strong>：</p><p>攻击者在用户和DNS服务器之间插入一个中间人，拦截并篡改DNS请求和响应</p></li></ol><p><strong>影响和危害</strong></p><ol><li><p><strong>隐私泄露</strong>：</p><p>攻击者可以通过DNS劫持将用户引导到钓鱼网站，从而窃取用户的敏感信息，如用户名、密码、信用卡信息等</p></li><li><p><strong>恶意软件传播</strong>：</p><p>用户被引导到恶意网站，可能会被强制下载和安装恶意软件，进一步危害用户的系统安全</p></li><li><p><strong>广告注入</strong>：</p><p>攻击者可以通过DNS劫持将用户引导到带有大量广告的网站，获取非法广告收益</p></li><li><p><strong>服务中断</strong>：</p><p>DNS劫持可能导致合法网站的访问中断，影响业务的正常运营和用户体验</p></li></ol><p><strong>防护措施</strong></p><ol><li><p><strong>使用安全DNS服务</strong>：</p><p>选择安全、可信赖的DNS服务提供商，如Google Public DNS、Cloudflare DNS等，这些服务通常具有更好的安全性和防护措施</p></li><li><p><strong>启用DNSSEC</strong>：</p><p>DNSSEC（DNS Security Extensions）是一种安全协议，通过对DNS数据进行数字签名，确保数据的完整性和真实性，防止DNS劫持</p></li><li><p><strong>定期更新和扫描</strong>：</p><p>定期更新操作系统、路由器固件和防病毒软件，扫描系统中的恶意软件，防止本地劫持</p></li><li><p><strong>使用HTTPS</strong>：</p><p>通过使用HTTPS加密通信，防止中间人攻击，即使DNS被劫持，攻击者也无法篡改加密的数据</p></li><li><p><strong>监控和检测</strong>：</p><p>实时监控DNS流量，检测异常的DNS解析行为，及时发现和应对潜在的DNS劫持攻击</p></li></ol><p><strong>总结</strong></p><p>DNS劫持是一种严重的网络安全威胁，可能导致隐私泄露、恶意软件传播、广告注入和服务中断</p><p>通过采取适当的防护措施，如使用安全DNS服务、启用DNSSEC、定期更新和扫描系统、使用HTTPS以及监控DNS流量，可以有效减少DNS劫持的风险</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：https为什么是安全的"><a href="#Q4：https为什么是安全的" class="headerlink" title="Q4：https为什么是安全的"></a>Q4：https为什么是安全的</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>HTTPS（HyperText Transfer Protocol Secure）之所以被认为是安全的，主要是因为它在HTTP的基础上增加了SSL/TLS（Secure Sockets Layer/Transport Layer Security）加密层</p><p>从而提供了以下几个关键的安全特性：</p><ol><li><p>数据加密</p><ul><li><p><strong>加密通信</strong>：HTTPS使用SSL/TLS协议对传输的数据进行加密，使得数据在客户端和服务器之间传输时无法被窃听或篡改</p></li><li><p><strong>对称加密</strong>：在通信过程中，使用对称加密算法（如AES）对数据进行加密和解密。对称加密的密钥是通过非对称加密算法（如RSA）安全交换的</p></li></ul></li><li><p>数据完整性</p><ul><li><strong>防篡改</strong>：通过消息认证码（MAC）或哈希函数（如SHA-256），确保数据在传输过程中未被篡改。如果数据被篡改，接收方可以通过校验发现并拒绝篡改的数据</li></ul></li><li><p>身份验证</p><ul><li><p><strong>服务器身份验证</strong>：通过数字证书（由可信的证书颁发机构CA签发），客户端可以验证服务器的身份，确保与之通信的确实是预期的服务器</p></li><li><p><strong>客户端身份验证</strong>（可选）：在某些情况下，服务器也可以要求客户端提供数字证书，以验证客户端的身份</p></li></ul></li><li><p>防止中间人攻击</p><ul><li><strong>防止中间人攻击（MITM）</strong>：通过加密和身份验证机制，HTTPS可以有效防止中间人攻击。攻击者无法在不被发现的情况下截获、篡改或伪造通信内容</li></ul></li></ol><p><strong>HTTPS 工作原理简述</strong></p><ol><li><p><strong>客户端发起HTTPS请求</strong>：</p><p>客户端向服务器发起HTTPS连接请求</p></li><li><p><strong>服务器返回数字证书</strong>：</p><p>服务器返回包含公钥的数字证书，该证书由可信的CA签发</p></li><li><p><strong>客户端验证证书</strong>：</p><p>客户端验证服务器的数字证书是否合法和有效</p><p>如果验证通过，客户端生成一个随机的对称加密密钥</p></li><li><p><strong>密钥交换</strong>：</p><p>客户端使用服务器的公钥加密对称加密密钥，并发送给服务器</p><p>服务器使用自己的私钥解密，得到对称加密密钥</p></li><li><p><strong>建立安全通信</strong>：</p><p>双方使用对称加密密钥进行加密通信，确保数据在传输过程中保持机密性和完整性</p></li></ol><p><strong>HTTPS的优势</strong></p><ul><li><strong>数据保密性</strong>：加密通信确保数据在传输过程中不会被窃听</li><li><strong>数据完整性</strong>：防止数据在传输过程中被篡改</li><li><strong>身份验证</strong>：确保通信双方的身份是合法的，防止中间人攻击</li><li><strong>用户信任</strong>：使用HTTPS的网站通常会在浏览器地址栏显示锁定图标，增加用户的信任感</li></ul><p><strong>总结</strong></p><p>HTTPS通过SSL/TLS协议提供数据加密、数据完整性和身份验证，确保客户端和服务器之间的通信安全</p><p>它有效防止了窃听、篡改和中间人攻击等安全威胁，使得用户在访问网站时能够更加放心地传输敏感信息</p>
              </div>
            </details>
<p><br/></p>
<h1 id="调试开发"><a href="#调试开发" class="headerlink" title="调试开发"></a>调试开发</h1><h3 id="Q1：浏览器乱码原因是什么？怎么解决？"><a href="#Q1：浏览器乱码原因是什么？怎么解决？" class="headerlink" title="Q1：浏览器乱码原因是什么？怎么解决？"></a>Q1：浏览器乱码原因是什么？怎么解决？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>字符编码不匹配：</strong></p><ul><li><p><strong>原因：</strong> HTML 文件和浏览器解析的字符编码不一致，或者在请求资源时服务器未正确设置字符编码。</p></li><li><p><strong>解决：</strong> 在 HTML 文件的 <code>&lt;head&gt;</code> 部分添加正确的字符编码声明。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>确保服务器正确设置响应头的字符编码。</p></li></ul></li><li><p><strong>字体缺失或不支持：</strong></p><ul><li><p><strong>原因：</strong> 浏览器默认字体无法显示特定字符，或者网页使用的字体不被系统支持。</p></li><li><p><strong>解决：</strong> 使用通用字体，如宋体、微软雅黑等，或者在 CSS 中指定多个备选字体。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font-family: &#x27;Arial&#x27;, &#x27;Helvetica&#x27;, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>文本文件编码问题：</strong></p><ul><li><p><strong>原因：</strong> 文本文件（如 JavaScript 文件）使用了不同的编码，导致浏览器解析时出现乱码。</p></li><li><p><strong>解决：</strong> 统一使用相同的字符编码，并确保在文件头部声明正确的编码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络传输问题：</strong></p><ul><li><strong>原因：</strong> 在网络传输过程中，如果没有正确设置字符编码，可能导致乱码。</li><li><strong>解决：</strong> 在服务器端设置正确的字符编码，确保响应头中包含正确的 Content-Type。</li></ul></li><li><p><strong>非法字符或损坏的文件：</strong></p><ul><li><strong>原因：</strong> 文件中包含非法字符或文件损坏。</li><li><strong>解决：</strong> 检查文件内容，确保文件中的字符都是合法的，并尝试重新下载或替换文件。</li></ul></li><li><p><strong>浏览器缓存问题：</strong></p><ul><li><strong>原因：</strong> 之前的资源缓存可能与当前网页字符编码不一致。</li><li><strong>解决：</strong> 尝试清除浏览器缓存，或使用浏览器的无痕模式加载页面。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何实现浏览器内多个标签页之间的通信"><a href="#Q2：如何实现浏览器内多个标签页之间的通信" class="headerlink" title="Q2：如何实现浏览器内多个标签页之间的通信"></a>Q2：如何实现浏览器内多个标签页之间的通信</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>LocalStorage 或 SessionStorage：</strong></p><ul><li>使用 <code>localStorage</code> 或 <code>sessionStorage</code> 存储数据，这两者在同一域下的不同标签页之间是共享的。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个标签页中设置数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个标签页中获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Broadcast Channel API：</strong></p><ul><li>使用 <code>BroadcastChannel</code> API，可以在同一域下的不同标签页之间广播消息。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个标签页中发送消息</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;my_channel&#x27;</span>);</span><br><span class="line">channel.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Tab 1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个标签页中接收消息</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;my_channel&#x27;</span>);</span><br><span class="line">channel.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); <span class="comment">// 输出：Hello from Tab 1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Window.postMessage：</strong></p><ul><li>使用 <code>window.postMessage</code> 方法，该方法允许一个窗口向另一个窗口发送消息。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在一个标签页中发送消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Tab 1&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个标签页中接收消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); <span class="comment">// 输出：Hello from Tab 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Service Workers：</strong></p><ul><li>使用 Service Workers 在后台执行脚本，可以通过 <code>postMessage</code> 进行通信，从而实现多个标签页之间的消息传递。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主线程（页面）</span></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">controller</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Tab 1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service Worker</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); <span class="comment">// 输出：Hello from Tab 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Shared Workers：</strong></p><ul><li>使用 Shared Workers 共享状态和消息，这样不同的标签页可以共享相同的工作线程。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在多个标签页中共享的脚本</span></span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;shared-worker.js&#x27;</span>);</span><br><span class="line">sharedWorker.<span class="property">port</span>.<span class="title function_">start</span>();</span><br><span class="line">sharedWorker.<span class="property">port</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Tab 1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shared Worker</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> port = event.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">  port.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>); <span class="comment">// 输出：Hello from Tab 1</span></span><br><span class="line">  &#125;);</span><br><span class="line">  port.<span class="title function_">start</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>他们之间的区别：</p><div class="table-container"><table><thead><tr><th>方法</th><th>区别与注意事项</th><th>适用场景</th></tr></thead><tbody><tr><td>LocalStorage</td><td>- 存储容量较小，通常在 5MB 左右。 <br> - 数据改变时，其他标签页需要轮询检查。</td><td>- 小量数据的共享。</td></tr><tr><td>Broadcast Channel API</td><td>- 要求同一域下的标签页。 <br> - 可以轻松地广播消息给所有其他标签页。</td><td>- 需要实时广播消息给所有标签页的场景。</td></tr><tr><td>Window.postMessage</td><td>- 跨域通信时，需要确保目标窗口的 <code>origin</code> 和当前窗口的 <code>targetOrigin</code> 匹配。 <br> - 安全性要求高。</td><td>- 跨域通信，安全性要求高的场景。</td></tr><tr><td>Service Workers</td><td>- 可以在后台执行脚本。 <br> - 仅在 HTTPS 或 localhost 下工作。 <br> - 可以实现离线缓存等功能。 <br> - 需要考虑 Service Worker 生命周期。</td><td>- 后台执行任务，实现离线功能，推送通知等场景。</td></tr><tr><td>Shared Workers</td><td>- 多个标签页可以共享相同的工作线程。 <br> - 需要使用相对较新的浏览器。 <br> - 全局共享状态，需要注意状态同步和互斥。 <br> - 需要考虑 Shared Worker 的生命周期。</td><td>- 多个标签页需要共享状态，如在线编辑文档等场景。</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：前端跨页面通信有哪些方法？"><a href="#Q3：前端跨页面通信有哪些方法？" class="headerlink" title="Q3：前端跨页面通信有哪些方法？"></a>Q3：前端跨页面通信有哪些方法？</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>前端跨页面通信是指在不同的浏览器标签页或窗口之间进行信息传递</p><p>以下是一些常见的前端跨页面通信的方法：</p><ol><li><p><strong>LocalStorage 或 SessionStorage</strong> </p><p>使用浏览器的本地存储机制，将数据存储在LocalStorage或SessionStorage中</p><p>这样可以在同一浏览器的不同标签页之间共享数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在页面1中设置数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面2中获取数据</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>Cookies</strong> </p><p>将数据存储在 Cookies 中，因为 Cookies 是在同一域名下的所有页面之间共享的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在页面1中设置Cookie</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;key=value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面2中获取Cookie</span></span><br><span class="line"><span class="keyword">var</span> cookies = <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>Broadcast Channel API</strong></p><p>使用 Broadcast Channel API，该 API 允许一个文档向其他具有相同频道名称的文档广播消息</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在页面1中广播消息</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;myChannel&#x27;</span>);</span><br><span class="line">channel.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Page 1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面2中监听消息</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;myChannel&#x27;</span>);</span><br><span class="line">channel.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Window.postMessage</strong></p><p>使用 <code>window.postMessage</code> 方法，允许从一个窗口向另一个窗口传递数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在页面1中发送消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;Hello from Page 1&#x27;</span>, <span class="string">&#x27;https://example.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面2中监听消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">origin</span> === <span class="string">&#x27;https://example.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received message:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Shared Workers</strong></p><p>使用共享 Web Worker，它是在多个浏览上下文（页面、标签页等）之间共享的后台线程，可以用于进行跨页面通信</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在页面1中创建 Shared Worker</span></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面2中连接到 Shared Worker</span></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>IndexedDB：</strong> 使用 IndexedDB 进行本地数据库存储，不同页面可以访问同一个数据库</p></li></ol><p>这些方法的选择取决于具体的需求和使用场景。localStorage 和 sessionStorage 适用于较小量的数据，而 Broadcast Channel API 和 Window.postMessage 更适用于需要频繁通信的情况。 Shared Workers 和 IndexedDB 则适用于更复杂的场景，涉及到大量数据或需要在后台进行处理。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：为什么推荐把静态资源放在CDN上"><a href="#Q4：为什么推荐把静态资源放在CDN上" class="headerlink" title="Q4：为什么推荐把静态资源放在CDN上"></a>Q4：为什么推荐把静态资源放在CDN上</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>将静态资源放在内容分发网络（CDN）上有很多优势</p><p>以下是一些主要原因：</p><ol><li><p>提高加载速度</p><p>CDN在全球范围内有多个分布式的服务器节点</p><p>当用户请求静态资源时，CDN会将请求路由到离用户最近的服务器节点，从而减少了网络延迟和加载时间</p><p>这对于用户体验的提升非常显著，特别是对于全球用户访问的网站</p></li><li><p>减少服务器负载</p><p>通过将静态资源托管在CDN上，可以显著减少原始服务器的负载</p><p>CDN会缓存这些资源并处理大部分的请求，这样原始服务器可以专注于处理动态内容和业务逻辑，提高整体系统的性能和稳定性</p></li><li><p>增强可扩展性</p><p>CDN具有很强的扩展能力，可以应对突发的大量请求</p><p>例如，在某个资源突然变得非常受欢迎时，CDN能够迅速扩展以处理大量的并发请求，而不需要对原始服务器进行复杂的扩容操作</p></li><li><p>提高可靠性</p><p>CDN通常具有高可用性和冗余机制，即使某个节点出现故障，流量也可以迅速切换到其他可用节点，确保资源的高可用性和可靠性</p></li><li><p>安全性</p><p>CDN提供了多种安全功能，如DDoS防护、WAF（Web应用防火墙）、SSL/TLS加密等，可以帮助保护网站免受各种网络攻击</p></li><li><p>节省带宽成本</p><p>CDN通过缓存和优化传输，减少了原始服务器的带宽消耗</p><p>许多CDN提供商还与ISP有合作，可以进一步降低带宽成本</p></li><li><p>降低延迟</p><p>CDN通过智能路由和优化传输路径，减少了数据包在网络中的传输时间，进一步降低了延迟，提高了资源加载速度</p></li><li><p>缓解网络拥堵</p><p>CDN的分布式架构可以有效地缓解网络拥堵问题，通过将请求分散到多个节点，避免了单一服务器或网络路径的过载</p></li><li><p>地理位置优化</p><p>CDN会根据用户的地理位置动态选择最优的服务器节点进行响应，这样可以最大程度地利用网络资源，提高访问速度</p></li><li><p>版本控制和缓存管理</p><p>CDN提供了强大的缓存管理功能，可以设置缓存策略、版本控制和缓存刷新策略，确保用户始终获取最新的资源版本</p></li></ol><p><strong>总结</strong></p><p>将静态资源放在CDN上，不仅可以显著提升网站的性能和用户体验，还可以提高系统的可靠性、安全性和可扩展性，同时降低运营成本</p><p>因此，使用CDN来托管静态资源是一个非常推荐的实践</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：Blob、ArrayBuffer和Base64分别有什么使用场景"><a href="#Q5：Blob、ArrayBuffer和Base64分别有什么使用场景" class="headerlink" title="Q5：Blob、ArrayBuffer和Base64分别有什么使用场景"></a>Q5：Blob、ArrayBuffer和Base64分别有什么使用场景</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Blob</code></p><p>Blob（Binary Large Object）是表示二进制数据的对象，通常用于处理文件数据</p><p>它可以包含任意类型的数据，并且可以通过JavaScript的File API进行操作</p><p><strong>功能</strong></p><ul><li><strong>存储二进制数据</strong>：Blob可以存储图像、视频、音频、文本文件等各种类型的二进制数据</li><li><strong>生成文件对象</strong>：可以通过Blob对象生成文件对象，从而进行文件的读取、上传和下载操作</li><li><strong>流式处理</strong>：Blob支持分块读取，适合处理大文件</li></ul><p><strong>使用场景</strong></p><ul><li><strong>文件上传</strong>：将用户选择的文件转换为Blob对象，然后通过FormData上传到服务器</li><li><strong>文件下载</strong>：从服务器获取二进制数据，生成Blob对象并创建下载链接，供用户下载文件</li><li><strong>图像处理</strong>：将Canvas绘制的图像数据转换为Blob对象，然后进行保存或上传操作</li><li><strong>音视频处理</strong>：将音频或视频数据存储为Blob对象，以便进行播放或传输</li></ul></li><li><p><code>ArrayBuffer</code></p><p>ArrayBuffer是一个通用的、固定长度的二进制数据缓冲区</p><p>它不能直接操作数据，但可以通过视图（如TypedArray和DataView）来读取和写入数据</p><p><strong>功能</strong></p><ul><li><strong>存储和操作二进制数据</strong>：ArrayBuffer可以存储二进制数据，并通过视图进行读取和写入操作</li><li><strong>高效的数据处理</strong>：适用于需要高效处理大量二进制数据的场景，如图像处理、音视频处理等</li><li><strong>与Web API集成</strong>：ArrayBuffer可以与许多Web API（如WebSockets、Fetch API等）集成，进行二进制数据的传输和处理</li></ul><p><strong>使用场景</strong></p><ul><li><strong>音视频处理</strong>：使用ArrayBuffer存储音频或视频数据，并通过TypedArray进行高效处理</li><li><strong>图像处理</strong>：使用ArrayBuffer存储图像数据，并通过视图进行操作和转换</li><li><strong>网络传输</strong>：通过WebSockets或Fetch API传输二进制数据，如文件或流媒体</li><li><strong>数据解析</strong>：解析二进制文件格式，如读取和解析二进制协议数据</li></ul></li><li><p><code>Base64</code></p><p>Base64是一种基于64个字符的编码方式，用于将二进制数据编码为ASCII字符串</p><p>它常用于在不支持二进制数据传输的场景中传输二进制数据</p><p><strong>功能</strong></p><ul><li><strong>数据编码</strong>：将二进制数据编码为Base64字符串，以便在文本环境中传输或存储</li><li><strong>数据解码</strong>：将Base64字符串解码为原始的二进制数据</li><li><strong>数据嵌入</strong>：将二进制数据嵌入到文本内容中，如HTML、CSS或JSON</li></ul><p><strong>使用场景</strong></p><ul><li><strong>数据传输</strong>：在不支持二进制传输的协议或环境中（如JSON、XML）传输二进制数据</li><li><strong>数据存储</strong>：将二进制数据以字符串形式存储在数据库或文本文件中</li><li><strong>数据嵌入</strong>：将图像、音频或其他二进制数据嵌入到HTML、CSS或JSON中，如在HTML中嵌入Base64编码的图像数据</li><li><strong>电子邮件附件</strong>：在电子邮件中嵌入Base64编码的附件，以便在不支持二进制附件的环境中传输文件</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>Blob</strong>：用于存储和处理二进制数据，适合文件上传、下载和流式处理等场景</li><li><strong>ArrayBuffer</strong>：用于高效存储和操作二进制数据，适合音视频处理、图像处理和网络传输等场景</li><li><strong>Base64</strong>：用于将二进制数据编码为ASCII字符串，适合在不支持二进制传输的环境中传输或存储数据</li></ul>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《FPS显示》</title>
    <url>/posts/fab43e38/</url>
    <content><![CDATA[<h2 id="新建Javascript文件"><a href="#新建Javascript文件" class="headerlink" title="新建Javascript文件"></a>新建Javascript文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rAF = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> ||</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> ||</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">            <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;();</span><br><span class="line"><span class="keyword">var</span> frame = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> allFrameCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">var</span> lastFameTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">var</span> loop = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">var</span> fs = (now - lastFameTime);</span><br><span class="line">    <span class="keyword">var</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">1000</span> / fs);</span><br><span class="line"> </span><br><span class="line">    lastFameTime = now;</span><br><span class="line">    <span class="comment">// 不置 0，在动画的开头及结尾记录此值的差值算出 FPS</span></span><br><span class="line">    allFrameCount++;</span><br><span class="line">    frame++;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (now &gt; <span class="number">1000</span> + lastTime) &#123;</span><br><span class="line">        <span class="keyword">var</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>((frame * <span class="number">1000</span>) / (now - lastTime));</span><br><span class="line">        <span class="keyword">if</span>(fps&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:#bd0000&quot;&gt;卡成ppt&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fps&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:red&quot;&gt;电竞级帧率&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fps&lt;=<span class="number">14</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:yellow&quot;&gt;难受&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fps&lt;<span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:orange&quot;&gt;卡&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fps&lt;=<span class="number">40</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:green&quot;&gt;...&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> kd=<span class="string">`&lt;span style=&quot;color:#425aef&quot;&gt;正常&lt;/span&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fps&quot;</span>).<span class="property">innerHTML</span>=<span class="string">`FPS:<span class="subst">$&#123;fps&#125;</span> <span class="subst">$&#123;kd&#125;</span>`</span>;</span><br><span class="line">        frame = <span class="number">0</span>;</span><br><span class="line">        lastTime = now;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">rAF</span>(loop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">loop</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 帧率检测 */</span></span><br><span class="line"><span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="comment">/* 指定位置 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.85</span>);</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#fps</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.72</span>);</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># 零零散散的css</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/新建的fps的.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 显示FPS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/新建的fps的.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">id=&quot;fps&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>面经汇总</title>
    <url>/posts/ed392c85/</url>
    <content><![CDATA[<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/556519a1/">Html</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/179be34f/">Css</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/e82d9764/">Javascript</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/cb2af883/">手写Javascript</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/376fa3ef/">Vue</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/f967bad7/">React</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/75cf67a1/">工程化</a></p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p><a href="https://wutiaowu5t5.github.io/posts/4d830755/">浏览器 &amp;&amp; 计算机网络</a></p>
            </div>
<div class='checkbox gray'><input type="checkbox" />
            <p>Node</p>
            </div>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>建站-《项目搭建、配置》</title>
    <url>/posts/9d37818d/</url>
    <content><![CDATA[<h2 id="Hexo起步"><a href="#Hexo起步" class="headerlink" title="Hexo起步"></a>Hexo起步</h2><ol>
<li><p>首先，你需要起一个项目，新建博客的文件夹作为根目录</p>
</li>
<li><p>然后采用编辑器的终端进行命令行输入</p>
</li>
<li><p>安装项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"><span class="comment">#将npm源替换为阿里的镜像。之后的安装就会迅速很多了。</span></span><br><span class="line"></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"><span class="comment"># hexo-cli 是 hexo的指令集。</span></span><br><span class="line"></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 有了指令集以后，使用它的初始化指令来初始化安装Hexo博客。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line"><span class="comment"># nib css支持插件，如无需求，可跳过</span></span><br><span class="line"></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"><span class="comment"># RSS订阅支持插件，如无需求，可跳过</span></span><br><span class="line"></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"><span class="comment"># sitemap生成插件，帮助搜索引擎抓取，如无需求，可跳过</span></span><br><span class="line"></span><br><span class="line">npm install hexo-admin --save</span><br><span class="line"><span class="comment"># 网页端hexo文档管理插件，如无需求，可跳过</span></span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># git部署插件，必须安装</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"><span class="comment">#清空缓存</span></span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line">hexo g <span class="comment">#简写</span></span><br><span class="line"><span class="comment">#重新编译</span></span><br><span class="line"></span><br><span class="line">hexo server</span><br><span class="line">hexo s <span class="comment">#简写</span></span><br><span class="line"><span class="comment">#打开本地访问</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;layout&gt; <span class="string">&quot;文章title&quot;</span></span><br><span class="line"><span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo deploy</span><br><span class="line">hexo d <span class="comment">#简写</span></span><br><span class="line"><span class="comment">#部署到云端</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>本地预览</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>终端跑了之后就会出现</p>
<p><img src="https://s2.loli.net/2023/12/06/RpX3qE1TfAHdBIy.png" alt="image-20231206151517155"></p>
<p>打开浏览器之后，在搜索框里面输入这个 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可以预览</p>
<p><img src="https://s2.loli.net/2023/12/06/f1vqxRX86BIaHyr.png" alt="image-20231206151909257"></p>
</li>
</ol>
<p><br/></p>
<h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><p>这里选择的主题是<code>butterfly</code>，<a href="https://butterfly.js.org">官网</a>在这里</p>
<ol>
<li><p>安装主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>运行这个命令，下载项目下来，这里安装的是开发分支的项目，可以体验更多的东西，但是bug比较多，看个人选择</p>
</li>
</ol>
<ol>
<li><p>应用主题</p>
<p>修改 <code>Hexo</code> 根目錄下的 <code>_config.yml</code>，把主題改為 <code>butterfly</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装插件</p>
<p>这里按照官方教程安装插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>复制<code>_config.yml</code></p>
<p>在 <code>hexo</code> 的根目錄創建一個文件 <code>_config.butterfly.yml</code>，並把主題目錄的 <code>_config.yml</code> 內容複製到 <code>_config.butterfly.yml</code> 去。( 注意: 複製的是主題的 <code>_config.yml</code> ，而不是 <code>hexo</code> 的 <code>_config.yml</code>)</p>
<p>注意： 不要把主題目錄的 <code>_config.yml</code> 刪掉</p>
<p>注意： 以後只需要在 <code>_config.butterfly.yml</code> 進行配置就行。如果使用了 <code>_config.butterfly.yml</code>， 配置主題的 <code>_config.yml</code> 將不會有效果。</p>
</li>
<li><p>运行 <code>hexo server</code></p>
</li>
</ol>
<p><br/></p>
<h2 id="基础的搭建"><a href="#基础的搭建" class="headerlink" title="基础的搭建"></a>基础的搭建</h2><p>本站的一些基础搭建参考<code>Jerry</code>的基础教程</p>
<ol>
<li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li>
<li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></li>
<li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></li>
</ol>
<p>然后基础的信息搭建好了，现在开始参考网上其他魔改大佬的教程</p>
<p><br/></p>
<h2 id="魔改准备工作"><a href="#魔改准备工作" class="headerlink" title="魔改准备工作"></a>魔改准备工作</h2><ol>
<li>在博客根目录下的<code>source</code>文件夹下新建<code>js</code>、<code>css</code>、<code>img</code>三个文件夹</li>
<li>在 <code>_config.butterfly.yml</code>文件下面的<code>inject</code>选项里面添加你新建的各种<code>js</code>，<code>css</code></li>
</ol>
<p><br/></p>
<h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h3><p>1、<a href="https://butterfly.js.org/posts/21cfbf15">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p>
<p>2、<a href="https://akilar.top/posts/6ef63e2d/">Win10:Hexo+github搭建个人博客 | Akilarの糖果屋</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript 面试题》</title>
    <url>/posts/e82d9764/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Q1：什么是DOM跟BOM"><a href="#Q1：什么是DOM跟BOM" class="headerlink" title="Q1：什么是DOM跟BOM"></a>Q1：什么是DOM跟BOM</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>DOM（文档对象模型）和 BOM（浏览器对象模型）都是由浏览器提供的两个重要的 API（应用程序接口），用于处理和操纵网页内容以及浏览器窗口等相关功能。</p><p>DOM（文档对象模型）：</p><ol><li><strong>定义：</strong><ul><li>DOM 是一种对文档的结构化表示，以树状的方式呈现 HTML 或 XML 文档，使开发者可以通过脚本语言（通常是 JavaScript）动态地访问和修改文档的内容、结构和样式。</li></ul></li><li><strong>主要功能：</strong><ul><li>提供了一种将文档表示为树形结构的方式，每个 HTML 或 XML 元素都是树中的一个节点。</li><li>允许开发者通过脚本语言操作文档的内容，例如添加、删除、修改元素。</li><li>提供了一系列的 API，使开发者能够动态地操作页面的结构和样式，响应用户的交互。</li></ul></li></ol><p>BOM（浏览器对象模型）：</p><ol><li><strong>定义：</strong><ul><li>BOM 是浏览器提供的一组对象，用于表示浏览器窗口和浏览器本身的各种信息，而不是文档的结构。</li></ul></li><li><strong>主要对象：</strong><ul><li><code>window</code> 对象：表示浏览器窗口，包含了有关窗口的信息和方法。</li><li><code>navigator</code> 对象：包含有关浏览器的信息，如浏览器类型和版本。</li><li><code>screen</code> 对象：包含有关用户屏幕的信息，如屏幕宽度和高度。</li><li><code>location</code> 对象：包含有关当前文档 URL 的信息，可以用于导航到其他页面。</li><li><code>history</code> 对象：包含用户在浏览器窗口中访问的 URL 历史记录。</li></ul></li></ol><p>区别：</p><ul><li><strong>DOM 关注文档的内容和结构，提供了一种访问和操作文档的方式。</strong></li><li><strong>BOM 关注浏览器窗口和浏览器本身的信息，提供了一种管理浏览器窗口和与浏览器交互的方式</strong></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：说说你对轮询的理解"><a href="#Q2：说说你对轮询的理解" class="headerlink" title="Q2：说说你对轮询的理解"></a>Q2：说说你对轮询的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>什么是轮询？</strong></p><p>轮询是一种用于获取信息或监视状态的计算机编程技术。在轮询中，程序会定期检查一个或多个资源的状态，以确定它们是否有可用数据或发生了特定事件。</p><p><strong>长短轮询有什么区别？</strong></p><ul><li><strong>长轮询（Long Polling）</strong>：客户端发送一个请求到服务器，服务器保持连接打开，直到有数据更新或超时才响应请求。如果超时，则客户端会立即发起新的请求。</li><li><strong>短轮询（Short Polling）</strong>：客户端定期向服务器发送请求，询问是否有数据更新。服务器会立即响应，并在每次响应后，客户端都会立即发起新的请求。</li></ul><p><strong>实现轮询的方式：</strong></p><ol><li><strong>传统轮询</strong>：客户端定期发送请求询问服务器是否有更新。</li><li><strong>长轮询</strong>：客户端发送请求到服务器，服务器保持连接，直到有数据更新或超时才响应。</li><li><strong>WebSocket</strong>：通过双向通信通道实现实时数据传输，避免了轮询的延迟和资源浪费。</li></ol><p><strong>轮询的优缺点对比（使用表格方式）：</strong></p><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>- 简单易实现<br>- 兼容性强<br>- 灵活性高<br></td><td>- 资源浪费（频繁轮询可能造成服务器负担增加）<br>- 延迟高（不能立即检测到状态变化）<br>- 不适用于实时应用场景</td></tr></tbody></table></div><p><strong>如何避免轮询的缺点？</strong></p><ol><li><strong>使用长轮询或WebSocket</strong>：长轮询和WebSocket可以降低延迟，提高实时性。</li><li><strong>优化轮询频率</strong>：根据应用场景的需要调整轮询频率，避免不必要的资源浪费。</li><li><strong>使用推送技术</strong>：使用服务器推送技术（如Server-Sent Events、WebSocket）可以在发生事件时立即将数据推送给客户端，避免了轮询的延迟和资源浪费。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获"><a href="#Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获" class="headerlink" title="Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获?"></a>Q3：给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li>捕获阶段点击事件触发</li><li>冒泡阶段点击事件触发</li></ol><p>这两个事件都会被执行一次。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>事件传播分为三个阶段：捕获阶段、目标阶段和冒泡阶段。当一个事件发生在 DOM 元素上时，它会经历这三个阶段。以下是对每个阶段的详细解释：</p><ol><li><strong>捕获阶段（Capturing Phase）</strong>：<ul><li>事件从顶层的根节点向下传播到目标节点之前的阶段。</li><li>在捕获阶段中，事件首先被捕获到最顶层的父节点，然后逐级向下传播到目标节点。</li></ul></li><li><strong>目标阶段（Target Phase）</strong>：<ul><li>事件到达目标节点后的阶段。</li><li>在目标阶段中，事件到达目标节点并在目标节点上触发。</li></ul></li><li><strong>冒泡阶段（Bubbling Phase）</strong>：<ul><li>事件从目标节点开始向上冒泡到顶层的根节点的阶段。</li><li>在冒泡阶段中，事件从目标节点开始，逐级向上传播到根节点。</li></ul></li></ol><p>事件传播过程中，如果某个阶段的处理函数调用了 <code>stopPropagation()</code> 方法，则会阻止事件继续传播到下一个阶段。如果某个阶段的处理函数返回 <code>false</code>，也会阻止事件继续传播到下一个阶段。否则，事件会继续传播到下一个阶段。</p><p>在实际开发中，可以利用事件传播的特性来实现事件委托（Event Delegation），即将事件绑定到父元素上，通过事件冒泡机制来处理子元素上的事件，从而提高性能和减少代码量。</p><p>总结：</p><ul><li>捕获阶段：从根节点向目标节点传播。</li><li>目标阶段：在目标节点上触发。</li><li>冒泡阶段：从目标节点向根节点传播。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：直接在script标签中写-export-为什么会报错"><a href="#Q4：直接在script标签中写-export-为什么会报错" class="headerlink" title="Q4：直接在script标签中写 export 为什么会报错?"></a>Q4：直接在script标签中写 export 为什么会报错?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 <code>&lt;script&gt;</code> 标签中直接写 <code>export</code> 会导致语法错误，因为 <code>export</code> 是 ECMAScript 模块的语法，而 <code>&lt;script&gt;</code> 标签内的代码通常被视为普通的 JavaScript 代码，不是模块。</p><p>如果要使用 <code>export</code>，需要将 JavaScript 代码放在一个模块中，并通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签引入，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 此处可以使用 export</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">const</span> greeting = <span class="string">&quot;Hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者将 <code>export</code> 语句放在独立的 JavaScript 文件中，然后通过 <code>&lt;script src=&quot;your-script.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code> 引入。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：mouseover-利-mouseenter-有什么区别"><a href="#Q5：mouseover-利-mouseenter-有什么区别" class="headerlink" title="Q5：mouseover 利 mouseenter 有什么区别?"></a>Q5：mouseover 利 mouseenter 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>mouseover</code> 和 <code>mouseenter</code> 是 DOM 事件中常见的鼠标事件，它们在触发时有一些区别：</p><ol><li><strong>mouseover</strong>：<ul><li><code>mouseover</code> 事件在鼠标指针从一个元素的外部移入到该元素或其子元素时触发。</li><li>当鼠标指针进入目标元素的任何子元素时，也会触发 <code>mouseover</code> 事件。</li><li>这个事件会冒泡，当鼠标指针穿过目标元素的多个子元素时，会在每个子元素上触发。</li></ul></li><li><strong>mouseenter</strong>：<ul><li><code>mouseenter</code> 事件在鼠标指针从一个元素的外部移入到该元素时触发，但不会在进入其子元素时触发。</li><li>即使鼠标指针进入目标元素的子元素，也不会触发 <code>mouseenter</code> 事件。</li><li>这个事件不会冒泡，只有在鼠标指针直接从外部移入目标元素时才会触发。</li></ul></li></ol><p>综上所述，主要区别在于 <code>mouseover</code> 事件在鼠标穿过目标元素的子元素时也会触发，而 <code>mouseenter</code> 事件只在鼠标直接从外部移入目标元素时触发，并且不会在鼠标进入目标元素的子元素时触发。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6-：offsetWidth-offsetHeight-clientWidth-clientHeight-与"><a href="#Q6-：offsetWidth-offsetHeight-clientWidth-clientHeight-与" class="headerlink" title="Q6 ：offsetWidth/offsetHeight,clientWidth/clientHeight 与"></a>Q6 ：offsetWidth/offsetHeight,clientWidth/clientHeight 与</h3><p>scrollWidth/scrollHeight 的区别?</p>
<p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这些属性都是用于获取元素的尺寸信息，但它们之间有一些区别：</p><ol><li><strong>offsetWidth/offsetHeight</strong>：<ul><li><code>offsetWidth</code> 和 <code>offsetHeight</code> 分别返回元素的宽度和高度，包括元素的边框(border)和内边距(padding)，以及垂直滚动条、水平滚动条（如果存在的话）的宽度和高度。</li><li>这些值通常是相对于父元素的内容框（content box）的。</li><li>即 <code>offsetWidth = width + border + padding + 滚动条宽度</code>，<code>offsetHeight = height + border + padding + 滚动条高度</code>。</li></ul></li><li><strong>clientWidth/clientHeight</strong>：<ul><li><code>clientWidth</code> 和 <code>clientHeight</code> 返回元素的内容框（content box）的宽度和高度，不包括边框和滚动条。</li><li>即 <code>clientWidth = width + padding</code>，<code>clientHeight = height + padding</code>。</li><li>这些值通常是相对于视口（viewport）的，即视口的宽度和高度。</li></ul></li><li><strong>scrollWidth/scrollHeight</strong>：<ul><li><code>scrollWidth</code> 和 <code>scrollHeight</code> 返回元素的内容区域的总宽度和总高度，包括了元素内容区域的实际宽度和高度以及被隐藏部分的宽度和高度（如果有的话）。</li><li>当元素内容区域大于其可视区域时，可以通过滚动来查看被隐藏的内容，此时 <code>scrollWidth</code> 和 <code>scrollHeight</code> 将会大于 <code>clientWidth</code> 和 <code>clientHeight</code>。</li><li>通常情况下，<code>scrollWidth</code> 和 <code>scrollHeight</code> 会大于或等于 <code>clientWidth</code> 和 <code>clientHeight</code>。</li></ul></li></ol><p>综上所述，这些属性提供了不同类型的尺寸信息，其中 <code>offsetWidth/offsetHeight</code> 包含了元素的边框、内边距和滚动条的尺寸，<code>clientWidth/clientHeight</code> 只包含了元素的内容区域的尺寸，而 <code>scrollWidth/scrollHeight</code> 则包含了元素内容的实际宽度和高度以及被隐藏的部分。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：JS中怎么阻止事件冒泡和默认事件"><a href="#Q7：JS中怎么阻止事件冒泡和默认事件" class="headerlink" title="Q7：JS中怎么阻止事件冒泡和默认事件?"></a>Q7：JS中怎么阻止事件冒泡和默认事件?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>阻止事件冒泡</strong>：</p><ul><li><p>使用 <code>event.stopPropagation()</code> 方法来停止事件冒泡。这会阻止事件进一步传播到父元素或其他祖先元素。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">    <span class="comment">// 这里的代码不会触发父元素的 click 事件处理程序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>阻止默认事件行为</strong>：</p><ul><li><p>使用 <code>event.preventDefault()</code> 方法来阻止事件的默认行为。例如，阻止链接的默认点击行为、表单提交等。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="comment">// 阻止链接的默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>同时阻止事件冒泡和默认行为</strong>：</p><ul><li><p>如果需要同时阻止事件的冒泡和默认行为，可以先调用<code>return false</code> 。在某些情况下，使用 <code>return false</code> 可以达到同时阻止事件冒泡和默认行为的目的，但需要注意这种方式并不是严格意义上的标准做法。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 阻止事件冒泡和默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8："><a href="#Q8：" class="headerlink" title="Q8："></a>Q8：</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：谈谈你对事件冒泡和捕获的理解"><a href="#Q9：谈谈你对事件冒泡和捕获的理解" class="headerlink" title="Q9：谈谈你对事件冒泡和捕获的理解"></a>Q9：谈谈你对事件冒泡和捕获的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>事件冒泡（Event Bubbling）和事件捕获（Event Capturing）是 DOM 事件传播的两种不同的阶段。理解它们对于编写复杂的交互式网页应用程序至关重要。</p><p><strong>事件冒泡（Event Bubbling）：</strong></p><p>事件冒泡是指当在 DOM 树中触发某个事件时，该事件将从最具体的元素（事件目标）开始逐级向上传播到最不具体的元素（document）。换句话说，事件首先触发在目标元素上，然后向上冒泡直到根节点（document）。</p><p><img src="https://s2.loli.net/2024/03/10/A64yikwsxhCMmPG.gif" alt=""></p><ul><li>事件从目标元素开始向上传播到父元素、祖父元素，一直到根节点。</li><li>大多数事件都会冒泡，包括点击事件、键盘事件等。</li></ul><p><strong>事件捕获（Event Capturing）：</strong></p><p>事件捕获是事件传播的另一个阶段，它在事件冒泡之前发生。事件捕获从根节点（document）开始，逐级向下直到达到事件的实际目标元素。</p><p><img src="https://s2.loli.net/2024/03/10/A64yikwsxhCMmPG.gif" alt="img"></p><ul><li>在事件捕获阶段，事件从根节点向下传播到目标元素。</li><li>在事件捕获阶段触发的事件处理程序会在目标元素的祖先元素上触发。</li></ul><p><strong>事件传播的三个阶段：</strong></p><ol><li><strong>捕获阶段（Capture Phase）</strong>：事件从根节点向下传播到目标元素。</li><li><strong>目标阶段（Target Phase）</strong>：事件在目标元素上触发。</li><li><strong>冒泡阶段（Bubble Phase）</strong>：事件从目标元素向上传播到根节点。</li></ol><p><strong>事件处理：</strong></p><p>当一个元素上触发了某个事件时，事件首先在捕获阶段触发该元素的事件处理程序，然后在目标阶段触发该元素上的事件处理程序，最后在冒泡阶段触发该元素的父级元素的事件处理程序。</p><p><strong>使用场景：</strong></p><ul><li><strong>事件代理（Event Delegation）</strong>：事件代理通常利用事件冒泡机制，将事件处理程序绑定在父元素上，以处理大量子元素的事件，提高性能和代码简洁性。</li><li><strong>控制事件的传播</strong>：了解事件冒泡和捕获可以更好地控制事件的传播行为，有助于编写更灵活、高效的交互式应用程序。</li></ul><p>综上所述，事件冒泡和捕获是理解 DOM 事件传播机制的关键概念，掌握它们可以更好地处理和控制事件流。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：ES6有什么新特性"><a href="#Q10：ES6有什么新特性" class="headerlink" title="Q10：ES6有什么新特性"></a>Q10：ES6有什么新特性</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>箭头函数</strong></p><p> 箭头函数提供了更简洁的函数定义语法，并且自动绑定了 <code>this</code> 关键字</p></li><li><p><strong>let 和 const</strong></p><p> let 和 const 关键字用于声明变量，let 声明的变量具有块级作用域，而 const 声明的变量是常量，其值无法再次赋值</p></li><li><p><strong>模板字符串</strong></p><p> 使用反引号 `` 包裹的字符串，可以在其中插入变量和表达式，实现更灵活的字符串拼接</p></li><li><p><strong>解构赋值</strong></p><p> 可以通过解构赋值语法，从数组或对象中提取值并赋给变量，使代码更简洁</p></li><li><p>**扩展运算符和剩余参数：</p><p> 使用 <code>...</code> 来表示扩展运算符和剩余参数，用于处理可变长度的参数列表或数组</p></li><li><p><strong>类和继承</strong> </p><p>ES6 引入了类的概念，使得在 JavaScript 中可以更方便地使用面向对象的编程风格，并支持类的继承</p></li><li><p><strong>Promise</strong></p><p> Promise 是一种处理异步操作的方式，可以更清晰地表示异步操作的完成或失败，并使用链式调用来处理异步操作的结果</p></li><li><p><strong>模块化</strong> </p><p>ES6 引入了模块化的语法，可以更好地组织和管理 JavaScript 代码，使其更易于维护和重用</p></li><li><p><strong>新的数据结构</strong></p><p> ES6 提供了新的数据结构，如 Set、Map、WeakSet、WeakMap，用于存储数据并支持高效的查找和操作</p></li><li><p><strong>Iterator 和 Generator</strong></p><p> Iterator 是一种统一的遍历接口，而 Generator 是一种通过函数简化迭代器的定义的方式。</p></li><li><p><strong>Symbol</strong> </p><p>Symbol 是一种新的基本数据类型，用于创建唯一的标识符，可以用作对象的属性名，从而避免属性名冲突</p></li><li><p><strong>Proxy 和 Reflect</strong></p><p> Proxy 对象用于定义自定义的行为，如拦截对象的读取、写入和删除等操作，而 Reflect 对象提供了一组与 Proxy 对象相关的方法</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：xml和json什么区别"><a href="#Q11：xml和json什么区别" class="headerlink" title="Q11：xml和json什么区别"></a>Q11：xml和json什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>XML（可扩展标记语言）和 JSON（JavaScript 对象表示法）都是用于表示和传输数据的格式，它们有以下区别：</p><ol><li><strong>语法</strong>:<ul><li>XML 使用标签来描述数据结构，每个标签包含开始标签和结束标签，例如 <code>&lt;name&gt;John&lt;/name&gt;</code>。</li><li>JSON 使用键值对的形式来描述数据结构，键和值之间使用冒号分隔，键值对之间使用逗号分隔，最外层通常是一个对象或数组。</li></ul></li><li><strong>可读性</strong>:<ul><li>JSON 更加简洁和易读，因为它使用了更轻量级的语法，适合于数据交换和传输。</li><li>XML 的语法相对冗长，标签名、属性、值等都需要以文本形式表示，不如 JSON 直观。</li></ul></li><li><strong>数据类型</strong>:<ul><li>JSON 支持对象（键值对）、数组、字符串、数字、布尔值和 null。</li><li>XML 支持更多的数据类型，包括字符串、数字、布尔值、日期、时间、文本、元素、属性等。</li></ul></li><li><strong>扩展性</strong>:<ul><li>XML 是可扩展的，允许使用者自定义标签和属性，适用于定义复杂的数据结构和领域特定语言。</li><li>JSON 的结构相对固定，不支持自定义标签和属性，只能通过对象和数组来组织数据。</li></ul></li><li><strong>解析和处理</strong>:<ul><li>在 JavaScript 中，JSON 更容易解析和处理，因为它可以直接转换为 JavaScript 对象。</li><li>XML 需要使用 DOM 解析器或 SAX 解析器进行解析，相对来说处理起来更加繁琐。</li></ul></li></ol><p>综上所述，JSON 更加轻量、简洁、易读，并且更适合于数据交换和传输。而 XML 则更加灵活，支持更多的数据类型和自定义标签，适用于定义复杂的数据结构和领域特定语言。选择使用 JSON 还是 XML 取决于具体的应用场景和需求。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：为什么JavaScript是单线程"><a href="#Q12：为什么JavaScript是单线程" class="headerlink" title="Q12：为什么JavaScript是单线程?"></a>Q12：为什么JavaScript是单线程?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 是一种单线程语言，这意味着它在任何给定的时间只能执行一个任务或代码块。这种设计是由 JavaScript 的最初用途所决定的，即作为网页上交互式脚本的语言。下面是一些原因解释为什么 JavaScript 是单线程的：</p><ol><li><strong>简单性和一致性</strong>：单线程模型使得 JavaScript 的行为更加简单和可预测。它不需要开发者担心多线程之间的竞态条件、死锁等复杂的并发问题。</li><li><strong>网页交互</strong>：JavaScript 最初是为了在浏览器中操作网页元素而设计的。在这种情况下，多线程并发可能会导致混乱和不可预测的结果，例如多个脚本同时尝试修改同一个 DOM 元素。</li><li><strong>防止阻塞</strong>：JavaScript 在浏览器中是由浏览器引擎负责解释和执行的。如果 JavaScript 是多线程的，那么一个线程的阻塞可能会影响到其他线程的执行，从而导致用户界面的卡顿和不流畅。</li></ol><p>虽然 JavaScript 本身是单线程的，但是通过使用事件循环和异步编程模型，JavaScript 可以利用回调函数、Promise、async/await 等机制来处理异步操作，从而实现非阻塞的并发执行。这样的设计使得 JavaScript 在处理网络请求、定时器、用户输入等异步任务时可以更高效地利用资源，同时保持了简单性和可预测性。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>JavaScript 的事件循环（Event Loop）是一种处理程序执行、事件和调度消息的过程</p><p>它允许 JavaScript 在执行长时间的任务时，仍然可以处理其他的事件，例如用户输入、脚本加载等</p><p>在深入事件循环之前，首先需要了解 JavaScript 的运行环境是单线程的</p><p>这意味着在同一时间内只能执行一个任务</p><p>为了协调这些任务，使得高延迟操作不会阻塞线程，事件循环得以产生</p><p>事件循环的机制如下：</p><ol><li><strong>调用栈（Call Stack）</strong>：<ul><li>执行的所有代码块（函数调用）都按顺序进入一个“调用栈”</li><li>当 JS 引擎首次执行脚本时，全局代码作为一个主要的块首先被推送到栈中</li><li>每当一系列函数调用发生时，它们会按照调用顺序被推入栈中，并且当函数执行完毕，返回结果后，它们会从栈中被弹出</li></ul></li><li><strong>任务队列（Task Queue）</strong>：<ul><li>当异步事件完成时，例如：HTTP 请求、文件读取、setTimeout 等，相应的回调函数会被添加到“任务队列”中</li><li>如果调用栈为空，即所有当前任务已经执行完成，事件循环就会从任务队列中取出回调函数并推入调用栈来执行</li><li>有哪些宏任务？<ul><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code> (主要用在 Node.js)</li><li>I/O 操作（如文件读写、网络请求等）</li><li>UI 渲染事件 (例如 <code>requestAnimationFrame</code>，在浏览器环境中)</li><li><code>MessageChannel</code></li><li>主脚本的执行 (HTML 页面加载完毕后，浏览器中的全局执行上下文)</li></ul></li></ul></li><li><strong>微任务队列（Microtask Queue）</strong>：<ul><li>微任务队列是一个处理比任务队列优先级更高的任务的队列</li><li>当一个 Promise 被解决或拒绝时，相应的 <code>.then()</code>、<code>.catch()</code> 或 <code>.finally()</code> 处理程序会被添加到微任务队列中</li><li>微任务队列在每个宏任务执行完毕后会完全清空</li><li>有哪些微任务？<ul><li><code>Promise.then</code>、<code>Promise.catch</code> 和 <code>Promise.finally</code> 处理函数</li><li><code>queueMicrotask</code> (这是一个显式将任务排入微任务队列的方法)</li><li><code>MutationObserver</code> (浏览器中，用于观察 DOM 变化的回调)</li><li><code>process.nextTick</code> (在 Node.js 中)</li></ul></li></ul></li></ol><p>任务队列的执行逻辑是这样的：</p><ul><li><p>当一个宏任务执行完毕后，JavaScript 引擎会查看是否有微任务需要执行</p><p>如果微任务队列中有任务，那么它们会被依次执行，直到微任务队列为空</p></li><li><p>如果微任务执行过程中产生新的微任务，这些新的微任务也会被加入微任务队列并在本轮循环中执行完毕</p></li><li><p>微任务全部执行完毕后，渲染进程（在浏览器中）将有机会更新渲染，然后事件循环将进入下一个宏任务执行</p><p>在此之前，可能会处理其他的UI事件、操作等</p></li><li><p>接着，下一个宏任务开始执行，之后该宏任务的微任务，依此类推</p></li></ul><p>整个这个循环确保了异步任务的有效执行，同时允许通过微任务和宏任务</p><p><br /></p><p>事件循环的过程简化如下：</p><ol><li><p>执行全局脚本</p></li><li><p>执行调用栈中的同步代码</p></li><li><p>如果调用栈为空，检查微任务队列</p><p>如果微任务队列不为空，执行微任务，直到队列为空</p></li><li><p>取出任务队列中的下一个任务，推入调用栈中执行</p></li><li><p>重复上述流程</p></li></ol><p>由于微任务的优先级高于普通任务，所以在任何新的宏任务被处理之前，微任务队列会被完全清空</p><p>这包括在微任务中创建的微任务</p><p>而对于宏任务来说，每执行完一个宏任务，都会检查并清空微任务队列，然后再执行下一个宏任务</p><p>最后，由于 JavaScript 的这个单线程非阻塞的性质，它适合处理 I/O 密集型的操作，而不是 CPU 密集型的操作，因为复杂的计算可能会长时间占据 JS 线程，造成界面不流畅或卡顿</p><p>在 Web 应用中，影响用户体验是需要避免的</p><p>因此理解和合理地利用事件循环，对于编写高效的 JavaScript 代码至关重要</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：”严格模式”是什么"><a href="#Q13：”严格模式”是什么" class="headerlink" title="Q13：”严格模式”是什么?"></a>Q13：”严格模式”是什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“严格模式”（Strict Mode）是 ECMAScript 5 引入的一种 JavaScript 执行模式，它提供了更加严格的语法和错误检查，有助于编写更安全、更规范的 JavaScript 代码。启用严格模式可以帮助开发者避免一些常见的错误，并且提高代码质量和性能。</p><p>启用严格模式的方法是在代码的顶部（全局作用域）或者函数体的开头（函数作用域）添加如下语句之一：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure><p>或者，在函数作用域内使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格模式对 JavaScript 的一些行为做了限制，其中一些主要的变化包括：</p><ol><li><strong>禁止使用未声明的变量</strong>：在严格模式下，使用未声明的变量会抛出 ReferenceError 错误。</li><li><strong>删除不可删除的属性</strong>：在严格模式下，删除不可删除的属性会抛出 TypeError 错误。</li><li><strong>禁止使用八进制表示法</strong>：在严格模式下，八进制数值的表示方式会被视为错误。</li><li><strong>禁止对只读属性赋值</strong>：在严格模式下，对只读属性赋值会抛出 TypeError 错误。</li><li><strong>函数参数名唯一性</strong>：在严格模式下，函数参数名不能重复。</li><li><strong>禁止使用 with 语句</strong>：在严格模式下，禁止使用 with 语句，因为它会导致作用域链被修改，增加代码的不可预测性。</li><li><strong>保留关键字</strong>：在严格模式下，一些在非严格模式下可以使用的关键字变成了保留字，不能作为变量名、函数名或参数名等标识符使用。</li></ol><p>启用严格模式的好处包括：</p><ul><li>帮助开发者捕获更多的错误，提高代码的健壮性。</li><li>使得 JavaScript 引擎可以更有效地优化代码，提高性能。</li><li>促使开发者遵循更严格的编程规范，减少不规范的代码写法。</li><li>为将来的 ECMAScript 版本引入新特性提供了更好的准备。</li></ul><p>因此，建议在 JavaScript 代码中尽可能使用严格模式，以获得更好的代码质量和执行性能。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：Node跟Element是什么关系？"><a href="#Q14：Node跟Element是什么关系？" class="headerlink" title="Q14：Node跟Element是什么关系？"></a>Q14：Node跟Element是什么关系？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在DOM（文档对象模型）中，Node 和 Element 是两个重要的接口，它们之间有一定的层次关系。</p><ol><li><strong>Node（节点）：</strong><ul><li><code>Node</code> 是 DOM 树中的基本构建块，代表文档树中的一个节点。<code>Node</code> 接口定义了所有节点类型的通用属性和方法。文档中的所有元素、属性、文本等都是节点。</li><li><code>Element</code> 是 <code>Node</code> 的子接口，因此每个 <code>Element</code> 对象也是 <code>Node</code> 对象。<code>Node</code> 接口提供了操作文档树的通用方法，比如查找父节点、子节点，添加、删除节点等。</li></ul></li><li><strong>Element（元素）：</strong><ul><li><code>Element</code> 接口表示文档中的元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等。<code>Element</code> 继承自 <code>Node</code>，因此具备了 <code>Node</code> 接口的所有属性和方法。</li><li><code>Element</code> 接口还提供了一些专门用于处理元素的属性和方法，如获取元素的标签名、设置和获取元素的属性、获取元素的子元素等。</li></ul></li></ol><p>在层次结构中，<code>Element</code> 是 <code>Node</code> 的一种特殊情况。所有的元素都是节点，但并非所有的节点都是元素。其他类型的节点包括文本节点、注释节点、文档节点等</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node and Element<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Example Element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;exampleElement&quot;</span>&gt;</span>This is an example element.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Accessing the element using JavaScript</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> elementNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Checking if it&#x27;s a Node</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (elementNode <span class="keyword">instanceof</span> <span class="title class_">Node</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is a Node.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Checking if it&#x27;s an Element</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (elementNode <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is an Element.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>document.getElementById(&#39;exampleElement&#39;)</code> 返回的是一个 <code>Element</code> 对象，它同时也是一个 <code>Node</code> 对象。通过 <code>instanceof</code> 运算符，我们可以检查对象是否是 <code>Node</code> 或 <code>Element</code> 的实例。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：说说你对DOM树的理解"><a href="#Q15：说说你对DOM树的理解" class="headerlink" title="Q15：说说你对DOM树的理解"></a>Q15：说说你对DOM树的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>文档对象模型（Document Object Model，简称DOM）是一种表达和操作HTML、XML等文档结构的方式。DOM 将文档解析为一个由节点组成的树状结构，每个节点代表文档中的一个元素、属性、文本等。</p><p>以下是对DOM树的一些理解：</p><ol><li><strong>树状结构：</strong> DOM 将文档表示为一个树状结构，其中树的根是文档节点，树的每个分支代表文档的不同层次结构，叶子节点代表文档中的具体元素或内容。</li><li><strong>节点：</strong> 树中的每个元素都是一个节点。节点可以是元素节点、属性节点、文本节点等。元素节点表示HTML或XML中的标签，属性节点表示元素的属性，文本节点表示元素包含的文本内容。</li><li><strong>层次结构：</strong> DOM 树按照文档的层次结构组织，每个节点有父节点、子节点和兄弟节点。根节点是文档节点，它没有父节点，而其他节点通过层次关系相互连接。</li><li><strong>实时性：</strong> DOM 是动态的，可以通过脚本语言（如JavaScript）来操作。可以通过脚本动态地添加、修改或删除节点，从而改变页面的结构和内容。</li><li><strong>接口：</strong> DOM 提供了一种通过编程方式访问和操作文档的接口。通过这些接口，开发者可以获取节点、修改节点的属性和内容、添加新节点等。</li><li><strong>跨平台性：</strong> DOM 是与平台和编程语言无关的标准，因此可以在各种环境和语言中使用。在浏览器中，通过JavaScript可以直接访问和操作DOM。</li><li><strong>事件模型：</strong> DOM 提供了事件模型，允许开发者对用户交互和其他事件进行监听和响应。例如，可以通过DOM来捕获用户的点击事件、键盘事件等。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><strong>分词器将字节流转化为 Token：</strong></li></ol><ul><li><strong>字节流：</strong> HTML 文档以字节流的形式从服务器传输到浏览器。</li><li><strong>分词器工作：</strong> 浏览器使用分词器（Tokenizer）将字节流转换为一系列 Token。Token 是解析过程的基本单元，包括标签 Token 和文本 Token。分词器根据 HTML 规范逐个读取字符，生成相应的 Token。</li></ul><ol><li><strong>Token解析为 DOM 节点</strong>：</li></ol><ul><li><strong>DOM 节点：</strong> Token 被解析为 DOM 节点，每个 Token 对应一个节点。节点包括元素节点、文本节点、属性节点等。</li><li><strong>构建 DOM 树：</strong> 浏览器通过将 Token 解析为相应的 DOM 节点来构建 DOM 树。元素节点表示 HTML 元素，文本节点表示元素包含的文本内容，属性节点表示元素的属性。</li></ul><ol><li><strong>将 DOM 节点添加到 DOM 树中：</strong></li></ol><ul><li><strong>DOM 树的构建：</strong> 在解析过程中，浏览器逐步构建 DOM 树，树的根节点是 <code>&lt;html&gt;</code> 元素，它有子节点 <code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code>。</li><li><strong>节点关系：</strong> 构建过程中，建立节点之间的父子关系。每个元素节点都成为其父节点的子节点，文本节点则成为相应元素节点的子节点。</li><li><strong>完整的 DOM 树：</strong> 构建完成后，得到一个完整的 DOM 树，表示了 HTML 文档的结构和层次关系。</li></ul><p>这三个阶段是解析和构建 DOM 树的关键步骤，DOM 树的构建是为了将文档结构化表示，以便浏览器进一步处理、布局和渲染到用户界面。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：Javascript跟Css是怎么阻塞DOM树构建的？"><a href="#Q16：Javascript跟Css是怎么阻塞DOM树构建的？" class="headerlink" title="Q16：Javascript跟Css是怎么阻塞DOM树构建的？"></a>Q16：Javascript跟Css是怎么阻塞DOM树构建的？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>JavaScript 阻塞 DOM 树构建：</strong><ul><li>当浏览器解析到 <code>&lt;script&gt;</code> 标签时，它会立即停止 HTML 解析，然后下载并执行 JavaScript 代码。</li><li>如果 JavaScript 代码位于文档的头部（即在 <code>&lt;head&gt;</code> 中），它可能会阻塞 DOM 树的构建，因为浏览器会等待 JavaScript 代码执行完成才能继续解析 HTML。</li><li>这种情况下，用户可能会看到一个白屏或加载延迟，因为 DOM 树的构建被阻塞，直到 JavaScript 执行完毕。</li></ul></li><li><strong>CSS 阻塞 DOM 树构建：</strong><ul><li>如果浏览器解析到外部样式表（通过 <code>&lt;link&gt;</code> 标签或 <code>@import</code>）或在文档头部的内联样式（在 <code>&lt;style&gt;</code> 标签中），它会开始下载和解析 CSS 文件。</li><li>如果 CSS 文件很大或者在网络上加载耗时，它可能会阻塞 DOM 树的构建，因为浏览器希望尽早获取和应用样式信息以正确渲染页面。</li><li>类似于 JavaScript 阻塞，这也可能导致页面加载延迟。</li></ul></li></ol><p>为了解决这些阻塞问题，可以采取以下措施：</p><ul><li><p><strong>将 JavaScript 放在底部：</strong> 将 <code>&lt;script&gt;</code> 标签放在文档底部，确保 HTML 解析不会因为 JavaScript 而阻塞。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">e<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- CSS 样式表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- JavaScript 脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>async</code> 或 <code>defer</code> 属性：</strong> 对于 <code>&lt;script&gt;</code> 标签，可以使用 <code>async</code> 或 <code>defer</code> 属性，使 JavaScript 异步加载和执行，减少对 DOM 树构建的阻塞。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化 CSS 文件加载：</strong> 尽可能减小 CSS 文件的大小，考虑使用浏览器缓存等策略，以减轻对 DOM 树构建的影响。</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：什么是变量提升"><a href="#Q17：什么是变量提升" class="headerlink" title="Q17：什么是变量提升"></a>Q17：什么是变量提升</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>变量提升（Hoisting）是 JavaScript 中的一种特性，它会将变量声明提升到当前作用域的顶部，但不会提升变量的赋值。</p><p>在 JavaScript 中，变量提升的规则如下：</p><ol><li>变量声明（以及函数声明）会被提升到当前作用域的顶部，但赋值操作不会被提升。这意味着在声明变量之前就可以访问这些变量，但访问时会返回 <code>undefined</code>。</li><li>变量提升只影响声明本身，不会影响作用域内的代码执行顺序。</li><li>如果变量名重复声明，后面的声明会覆盖前面的声明。</li></ol><p>例如，以下代码演示了变量提升的行为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 10;</span><br><span class="line"></span><br><span class="line">// 上面的代码实际上被 JavaScript 引擎理解为：</span><br><span class="line">var a;</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">a = 10;</span><br></pre></td></tr></table></figure><p>在上面的例子中，变量 <code>a</code> 在声明之前被访问，但由于变量提升的影响，代码不会报错，而是打印出 <code>undefined</code>。这是因为变量声明 <code>var a;</code> 被提升到了作用域的顶部，但赋值操作 <code>a = 10;</code> 并未被提升。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：JavaScript中的事件模型有哪些"><a href="#Q18：JavaScript中的事件模型有哪些" class="headerlink" title="Q18：JavaScript中的事件模型有哪些"></a>Q18：JavaScript中的事件模型有哪些</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 中的事件模型通常指的是 DOM 事件模型，它描述了在网页中处理和触发事件的机制。在 DOM 事件模型中，事件分为捕获阶段、目标阶段和冒泡阶段，而 JavaScript 提供了一些方法来注册和处理这些事件。以下是常见的几种事件模型：</p><ol><li><strong>DOM0级事件模型</strong>：<ul><li>在 DOM0 级事件模型中，事件处理程序直接赋值给 DOM 元素的属性。</li><li>示例：<code>element.onclick = function() { // 事件处理逻辑 }</code></li><li>特点：简单直接，适用于单一的事件处理。</li></ul></li><li><strong>DOM2级事件模型</strong>：<ul><li>在 DOM2 级事件模型中，通过 <code>addEventListener</code> 和 <code>removeEventListener</code> 方法来注册和移除事件处理程序。</li><li>示例：<code>element.addEventListener(&#39;click&#39;, function() { // 事件处理逻辑 }, false)</code></li><li>特点：支持多个事件处理程序，可以为同一个元素的同一种事件注册多个处理程序；支持事件捕获和冒泡；更加灵活和标准化。</li></ul></li><li><strong>IE 事件模型</strong>：<ul><li>IE 浏览器早期采用了与标准不同的事件模型，通过 <code>attachEvent</code> 和 <code>detachEvent</code> 方法来注册和移除事件处理程序。</li><li>示例：<code>element.attachEvent(&#39;onclick&#39;, function() { // 事件处理逻辑 })</code></li><li>特点：与 DOM2 级事件模型不同，IE 事件模型不支持事件捕获，只支持事件冒泡；事件处理程序的执行顺序与注册顺序相反。</li></ul></li><li><strong>事件委托模型</strong>：<ul><li>事件委托模型是利用事件冒泡的特性，将事件处理程序绑定在父元素上，通过判断事件目标来执行相应的逻辑。</li><li>特点：减少了事件处理程序的数量，提高了性能；适用于需要处理大量相似事件的情况，比如列表或表格中的事件处理。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19：-什么是同步和异步"><a href="#Q19：-什么是同步和异步" class="headerlink" title="Q19： 什么是同步和异步"></a>Q19： 什么是同步和异步</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<strong>同步</strong>和<strong>异步</strong>是两个描述代码执行模式的术语，它们用于处理代码的执行流程。理解这两个概念对编写高效、响应迅速的应用程序非常重要。</p><p><strong>同步（Synchronous）：</strong></p><ul><li><strong>定义</strong>：同步代码是指代码按照编写的顺序执行，前一个任务完成后，才会执行后一个任务。这种模式下，代码会阻塞在一个任务上，直到任务完成。</li><li><strong>执行方式</strong>：JavaScript 是单线程的，因此在同步代码中，所有代码在同一个线程中按顺序执行。如果某个任务（例如计算密集型任务或 I/O 操作）耗时较长，它会阻塞后续代码的执行，导致用户界面卡顿或响应迟钝。</li><li><strong>示例</strong>：例如，如果你在代码中执行一个循环，而循环内有一个密集计算操作，整个循环执行期间程序将一直阻塞在这个操作上。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 密集计算任务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，密集计算任务会阻塞程序，导致第二个 <code>console.log</code> 语句的执行延迟。</p><p><strong>异步（Asynchronous）：</strong></p><ul><li><strong>定义</strong>：异步代码是指不按照顺序执行任务，而是让任务在后台进行。程序可以在等待任务完成的同时继续执行其他代码，这样的机制可以避免阻塞。</li><li><strong>执行方式</strong>：JavaScript 使用事件循环来管理异步任务。这意味着在执行同步代码的同时，异步任务可以在后台进行。一旦异步任务完成，它将通过回调函数、Promise、<code>async/await</code> 等方式来通知主线程。</li><li><strong>示例</strong>：例如，使用 <code>setTimeout</code> 来延迟执行某个代码块。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务完成&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>console.log(&#39;结束&#39;)</code> 会在 <code>setTimeout</code> 的回调函数执行之前立即执行。因此，”结束” 会先于 “异步任务完成” 输出。</p><p><strong>异步编程的常用方式：</strong></p><ul><li><strong>回调函数</strong>：使用函数作为参数传递给异步操作，当异步操作完成时调用。</li><li><strong>Promise</strong>：一种表示异步操作最终完成或失败的对象，允许链式处理异步任务。</li><li><strong><code>async/await</code></strong>：基于 Promise 的异步语法糖，使异步代码更类似于同步代码。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：CSS动画和JS实现的动画分别有哪些优缺点"><a href="#Q20：CSS动画和JS实现的动画分别有哪些优缺点" class="headerlink" title="Q20：CSS动画和JS实现的动画分别有哪些优缺点?"></a>Q20：CSS动画和JS实现的动画分别有哪些优缺点?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>CSS 动画和 JavaScript 实现的动画是两种常用的网页动画方式，它们各有优缺点</p><p>理解它们的特性和适用场景可以帮助你在项目中做出最佳的选择</p><p><strong>CSS 动画</strong></p><p><strong>优点：</strong></p><ol><li><strong>性能优越</strong>：CSS 动画通常会被 GPU 加速，这可以减少 CPU 的负担，提高动画的流畅度。</li><li><strong>简单易用</strong>：CSS 动画通过定义样式来实现，代码简洁明了，不需要过多的 JavaScript 逻辑。</li><li><strong>自动化</strong>：CSS 动画可以在元素进入和离开 DOM 时自动触发，例如通过 <code>:hover</code>、<code>:focus</code> 等伪类。</li><li><strong>不阻塞页面渲染</strong>：CSS 动画不会阻塞页面渲染，因为它们是异步执行的。</li><li><strong>一致性</strong>：不同浏览器对 CSS 动画的实现一致，提供了良好的跨浏览器兼容性。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>控制有限</strong>：CSS 动画的功能较为简单，不如 JavaScript 实现的动画灵活</li><li><strong>事件监听受限</strong>：CSS 动画很难直接与 JavaScript 的事件监听器互动（可以通过监听 <code>animationend</code> 事件解决）</li><li><strong>调试困难</strong>：CSS 动画的调试和调整通常比 JavaScript 实现的动画更困难</li></ol><p><strong>JavaScript 实现的动画</strong></p><p><strong>优点：</strong></p><ol><li><strong>高度灵活</strong>：JavaScript 实现的动画可以控制动画的细节和行为，提供了更高的灵活性</li><li><strong>交互性强</strong>：JavaScript 动画可以与其他事件（如点击、鼠标移动等）和数据源（如 API）结合，实现更复杂的交互</li><li><strong>自定义</strong>：可以通过 JavaScript 控制动画的整个生命周期，包括开始、暂停、恢复、停止等</li><li><strong>链式调用</strong>：JavaScript 动画库（如 GSAP）通常支持链式调用，允许你方便地创建复杂的动画序列</li></ol><p><strong>缺点：</strong></p><ol><li><strong>性能可能较差</strong>：如果处理不当，JavaScript 动画可能导致性能问题，如 CPU 负载高、动画不流畅等</li><li><strong>代码复杂度高</strong>：JavaScript 实现的动画通常需要更多的代码和逻辑来管理，代码复杂度较高</li><li><strong>动画可能阻塞页面渲染</strong>：如果 JavaScript 动画在主线程中运行，它可能会阻塞页面渲染，导致用户体验下降</li></ol><p><strong>选择的权衡</strong></p><ul><li>对于简单的动画（例如元素的淡入淡出、滑动效果等），并且不需要高度灵活性，CSS 动画通常是最佳选择</li><li>对于需要高度交互和定制化的动画，或者需要与其他 JavaScript 逻辑密切配合的动画，JavaScript 是更好的选择</li><li>无论选择哪种方式，确保动画的性能和流畅性是关键。此外，可以结合两者的优势，CSS 用于简单的动画效果，而 JavaScript 用于更复杂的逻辑和交互</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：堆与栈有什么区别"><a href="#Q21：堆与栈有什么区别" class="headerlink" title="Q21：堆与栈有什么区别"></a>Q21：堆与栈有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>栈（Stack）</strong></p><ol><li><p><strong>管理方式</strong></p><p>栈由编译器自动管理，无需程序员手动控制</p></li><li><p><strong>内存分配和回收</strong></p><p>遵循后进先出（LIFO，Last In First Out）原则，意味着最后分配的内存块会被最先释放</p></li><li><p><strong>速度</strong></p><p>栈内存的分配和回收速度非常快</p></li><li><p><strong>大小限制</strong></p><p>栈的大小在程序启动时已经定好，因此空间有限</p></li><li><p><strong>用途</strong></p><p>主要用于存放局部变量、函数参数和返回地址等</p></li><li><p><strong>生命周期</strong></p><p>栈内存中的对象通常在其定义的代码块执行结束后即失效</p></li></ol><p><strong>堆（Heap）</strong></p><ol><li><p><strong>管理方式</strong></p><p>堆内存的分配和释放需要程序员通过代码手动管理（或通过垃圾回收机制自动管理，例如在 Java、Python 等语言中）</p></li><li><p><strong>内存分配和回收</strong></p><p>内存分配更为灵活，可以在任何时候申请和释放内存</p></li><li><p><strong>速度</strong></p><p>相比于栈，堆内存的分配和回收速度较慢</p></li><li><p><strong>大小限制</strong></p><p>堆的大小受到系统可用内存的限制，理论上比栈要大得多</p></li><li><p><strong>用途</strong></p><p>主要用于存储程序运行中动态分配的大块内存，比如用来存储由<code>new</code>操作符创建的对象和数组</p></li><li><p><strong>生命周期</strong></p><p>堆内存中的对象生命周期不由代码块控制，而是依赖于引用和垃圾回收机制</p></li></ol><p><strong>核心区别</strong></p><ul><li><p><strong>管理方式</strong></p><p>栈是由系统自动分配释放，而堆则需由程序员控制或依赖于垃圾回收机制</p></li><li><p><strong>性能</strong></p><p>栈操作更快但有大小限制，而堆内存更灵活但分配和回收速度较慢</p></li><li><p><strong>用途差异</strong></p><p>栈通常用来存储执行线程的临时变量，而堆则用来存储程序运行时动态分配的内存</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：Service-worker是什么"><a href="#Q22：Service-worker是什么" class="headerlink" title="Q22：Service worker是什么"></a>Q22：Service worker是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Service Worker 是一种在Web浏览器中运行的脚本，它充当客户端（例如Web应用）与网络之间的代理服务器</p><p>它可以帮助你通过以下方式控制网络请求、缓存资产、以及提供能够在网络不可用时仍能正常使用网站或应用的能力</p><p>这些特性在PWA（渐进式Web应用）中尤为关键</p><p>下面是 Service Worker 的一些主要功能和特点：</p><ol><li><p><strong>离线体验</strong></p><p>Service Worker 可以拦截并缓存网络请求，使得网站能够在无网络状态下运行，从而提供更好的离线体验</p></li><li><p><strong>背景同步</strong></p><p>即使页面关闭后，Service Worker 仍然可以同步数据，等你下次上线时更新状态或进行通知</p></li><li><p><strong>网络请求优化</strong></p><p>通过缓存一些重复的资源请求，Service Worker 能够优化应用的加载时间和性能</p></li><li><p><strong>推送通知</strong></p><p>Service Worker 有能力接收服务器的推送消息，并将这些消息作为系统通知展示给用户，即使网页没有打开</p></li><li><p><strong>生命周期独立</strong></p><p>Service Worker 与 Web 页面的生命周期是独立的，它可以在 Web 页面关闭后仍然活跃，与服务器进行通信</p></li><li><p><strong>不直接操作DOM</strong></p><p>Service Worker 运行在其自己的上下文中，无法直接操作DOM。它通过发送消息与页面通信</p></li><li><p><strong>安全性</strong></p><p>Service Worker 由于其强大的能力，要求在 HTTPS 环境下才能工作，以确保传输内容的安全性</p></li><li><p><strong>可编程网络代理</strong></p><p>开发者可以编写 Service Worker 中的事件响应器来自定义处理所有浏览器的网络请求</p></li></ol><p>由于 Service Worker 在浏览器后台作为一种独立的脚本运行，因此它能在你访问网页时启动，并且即使用户关闭了网页，它还可以打开新的网页</p><p>这为Web应用提供了更强的背景处理能力，大幅度扩展了Web的功能和可用性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：JSBridge是什么"><a href="#Q23：JSBridge是什么" class="headerlink" title="Q23：JSBridge是什么"></a>Q23：JSBridge是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>JSBridge</code> 是一种在移动应用的 <code>WebView</code> 中使用的技术，它允许 <code>JavaScript</code>（通常运行在 <code>WebView</code> 中的前端代码）与原生 <code>app</code> 代码（如 <code>Android</code> 或 <code>iOS</code>）进行通信</p><p><code>Bridge</code> 即是桥梁，指的是它作为前端代码和原生代码之间的桥梁，使得这两部分可以互相调用功能和数据</p><p>在开发过程中，通常会遇到一些网页功能无法直接实现或效率不高的问题，这时候就需要原生的支持</p><p>然而，网页端的 <code>JS</code> 无法直接访问手机系统的原生功能，如相机、文件系统等</p><p><code>JSBridge</code> 提供了这样的一种机制，允许网页端通过定义的协议发出调用指令，由原生端接收这个指令，执行相应的原生操作，并将结果返回给网页端</p><p>举个例子，如果你想在 <code>WebView</code> 中实现一个按钮，点击后打开手机相册并选择图片，你可能需要通过 <code>JSBridge</code> 来调用手机系统的相册功能</p><p>在 <code>JavaScript</code> 中，你可能会调用一个特定的函数或发送一个特定的消息，并通过 <code>JSBridge</code>，这个请求被原生应用捕获并处理，最终原生应用可以打开相册，用户选择图片后，原生代码再把选中的图片通过桥梁传递回 <code>JS</code> 端</p><p><code>JSBridge</code> 核心包含以下几个步骤：</p><ol><li><p><strong>消息发送</strong></p><p>网页端 <code>JS</code> 发起调用，发送消息</p></li><li><p><strong>消息拦截</strong></p><p>原生端拦截这些特定的消息/调用请求</p></li><li><p><strong>执行原生方法</strong></p><p>原生端执行对应的原生操作</p></li><li><p><strong>回调</strong></p><p>原生端处理完成后，通过桥梁将结果返回给网页端 <code>JS</code>，可能是通过回调函数或者是事件</p></li></ol><p>这种机制在很多移动应用中都有广泛的应用，特别是在混合应用（<code>Hybrid App</code>）开发中，混合应用是指同时包含原生界面元素和 <code>WebView</code> 的应用程序</p><p>使用 <code>JSBridge</code> 可以使得开发者既可以利用 <code>web</code> 技术的便捷和跨平台特性，又可以让应用有更丰富的功能，更好的性能和用户体验</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong><code>JSBridge</code>的实现原理是什么</strong></p><ul><li><p><code>URL Scheme</code></p><p>这是最早期的实现方式之一，通过拦截WebView的URL请求实现</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>JavaScript端通过修改<code>location.href</code>为特定的URL Scheme（如<code>myapp://functionName?param1=value1&amp;param2=value2</code>），然后原生代码可以通过WebView的代理方法拦截到这个URL请求，解析出要调用的函数和参数，执行相应的原生操作</p></li><li><p><strong>原生调用JavaScript</strong></p><p>原生代码执行完毕后，可以通过调用WebView的方法（如Android的<code>webView.loadUrl(&quot;javascript:methodName(params)&quot;)</code>，iOS的<code>webView.evaluateJavaScript(&quot;methodName(params)&quot;, completionHandler: nil)</code>）来执行JavaScript端的方法，以此来传递结果或者触发页面的更新</p></li></ul></li><li><p><code>JavaScriptInterface</code>（<code>Android</code>特有）</p><p>在Android中，可以通过向WebView添加JavaScript的接口来实现JSBridge</p><p>即通过<code>WebView.addJavascriptInterface(Object, String)</code>方法，将一个Java对象映射到JavaScript环境中，JavaScript代码就可以直接调用这个Java对象的方法</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>定义一个Java对象，其中的方法使用<code>@JavascriptInterface</code>注解标注，然后添加到WebView中。JavaScript通过映射的对象直接调用这些方法</p></li><li><p><strong>原生调用JavaScript</strong></p><p>同上，通过<code>webView.loadUrl(&quot;javascript:...&quot;)</code>或<code>webView.evaluateJavaScript</code>方法调用</p></li></ul></li><li><p><code>MessageChannel</code> 或 <code>postMessage</code> (现代方法)</p><p>这是一种更现代的、基于HTML5的交互方式，适用于进行更复杂的数据交换</p><ul><li><p><strong>JavaScript调用原生</strong></p><p>通过WebView的<code>postMessage</code>方法发送消息，原生代码通过相应的监听器接收并处理这些消息</p></li><li><p><strong>原生调用JavaScript</strong></p><p>原生代码处理完业务逻辑后，可以通过调用<code>postMessage</code>方法向JavaScript发送消息，JavaScript端监听并处理这些消息</p></li></ul></li></ul></li></ul><p>不同的实现方式各有优缺点，比如URL Scheme简单但有安全风险，JavaScriptInterface易用但只限于Android，而MessageChannel或postMessage方式则更为安全和灵活，但需要较新的浏览器支持</p><p>在实践中，开发者需要根据自己的具体需求和目标平台的特点选择合适的实现方式</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：-JavaScript-中内存泄漏有哪几种情况"><a href="#Q24：-JavaScript-中内存泄漏有哪几种情况" class="headerlink" title="Q24： JavaScript 中内存泄漏有哪几种情况"></a>Q24： JavaScript 中内存泄漏有哪几种情况</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存</p><p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存</p><p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</p><p><img src="https://s2.loli.net/2024/05/10/jZoAS2xtUrBdOsq.png" alt="image-20240510182435283"></p><p>在JavaScript中，内存泄漏可能有以下几种常见情况：</p><ol><li><p><strong>全局变量意外赋值</strong></p><p>未经声明就赋值的变量会自动成为全局对象的属性，这意味着它们不会被当作局部变量进行垃圾收集</p></li><li><p><strong>被遗忘的计时器或回调函数</strong></p><p>如果你设置了定时器或者间隔（如 <code>setTimeout</code> 或 <code>setInterval</code>）并忘记清除它们，或者绑定了事件监听器并且没有适当移除，它们会一直存在，并且保持对它们回调函数中变量的引用</p></li><li><p><strong>脱离了DOM的引用</strong></p><p>如果你保存了一些DOM元素的引用然后删除了这些元素，除非这些引用也被明确地设置为null，否则它们不会被垃圾回收器回收</p></li><li><p><strong>闭包</strong></p><p>不正确或者不必要地使用闭包，可以造成父级函数作用域链中的变量无法被释放，特别是在闭包被长期保持的时候</p></li><li><p><strong>循环引用</strong></p><p>在早期的IE浏览器中，JavaScript中的对象和DOM对象之间的循环引用会导致内存无法释放</p><p>现代浏览器通过改进垃圾收集器来处理此问题，但在某些情况下循环引用仍然可能是问题</p></li></ol><p>为了避免内存泄漏，建议进行以下几个步骤</p><ul><li><p>明确生命周期</p><p>了解和规划你的代码和对象的生命周期以确保及时释放</p></li><li><p>使用工具和分析</p><p>利用浏览器提供的开发工具来监控和分析内存使用情况</p></li><li><p>减少全局变量使用</p><p>尽可能通过局部作用域和模块化来避免全局变量</p></li><li><p>清理定时器和监听器</p><p>确保用不到的时钟或者事件监听被清理掉</p></li><li><p>管理DOM引用</p><p>移除DOM元素时注意也要清理掉对应的JavaScript引用</p></li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>什么是垃圾回收机制</strong></p><p>垃圾回收（Garbage Collection，GC）是一种自动内存管理的形式</p><p>它的作用是回收程序中不再使用的内存空间，防止内存泄漏导致的资源浪费</p><p>大多数现代编程语言，包括JavaScript，都提供了某种形式的垃圾回收机制</p><p>垃圾回收主要基于这样一个事实：在程序运行过程中，有些对象会变得不再可达，即不存在任何方式来引用它们。这通常是因为对象已经超出了其作用域，或者没有任何变量或属性引用它</p><p>JavaScript中的垃圾回收通常由以下几个策略和算法实现：</p><ol><li><strong>标记-清除（Mark-and-Sweep）</strong><br>这是最常见的垃圾回收算法。当变量进入环境时，垃圾收集器会将它“标记”（通常设置一个位），以说明这个变量目前是活跃的。随后，收集器会去“扫描”内存中的所有变量，并标记那些还在被引用或者在作用域中可达的变量。之后，清除阶段启动，此时收集器会进行再次扫描，销毁那些在扫描阶段没被标记为活跃的变量，并回收它们占据的内存</li><li><strong>引用计数（Reference Counting）</strong><br>这是一种较早的垃圾回收算法，在该算法中，每个对象都有一个引用计数器。当有一个变量引用该对象时，引用计数增加；当引用被移除时，计数减少。如果一个对象的引用计数变为0，则意味着对象不再被引用，可以将其内存回收。然而，引用计数有一个主要问题，即循环引用。如果两个对象相互引用，即使它们都已不可访问，它们的引用计数也不会是0，导致内存无法释放</li><li><strong>分代收集（Generational Collection）</strong><br>这种算法是基于这样的事实：大多数对象都是短暂的。因此，它会将对象分为两组，新生代（Young Generation）和老年代（Old Generation）。新生代中的对象经常进行垃圾回收，因为许多对象都很快就不再需要了，而老年代中的对象不那么频繁进行回收，因为它们通常存活时间更长。在实际操作中，如果一个新生代的对象在多次收集后依然存活，它可能会被移至老年代</li><li><strong>增量收集（Incremental Collection）</strong>：<br>由于GC会暂停所有代码的执行，如果堆内存很大，这可能会导致明显的暂停。增量收集算法会将垃圾收集分成小片段执行，减少每次收集导致的停顿时间。这样，垃圾回收与应用程序代码可以交替执行</li><li><strong>空闲时间收集（Idle-time Collection）</strong><br>某些垃圾回收系统只会在CPU空闲时执行，减少对程序执行的影响</li></ol><p>JavaScript的垃圾收集是自动的，而我们作为开发者通常无需直接管理内存</p><p>但了解和遵循良好的编码习惯可以减少内存泄漏和过早的垃圾收集，从而提高应用程序的性能</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：什么是事件代理"><a href="#Q25：什么是事件代理" class="headerlink" title="Q25：什么是事件代理"></a>Q25：什么是事件代理</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>事件代理是一种利用事件冒泡原理来简化事件处理器管理的技术</p><p>在DOM中，如果一个元素发生了事件（比如点击），这个事件会依次冒泡至其所有的父元素，直至文档的根元素</p><p>事件代理就是在父元素上设置一个事件监听器，监听来自子元素的事件</p><p><br/></p><p><strong>文字例子</strong></p><p>想象你在一个图书馆里，有一个专门的儿童阅读区，这个区域里有很多本绘本供孩子们阅读</p><p>每当一个孩子对某本书感兴趣，并想要借阅时，他们都会举手示意</p><p>为了管理这些请求，图书管理员不会挨个去询问每一个举手的孩子想要阅读哪本书，而是只在儿童区设置一个“服务点”</p><p>每当有孩子举手时，他们就会到这个服务点告诉管理员他们想要的书</p><p>这样，无论儿童区有多少孩子想要借书，管理员只需要在一个地方就能管理所有的请求</p><p><br/></p><p><strong>代码例子</strong></p><p>假设我们有一个按钮列表，每个按钮点击时都会触发一个事件</p><p>不使用事件代理，我们可能需要为每个按钮单独添加事件监听器</p><p>使用事件代理，我们只需要在它们的父元素上添加一个事件监听器</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;buttonList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;buttonList&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 检查事件来源是否是按钮</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&#x27;BUTTON&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">textContent</span> + <span class="string">&#x27; 被点击了&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>好处</strong></p><ul><li>减少内存使用：不需要为每个子元素单独绑定事件监听器，只在共同的父元素上绑定一个监听器即可</li><li>方便代理动态元素：对于动态添加到父元素中的子元素，无需再次手动添加事件监听器</li></ul><p><strong>局限性</strong></p><ul><li>不是所有事件都能冒泡：适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code>。某些事件（如<code>focus</code>、<code>blur</code>等）不会冒泡，对于这些事件，事件代理不适用</li><li>事件对象的<code>target</code>属性可能需要额外处理：在某些情况下，需要确切知道事件具体是在哪个子元素上被触发，这时可能需要对<code>event.target</code>进行额外的检查和处理</li><li>细粒度控制较困难：如果只想对特定的子元素进行事件处理，而这些元素并没有共同的父元素，用事件代理的方式就比较困难</li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>Javascript事件流</strong></p><p>JavaScript中的事件流描述了从页面中接收事件的顺序</p><p>事件流可以分为两种主要的模型：事件冒泡（Event Bubbling）和事件捕获（Event Capturing）</p><p>这两种事件流模型的主要区别在于事件触发的顺序</p><p><br/></p><p><strong>事件冒泡（Event Bubbling）</strong></p><p>事件冒泡是最常见的事件流模型，在这个模型中，当一个事件触发在DOM中的某个元素上时，这个事件会逐级向上传播至其所有的祖先元素直到文档的根元素（通常是<code>document</code>对象）</p><p>例如，如果你点击了一个按钮，那么首先这个点击事件会在按钮上触发，然后冒泡到按钮的父元素，然后是更高一级的父元素，一直冒泡到<code>document</code>对象</p><p><br/></p><p><strong>事件捕获（Event Capturing）</strong></p><p>事件捕获则是另一种事件流模型</p><p>事件捕获的顺序与事件冒泡相反，当一个事件发生后，浏览器首先会从<code>document</code>对象开始捕获事件，然后通过DOM树向下传递到事件实际发生的位置</p><p>事件捕获的目的是在事件到达预定目标前先捕获它</p><p><br/></p><p><strong>DOM标准事件流的三个阶段</strong></p><p>DOM事件标准定义了事件处理的三个阶段：</p><ol><li>捕获阶段（Capturing phase）：从<code>document</code>对象传导到事件目标的路径上的对象开始捕获事件</li><li>目标阶段（Target phase）：实际的事件目标对象对事件作出反应</li><li>冒泡阶段（Bubbling phase）：从事件目标对象传导回<code>document</code>对象的路径上的对象开始处理事件</li></ol><p><br/></p><p><strong>使用addEventListener进行事件处理</strong></p><p>使用<code>addEventListener</code>方法添加事件处理程序时，你可以指定第三个参数来决定是在捕获阶段还是冒泡阶段触发该处理程序</p><p>如果第三个参数设置为<code>true</code>，那么事件处理程序将在捕获阶段触发，如果设置为<code>false</code>（或者不设置，因为默认值就是<code>false</code>），事件处理程序将在冒泡阶段触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在冒泡阶段触发</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// handle click event</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在捕获阶段触发</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// handle click event</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>了解事件流对于开发者来说至关重要，因为它直接影响事件处理程序的行为和程序的整体性能</p><p>通过合适的使用事件捕获和冒泡，开发者可以更精确地控制事件处理的策略</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：什么是作用域、作用域链"><a href="#Q26：什么是作用域、作用域链" class="headerlink" title="Q26：什么是作用域、作用域链"></a>Q26：什么是作用域、作用域链</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li><p>作用域</p><p>作用域是指程序中定义变量的区域，该位置决定了变量的可见性和生命周期</p><p>它限定了一个变量的使用范围</p><p>在JavaScript中，作用域可以大致分为两种：全局作用域和局部作用域</p><ul><li><p><strong>全局作用域</strong></p><p>在代码中任何位置都能访问到的变量，都处于全局作用域</p><p>一般来说，在最外层定义的变量或者未经声明直接赋值的变量（这是不推荐的做法），都是全局作用域的变量</p></li><li><p><strong>局部作用域</strong></p><p>只能在定义它的函数内部访问到的变量</p><p>局部作用域可以进一步分为函数作用域和块级作用域（ES6新增）</p><ul><li><p><strong>函数作用域</strong></p><p>在函数内部声明的变量，只能在该函数内部被访问</p></li><li><p><strong>块级作用域</strong></p><p>由<code>{}</code>包括的区域定义的作用域，使用<code>let</code>和<code>const</code>声明的变量在相应的块级作用域中有效</p></li></ul></li></ul></li><li><p>作用域链</p><p>当代码在一个环境中执行时，会创建变量的作用域链</p><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问</p><p>作用域链的前端，始终都是当前执行的代码所在环境的变量对象，如果这个环境是函数，则将其活动对象作为变量对象</p><p>活动对象在最开始时只包含一个变量，即<code>arguments</code>对象（这个对象包含了调用函数时传入的所有参数）</p><p>作用域链向上逐级查询直到全局执行环境，全局环境的变量对象始终是作用域链的最后一个对象</p><ul><li><p><strong>作用域链的工作机制</strong></p><p>当代码需访问一个变量时，JavaScript引擎首先会尝试在当前执行环境的变量对象中查找标识符</p><p>如果没找到，继续在上一层作用域的变量对象中查找</p><p>一直向上直到全局执行环境</p><p>如果在整个作用域链中都没有找到标识符，则表明该变量未声明</p></li></ul></li><li><p>例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;global&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&quot;outer&quot;</span>; <span class="comment">// 局部变量，函数outer的作用域</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> innerVar = <span class="string">&quot;inner&quot;</span>; <span class="comment">// 局部变量，函数inner的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(innerVar); <span class="comment">// &quot;inner&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// &quot;outer&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// &quot;global&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure><p>在<code>inner</code>函数中，尝试访问<code>innerVar</code>、<code>outerVar</code>和<code>globalVar</code></p><p>首先，在<code>inner</code>的作用域中找到了<code>innerVar</code></p><p>由于在<code>inner</code>作用域中找不到<code>outerVar</code>，它会去上一级作用域，即<code>outer</code>函数的作用域中查找，找到了<code>outerVar</code></p><p>同样的，<code>globalVar</code>在<code>inner</code>和<code>outer</code>的作用域中都找不到，所以它会继续向上查找直到全局作用域，最后在全局作用域中找到了<code>globalVar</code></p><p>这个过程就是作用域链的体现：从当前作用域开始，逐级向上查找变量，直到找到为止，或者最终在全局作用域结束查找</p><p>这确保了在函数嵌套的情况下，内部函数可以访问到外部函数以及全局变量</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：说一下对于SPA的理解"><a href="#Q27：说一下对于SPA的理解" class="headerlink" title="Q27：说一下对于SPA的理解"></a>Q27：说一下对于SPA的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>单页面应用程序（Single Page Application，SPA）</strong>是一种浏览器中运行的应用程序模型</p><p>在这种模型中，用户在浏览器中加载一个HTML页面，然后所有的交互都通过JavaScript完成，这些JavaScript代码会动态更新页面上的部分，而不是加载新页面</p><p>这种模式提供了一种更接近原生应用的用户体验</p><p>当你打开一个SPA，大部分资源（HTML + CSS + Scripts）都会在一次加载中完成</p><p>之后的每次操作，例如点击一个链接或者提交表单，都不会引发页面的重新加载</p><p>相反，JavaScript将运行，执行必要的操作（可能是AJAX请求到服务器获取新数据），并在当前页内动态更新HTML</p><p>这种页面渲染方式避免了页面间切换时常规的网络请求，大大提高了页面交互的速度和效率</p><p>典型的SPA框架有React、Angular、Vue.js等，他们提供了构建用户界面的集合工具，帮助你处理页面的动态更新等问题</p><p>然而，SPA不是没有缺点</p><p>它对于SEO（搜索引擎优化）不太友好，因为搜索引擎可能会不理解或者执行你的JavaScript代码，导致某些内容无法被搜索引擎抓取到</p><p>而且，由于它需要一次性加载所有的代码和资源，可能会导致初次加载速度比较慢</p><p>最后，SPA的安全性也需要额外的关注，因为大部分代码都在客户端执行，因此可能存在安全风险</p><p><br /></p><p><strong>优点</strong></p><ol><li><p><strong>改进的用户体验</strong></p><p>由于用户在使用SPA时无需等待页面重新加载，因此可以提供平滑的用户体验，类似于使用桌面应用程序或原生移动应用程序</p></li><li><p><strong>减少服务器负载</strong></p><p>由于服务器不需要重新处理HTML页面和发送响应，所以服务器只需处理数据请求，降低了服务器的负载和带宽使用</p></li><li><p><strong>快速的响应时间</strong></p><p>页面不需要重新加载所有资源，只需加载新数据，这通常可以提供比传统多页应用更快的响应时间</p></li><li><p><strong>前后端分离</strong></p><p>SPA架构促进了前后端分离发展，前端负责用户界面和用户体验，后端负责数据管理和业务逻辑。这使得开发工作可以更好地协作分工</p></li><li><p><strong>简化的调试过程</strong></p><p>在SPA中，开发者可以只关注单一页面，使用Chrome开发者工具等辅助工具进行调试变得更加容易</p></li><li><p><strong>流畅的跨设备体验</strong></p><p>SPA能够适应不同的设备，而不要专门为移动设备或桌面设备开发不同的版本</p></li><li><p><strong>易于维护</strong></p><p>由于应用由模块化、互相独立的组件构建，开发者更容易添加新功能或者更新现有功能</p></li><li><p><strong>缓存效率</strong></p><p>SPA通过发送单一页面，可以有效地缓存本地数据或资源，因此可以离线使用</p></li><li><p><strong>实时交互</strong></p><p>SPA适合需要实时数据更新的应用，如游戏、绘图应用或社交网络，可以提供较好的实时交互体验</p></li></ol><p><br /></p><p><strong>缺点</strong></p><ol><li><p><strong>SEO（搜索引擎优化）问题</strong></p><p>传统的SPA往往难以被搜索引擎有效索引，因为它们的内容是动态通过JavaScript加载的，这可能导致搜索引擎抓取工具难以抓取到所有内容</p></li><li><p><strong>首次加载时间较长</strong></p><p>尽管SPA在页面间的切换上非常快，但其首次加载时，需要加载应用的所有脚本和资源，这可能导致相比于多页应用（MPA）更长的加载时间</p></li><li><p><strong>浏览器的前进/后退按钮可能不工作</strong></p><p>由于SPA在单个页面内动态更改内容，没有加载新页面，所以对浏览器的前进和后退按钮支持可能不那么直观。开发者需要额外实现这些功能，以保证用户体验</p></li><li><p><strong>内存利用问题</strong></p><p>单页应用可能会因为长时间运行而消耗大量浏览器内存，尤其是当应用未正确管理内存时（如未清理定时器或事件监听器）</p></li><li><p><strong>安全性问题</strong></p><p>SPA可能更容易受到某些类型的安全攻击，如跨站脚本（XSS）攻击，因为所有页面逻辑都由客户端JavaScript控制</p></li><li><p><strong>JavaScript依赖性</strong></p><p>如果用户禁用了浏览器的JavaScript，或者浏览器不支持当前使用的JavaScript特性，那么SPA将无法正常工作</p></li><li><p><strong>难以调试</strong></p><p>SPA由于大量用到JavaScript和异步请求，可能在出现问题时难以追踪和调试</p></li><li><p><strong>用户体验一致性</strong></p><p>SPA的表现和行为完全依赖于客户端设备的性能，这导致不同用户可能会有不同的体验，特别是在老旧或性能较低的设备上</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>多页应用（MPA）是传统的Web应用模式，在这种模式中，每当页面跳转发生时，服务器将会提供一个新的页面</p><p>这跟单页面应用（SPA）不同，在SPA中，页面不会重新加载，只会动态地替换内容</p><p>以下是MPA的一些具体特点：</p><ol><li><strong>全页刷新</strong>：<ul><li>在MPA中，用户的每一个操作，如链接点击、表单提交等，都可能导致整个页面的重新加载或跳转到一个新页面</li><li>这可能会导致更明显的用户等待时间，因为客户端每次都需要从服务器加载新的HTML、CSS和JavaScript</li></ul></li><li><strong>SEO友好</strong>：<ul><li>因为每个页面都有独立的链接，搜索引擎可以很容易地爬取和索引每一个页面</li><li>这是MPA的一个强大优势，尤其适合那些需要良好搜索引擎优化的大型网站</li></ul></li><li><strong>前后端耦合</strong>：<ul><li>在MPA应用中，后端不仅负责业务逻辑和数据库操作，还负责控制页面的渲染</li><li>这种耦合方式简化了开发流程，适合小的团队和小到中端的项目</li></ul></li><li><strong>开发工具和框架</strong>：<ul><li>开发MPA可以采用各种后端语言（如PHP、Java、Ruby等）和框架（如Express.js、Django</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">特点</th><th style="text-align:left">SPA</th><th style="text-align:left">MPA</th></tr></thead><tbody><tr><td style="text-align:left">单一页面加载</td><td style="text-align:left">✓</td><td style="text-align:left">✕</td></tr><tr><td style="text-align:left">用户体验</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">SEO优化</td><td style="text-align:left">需要优化</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">首次加载速度</td><td style="text-align:left">一般，取决于项目大小</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">页面切换速度</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">前后端分离</td><td style="text-align:left">✓</td><td style="text-align:left">可以实现</td></tr><tr><td style="text-align:left">缓存管理</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">浏览器历史导航</td><td style="text-align:left">需要优化</td><td style="text-align:left">✓</td></tr><tr><td style="text-align:left">初始开发复杂性</td><td style="text-align:left">较高</td><td style="text-align:left">一般</td></tr><tr><td style="text-align:left">状态管理</td><td style="text-align:left">✓</td><td style="text-align:left">可以实现</td></tr><tr><td style="text-align:left">服务器负载</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">依赖JavaScript</td><td style="text-align:left">✓</td><td style="text-align:left">一般</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：原型、原型链是什么"><a href="#Q28：原型、原型链是什么" class="headerlink" title="Q28：原型、原型链是什么"></a>Q28：原型、原型链是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>原型（Prototype）</strong></p><p>在JavaScript中，原型是一种让对象继承属性和方法的机制。每个JavaScript对象（除了<code>null</code>）都具有一个特殊的内置属性，称为<code>[[Prototype]]</code>，但在代码中通常通过<code>__proto__</code>属性的形式来访问（虽然这种方式现在被JavaScript社区视为过时和不推荐。在ES6中，<code>Object.getPrototypeOf()</code>方法可以更标准地获取对象的原型</p><p>更正式地，所有JavaScript对象都是通过引用一个原型对象来继承属性和方法的当你创建一个新对象时，你可以选择某个对象作为它的原型。JavaScript提供了<code>Object.create</code>方法来创建一个新对象，同时让你指定这个对象的原型</p><p><strong>原型链（Prototype Chain）</strong></p><p>原型链是JavaScript的一种基本工作机制，用于在对象之间共享属性和方法。当你尝试访问一个对象的某个属性时，如果这个对象本身没有这个属性，JavaScript会自动去其原型（即<code>__proto__</code>属性指向的对象）中查找。如果这个原型对象也没有这个属性，那么JS将继续搜索这个原型的原型，以此类推，直至找到该属性或者到达原型链的末尾（<code>Object.prototype</code>的原型是<code>null</code>）。</p><p>原型链的这种机制让对象可以共享方法和属性，极大地节省了内存资源，因为这意味着JavaScript中的所有对象实例可以共享它们的构造函数的原型上的属性和方法，而不是在每个对象实例中复制一份。</p><p><img src="https://s2.loli.net/2024/05/11/1ns4IhfcHJCwOTX.png" alt="image-20240511173637440"></p><p><strong>示例</strong></p><p>为了更好地理解，让我们来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>Person</code>是一个构造函数</p></li><li><p>通过<code>Person.prototype.sayHello</code>给<code>Person</code>的原型添加了一个<code>sayHello</code>方法</p></li><li><p><code>person1</code>和<code>person2</code>都是<code>Person</code>的实例</p><p>它们是通过<code>new Person()</code>创建的，因此它们的原型都是<code>Person.prototype</code></p></li><li><p>当调用<code>person1.sayHello()</code>时，JS首先检查<code>person1</code>自身有没有<code>sayHello</code>方法</p><p>没有找到时，它会沿着原型链往上查找，即查找<code>Person.prototype</code>是否有这个方法</p><p>找到后就执行这个方法</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：对JS模块化方案的理解"><a href="#Q29：对JS模块化方案的理解" class="headerlink" title="Q29：对JS模块化方案的理解"></a>Q29：对JS模块化方案的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript模块化方案是寻求在逻辑上划分代码，并通过公开和获取进口接口来组合这些代码块的一种方法</p><p>这意味着，我们可以将复杂的代码分离成可维护的小文件，并且这些文件可以在不同的项目之间轻松重用</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在JavaScript中，有几种不同的模块化标准：</p><ol><li><p><strong>CommonJS</strong></p><ul><li><p><strong>概念</strong> </p><p>CommonJS是一个在服务器端对模块的定义，特别是为了Node.js设计的</p><p>它的目标是弥补JavaScript没有标准库的缺陷，以及提供一个模块化的标准，以便JavaScript也能在服务器端运行</p></li><li><p><strong>核心思想</strong></p><p>使用<code>require</code>函数来同步加载依赖，使用<code>module.exports</code>或<code>exports</code>来导出模块</p><p>由于是设计给服务器端使用的，因此其同步的本质不会造成问题，因为服务器端的文件通常都是本地可访问的，而无需像在浏览器端那样从网络上异步加载</p></li><li><p>这是Node.js使用的模块标准，它允许使用<code>require</code>语句来加载模块，并通过<code>module.exports</code>或<code>exports</code>导出</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = libMethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> libMethod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>AMD (Asynchronous Module Definition)</strong></p><ul><li><p><strong>概念</strong></p><p>AMD即异步模块定义，它是一种针对浏览器而设计的模块化方案</p><p>AMD采用异步方式加载模块，是为了解决浏览器环境下模块代码可能需要从服务器异步加载的问题</p></li><li><p><strong>核心思想</strong></p><p>通过<code>define</code>函数定义模块，<code>require</code>函数来异步加载依赖</p><p>AMD最大的特点就是支持浏览器端的异步加载，且允许指定回调函数，以便在所有需要的模块都加载完成后进行操作</p></li><li><p>主要用于异步加载模块，并在浏览器端使用，RequireJS是实现AMD规范的著名库</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="title function_">define</span>([], <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> libMethod;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;lib&#x27;</span>], <span class="keyword">function</span>(<span class="params">libMethod</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>ES Modules (ESM)</strong></p><ul><li><p><strong>概念</strong></p><p>ESM是ECMAScript标准的一部分，是JavaScript的官方模块系统</p><p>它设计之初就考虑到了代码的静态分析，允许浏览器和服务器（如Node.js）对模块进行优化载入</p></li><li><p><strong>核心思想</strong></p><p>通过<code>import</code>和<code>export</code>语句来导入导出模块</p><p>ESM支持静态导入也支持动态导入（通过<code>import()</code>表达式）</p><p>ESM的模块是单例的，且导入导出是实时绑定的，并且ESM模块是异步解析的</p></li><li><p>这是现代浏览器支持的原生JavaScript模块系统，利用<code>import</code>和<code>export</code>关键字实现模块化</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; libMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br></pre></td></tr></table></figure></li><li><p><strong>UMD</strong></p><ul><li><p><strong>概念</strong></p><p>UMD是一种兼容CommonJS和AMD的模块定义方式，它使得模块可以在AMD环境、CommonJS环境以及全局变量使用场景下运行</p></li><li><p><strong>核心思想</strong></p><p> UMD通过一个立即执行的函数表达式(IIFE)来检测当前环境支持哪模块方案，并相应地初始化模块</p><p>它试图提供一个在前后端都可以通用的方案，实现代码的最大兼容性</p></li><li><p>UMD是一种支持两种模块化标准（CommonJS和AMD）的模式，以便模块能够在AMD环境、CommonJS环境和全局变量的使用环境中使用</p></li><li><p>UMD尤其适合那些要在浏览器和服务器（比如Node）上运行的模块</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">    <span class="title function_">define</span>([], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span> ? self : <span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Actual module code</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">libMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;This is a library method&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> libMethod;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (CommonJS)</span></span><br><span class="line"><span class="keyword">const</span> libMethod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (AMD)</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;lib&#x27;</span>], <span class="keyword">function</span>(<span class="params">libMethod</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">libMethod</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js (Browser Global)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">returnExports</span>());</span><br></pre></td></tr></table></figure></li></ol><p>ESM是目前推荐的JavaScript模块化标准，因为它是JavaScript语言的官方标准，得到了现代浏览器和Node.js的原生支持，无需额外的工具或编译</p><p>模块化使得开发者能够构建大型、复杂的应用程序，通过模块划分可以让不同的功能和组件彼此隔离，变得更易于理解和调试</p><p>同时也促进了社区共享代码，例如通过npm上的包</p><div class="table-container"><table><thead><tr><th style="text-align:left">特点/标准</th><th style="text-align:left">CommonJS</th><th style="text-align:left">AMD</th><th style="text-align:left">ESM</th><th style="text-align:left">UMD</th></tr></thead><tbody><tr><td style="text-align:left">环境</td><td style="text-align:left">Node.js</td><td style="text-align:left">浏览器</td><td style="text-align:left">现代浏览器和Node.js</td><td style="text-align:left">浏览器和Node.js</td></tr><tr><td style="text-align:left">异步加载</td><td style="text-align:left">不支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持（依条件）</td></tr><tr><td style="text-align:left">导入语法</td><td style="text-align:left">require</td><td style="text-align:left">define/require</td><td style="text-align:left">import</td><td style="text-align:left">根据环境使用require或define</td></tr><tr><td style="text-align:left">导出语法</td><td style="text-align:left">module.exports</td><td style="text-align:left">return</td><td style="text-align:left">export</td><td style="text-align:left">module.exports或return</td></tr><tr><td style="text-align:left">本地变量</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">循环依赖</td><td style="text-align:left">支持</td><td style="text-align:left">有限支持</td><td style="text-align:left">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:left">标准</td><td style="text-align:left">非官方标准</td><td style="text-align:left">非官方标准</td><td style="text-align:left">ECMA标准</td><td style="text-align:left">综合式非官方标准</td></tr><tr><td style="text-align:left">加载方式</td><td style="text-align:left">同步</td><td style="text-align:left">异步</td><td style="text-align:left">同步和异步</td><td style="text-align:left">适应性</td></tr><tr><td style="text-align:left">浏览器支持</td><td style="text-align:left">通常需要打包工具</td><td style="text-align:left">通常需要RequireJS</td><td style="text-align:left">原生支持，可能需要编译</td><td style="text-align:left">无需特定库或工具</td></tr><tr><td style="text-align:left">执行时机</td><td style="text-align:left">立即执行</td><td style="text-align:left">延时执行</td><td style="text-align:left">导入时执行</td><td style="text-align:left">根据模块系统选择立即执行或延时执行</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：JavaScript对象里面的可枚举性是什么"><a href="#Q30：JavaScript对象里面的可枚举性是什么" class="headerlink" title="Q30：JavaScript对象里面的可枚举性是什么"></a>Q30：JavaScript对象里面的可枚举性是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，对象属性（包括数据属性和访问器属性）有一个名为“可枚举性”的特性（enumerable）</p><p>可枚举性决定了一个属性是否能够出现在对象的枚举属性中，也就是说，它是否可以通过某些循环或方法（如<code>for...in</code>循环、<code>Object.keys()</code>方法、<code>JSON.stringify()</code>函数等）来访问</p><p>如果一个属性的可枚举性特性为<code>true</code>，那么它就可以被这些操作发现或访问</p><p>反之，如果可枚举性为<code>false</code>，则这些操作会忽略该属性</p><p>这里有一个例子来说明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象上定义一个不可枚举的属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;nonEnumerableProperty&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;This is non-enumerable&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象上定义一个可枚举的属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;enumerableProperty&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;This is enumerable&#x27;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出对象的所有可枚举属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果： &quot;enumerableProperty: This is enumerable&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>enumerableProperty</code>的可枚举性为<code>true</code>，所以它可以在<code>for...in</code>循环中被访问到</p><p>而<code>nonEnumerableProperty</code>的可枚举性为<code>false</code>，所以它在循环中被忽略</p><p>需要注意的是，尽管可枚举性决定了属性是否可以通过<code>for...in</code>循环或<code>Object.keys()</code>方法等方式访问，但并不阻止通过点标记法（<code>.</code>）或方括号（<code>[]</code>）来直接访问属性</p><p>即使属性的可枚举性为<code>false</code>，我们仍然可以直接获取或设置其值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">nonEnumerableProperty</span>); </span><br><span class="line"><span class="comment">// 输出结果：&quot;This is non-enumerable&quot;</span></span><br></pre></td></tr></table></figure><p>简而言之，可枚举性特性控制了一些枚举操作如何与属性交互，而不是控制访问属性的能力</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：对函数式编程的理解"><a href="#Q31：对函数式编程的理解" class="headerlink" title="Q31：对函数式编程的理解"></a>Q31：对函数式编程的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数式编程（Functional Programming, FP）是一种编程范式，它将计算视为数学函数的评估，并避免状态以及可变数据</p><p>与面向对象编程强调对象包含数据和行为不同，函数式编程强调了应用函数和函数之间的组合，以创建更复杂的函数和过程</p><p><strong>优点:</strong></p><ol><li><p><strong>易于测试和调试</strong> </p><p>因为纯函数遵循相同输入相同输出的原则，不依赖于程序中的其他状态，这使得纯函数更容易进行单元测试。</p></li><li><p><strong>更好的模块化</strong> </p><p>函数式编程鼓励将大问题分解为小问题，通过函数组合的方式将小函数组合起来解决复杂的问题。</p></li><li><p><strong>更少的副作用</strong></p><p> 函数式编程的纯函数减少了意外的副作用，使得程序的状态更加可控，降低了程序运行过程中出现bug的风险。</p></li><li><p><strong>并行处理</strong> </p><p>不可变数据和无副作用函数意味着没有线程之间的冲突，可以更安全地进行并行代码的编写。</p></li><li><p><strong>代码的可读性</strong> </p><p>通过函数组合可以写出声明式的代码，意图更加明确，可读性更好。</p></li></ol><p><strong>缺点:</strong></p><ol><li><p><strong>学习曲线</strong> </p><p>对于习惯了命令式编程的开发者来说，需要时间适应函数式编程的思维方式</p></li><li><p><strong>性能问题</strong></p><p> 递归和不可变数据结构可能导致性能下降，尤其是在那些不自动进行尾调用优化的环境中</p></li><li><p><strong>内存使用</strong> </p><p>纯粹函数式编程使用不可变数据，可能会增加内存的使用量，因为每次数据修改都会创建一个新的数据副本</p></li><li><p><strong>语言支持</strong> </p><p>不是所有编程语言都原生支持函数式编程概念，有些语言可能只能通过库来实现，这可能会制约函数式编程的应用</p></li><li><p><strong>递归的复杂性</strong></p><p> 在一些场景下，使用递归比迭代循环更难以理解，且如果递归深度过大也可能导致栈溢出</p></li><li><p><strong>资源消耗</strong> </p><p>某些函数式编程操作，比如尤其在组合多个函数操作大数据集时，可能会导致计算资源（CPU/内存）的高消耗</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>函数式编程的一些关键特征和概念：</p><ol><li><p><strong>不可变性（Immutability）</strong></p><p>在函数式程序中，状态是不可变的。一旦创建了数据结构（如对象、数组等），它就不能被修改。任何“修改”操作都会产生一个新的数据结构，而原有的数据结构保持不变。</p></li><li><p><strong>纯函数（Pure Functions）</strong></p><p>函数的输出仅由输入决定，不依赖于程序的状态（无状态）、不修改程序状态，也不具有可观察的副作用，使得它们更易于推理与测试</p></li><li><p><strong>函数组合（Function Composition）</strong></p><p>小函数可以组合成更复杂的函数，就像在数学中的函数组合（f o g）</p><p>这种方式可以构建出复杂的操作，而每一个操作都由简单清晰的函数构成</p></li><li><p><strong>高阶函数（Higher-Order Functions）</strong></p><p>函数可以作为参数或返回值传递。这使得抽象和重复的逻辑能够被轻易地重用</p></li><li><p><strong>惰性评估（Lazy Evaluation）</strong></p><p>计算会被推迟直到绝对需要结果，这可以提升性能，通过避免不必要的计算，并能处理无限数据结构（比如无限列表）</p></li><li><p><strong>递归（Recursion）</strong></p><p>在函数式编程中，循环被递归结构所替代</p><p>因为没有可变状态，函数式编程利用递归来执行重复任务或迭代数据结构</p></li><li><p><strong>模式匹配（Pattern Matching）</strong></p><p>这通常用于FP中，可以简化对数据结构的解构和分析，是一种更直观的数据访问与处理方式</p></li><li><p><strong>尾调用优化（Tail Call Optimization）</strong></p><p>尾调用是指函数的最后一个动作是返回另一个函数调用</p><p>尾调用优化降低了递归函数的空间复杂度，从而避免栈溢出</p></li></ol><p>函数式编程的目标是使用这些原则和技术来创造更可预测、更少出错并易于测试的软件</p><p>然而，实际应用时，完全的不可变性或纯函数可能难以实现或低效</p><p>因而，现代函数式编程语言和库通常提供了一些实用主义的策略，以便更好的融入实际问题解决之中</p><p>其中，JavaScript并不是一种纯粹的函数式编程语言，但是它支持许多函数式编程的特性，并且社区内有大量的库来应用函数式编程概念</p><p><br /></p><p>命令式编程（Imperative Programming）是一种计算机编程范式，它通过详细描述计算机需要执行的步骤来更改程序状态</p><p>这一范式是通过编写一系列指令来告诉计算机如何达到期望的结果，这些指令会改变程序的状态</p><p>命令式编程可以视为一系列的命令，指导计算机完成特定的操作，类似于烹饪食谱中的步骤，每个步骤告诉你如何做</p><p><strong>特征</strong></p><p><strong>详细性：</strong> 在命令式编程中，开发人员需要给出获取输出的确切步骤指令</p><p><strong>状态变化：</strong> 程序由一系列的状态组成，各个命令将导致状态的变化</p><p><strong>控制结构：</strong> 包括循环、条件分支、顺序结构等，控制程序的执行流程</p><p><strong>变量：</strong> 功能上类似于存储数据的 “容器”，它们的值可以改变</p><p><strong>迭代：</strong> 重复执行同一块代码，直到满足特定条件</p><p><strong>常见语言</strong></p><p>许多流行的编程语言是支持命令式编程的：</p><ul><li>C</li><li>C++</li><li>Java</li><li>Python（虽然它同时也支持其他编程范式）</li></ul><p><strong>优点与缺点</strong></p><p><strong>优点：</strong></p><ul><li><strong>直观性：</strong> 思考和解决问题的方式更符合我们进行日常任务时的顺序逻辑</li><li><strong>控制性：</strong> 开发者可以控制程序的每一步，使得可以进行微观管理</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性：</strong> 当应用程序变得复杂时，管理和理解所有的状态变化变得困难</li><li><strong>可维护性：</strong> 代码重复和难以追踪的状态可能导致程序难以维护</li><li><strong>并发性：</strong> 变化的状态使得处理并发任务更加复杂</li></ul><p>命令式编程和函数式编程最主要的区别在于，命令式编程关注如何执行，而函数式编程关注什么需要被执行</p><p>在函数式编程中，状态的变化被尽量避免，而命令式编程则大量依赖于状态变化</p><p>在实际的工作中，很多语言和项目会融合多种编程范式，以适合不同的用例和优化开发体验</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：对闭包的理解"><a href="#Q32：对闭包的理解" class="headerlink" title="Q32：对闭包的理解"></a>Q32：对闭包的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>闭包（Closure）在编程中是一个非常重要的概念，尤其是在JavaScript等支持词法作用域的编程语言中</p><p><strong>闭包的定义</strong></p><p>闭包是函数和声明该函数的词法环境的组合</p><p>它允许一个函数访问并操纵函数外部的变量</p><p>即使外部函数执行完毕，闭包仍然能记住和访问函数外部的变量</p><p><strong>闭包的优点包括：</strong></p><ul><li><p><strong>数据封装性</strong></p><p> 闭包可以帮助创建私有变量，其他代码不能直接访问这些变量，只能通过提供的方法来操作</p></li><li><p><strong>持久性</strong> </p><p>常规的局部变量在函数执行完后会被销毁，但闭包中的数据可以维持状态，即使外部函数调用结束后仍然存在</p></li><li><p><strong>记忆状态</strong> </p><p>闭包可以记住它被创建时的环境，这使得它非常适合在如实现迭代器或生成器等场景</p></li></ul><p><strong>闭包的缺点包括：</strong></p><ul><li><p><strong>内存消耗</strong> </p><p>因为闭包可能会长时间保存变量，所以它可能会导致比普通函数更大的内存消耗</p></li><li><p><strong>复杂性</strong> </p><p>对于不熟悉闭包的开发者来说，闭包可能会带来不必要的复杂性和理解障碍</p></li><li><p><strong>调试困难</strong> </p><p>由于闭包的特殊作用域，有时候调试它们的状态和行为可能会比较困难</p></li></ul><p><strong>闭包的使用场景：</strong></p><ul><li><p><strong>事件处理</strong> </p><p>在JavaScript中，闭包广泛用于事件监听和处理中，以便在事件回调中使用在外部函数中定义的数据</p></li><li><p><strong>模拟私有方法和变量</strong> </p><p>在JavaScript中模拟对象的私有成员</p></li><li><p><strong>函数柯里化</strong></p><p> 闭包可以用于函数柯里化，创建一个新函数，这个新函数持有一些已设定的参数</p></li><li><p><strong>模块化</strong></p><p>创建模块，闭包能够将一组相关的功能封装起来，形成一个模块，公开一些方法，隐藏其他状态和方法</p></li></ul><p>例如，下面的代码展示了一个创建闭包的例子，其中的<code>makeAdder</code>函数创建了一个闭包，包括函数<code>adder</code>和该函数能记住的自由变量<code>x</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = <span class="title function_">makeAdder</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add10</span>(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>add5</code>和<code>add10</code>是闭包，它们分别记忆了<code>x</code>为5和10</p><p>即使<code>makeAdder</code>函数的执行上下文结束后，这两个闭包仍然可以访问和操纵它们自己的<code>x</code>变量</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>函数柯里化（Currying）是函数式编程中的一个重要概念，它是指将一个接受多个参数的函数转换成接受单一参数（最初函数的第一个参数）的函数，并且返回接受余下参数且返回结果的新函数的技术</p><p><strong>基本原理</strong></p><p>柯里化的核心是闭包</p><p>利用闭包可以存储函数的状态，还可以继续接收剩余的参数，直到所有参数都被传递完毕，最后统一处理这些参数</p><p><strong>柯里化的作用</strong></p><p>柯里化主要有以下几个作用：</p><ul><li><p><strong>参数复用</strong> </p><p>柯里化可以将一个多参数的函数转换成多个单参数函数，这样部分参数可以被复用</p></li><li><p><strong>延迟计算/执行</strong> </p><p>通过柯里化可以延迟函数的执行，只有在接收了所有需要的参数之后，才执行原函数</p></li><li><p><strong>动态生成函数</strong></p><p> 可以根据传入的参数，动态地生成具有特定功能的新函数</p></li></ul><p><strong>一个简单的柯里化函数示例</strong></p><p>来看一个简化的柯里化函数的例子，用以加深理解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果提供的参数数量足够，则直接调用原函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，返回一个接受剩余参数的函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的未柯里化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后的函数</span></span><br><span class="line"><span class="keyword">const</span> curriedSum = <span class="title function_">curry</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>curry</code>函数接收一个函数<code>fn</code>并返回一个新的函数<code>curried</code></p><p>当<code>curried</code>函数被调用，它检查传递给它的参数数量</p><p>如果参数数量不够，它返回一个新的函数，这个函数期待更多的参数</p><p>这个过程会一直进行直到收到了足够的参数，最终原始函数被调用</p><p><strong>使用场景</strong></p><p>常见的柯里化使用场景有事件处理、部分求值等需要预置某些参数的情况</p><p><strong>注意事项</strong></p><p>柯里化函数通常的实现依赖于闭包，这意味着柯里化可能会导致与闭包相同的一些问题，例如变量作用域混淆和内存消耗问题</p><p>柯里化是一种强大但稍显复杂的技术</p><p>在实际应用中，它可以帮助我们编写高度模块化和重用性强的代码</p><p>了解和掌握柯里化，可以提升你在函数式编程领域的技能，并能帮助你更好的理解JavaScript这门语言的函数式特性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：深拷贝跟浅拷贝"><a href="#Q33：深拷贝跟浅拷贝" class="headerlink" title="Q33：深拷贝跟浅拷贝"></a>Q33：深拷贝跟浅拷贝</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>浅拷贝</p><ul><li><p>浅拷贝是创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</p></li><li><p>实现方式</p><ul><li><p><strong>Object.assign</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扩展运算符</strong></p><p>当对象里面只有基础类型的时候，拓展运算符就会变成深拷贝</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>深拷贝</p><ul><li><p>深拷贝会拷贝所有的属性，并且会递归到所有层级的子属性，直到找到所有的基本类型为止。这样的话，一个对象改变不会影响另一个对象</p></li><li><p>实现方式</p><ul><li><p><strong>JSON.parse(JSON.stringify(object))</strong></p><p>需要特别注意，<code>JSON.parse(JSON.stringify(object))</code>会忽略掉原对象中的<code>undefined</code>、<code>function</code>和<code>symbol</code></p><p>并且，如果对象中存在循环引用的情况也无法正确处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>递归拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            copy[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">deepClone</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>lodash 的 _.cloneDeep</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123; a: 1, b: &#123; c: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h3 id="Q1：typeof-NaN的结果是什么"><a href="#Q1：typeof-NaN的结果是什么" class="headerlink" title="Q1：typeof NaN的结果是什么"></a>Q1：typeof NaN的结果是什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>NaN（Not a Number）是一种特殊的数值，表示一个本来要返回数值的操作未返回数值的情况。虽然 NaN 是一种特殊的数值，但它的数据类型仍然被归类为 <code>&#39;number&#39;</code>。</p><p>这种设计的原因在于 JavaScript 的 <code>typeof</code> 操作符返回数据类型的字符串表示，而 <code>&#39;number&#39;</code> 是 NaN 实际的数据类型。因此，<code>typeof NaN</code> 返回 <code>&#39;number&#39;</code> 是符合语言规范的结果。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>typeof NaN</code> 的结果是 <code>&#39;number&#39;</code></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>NaN</code> 是一个特殊的值，表示 “Not a Number”，通常用于表示数学运算中产生的非数值结果。虽然 <code>NaN</code> 本身不是一个有效的数字，但是它仍然可以参与一些操作。</p><p>以下是一些 <code>NaN</code> 的用法示例：</p><ol><li><p><strong>检查是否为 <code>NaN</code></strong>： 可以使用全局函数 <code>isNaN()</code> 来检查一个值是否为 <code>NaN</code>。这个函数会尝试将传入的值转换为数字，如果不能成功转换为数字，或者转换后的值是 <code>NaN</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查是否为有效数字</strong>： 由于 <code>NaN</code> 表示 “Not a Number”，因此可以使用 <code>isNaN()</code> 函数来检查一个值是否为有效的数字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;123&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数学运算中的 <code>NaN</code></strong>： 当数学运算中出现非法操作时，通常会产生 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断是否为 <code>NaN</code></strong>： 可以使用 <code>===</code> 运算符直接比较一个值是否等于 <code>NaN</code>。注意，<code>NaN</code> 与任何其他值，包括自身，都不相等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>总之，<code>NaN</code> 在 JavaScript 中代表着 “Not a Number”，通常用于表示数学运算中产生的非数值结果，可以通过 <code>isNaN()</code> 函数来检查一个值是否为 <code>NaN</code>，并且在一些操作中需要小心处理 <code>NaN</code> 的情况</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：如何区分数组和对象"><a href="#Q2：如何区分数组和对象" class="headerlink" title="Q2：如何区分数组和对象?"></a>Q2：如何区分数组和对象?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Array.isArray() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myArray)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>typeof 操作符</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> myObject === <span class="string">&#x27;object&#x27;</span> &amp;&amp; !<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myObject)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>instanceof 操作符</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (myArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查构造函数</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myArray.<span class="property">constructor</span> === <span class="title class_">Array</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myObject.<span class="property">constructor</span> === <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查原型链</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myObject = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myArray) === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 是一个数组&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myArray 不是一个数组&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObject) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 是一个对象&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myObject 不是一个对象&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：js中如何判断一个值是否是数组类型"><a href="#Q3：js中如何判断一个值是否是数组类型" class="headerlink" title="Q3：js中如何判断一个值是否是数组类型?"></a>Q3：js中如何判断一个值是否是数组类型?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>instanceof 操作符</strong>：使用 <code>instanceof</code> 操作符可以检查一个值是否是某个对象的实例，对于数组来说，可以检查是否是 <code>Array</code> 类型的实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用对象的 constructor 属性</strong>：每个 JavaScript 对象都有一个 <code>constructor</code> 属性，可以通过它来获取对象的构造函数。对于数组来说，其构造函数是 <code>Array</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">constructor</span> === <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Object.prototype.toString() 方法</strong>：通过调用 <code>Object.prototype.toString()</code> 方法，可以获取对象的字符串表示，对于数组来说，其返回的字符串格式是 <code>[object Array]</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr) === <span class="string">&#x27;[object Array]&#x27;</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用数组的原型链</strong>：数组是原型链的一部分，可以通过 <code>Array.prototype</code> 来检查一个值是否具有数组的方法和属性。如果一个值具有数组的方法和属性，那么它很可能是一个数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>以上方法都可以用来判断一个值是否是数组类型，但各有优劣。<code>Array.isArray()</code> 方法是最简单直接的方式，而其他方法更多是作为了解 JavaScript 内部工作原理的参考。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：null和-undefined-有什么区别"><a href="#Q4：null和-undefined-有什么区别" class="headerlink" title="Q4：null和 undefined 有什么区别?"></a>Q4：null和 undefined 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>null</code> 和 <code>undefined</code> 是 JavaScript 中的两种特殊的数据类型，它们之间有一些区别：</p><ol><li><p><strong>undefined</strong>:</p><ul><li><p><code>undefined</code> 是表示未定义的值，用于表示变量声明了但没有赋值的情况，或者函数调用时没有提供参数的情况。</p></li><li><p>在 JavaScript 中，未初始化的变量默认值为 <code>undefined</code>。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x;</span><br><span class="line">console.log(x); // 输出 undefined</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>null</strong>:</p><ul><li><p><code>null</code> 是表示空值的特殊值，用于表示一个变量被显式地赋值为“空”。</p></li><li><p><code>null</code> 值不代表任何对象，它是 JavaScript 中的关键字。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var y = null;</span><br><span class="line">console.log(y); // 输出 null</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>主要区别：</p><ul><li><code>undefined</code> 表示变量未定义或者属性不存在，而 <code>null</code> 表示变量已经定义并且赋值为“空”。</li><li>在使用条件语句时，<code>undefined</code> 会被转换为 <code>false</code>，而 <code>null</code> 不会。</li><li>当想要表示一个“空”值时，通常使用 <code>null</code>，而不是 <code>undefined</code>。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：’1’-toString-为什么不会报错"><a href="#Q5：’1’-toString-为什么不会报错" class="headerlink" title="Q5：’1’.toString()为什么不会报错?"></a>Q5：’1’.toString()为什么不会报错?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，基本数据类型（如数字、字符串和布尔值）并没有方法</p><p>然而，JavaScript 允许你像对待对象一样对待这些基本类型的值，比如调用方法</p><p>这是因为 JavaScript 会临时地将它们转换成对应的对象，这个过程称为“装箱”（Boxing）</p><p>之后，就可以在这个对象上调用方法了</p><p>其实在这个语句运行的过程中做了这样几件事情：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;1&#x27;</span>); </span><br><span class="line">s.<span class="title function_">toString</span>();</span><br><span class="line">s = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，当调用<code>&#39;1&#39;.toString()</code>时，JavaScript 内部会自动创建一个临时的<code>String</code>对象，然后在这个对象上调用<code>toString</code>方法</p><p>调用完成后，这个临时对象就被丢弃</p><p>这个过程对于开发者来说是透明的，开发者看到的只是原始类型值似乎拥有了调用方法的能力</p><p>整个过程体现了 <code>基本包装类型</code> 的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String</p><p>在JavaScript中，基本包装类型是一些特殊的内置构造函数，这些构造函数用于为简单的基本数据类型（如String, Number, Boolean）创建对应的对象</p><p>这样做使得基本数据类型可以像对象一样使用，且能访问一些方法去处理数据，比如字符串的拼接、大小写转换，数字的转换，以及布尔值的逻辑操作等</p><p>这三个基本包装类型如下：</p><ol><li><strong>String</strong>：用于创建一个包含字符串的对象</li><li><strong>Number</strong>：用于创建一个包含数字的对象</li><li><strong>Boolean</strong>：用于创建一个包含布尔值（true或false）的对象</li></ol><p>以下展示了如何使用基本包装类型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这些基本包装类型的对象版和基本类型的值版（如直接使用字面量创建的字符串、数字或布尔值）在许多情况下行为很相似，但它们是不同的</p><p>对象是引用类型，而基本数据类型是直接值</p><p>这意味着基本类型的值存储是按值访问的，并且它们是不可变的</p><p>而包装对象则是按照引用访问的，它们有自己的内存地址，并且是可以添加属性的对象</p><p>大多数情况下，没有必要直接使用基本包装类型，因为JavaScript会自动进行装箱和拆箱操作</p><p>当对一个基本类型值调用方法时，JavaScript会临时使用相应的包装类型来使这一方法的调用成为可能</p><p>在方法执行完之后，这个临时创建的包装对象就会被销毁</p><p>这个过程是自动和隐形的，从而让基本数据类型看起来像是具有对象的性质</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>这个现象根源于JavaScript语言的设计原则及其类型系统的构造</p><p>JavaScript是一种动态类型语言，它通过一套称为自动装箱（autoboxing）的机制使得原始数据类型（如字符串、数字和布尔值）能够调用与之对应的对象原型上的方法</p><p>这种设计使得基础数据类型在使用上更加灵活，同时保持了性能效率</p><p><strong>自动装箱转换机制</strong></p><p>在JavaScript中，当对一个原始值（比如字符串、数字或布尔值）执行对象的操作时，JavaScript会临时把这个原始值包装成一个相应类型的对象</p><p>这个过程是自动的，发生在原始值上调用方法的那一刻</p><p>例如，当你对一个字符串调用<code>.toString()</code>方法时，JavaScript内部会创建一个<code>String</code>对象，然后在这个临时对象上调用<code>.toString()</code>方法</p><p>方法调用完成后，这个对象会被丢弃，不会影响原始值</p><p><strong>为何不能跨类型调用方法</strong></p><p>原始数据类型包装对象的设计初衷是为了提供对相应类型相关操作的便捷性，并不意味着可以让数据类型之间无限制地互相调用对方的方法：</p><ol><li><p><strong>类型安全</strong></p><p>不同的数据类型支持不同的方法，这基于它们各自的用途和行为</p><p>允许一个类型的原始值随意调用另一个类型的方法会破坏类型之间的边界，引入潜在的类型安全问题和逻辑错误</p></li><li><p><strong>明确性和可维护性</strong></p><p>JavaScript的设计鼓励明确而直接的代码</p><p>类型之间的明确界限让代码更容易理解和维护</p><p>如果原始数据类型之间可以相互调用方法，这将大大增加理解和使用语言时的复杂度</p></li><li><p><strong>性能问题</strong></p><p>自动的类型转换和方法调用如果不受限制地发生，可能会导致性能问题</p><p>为了维护运行时的效率，避免不必要的类型转换和装箱操作是重要的</p></li></ol><p><strong>实用性</strong></p><p>在实际应用中，如果你需要对一个数据类型执行不自然的操作（例如，把字符串当作数组处理），通常有专门的方法或者是模式来实现这个需求，比如使用<code>split</code>方法把字符串转换为数组，再对数组操作</p><p>这样的处理方式更加明确且高效</p><p>JavaScript提供了足够的工具和方法来在不同类型之间进行转换和操作，同时保持代码的清晰和效率</p><p>总的来说，虽然JavaScript通过自动装箱允许原始数据类型调用对象方法，这种机制的存在是为了增强编程的便利性和灵活性，而不是让不同数据类型之间的方法随意横跨调用</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：typeof-与instanceof-有什么区别"><a href="#Q6：typeof-与instanceof-有什么区别" class="headerlink" title="Q6：typeof 与instanceof 有什么区别"></a>Q6：typeof 与instanceof 有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>typeof</code> 和 <code>instanceof</code> 是 JavaScript 中用于检查数据类型的两种操作符，它们有以下区别：</p><ol><li><strong>typeof</strong>：<ul><li>用法：<code>typeof</code> 是一个一元操作符，可以用来检查一个值的数据类型。</li><li>返回值：<code>typeof</code> 返回一个表示值的数据类型的字符串，包括 <code>&quot;undefined&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;string&quot;</code>、<code>&quot;bigint&quot;</code>、<code>&quot;symbol&quot;</code>、<code>&quot;function&quot;</code> 和 <code>&quot;object&quot;</code>。</li><li>特点：<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，这是一个历史遗留问题；<code>typeof</code> 对于函数和数组也返回 <code>&quot;function&quot;</code> 和 <code>&quot;object&quot;</code>，无法准确区分。</li><li>适用范围：通常用于检查基本数据类型（除了 <code>null</code>）和函数的数据类型。</li></ul></li><li><strong>instanceof</strong>：<ul><li>用法：<code>instanceof</code> 是一个二元操作符，用于检查对象是否属于某个类或其原型链上是否存在某个构造函数的 prototype 属性。</li><li>返回值：如果对象是指定类的实例，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>特点：<code>instanceof</code> 通过原型链检查对象的构造函数是否存在于指定类的原型链上，因此可以准确地检查对象是否是指定类的实例。</li><li>适用范围：通常用于检查对象是否是特定类的实例，特别适用于自定义对象或继承关系的检查。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：JavaScript中的错误有哪几种类型"><a href="#Q7：JavaScript中的错误有哪几种类型" class="headerlink" title="Q7：JavaScript中的错误有哪几种类型?"></a>Q7：JavaScript中的错误有哪几种类型?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>语法错误（Syntax Errors）</strong></p><p>也称为解析错误（Parsing Errors），是由于代码中的语法不正确而导致的错误</p><p>这种错误通常在代码解析阶段就会被检测到，并在控制台中显示错误消息</p></li><li><p><strong>类型错误（Type Errors）</strong></p><p>当操作或表达式的类型不符合预期时，会引发类型错误</p><p>例如，对非函数对象进行函数调用、对未定义或空值进行属性访问、非法的操作符操作等</p><p>这种错误通常会在运行时抛出异常</p></li><li><p><strong>引用错误（Reference Errors）</strong></p><p>当代码尝试引用一个不存在的变量或属性时，会抛出引用错误</p><p>例如，访问未定义的变量、调用未声明的函数、使用未定义的对象属性等</p></li><li><p><strong>范围错误（Range Errors）</strong></p><p>当操作超出有效范围时，会引发范围错误</p><p>例如，尝试使用超出数组长度的索引、使用负数作为参数传递给内置函数（如 <code>Array</code> 构造函数的 <code>length</code> 属性）等</p></li><li><p><strong>URI 错误（URI Errors）</strong></p><p>在处理统一资源标识符（URI）时发生的错误，例如使用 <code>encodeURI()</code> 和 <code>decodeURI()</code> 函数时的错误</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：js中的undefined和-ReferenceError-xxx-is-not-defined-有什么区别"><a href="#Q8：js中的undefined和-ReferenceError-xxx-is-not-defined-有什么区别" class="headerlink" title="Q8：js中的undefined和 ReferenceError: xxx is not defined 有什么区别?"></a>Q8：js中的undefined和 ReferenceError: xxx is not defined 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>JavaScript 中的 <code>undefined</code> 和 <code>ReferenceError</code> 的区别在于它们表示的含义和产生的原因不同。</p><ol><li><p><strong><code>undefined</code></strong>：</p><ul><li><p><code>undefined</code> 表示一个变量已被声明，但尚未被赋值，或者一个函数没有明确返回值时的默认返回值。</p></li><li><p>当你访问一个已声明但未赋值的变量时，或者调用一个没有返回值的函数时，其结果会是 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>ReferenceError</code></strong>：</p><ul><li><p><code>ReferenceError</code> 表示一个变量不存在，即在作用域中未声明或未定义该变量。</p></li><li><p>当你访问一个未声明的变量时，或者尝试访问一个未在当前作用域内定义的变量时，会导致 <code>ReferenceError</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>undefined</code> 是一个表示未赋值的特殊值，而 <code>ReferenceError</code> 表示变量或函数在当前作用域中未定义</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9：null是对象吗？为什么"><a href="#Q9：null是对象吗？为什么" class="headerlink" title="Q9：null是对象吗？为什么"></a>Q9：null是对象吗？为什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>null</code> 被认为是一种特殊的对象类型，但实际上它并不是一个对象。<code>null</code> 表示一个空值或者不存在的对象，用于表示一个变量不指向任何对象。</p><p>尽管在 JavaScript 中，<code>typeof null</code> 的结果是 <code>&quot;object&quot;</code>，但这其实是一个历史遗留问题，起源于 JavaScript 最初的设计。在 JavaScript 的早期版本中，表示对象的第一个字节的值为 <code>000</code>，而 <code>null</code> 的二进制表示是全 <code>0</code>，因此被错误地判断为对象类型。这个问题至今仍然保留了下来，为了保持向后兼容性，JavaScript 的设计者们没有修复这个问题。</p><p>因此，尽管 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>，但 <code>null</code> 实际上不是一个对象，而是一个原始值。可以使用 <code>===</code> 运算符来判断一个值是否为 <code>null</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：数据类型检测的方式有哪些"><a href="#Q10：数据类型检测的方式有哪些" class="headerlink" title="Q10：数据类型检测的方式有哪些"></a>Q10：数据类型检测的方式有哪些</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>typeof</code>运算符</p><p><code>typeof</code>是最常用的检测数据类型的方法，适用于基本类型（如String, Number, Boolean, Undefined, Symbol）的检测，但对于Array, Null, Object的检测则会返回<code>&quot;object&quot;</code>，对于Function会返回<code>&quot;function&quot;</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">42</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>)); <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.isArray()</code>方法</p><p>由于<code>typeof</code>不能准确判断数组类型，<code>Array.isArray()</code>方法能够准确检测一个值是否为数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([])); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>instanceof</code>运算符</p><p><code>instanceof</code>可以检测一个对象是否是其原型链中某个构造函数的实例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.prototype.toString.call()</code></p><p>这个方法通过调用<code>Object</code>原型上的<code>toString</code>方法检测对象的类型，可以准确区分大部分内置对象类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;Hello World&quot;</span>)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())); <span class="comment">// [object Date]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;sym&#x27;</span>))); <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数名称<code>（constructor.name）</code></p><p>每个对象都有一个<code>constructor</code>属性，该属性指向创建该对象的构造函数</p><p>通过检查<code>constructor.name</code>属性的值，可以得知对象类型的名称</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="property">constructor</span>.<span class="property">name</span>); <span class="comment">// Function</span></span><br></pre></td></tr></table></figure></li></ol><p>每种方法都有其优缺点，选择哪种方法取决于具体的应用场景和对准确度的要求</p><p>通常，<code>Object.prototype.toString.call()</code>提供了最准确的类型检测结果</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：isNaN-和-NumberisNaN-函数有什么区别"><a href="#Q11：isNaN-和-NumberisNaN-函数有什么区别" class="headerlink" title="Q11：isNaN 和 NumberisNaN 函数有什么区别"></a>Q11：isNaN 和 NumberisNaN 函数有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>isNaN</code>（全局函数）</p><ul><li><code>isNaN</code>函数将其参数转换成数字，然后判断该数字是否为<code>NaN</code></li><li>如果参数不能被转换成数字（比如一个字符串或对象），或者转换后的数字是<code>NaN</code>，则返回<code>true</code></li><li>也就是说，如果你传递给<code>isNaN</code>的参数在转换为数字过程中变成了<code>NaN</code>，那么<code>isNaN</code>就会返回<code>true</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// true - &quot;hello&quot; 转换为数字失败，所以是 NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// true - undefined 转换为数字得到 NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// true - &#123;&#125; 转换为数字失败</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">37</span>);        <span class="comment">// false - 37 是一个数字</span></span><br></pre></td></tr></table></figure></li><li><p><code>Number.isNaN</code>（ES6中引入）</p><ul><li><code>Number.isNaN</code>不会将参数转换成数字，只有当参数类型为<code>Number</code>且值为<code>NaN</code>时，才返回<code>true</code></li><li>它是对<code>NaN</code>的直接判断，不会有任何类型转换，这意味着除了<code>NaN</code>本身，对于其他不是数字类型的参数，即使它们在类型转换后可能会是<code>NaN</code>，<code>Number.isNaN</code>也返回<code>false</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// false - 这里不会尝试将字符串 &quot;hello&quot; 转换成数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">// false - undefined 不是数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(&#123;&#125;);        <span class="comment">// false - &#123;&#125; 不是数字</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">37</span>);        <span class="comment">// false - 37 是一个数字</span></span><br></pre></td></tr></table></figure></li></ol><p><code>Number.isNaN</code>是一个更严格的检查，它避免了<code>isNaN</code>因为类型强制转换导致的一些可能会引起混淆的情况</p><p>因此，在判断一个值是否为<code>NaN</code>时，通常推荐使用`Number.isNaN</p>
              </div>
            </details>
<p><br/></p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="Q1：怎么获取到一个实例对象的原型对象？"><a href="#Q1：怎么获取到一个实例对象的原型对象？" class="headerlink" title="Q1：怎么获取到一个实例对象的原型对象？"></a>Q1：怎么获取到一个实例对象的原型对象？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>Object.getPrototypeOf(obj)</code>：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype1 = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype1);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>__proto__</code> 属性（非标准）：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype2 = obj.<span class="property">__proto__</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype2);</span><br><span class="line"><span class="comment">// 虽然在一些环境中有效，但不是标准的 JavaScript，而且在未来可能会被废弃</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数的 <code>prototype</code> 属性：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomObject</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">CustomObject</span>(); <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype3 = <span class="title class_">CustomObject</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype3);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过实例对象的构造函数的 <code>constructor</code> 属性和 <code>prototype</code> 属性：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomObject</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">CustomObject</span>(); <span class="comment">// 你的实例对象</span></span><br><span class="line"><span class="keyword">const</span> prototype4 = obj.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prototype4);</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：改变this指向的方法有哪些？"><a href="#Q2：改变this指向的方法有哪些？" class="headerlink" title="Q2：改变this指向的方法有哪些？"></a>Q2：改变this指向的方法有哪些？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，有几种方式可以改变函数执行时的 <code>this</code> 指向：</p><ol><li><p><strong>使用 <code>bind</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunction = sayHello.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">boundFunction</span>(); <span class="comment">// Hello, Alice!</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用箭头函数：</strong></p><p>箭头函数不会创建自己的 <code>this</code>，而是捕获当前所处上下文的 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// Hello, Bob!</span></span><br></pre></td></tr></table></figure><p>请注意，箭头函数的 <code>this</code> 是在定义时确定的，而不是在运行时确定的。</p></li><li><p><strong>使用 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法：</strong></p><p>这些方法可以在调用函数的同时传递一个对象作为 <code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello.<span class="title function_">call</span>(obj); <span class="comment">// Hello, Charlie!</span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(obj); <span class="comment">// Hello, Charlie!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundFunction = sayHello.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">boundFunction</span>(); <span class="comment">// Hello, Charlie!</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>this</code>对象在JavaScript中是一个特别重要的概念，它是在运行时基于函数的执行环境动态绑定的</p><p><code>this</code>的值并不是在函数定义的时候被绑定的，而是在函数被调用的时候决定的</p><p>以下是<code>this</code>在不同情境下的一些基本行为：</p><ol><li><p>全局上下文</p><p>在全局执行上下文（不在任何函数内部）中，<code>this</code>指向全局对象</p><p>在浏览器中，全局对象是<code>window</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// 在浏览器中返回true</span></span><br></pre></td></tr></table></figure></li><li><p>函数上下文</p><p>在函数内部，<code>this</code>的值取决于函数是如何被调用的。</p><ul><li><strong>非严格模式下</strong>：未指定上下文的函数调用中，<code>this</code>指向全局对象</li><li><strong>严格模式下</strong>：<code>this</code>的值为<code>undefined</code></li><li>使用<code>call</code>、<code>apply</code>或者<code>bind</code>：可以将<code>this</code>显式地设置为第一个参数指定的对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 在非严格模式下返回 window，在严格模式下返回 undefined</span></span><br><span class="line"></span><br><span class="line">func.<span class="title function_">call</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;example&#x27;</span> &#125;); <span class="comment">// 返回 &#123; a: &#x27;example&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>对象方法</p><p>当函数作为对象的方法调用时，<code>this</code>指向该对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">method</span>(); <span class="comment">// 返回 obj</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><p>在构造函数中，<code>this</code>指的是一个新创建的对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;example&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">a</span>); <span class="comment">// 返回 &#x27;example&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>箭头函数</p><p>箭头函数不绑定自己的<code>this</code>，它们继承了上层代码块的<code>this</code>值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">method</span>()(); <span class="comment">// 返回 obj</span></span><br></pre></td></tr></table></figure></li><li><p>事件处理器</p><p>在事件处理函数中，<code>this</code>通常指向触发事件的元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向按钮元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>理解<code>this</code>的工作机制对于编写可预测和有效的代码非常重要</p><p>不同的调用方式和函数类型会影响<code>this</code>的绑定，正确的使用<code>this</code>可以使代码更简洁、逻辑更清晰</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：对ToPrimitive的理解"><a href="#Q3：对ToPrimitive的理解" class="headerlink" title="Q3：对ToPrimitive的理解"></a>Q3：对ToPrimitive的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>ToPrimitive</code> 是 JavaScript 中的一个抽象操作符，用于将值转换为基本类型（primitive type）。这个操作通常由内置函数调用，例如进行运算或将对象转换为原始值的时候。</p><p><code>ToPrimitive</code> 的具体规则如下：</p><ol><li>如果一个对象有 <code>Symbol.toPrimitive</code> 方法，就调用该方法，返回其结果。</li><li>否则，如果 hint 参数是 “string”，尝试调用对象的 <code>valueOf</code> 和 <code>toString</code> 方法，如果其中任意一个返回原始值，则返回该值。</li><li>否则，如果 hint 参数是 “number” 或默认（没有提供 hint 参数），尝试调用对象的 <code>valueOf</code> 和 <code>toString</code> 方法，如果其中任意一个返回原始值，则返回该值。</li><li>否则，抛出 <code>TypeError</code>。</li></ol><p>以下是一些示例：</p><p><strong>对象有 <code>Symbol.toPrimitive</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// 输出 &#x27;Hello&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(obj)); <span class="comment">// 输出 42</span></span><br></pre></td></tr></table></figure><p><strong>对象没有 <code>Symbol.toPrimitive</code> 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// 输出 &#x27;Hello&#x27;，toString 返回原始值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(obj)); <span class="comment">// 输出 42，valueOf 返回原始值</span></span><br></pre></td></tr></table></figure><p><code>ToPrimitive</code> 主要用于规范中描述对象转换为原始值的过程，通常在 JavaScript 引擎内部处理。开发者在日常编码中不经常直接使用这个抽象操作符</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：Object与Map有什么区别"><a href="#Q4：Object与Map有什么区别" class="headerlink" title="Q4：Object与Map有什么区别?"></a>Q4：Object与Map有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>Object</code> 和 <code>Map</code> 都是用于存储键值对的数据结构，但它们有一些重要的区别：</p><ol><li><strong>键的类型</strong>：<ul><li><strong>Object</strong>：对象的键必须是字符串或者 Symbol 类型。如果试图使用其他类型的值作为键，JavaScript 引擎会将其转换为字符串。</li><li><strong>Map</strong>：Map 可以接受任意类型的值作为键，包括原始类型和对象引用。</li></ul></li><li><strong>键值对的顺序</strong>：<ul><li><strong>Object</strong>：对象的键值对是无序的。尽管在一些实现中，属性的遍历顺序可能会按照添加的顺序，但 JavaScript 规范并不保证这一点。</li><li><strong>Map</strong>：Map 保留键值对的插入顺序。当你迭代一个 Map 对象时，它会按照键值对被添加的顺序进行迭代。</li></ul></li><li><strong>大小</strong>：<ul><li><strong>Object</strong>：对象的大小没有直接的属性或方法来获取。要获取对象的键值对数量，需要手动计算属性的数量或者使用 <code>Object.keys(obj).length</code>。</li><li><strong>Map</strong>：Map 对象有一个 size 属性，可以直接获取键值对的数量。</li></ul></li><li><strong>迭代</strong>：<ul><li><strong>Object</strong>：要遍历对象的属性，可以使用 <code>for...in</code> 循环或者 <code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code> 方法。</li><li><strong>Map</strong>：Map 对象实现了迭代器协议，可以使用 <code>for...of</code> 循环直接遍历 Map 对象。</li></ul></li><li><strong>内存占用</strong>：<ul><li><strong>Object</strong>：对象的键值对在某些情况下可能会占用更多的内存，因为对象会维护原型链和额外的属性。</li><li><strong>Map</strong>：Map 对象的实现通常会对内存进行优化，特别是在大型数据集上时。Map 可以更有效地存储大量的键值对。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：cookie-的有效时间设置为-0会怎么样"><a href="#Q5：cookie-的有效时间设置为-0会怎么样" class="headerlink" title="Q5：cookie 的有效时间设置为 0会怎么样"></a>Q5：cookie 的有效时间设置为 0会怎么样</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>将 cookie 的有效时间设置为 0 实际上是告诉浏览器在会话结束时将其删除。在 HTTP 协议中，如果 cookie 的过期时间设置为 0 或者省略，则 cookie 会成为一个会话 cookie，它仅在用户当前会话期间有效，一旦用户关闭浏览器，这个 cookie 就会被删除。</p><p>设置 cookie 的有效时间为 0 通常用于创建会话 cookie，这些 cookie 存储了在用户会话期间需要保持的数据，例如用户登录状态或者临时会话标识。当用户关闭浏览器时，这些 cookie 就会被删除，从而保护用户的隐私和安全。</p><p>总之，将 cookie 的有效时间设置为 0 表示这是一个会话 cookie，它只在用户当前会话期间有效，并在用户关闭浏览器时被删除。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Dom操作有哪些"><a href="#Q6：Dom操作有哪些" class="headerlink" title="Q6：Dom操作有哪些"></a>Q6：Dom操作有哪些</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>DOM（文档对象模型）操作是指对网页中的 HTML 元素进行增、删、改、查等操作，使得页面的结构、样式和内容能够动态地改变。以下是常见的 DOM 操作：</p><ol><li><strong>获取元素</strong>：<ul><li><code>document.getElementById(id)</code>：通过元素的 id 属性获取元素。</li><li><code>document.getElementsByClassName(className)</code>：通过元素的类名获取元素集合。</li><li><code>document.getElementsByTagName(tagName)</code>：通过元素的标签名获取元素集合。</li><li><code>document.querySelector(selector)</code>：通过 CSS 选择器获取第一个匹配的元素。</li><li><code>document.querySelectorAll(selector)</code>：通过 CSS 选择器获取所有匹配的元素集合。</li></ul></li><li><strong>创建元素</strong>：<ul><li><code>document.createElement(tagName)</code>：创建一个指定标签名的元素节点。</li><li><code>document.createTextNode(text)</code>：创建一个包含指定文本的文本节点。</li></ul></li><li><strong>添加、移除和替换元素</strong>：<ul><li><code>parentNode.appendChild(newNode)</code>：将一个新节点添加到指定节点的子节点列表的末尾。</li><li><code>parentNode.removeChild(node)</code>：从指定节点的子节点列表中移除一个子节点。</li><li><code>parentNode.replaceChild(newNode, oldNode)</code>：用一个新节点替换指定节点的子节点列表中的一个子节点。</li></ul></li><li><strong>修改元素的属性和内容</strong>：<ul><li><code>element.setAttribute(attribute, value)</code>：设置指定元素的属性值。</li><li><code>element.getAttribute(attribute)</code>：获取指定元素的属性值。</li><li><code>element.innerHTML</code>：获取或设置指定元素的 HTML 内容。</li><li><code>element.innerText</code>：获取或设置指定元素的文本内容。</li></ul></li><li><strong>添加和移除事件监听器</strong>：<ul><li><code>element.addEventListener(event, handler)</code>：为指定元素添加事件监听器。</li><li><code>element.removeEventListener(event, handler)</code>：移除指定元素的事件监听器。</li></ul></li><li><strong>样式操作</strong>：<ul><li><code>element.style.property = value</code>：直接设置元素的样式属性。</li><li><code>element.classList.add(className)</code>：为元素添加类名。</li><li><code>element.classList.remove(className)</code>：移除元素的类名。</li><li><code>element.classList.toggle(className)</code>：切换元素的类名。</li></ul></li><li><strong>查询元素的位置和尺寸</strong>：<ul><li><code>element.getBoundingClientRect()</code>：返回元素的大小及其相对于视口的位置。</li><li><code>element.offsetParent</code>：返回最近的包含该元素的定位元素。</li><li><code>element.offsetWidth</code>、<code>element.offsetHeight</code>、<code>element.offsetTop</code>、<code>element.offsetLeft</code>：返回元素的宽度、高度、相对于父元素的顶部距离和左侧距离。</li></ul></li><li><strong>其他常用操作</strong>：<ul><li><code>document.createDocumentFragment()</code>：创建一个文档片段，用于高效地进行多个 DOM 操作。</li><li><code>element.scrollIntoView()</code>：使元素滚动到浏览器窗口的可视区域内。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：ES6中对象新增了哪些扩展"><a href="#Q7：ES6中对象新增了哪些扩展" class="headerlink" title="Q7：ES6中对象新增了哪些扩展?"></a>Q7：ES6中对象新增了哪些扩展?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>对象字面量的简写语法</strong>：</p><ul><li><p>可以在定义对象时使用更简洁的语法，不再需要写重复的属性名。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; x, y &#125;; <span class="comment">// 等价于 &#123; x: x, y: y &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>计算属性名</strong>：</p><ul><li><p>在对象字面量中可以使用计算属性名，使得属性名可以动态计算。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propName = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propName]: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>方法简写</strong>：</p><ul><li><p>在对象字面量中定义方法时可以省略 <code>function</code> 关键字。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Object.assign()</strong>：</p><ul><li><p>可以用于将一个或多个源对象的属性复制到目标对象中。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source); <span class="comment">// target 变为 &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Object.keys()、Object.values() 和 Object.entries()</strong>：</p><ul><li><p><code>Object.keys()</code>：返回一个包含目标对象所有可枚举属性名的数组。</p></li><li><p><code>Object.values()</code>：返回一个包含目标对象所有可枚举属性值的数组。</p></li><li><p><code>Object.entries()</code>：返回一个包含目标对象所有可枚举属性键值对的数组，每个键值对以数组形式表示。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// 返回 [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj); <span class="comment">// 返回 [1, 2, 3]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj); <span class="comment">// 返回 [[&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>对象的扩展方法</strong>：</p><ul><li><code>Object.setPrototypeOf()</code>：设置一个对象的原型（即修改 <code>__proto__</code> 属性）。</li><li><code>Object.getPrototypeOf()</code>：获取一个对象的原型。</li><li><code>Object.getOwnPropertyDescriptors()</code>：获取一个对象的所有属性的描述符。</li></ul></li><li><p><strong>Symbol 类型</strong>：</p><ul><li><p><code>Symbol</code> 类型是一种新的原始数据类型，表示独一无二的值。</p></li><li><p>可以用作对象的属性名，用于创建唯一标识符。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [sym]: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Proxy-能够监听到对象中的对象的引用吗"><a href="#Q8：Proxy-能够监听到对象中的对象的引用吗" class="headerlink" title="Q8：Proxy 能够监听到对象中的对象的引用吗?"></a>Q8：Proxy 能够监听到对象中的对象的引用吗?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>是的，<code>Proxy</code> 可以监听到对象中的对象引用的变化。</p><p>当使用 <code>Proxy</code> 对象对某个对象进行代理时，代理对象可以拦截对目标对象的各种操作，包括对对象属性的访问、修改、添加和删除等。如果目标对象的属性值是对象，那么对该属性的操作也会被拦截，包括对该属性值对象内部属性的修改。</p><p>下面是一个示例，演示了如何使用 <code>Proxy</code> 监听对象中的对象引用的变化：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">nestedObj</span>: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">nestedObj</span>.<span class="property">key</span> = <span class="string">&#x27;new value&#x27;</span>; <span class="comment">// 输出 &quot;Setting key to new value&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，当通过 <code>proxy</code> 对象修改 <code>nestedObj</code> 的 <code>key</code> 属性时，<code>set</code> 拦截器会捕获到操作，并输出相关信息。这表明 <code>Proxy</code> 可以监听到对象中的对象引用的变化。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：导致-JavaScript-中-this-指向混乱的原因是什么"><a href="#Q9-：导致-JavaScript-中-this-指向混乱的原因是什么" class="headerlink" title="Q9 ：导致 JavaScript 中 this 指向混乱的原因是什么?"></a>Q9 ：导致 JavaScript 中 this 指向混乱的原因是什么?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 中 this 指向混乱的原因主要有以下几点：</p><ol><li>函数调用方式不同：JavaScript 中函数的调用方式有多种，包括普通函数调用、方法调用、构造函数调用和箭头函数等。不同的调用方式会导致 this 的指向不同。</li><li>丢失绑定：当一个函数被单独调用时，即没有任何对象或上下文与之相关联时，this 将指向全局对象（在浏览器环境中通常是 <code>window</code> 对象）。这种情况下，如果函数内部使用了 this，则可能会出现意外结果。</li><li>隐式绑定丢失：当一个方法从对象中切割出来并作为独立函数调用时，隐式绑定将会丢失，导致 this 不再指向原对象。这往往发生在将对象方法作为回调函数传递给其他函数的情况下。</li><li>显式绑定问题：使用 <code>.call()</code>、<code>.apply()</code> 或 <code>.bind()</code> 方法可以显式地绑定函数的 this，但如果不小心使用或错误地使用这些方法，也可能导致 this 指向混乱。</li><li>箭头函数中的 this：箭头函数没有自己的 this 绑定机制，它会从外围作用域继承 this。这意味着箭头函数中的 this 与其定义时的上下文相关联，而不是调用时的上下文。</li><li>异步操作中的 this：在异步函数或回调函数中，this 的指向可能会发生变化，因为它们的执行上下文可能会改变。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>为了避免 this 指向混乱的问题，可以采取以下措施：</p><ul><li>使用箭头函数，它能够继承外部作用域的 this。</li><li>使用 <code>.bind()</code>、<code>.call()</code> 或 <code>.apply()</code> 方法显式地绑定函数的 this。</li><li>使用闭包将需要引用的 this 缓存起来。</li><li>在方法调用时确保上下文正确。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：e-target跟e-currentTarget有什么区别？"><a href="#Q10：e-target跟e-currentTarget有什么区别？" class="headerlink" title="Q10：e.target跟e.currentTarget有什么区别？"></a>Q10：e.target跟e.currentTarget有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong><code>e.target</code>：</strong><ul><li><code>e.target</code> 表示触发事件的实际目标元素。</li><li>对于事件冒泡，它是最深层次的元素，即实际接收到事件的元素。</li><li>对于事件捕获，它是最外层的元素，即最先接收到事件的元素。</li><li>通常用于获取用户实际与之交互的元素。</li></ul></li><li><strong><code>e.currentTarget</code>：</strong><ul><li><code>e.currentTarget</code> 表示当前正在处理事件的元素，即事件处理程序所附加到的元素。</li><li>对于事件冒泡，它是在事件流上当前正在处理事件的元素。</li><li>对于事件捕获，它是在事件流下当前正在处理事件的元素。</li><li>通常用于在事件处理函数内部引用附加处理程序的元素。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>e.target</code> 表示触发事件的实际元素</p><p> <code>e.currentTarget</code> 表示当前正在处理事件的元素</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span>哈哈哈哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/25/txhNyCamkpZ7ovB.png" alt="image-20240125161544126"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> c = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">a.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">b.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">d.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    target,</span><br><span class="line">    currentTarget</span><br><span class="line">  &#125; = e</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target是<span class="subst">$&#123;target.id&#125;</span>`</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`currentTarget是<span class="subst">$&#123;currentTarget.id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别点击这几个之后的结果</span></span><br><span class="line"><span class="comment">// target是d currentTarget是d</span></span><br><span class="line"><span class="comment">// target是d currentTarget是c</span></span><br><span class="line"><span class="comment">// target是d currentTarget是b</span></span><br><span class="line"><span class="comment">// target是d currentTarget是a</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：说说你对-new-target-的理解"><a href="#Q11：说说你对-new-target-的理解" class="headerlink" title="Q11：说说你对 new.target 的理解"></a>Q11：说说你对 new.target 的理解</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 输出: [Function: Person]</span></span><br><span class="line"><span class="title class_">Person</span>(); <span class="comment">// 输出: undefined</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>Person()</code> 构造函数中的 <code>new.target</code> 分别输出了 <code>[Function: Person]</code> 和 <code>undefined</code>。这是因为第一个调用是通过 <code>new</code> 关键字调用的，所以 <code>new.target</code> 指向 <code>Person</code> 构造函数本身；而第二个调用是普通函数调用，所以 <code>new.target</code> 是 <code>undefined</code>。</p><p><code>new.target</code> 主要用于确定构造函数或者类是否通过 <code>new</code> 关键字调用，从而执行不同的逻辑，例如在类的构造函数中可以使用 <code>new.target</code> 来确保类只能通过 <code>new</code> 关键字调用。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>new.target</code> 是 ECMAScript 6 引入的一个元属性，它在构造函数或者类的构造函数中表示通过 <code>new</code> 关键字调用的构造函数或者类的引用。</p><p>具体来说，<code>new.target</code> 返回一个指向正在执行的构造函数或者类的引用。如果构造函数或者类是通过 <code>new</code> 关键字调用的，则 <code>new.target</code> 会指向该构造函数或者类本身；如果构造函数或者类是通过普通函数调用的，则 <code>new.target</code> 会是 <code>undefined</code>。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：如何判断一个对象是不是空对象"><a href="#Q12：如何判断一个对象是不是空对象" class="headerlink" title="Q12：如何判断一个对象是不是空对象"></a>Q12：如何判断一个对象是不是空对象</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Object.keys()</code> 方法</p><p>我们可以使用<code>Object.keys()</code>方法来获取对象的所有键，然后检查键的数量。如果键的数量为 0，意味着对象为空</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object1));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object2));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure></li><li><p><code>for...in</code> 循环</p><p>通过 <code>for...in</code> 循环遍历对象。如果循环没有执行，那么对象就是空的</p><p>其中 <code>obj.hasOwnProperty(key)</code> 用于确保属性是对象自己的属性，而非继承自原型链</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object1));  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(object2));  <span class="comment">// 输出：false</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：正则表达式是什么"><a href="#Q13：正则表达式是什么" class="headerlink" title="Q13：正则表达式是什么"></a>Q13：正则表达式是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>“正则表达式”（Regular Expression）是一种强大的文本处理工具，用于字符串的搜索、替换、检索和拆分等操作</p><p>它通过定义一个规则来匹配一系列符合某个句法规则的字符串</p><p>正则表达式非常灵活且高效，广泛应用于文本编辑器、编程语言、数据库查询等多种领域</p><p>正则表达式由普通字符（例如字母和数字）以及特殊字符（称为”元字符”）组成</p><p>这些规则简洁但功能强大，可以非常精确地描述和匹配文本模式，包括：</p><ul><li><p><strong>字面字符</strong></p><p>直接匹配文本中的指定字符</p></li><li><p><strong>元字符</strong></p><p>具有特殊含义的字符，例如用于表示空白字符、单词边界、字符集合等</p></li><li><p><strong>量词</strong></p><p>指明了模式出现的频率，如“一次或更多次”、“零次或一次”等</p></li><li><p><strong>位置匹配</strong></p><p>比如单词的开始和结束、字符串的开头和结尾</p></li><li><p><strong>分组和引用</strong></p><p>可以将模式的一部分组合在一起，以便可以后续引用或应用量词</p></li></ul>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>匹配规则</strong></p><ol><li>字符匹配<ul><li><code>.</code>：匹配除换行符 <code>\n</code> 之外的任意单个字符</li><li><code>\d</code>：匹配任意一位数字，等同于 <code>[0-9]</code></li><li><code>\D</code>：匹配任意非数字字符，等同于 <code>[^0-9]</code></li><li><code>\w</code>：匹配任意字母、数字或下划线（Word Character），等同于 <code>[a-zA-Z0-9_]</code></li><li><code>\W</code>：匹配任意非单词字符，等同于 <code>[^a-zA-Z0-9_]</code></li><li><code>\s</code>：匹配任意空白字符，包括空格、制表符、换行符等</li><li><code>\S</code>：匹配任意非空白字符</li><li><code>[abc]</code>：字符集合，匹配包含的任一字符</li><li><code>[^abc]</code>：否定字符集，匹配不在指定集合中的任一字符</li><li><code>[a-z]</code> 或 <code>[A-Z]</code> 或 <code>[0-9]</code>：范围，匹配指定范围内的任意字符</li><li><code>^</code>：在字符集合中使用时，表示否定，如 <code>[^a-e]</code> 表示非 a 到 e 的字符。在其他时候表示行的起始</li><li><code>$</code>：匹配行的结束</li><li><code>\b</code>：匹配单词的边界</li><li><code>\B</code>：匹配非单词边界</li><li><code>\</code>：转义字符，用来匹配那些特殊字符，如 <code>\\.</code>, <code>\\$</code>, <code>\(</code> 等</li><li><code>|</code>：选择，匹配符号左边或者右边的表达式</li><li><code>(expr)</code>：分组符号，用来定义一个组</li><li><code>(?:expr)</code>：非捕获分组，该组匹配的内容不会被捕获，不分配组号</li><li><code>(?=expr)</code>：正向先行断言，表示之后的内容必须匹配表达式 <code>expr</code></li><li><code>(?!expr)</code>：负向先行断言，表示之后的内容不匹配表达式 <code>expr</code></li><li><code>expr1(?&lt;=expr2)</code>：正向后行断言，表示 <code>expr1</code> 前面的内容必须匹配 <code>expr2</code></li><li><code>expr1(?&lt;!expr2)</code>：负向后行断言，表示 <code>expr1</code> 前面的内容不匹配 <code>expr2</code></li><li><code>x*</code>：匹配前面的模式 <code>x</code> 0 或多次</li><li><code>x+</code>：匹配前面的模式 <code>x</code> 1 或多次</li><li><code>x?</code>：匹配前面的模式 <code>x</code> 0 或 1 次</li><li><code>x{n}</code>：匹配前面的模式 <code>x</code> 恰好 <code>n</code> 次</li><li><code>x{n,}</code>：匹配前面的模式 <code>x</code> 至少 <code>n</code> 次</li><li><code>x{n,m}</code>：匹配前面的模式 <code>x</code> 至少 <code>n</code> 次，但不超过 <code>m</code> 次</li></ul></li><li>位置匹配<ul><li><code>^</code>：匹配输入字符串的开始位置</li><li><code>$</code>：匹配输入字符串的结束位置</li><li><code>\b</code>：匹配一个单词边界，也就是指单词和空格间的位置</li><li><code>\B</code>：匹配非单词边界，<code>&#39;er\B&#39;</code> 可以匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’</li><li><code>(?=p)</code>：匹配 ‘p’ 前面的位置</li><li><code>(?!p)</code>：匹配 ‘p’ 不在其后的位置</li></ul></li><li>分组引用<ul><li><code>(abc)</code>：匹配abc并捕获该匹配项</li><li><code>(?:abc)</code>：匹配abc但不捕获该匹配项（非捕获组）</li><li><code>\1</code>：匹配之前第1个分组捕获的文本</li></ul></li><li>量词<ul><li><code>*</code>：匹配前面的子表达式零次或多次</li><li><code>+</code>：匹配前面的子表达式一次或多次</li><li><code>?</code>：匹配前面的子表达式零次或一次</li><li><code>{n}</code>：匹配确定的n次</li><li><code>{n,}</code>：至少匹配n次</li><li><code>{n,m}</code>：最少匹配n次且最多匹配m次</li></ul></li><li>选择<ul><li><code>|</code>：或运算符，匹配两项之一</li></ul></li><li>转义字符<ul><li><code>\</code>：将下一个字符标记为特殊字符或字面值</li></ul></li></ol><p><br /></p><p><strong>模式</strong></p><p>在正则表达式中，贪婪模式（Greedy Mode）和懒惰模式（Lazy Mode，也叫非贪婪模式或惰性模式）是与量词相关的两种匹配模式</p><p>它们决定了正则表达式匹配字符的方式，即是尽可能多地匹配（贪婪）还是尽可能少地匹配（懒惰）</p><ol><li><p>贪婪模式</p><p>贪婪模式是正则表达式的默认匹配模式，它会尽可能多地匹配字符</p><p>也就是说，它会匹配尽可能多的字符，直到整个表达式能够匹配为止</p><p>例如，在表达式 <code>a.*b</code> 中，它会匹配从第一个 <code>&quot;a&quot;</code> 到最后一个 <code>&quot;b&quot;</code> 之间的所有内容</p></li><li><p>懒惰模式</p><p>懒惰模式或非贪婪模式，会尽可能少地匹配字符</p><p>在量词后加上问号 <code>?</code> 可以实现懒惰匹配</p><p>例如，在表达式 <code>a.*?b</code> 中，它会匹配从第一个 <code>&quot;a&quot;</code> 到最近的一个 <code>&quot;b&quot;</code> 之间的内容，使用尽可能少的匹配尝试找到满足条件的匹配项</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is a &lt;div&gt;simple&lt;/div&gt; div.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line"><span class="keyword">let</span> greedyRegex = <span class="regexp">/&lt;.*&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> greedyResult = text.<span class="title function_">match</span>(greedyRegex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greedy Result:&quot;</span>, greedyResult[<span class="number">0</span>]); <span class="comment">// Greedy Result: &lt;div&gt;simple&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line"><span class="keyword">let</span> lazyRegex = <span class="regexp">/&lt;.*?&gt;/</span>;</span><br><span class="line"><span class="keyword">let</span> lazyResult = text.<span class="title function_">match</span>(lazyRegex);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lazy Result:&quot;</span>, lazyResult[<span class="number">0</span>]); <span class="comment">// Lazy Result: &lt;div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>贪婪匹配的结果是 <code>&quot;&lt;div&gt;simple&lt;/div&gt;&quot;</code>。它匹配了从字符串中的第一个 <code>&lt;</code> 到最后一个 <code>&gt;</code> 的整段文本。</li><li>懒惰匹配的结果是 <code>&quot;&lt;div&gt;&quot;</code>。它只匹配了开头的 <code>&lt;div&gt;</code> 标签，因为懒惰模式会在找到第一个满足条件的 <code>&gt;</code> 后停止匹配。</li></ul><p><br /></p><p><strong>匹配方法</strong></p><ol><li><code>exec()</code><ul><li>此方法由正则表达式对象调用</li><li>它返回一个数组（包含匹配的信息）或在没有匹配项时返回null</li><li>例子: <code>/[a-e]/i.exec(&quot;Hello World&quot;)</code></li></ul></li><li><code>test()</code><ul><li>此方法同样由正则表达式对象调用</li><li>它返回一个布尔值，表示是否存在匹配</li><li>例子: <code>/hello/i.test(&quot;Hello world&quot;)</code></li></ul></li><li><code>match()</code><ul><li>这个方法由字符串对象调用</li><li>它返回一个包含匹配结果的数组或在没有匹配项时返回null</li><li>例子: <code>&quot;Hello world&quot;.match(/[a-e]/i)</code></li></ul></li><li><code>matchAll()</code><ul><li>此方法由字符串对象调用</li><li>它返回一个包含所有匹配的迭代器</li><li>例子: <code>&quot;test1test2&quot;.matchAll(/\d/g)</code></li></ul></li><li><code>replace()</code><ul><li>由字符串对象调用</li><li>它返回一个新字符串，其中的匹配项被替换</li><li>例子: <code>&quot;Hello World&quot;.replace(/world/i, &quot;Mars&quot;)</code></li></ul></li><li><code>replaceAll()</code><ul><li>类似于 <code>replace()</code>，但它会替换掉字符串中所有的匹配项</li><li>例子: <code>&quot;2022/05/11&quot;.replaceAll(/\//g, &quot;-&quot;)</code></li></ul></li><li><code>search()</code><ul><li>此方法由字符串对象调用</li><li>返回第一个匹配项的索引，如果没有匹配则返回-1</li><li>例子: <code>&quot;Hello World&quot;.search(/world/i)</code></li></ul></li><li><code>split()</code><ul><li>此方法由字符串对象调用</li><li>它使用正则表达式或一个固定字符串来分割字符串，并返回一个数组</li><li>例子: <code>&quot;Hello World&quot;.split(/\s/)</code></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：Javascript里面的继承方式有哪些？"><a href="#Q14：Javascript里面的继承方式有哪些？" class="headerlink" title="Q14：Javascript里面的继承方式有哪些？"></a>Q14：Javascript里面的继承方式有哪些？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，继承是一种让一个对象获得另一个对象的属性和方法的机制。以下是主要的继承方式：</p><ol><li><p><strong>原型链继承</strong></p><p>每个对象都有一个指向另一个对象的链接称为原型（prototype）</p><p>当你试图访问一个对象的属性时，如果对象本身没有这个属性，则会去它的原型（及原型的原型，依次类推）中查找</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentProperty</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getParentProperty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">parentProperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childProperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Parent</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getParentProperty</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>构造函数继承</strong></p><p>通过在子类的构造函数中调用父类的构造函数，可以继承父类的属性，但没法继承父类原型的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">name</span>); <span class="comment">// &#x27;child1&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>组合继承</strong></p><p>结合了原型链继承和构造函数继承，既能继承属性也能继承方法</p><p>通常是在子类构造函数中调用父类构造函数，并将子类的原型设置为父类的实例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>原型式继承</strong></p><p>是ECMAScript 5中通过<code>Object.create</code>方法实现的，可以创建一个新对象，用现有的对象来提供新创建的对象的<code>__proto__</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">colors</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent);</span><br><span class="line">child.<span class="property">name</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// &#x27;child&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">colors</span>); <span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄生式继承</strong></p><p>创建一个仅用于封装继承过程的函数来增强对象，然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="attr">colors</span>: [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="title function_">createAnother</span>(parent);</span><br><span class="line">child.<span class="title function_">sayHi</span>(); <span class="comment">// &#x27;Hi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// &#x27;parent&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>寄生组合式继承</strong></p><p>为了解决组合继承调用两次父构造函数的问题，寄生组合式继承将父对象的原型赋给子对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ES6类继承 <code>extends</code> 和 <code>super</code></strong></p><p>ES6引入了类（class）概念，通过<code>class</code>和<code>extends</code>关键字，提供了更清晰和易于理解的继承语法</p><p><code>super</code>关键字用于调用父类的构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child1&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="title function_">getName</span>()); <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">age</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>每种继承方式都有其特定的适用场景、优点和缺点</p><p>了解这些可以帮助你更好地选择适合你项目的继承策略：</p><ol><li><strong>原型链继承</strong><ul><li>优点：简单易理解。</li><li>缺点：来自原型的所有属性被所有实例共享，无法实现多继承。</li></ul></li><li><strong>构造函数继承</strong><ul><li>优点：可以实现多继承，创建子类实例时可以向父类传递参数。</li><li>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul></li><li><strong>组合继承</strong><ul><li>优点：融合了原型链继承和构造函数继承的优点，能够实现函数复用。</li><li>缺点：调用了两次父类构造函数，生成了两份实例。</li></ul></li><li><strong>原型式继承</strong><ul><li>优点：适用于不需要单独创建构造函数，但仍然需要在多个对象间共享信息的场景。</li><li>缺点：包含引用类型的属性值始终会共享相应的值，这样的话就不适合单独实例。</li></ul></li><li><strong>寄生式继承</strong><ul><li>优点：可以为对象添加新方法。</li><li>缺点：使用函数创造对象，无法做到函数复用，效率较低。</li></ul></li><li><strong>寄生组合式继承</strong><ul><li>优点：避免了组合继承的缺点，只调用一次父类构造函数，并且原型链保持不变。</li><li>缺点：实现起来较为复杂。</li></ul></li><li><strong>ES6类继承 (<code>extends</code> 和 <code>super</code>)</strong><ul><li>优点：语法更清晰简洁，更接近传统面向对象语言的写法，易于理解和使用。</li><li>缺点：<code>class</code>关键字实质上还是原型继承的语法糖，不能完全摆脱原型链继承的限制。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：base64编码图片，为什么会让数据量变大"><a href="#Q15：base64编码图片，为什么会让数据量变大" class="headerlink" title="Q15：base64编码图片，为什么会让数据量变大"></a>Q15：base64编码图片，为什么会让数据量变大</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Base64 是一种用64个字符来表示任意二进制数据的方法</p><p>它用 64 个可打印的 ASCII 字符来表示二进制数据</p><p>为什么 Base64 会使数据变大呢？</p><p>这是因为 Base64 编码设计的初衷是在无法直接处理二进制数据的情况下，将二进制数据转换为只包含ASCII字符的字符串，以便二进制数据可以以文本的形式在网络上进行传输或存储</p><p>然而，这种转换是有代价的</p><p>Base64编码过程中，每3个字节（24位）的数据，会被编码为4个字节的ASCII字符</p><p>这就导致了增加了约33%的数据量（4/3）</p><p>如果原始数据没有足够的数据（如不是3的倍数），那么 Base64 还会在末尾添加填充字符(‘=’)，这可能会导致数据量进一步增加</p><p>因此，Base64编码并不适合用于压缩数据或减小数据大小，对于大量数据或者大文件，使用Base64会显著增加数据量</p><p>然而，如果你需要在无法直接发送二进制数据的环境中发送数据（例如在 JSON 中发送图像），或者需要将二进制数据存储为文本（如 CSS 中的内联图像），那么Base64是非常方便的工具</p><p>Base64编码的根本目的并不是为了减少数据大小，而是为了能在仅支持文本的环境中处理二进制数据</p>
              </div>
            </details>
<p><br/></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="Q1：将数组的length设置为0，获取它的第一个元素会返回什么"><a href="#Q1：将数组的length设置为0，获取它的第一个元素会返回什么" class="headerlink" title="Q1：将数组的length设置为0，获取它的第一个元素会返回什么"></a>Q1：将数组的length设置为0，获取它的第一个元素会返回什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>当将数组的 <code>length</code> 设置为0时，数组实际上被清空，不包含任何元素。在这种情况下，获取数组的第一个元素将返回 <code>undefined</code>。</p><p>这是因为数组为空，没有任何元素可以被访问。当你尝试获取一个不存在的元素时，JavaScript 返回 <code>undefined</code>，表示值不存在或未定义。因此，如果数组的 <code>length</code> 被设置为0，任何尝试获取数组元素的操作都将返回 <code>undefined</code>。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>undefined</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：什么是类数组对象"><a href="#Q2：什么是类数组对象" class="headerlink" title="Q2：什么是类数组对象"></a>Q2：什么是类数组对象</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>类数组对象（Array-like Object）是具有类似数组结构的对象，但并不是真正的数组。这些对象在结构上类似数组，通常有数值索引和 <code>length</code> 属性，但它们不继承自数组（Array）原型，因此不具备数组原型上的方法</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>常见的类数组对象包括：</p><ol><li><strong>arguments 对象：</strong> 在函数内部可用，包含了传递给函数的参数，具有数值索引和 <code>length</code> 属性。</li><li><strong>NodeList 对象：</strong> 代表文档中的节点列表，例如使用 <code>document.querySelectorAll</code> 或 <code>element.childNodes</code> 得到的对象。</li><li><strong>字符串（String）：</strong> 字符串也可以被视为类数组对象，因为它们有类似数组的索引和 <code>length</code> 属性。</li><li><strong>函数的 <code>arguments</code> 对象：</strong> 函数内部的 <code>arguments</code> 对象也是一个类数组对象。</li></ol><p>类数组对象在某些情况下非常有用，但由于它们不具备数组原型上的方法，例如 <code>push</code>、<code>pop</code>、<code>slice</code> 等，因此在需要使用数组方法的场合，需要将其转换为真正的数组</p><p>有多种方法可以将类数组对象转换为数组。以下是几种常见的方法：</p><ol><li><p>使用 Array.from()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用扩展运算符 (…)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [...arrayLikeObject];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Array.prototype.slice.call()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Array.prototype.concat.apply()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], arrayLikeObject);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 forEach()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(arrayLikeObject, <span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>使用 for…of 循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123; <span class="number">0</span>: <span class="string">&#x27;apple&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;banana&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> arrayLikeObject) &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：空数组调用reduce会发生什么"><a href="#Q3：空数组调用reduce会发生什么" class="headerlink" title="Q3：空数组调用reduce会发生什么"></a>Q3：空数组调用reduce会发生什么</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在空数组上调用 <code>reduce</code> 方法时，如果没有提供初始值（initialValue），会抛出 <code>TypeError</code>。这是因为 <code>reduce</code> 需要至少有一个元素来执行归约操作，而在空数组中没有元素可供归约</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"><span class="keyword">const</span> result = emptyArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Reduce of empty array with no initial value</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>为了避免这个错误，可以在调用 <code>reduce</code> 时提供一个初始值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emptyArray = [];</span><br><span class="line"><span class="keyword">const</span> result = emptyArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：数组的reduce有什么用法"><a href="#Q4：数组的reduce有什么用法" class="headerlink" title="Q4：数组的reduce有什么用法"></a>Q4：数组的reduce有什么用法</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>reduce</code> 是数组方法之一，用于迭代数组的每个元素，并将它们汇总为单个值。下面列举了一些 <code>reduce</code> 方法的常见用途：</p><ol><li><p><strong>累加（Summation）：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>累积（Product）：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> product = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator * currentValue, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(product); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最大值：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> max = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(accumulator, currentValue));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查找最小值：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> min = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(accumulator, currentValue));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>拼接字符串：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;World&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> sentence = words.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sentence); <span class="comment">// &#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>统计元素出现次数：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> countByFruit = fruits.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[currentValue] = (accumulator[currentValue] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countByFruit); <span class="comment">// &#123; apple: 3, orange: 2, banana: 1 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扁平化数组：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nestedArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="keyword">const</span> flattenedArray = nestedArray.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.<span class="title function_">concat</span>(currentValue), []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flattenedArray); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将对象数组转换为对象：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> peopleMap = people.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, person</span>) =&gt;</span> &#123;</span><br><span class="line">  accumulator[person.<span class="property">id</span>] = person.<span class="property">name</span>;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(peopleMap); <span class="comment">// &#123; 1: &#x27;Alice&#x27;, 2: &#x27;Bob&#x27;, 3: &#x27;Charlie&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>这些只是 <code>reduce</code> 方法的一些用途，它的强大之处在于其灵活性，可以根据具体需求执行各种汇总操作</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：arguments-这种类数组，如何遍历类数组"><a href="#Q5：arguments-这种类数组，如何遍历类数组" class="headerlink" title="Q5：arguments 这种类数组，如何遍历类数组?"></a>Q5：arguments 这种类数组，如何遍历类数组?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，类数组是类似数组的对象，它们通常具有数字索引和 length 属性，但不具有数组原型链上的方法（例如 forEach、map 等）。在遍历类数组时，可以使用多种方法：</p><ol><li><p><strong>for 循环</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 对 arguments 中的每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Array.prototype.forEach()</strong>（需要将类数组转换为真正的数组）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>转换为真正的数组后使用其他数组方法</strong>（例如 map、filter 等）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> argsArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">argsArray.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 ES6 中的扩展运算符</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="variable language_">arguments</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="comment">// 对每个元素执行操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Javscript数组的常用方法有哪些"><a href="#Q6：Javscript数组的常用方法有哪些" class="headerlink" title="Q6：Javscript数组的常用方法有哪些?"></a>Q6：Javscript数组的常用方法有哪些?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>push()</strong>：向数组末尾添加一个或多个元素，并返回修改后的数组的长度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 返回值为 4，arr 变为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>pop()</strong>：移除数组末尾的元素，并返回移除的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> removedElement = arr.<span class="title function_">pop</span>(); <span class="comment">// 返回值为 3，arr 变为 [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shift()</strong>：移除数组的第一个元素，并返回移除的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> removedElement = arr.<span class="title function_">shift</span>(); <span class="comment">// 返回值为 1，arr 变为 [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>unshift()</strong>：向数组的开头添加一个或多个元素，并返回修改后的数组的长度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">1</span>); <span class="comment">// 返回值为 3，arr 变为 [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>concat()</strong>：将两个或多个数组合并成一个新数组，不修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// newArr 变为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>slice()</strong>：从数组中提取出指定范围的元素，返回一个新数组，不修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slicedArr = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// slicedArr 变为 [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>splice()</strong>：从数组中添加、移除或替换元素，会修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> removedElements = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 返回值为 [2, 3]，arr 变为 [1, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>forEach()</strong>：对数组的每个元素执行指定的操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item)); <span class="comment">// 依次输出 1、2、3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>map()</strong>：对数组的每个元素执行指定的操作，并返回操作后的结果组成的新数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>); <span class="comment">// newArr 变为 [2, 4, 6]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>filter()</strong>：筛选数组中满足条件的元素，并返回满足条件的元素组成的新数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> filteredArr = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// filteredArr 变为 [2, 4]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reduce()</strong>：对数组中的所有元素执行指定的累加操作，返回累加结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>); <span class="comment">// sum 变为 15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>every()</strong>：检测数组中的所有元素是否都满足指定条件，如果所有元素都满足条件，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> allEven = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>some()</strong>：检测数组中是否有至少一个元素满足指定条件，如果有至少一个元素满足条件，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> hasEven = arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>find()</strong>：查找数组中第一个满足指定条件的元素，并返回该元素；如果未找到满足条件的元素，则返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> found = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">3</span>); <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure></li><li><p><strong>findIndex()</strong>：查找数组中第一个满足指定条件的元素的索引，并返回该索引；如果未找到满足条件的元素，则返回 <code>-1</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> foundIndex = arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">3</span>); <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>includes()</strong>：检测数组是否包含指定元素，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> hasElement = arr.<span class="title function_">includes</span>(<span class="number">3</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reverse()</strong>：颠倒数组中元素的顺序，原地修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>(); <span class="comment">// arr 变为 [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>sort()</strong>：对数组元素进行排序，默认按照字母顺序进行排序，原地修改原始数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(); <span class="comment">// arr 变为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>join()</strong>：将数组中所有元素以指定的分隔符连接成一个字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 返回 &#x27;a-b-c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>toString()</strong>：将数组转换为字符串，效果与 <code>join()</code> 方法一样，默认使用逗号 <code>,</code> 连接元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">toString</span>(); <span class="comment">// 返回 &#x27;a,b,c&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="Q1：js的函数声明有几种方式？有什么区别？"><a href="#Q1：js的函数声明有几种方式？有什么区别？" class="headerlink" title="Q1：js的函数声明有几种方式？有什么区别？"></a>Q1：js的函数声明有几种方式？有什么区别？</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，函数声明有三种主要方式：函数声明（Function Declaration）、函数表达式（Function Expression）、箭头函数（Arrow Function）。它们之间的区别主要体现在语法和行为上。</p><ol><li><p><strong>函数声明（Function Declaration）</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>在代码执行前进行预解析（hoisting），可以在声明之前调用。</li><li>函数名是必须的，函数名会被添加到当前作用域（通常是全局作用域或函数作用域）。</li><li>可以直接调用，不需要赋值给变量。</li></ul></li></ul></li><li><p><strong>函数表达式（Function Expression）</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>在代码执行到赋值语句时创建函数，因此不能在定义之前调用。</li><li>函数名是可选的，可以省略，这种情况下函数被称为匿名函数。</li><li>赋值给变量或作为参数传递给其他函数。</li></ul></li></ul></li><li><p><strong>箭头函数（Arrow Function）</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">functionName</span> = (<span class="params">parameters</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>特点：<ul><li>箭头函数是ES6新增的一种函数定义方式，语法更简洁。</li><li>不绑定this，会捕获所在上下文的this值。</li><li>不能用作构造函数，不具备自己的this，不能使用arguments对象。</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：对“立即执行函数”的理解"><a href="#Q2：对“立即执行函数”的理解" class="headerlink" title="Q2：对“立即执行函数”的理解"></a>Q2：对“立即执行函数”的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>立即执行函数（Immediately Invoked Function Expression，IIFE）是一种在定义后立即执行的 JavaScript 函数。它的语法形式是将函数声明或函数表达式包裹在圆括号中，然后紧接着使用另一对圆括号来立即调用这个函数。</p><p>下面是一个典型的立即执行函数的示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="keyword">function</span> (<span class="params">test</span>) &#123;    <span class="comment">//使用!运算符,输出123</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line">&#125;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>这个函数在声明后立即被调用执行。()，！，+，-，=等运算符都能起到立即执行的作用</p><p>立即执行函数的主要特点和用途包括：</p><ol><li><strong>作用域隔离</strong>：立即执行函数可以创建一个独立的作用域，其中的变量不会污染到全局作用域，避免了变量命名冲突。</li><li><strong>模块化开发</strong>：通过立即执行函数，可以创建模块化的代码结构，将代码封装在独立的作用域中，提高了代码的可维护性和可重用性。</li><li><strong>防止变量提升</strong>：立即执行函数中的变量会在函数执行完毕后被销毁，不会污染全局作用域，避免了变量提升可能带来的问题。</li><li><strong>封装变量</strong>：可以将一些私有的变量或函数封装在立即执行函数中，只暴露需要暴露的接口，隐藏实现细节，增强了代码的安全性。</li><li><strong>初始化代码</strong>：立即执行函数常被用于执行一些初始化代码，确保代码在加载后立即执行。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：new-fn与new-fn（）有什么区别吗"><a href="#Q3：new-fn与new-fn（）有什么区别吗" class="headerlink" title="Q3：new fn与new fn（）有什么区别吗?"></a>Q3：new fn与new fn（）有什么区别吗?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>new fn</code> 和 <code>new fn()</code> 看起来很相似，但实际上它们之间有重要的区别：</p><ol><li><strong>new fn</strong>： 这种写法是在调用构造函数 <code>fn</code> 时省略了括号。它会创建一个新的对象，并将构造函数的作用域绑定到这个新对象上，但不传递任何参数给构造函数。因此，如果构造函数 <code>fn</code> 没有参数，那么这两种写法会得到相同的结果。</li><li><strong>new fn()</strong>： 这是标准的构造函数调用语法，它会创建一个新的对象，并将构造函数的作用域绑定到这个新对象上，并传递括号内的参数给构造函数。即使构造函数不需要参数，也必须使用括号。</li></ol><p>因此，主要区别在于是否传递参数给构造函数。如果构造函数需要参数，则必须使用 <code>new fn()</code>，而如果构造函数不需要参数，则可以使用 <code>new fn</code>，两者效果是一样的。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：ES6中函数新增了哪些扩展"><a href="#Q4：ES6中函数新增了哪些扩展" class="headerlink" title="Q4：ES6中函数新增了哪些扩展?"></a>Q4：ES6中函数新增了哪些扩展?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>箭头函数（Arrow Functions）</strong>：<ul><li>箭头函数是一种更简洁的函数定义语法，使用箭头（<code>=&gt;</code>）来定义函数。</li><li>箭头函数没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code> 或 <code>new.target</code>，它们会从父作用域中继承这些值。</li><li>示例：<code>(param1, param2) =&gt; expression</code></li></ul></li><li><strong>默认参数（Default Parameters）</strong>：<ul><li>可以为函数参数设置默认值，如果调用函数时未传递参数，则使用默认值。</li><li>示例：<code>function func(param1 = defaultValue) { }</code></li></ul></li><li><strong>剩余参数（Rest Parameters）</strong>：<ul><li>使用剩余参数语法（<code>...args</code>）来捕获函数中的剩余参数，将它们放入一个数组中。</li><li>示例：<code>function func(param1, ...args) { }</code></li></ul></li><li><strong>扩展运算符（Spread Operator）</strong>：<ul><li>使用扩展运算符（<code>...</code>）可以将数组展开为独立的参数。</li><li>示例：<code>function func(param1, param2, ...restParams) { }</code></li></ul></li><li><strong>函数的扩展方法</strong>：<ul><li><code>Function.prototype.bind()</code> 方法现在支持在箭头函数上调用，可以创建绑定了指定 <code>this</code> 的箭头函数。</li><li><code>Function.prototype.toString()</code> 方法现在返回函数原始代码，包括 ES6 中新增的箭头函数和方法简写。</li></ul></li><li><strong>模板字符串（Template Strings）</strong>：<ul><li>模板字符串是一种新的字符串语法，使用反引号（``）来定义字符串，并支持嵌入表达式和多行字符串。</li><li>示例：<code>Hello, ${name}!</code></li></ul></li><li><strong>函数参数的解构赋值</strong>：<ul><li>可以在函数参数中使用解构赋值语法，将传入的对象或数组解构为单独的变量。</li><li>示例：<code>function func({param1, param2}) { }</code></li></ul></li><li><strong><code>arguments</code> 对象的限制</strong>：<ul><li>在箭头函数中，<code>arguments</code> 对象会继承自父作用域，而不是创建一个独立的 <code>arguments</code> 对象。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：什么是尾调用优化和尾递归"><a href="#Q5：什么是尾调用优化和尾递归" class="headerlink" title="Q5：什么是尾调用优化和尾递归"></a>Q5：什么是尾调用优化和尾递归</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>尾调用</p><p>尾调用准确来说，是在一个函数的最后一部操作是另外一个函数的调用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">funcA</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">funcB</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 funcA 中，最后一步操作是调用 funcB，所以这就是一个尾调用</p></li><li><p>尾调用优化 (Tail Call Optimization)</p><p>在函数调用时，为了回到函数调用位置，及恢复所需环境，操作系统会在调用栈中维护所谓的“调用记录”或“帧”，这会占用一些内存</p><p>对于一般的函数调用，新的函数调用需要维护一个新的帧，因此如果有大量的函数调用（例如在深度递归中），这个帧的堆栈可能会非常大，占用很多内存空间，甚至可能导致“栈溢出”</p><p>然而对于尾调用来说，由于它是函数的最后一个操作，所以没有必要保留当前的帧</p><p>尾调用优化就是利用这个性质来节约内存的一种技术</p><p>在支持尾调用优化的环境中，如果一个函数的最后一步是尾调用，则解释器或编译器不会创建新的帧，而是复用当前的帧</p></li><li><p>尾递归</p><p>尾递归是特殊的尾调用，它指的在函数的最后一步调用了函数自身</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 factorial 函数这个例子中，我们实现了一个用于计算阶乘的尾递归函数</p><p>在这个函数中，每次函数调用自身（也就是进行递归）的时候，都是在函数的最后一步，所以它就是个尾递归</p><p>而且由于我们把 total 参数传递给下一次调用，使得下一次递归有了起始值，这样就能确保递归在结束条件满足时能立即得到结果</p><p>这样的方法在编程中被称为累积传递风格（Accumulate Passing Style，简称APS），经常被用于实现尾递归</p></li></ol><p>在支持尾调用优化的环境中，尾递归函数不会因为递归深度过大而导致栈溢出或者内存消耗过大，它的性能和循环差不多</p><p>不过需要注意的是，目前并不是所有的 JavaScript 环境都支持尾调用优化</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong>尾调用优化如何帮助减少内存占用？</strong></p><p>尾调用优化（Tail Call Optimization，TCO）帮助减少内存占用的方式与其工作原理紧密相关</p><p>一般来说，每当一个函数调用另一个函数时，计算机需要在内存中保留一些信息，如函数在哪里被调用的，该函数的参数，还有局部变量等等。这种信息记录被称为”栈帧”(stack frame)</p><p>如果有一个函数在其函数体最后的语句中调用了另一个函数（不管是相同的函数还是不同的函数），这样的调用被称为”尾调用”。由于尾调用是函数的最后一步操作，函数的栈帧已经可以被废弃，因为我们已经没有其他的操作需要使用这个栈帧了</p><p>在不进行尾调用优化的情况下，对每一个函数调用，系统都会为其创建一个新的栈帧，即使是尾调用。然而在开启尾调用优化的环境中，如果发生尾调用，不会创建新的栈帧，而是清除当前的栈帧并复用，因为我们知道老的栈帧已经不再需要了</p><p>这样就实现了内存的优化，即使在大量的递归调用中，也仅需要维护一个栈帧，极大地优化了内存占用，因此就避免了内存溢出或者栈溢出的问题</p></li><li><p><strong>为什么目前并不是所有的 JavaScript 环境都支持尾调用优化</strong></p><ol><li><strong>技术挑战</strong>：在 JavaScript 引擎中实现 TCO 要处理诸多技术问题和挑战。由于 JavaScript 的动态特性，很多情况下很难判断是否可以安全地进行尾调用优化。引擎必须确保优化不会对代码的预期行为产生副作用。</li><li><strong>性能考量</strong>：虽然 TCO 在理论上能节省内存，并防止栈溢出的问题，但在实践中，并不是所有应用场景都能体现这种优化的效果。尤其是在目前大多数的 web 应用中，深层次的递归调用并不常见，因此浏览器厂商可能认为投入资源来实现这一特性的优先级不高。</li><li><strong>规范更迭</strong>：Javascript 的规范在不断发展和更迭之中，一些特性可能在接下来的版本中被调整或替换。一部分实现者可能在等待规范的稳定，从而避免在未来需要重做相关的实现。</li><li><strong>向后兼容性</strong>：引入 TCO 可能会影响到现有代码的功能，特别是那些依赖于栈追踪信息的代码，因此，实现 TCO 需要仔细考虑如何与旧代码兼容。</li><li><strong>优先级与资源分配</strong>：浏览器和 JavaScript 环境的开发者可能有其他更紧急或更重要的优先级，这决定了他们如何分配时间和资源来实现语言规范的各个部分。</li></ol></li></ul>
              </div>
            </details>
<p><br/></p>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h3 id="Q1：以下等式是成立的吗？1-000-000-1000000"><a href="#Q1：以下等式是成立的吗？1-000-000-1000000" class="headerlink" title="Q1：以下等式是成立的吗？1_000_000 === 1000000"></a>Q1：以下等式是成立的吗？1_000_000 === 1000000</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，下划线（<code>_</code>）在数字中的使用是为了提高数字的可读性，而不影响其值。这种表示法通常用于表示较大的数字，以便更容易阅读和理解数字的大小。</p><p>在你的例子中，<code>1_000_000</code> 和 <code>1000000</code> 实际上表示相同的数值，因为下划线在JavaScript中被视为一个合法的数字分隔符，但在计算时会被忽略。这就意味着，无论你是用下划线分隔还是没有下划线，这两个表示法都代表相同的数字1,000,000。</p><p>这种语法的引入是为了方便阅读和书写较大的数字，而不改变其实际值。这样的可读性改进对于理解代码或数据中的大数字是很有帮助的。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>true</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：空值合并运算符是什么？有什么使用场景"><a href="#Q2：空值合并运算符是什么？有什么使用场景" class="headerlink" title="Q2：空值合并运算符是什么？有什么使用场景"></a>Q2：空值合并运算符是什么？有什么使用场景</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>空值合并运算符（nullish coalescing operator），通常表示为 <code>??</code>，是 JavaScript 的一个逻辑运算符。它提供了一种简洁的方式来处理值为 <code>null</code> 或 <code>undefined</code> 时的默认值设置。</p><p>语法形式为：<code>a ?? b</code>，它的行为是：如果 <code>a</code> 是 <code>null</code> 或 <code>undefined</code>，则返回 <code>b</code>，否则返回 <code>a</code>。</p><p>下面是一些示例说明空值合并运算符的使用场景：</p><p><strong>设置默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  name: &#x27;Alice&#x27;,</span><br><span class="line">  age: null,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userName = user.name ?? &#x27;Guest&#x27;;</span><br><span class="line">const userAge = user.age ?? 18;</span><br><span class="line"></span><br><span class="line">console.log(userName); // &#x27;Alice&#x27;</span><br><span class="line">console.log(userAge);   // 18</span><br></pre></td></tr></table></figure><p><strong>防止使用空值运算符时，<code>0</code> 或 <code>&#39;&#39;</code> 被认为是空值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const height = 0;</span><br><span class="line">const minHeight = height || 100; // 如果 height 为 falsy（0），则使用默认值 100</span><br><span class="line"></span><br><span class="line">console.log(minHeight); // 100</span><br><span class="line"></span><br><span class="line">const minHeightWithNullish = height ?? 100; // 只有在 height 为 null 或 undefined 时才使用默认值 100</span><br><span class="line"></span><br><span class="line">console.log(minHeightWithNullish); // 0</span><br></pre></td></tr></table></figure><p><strong>避免未定义属性引发错误</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  server: &#123;</span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    port: null,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const serverPort = config.server.port ?? 3000;</span><br><span class="line"></span><br><span class="line">console.log(serverPort); // 3000</span><br></pre></td></tr></table></figure><p>在上述示例中，如果 <code>config.server.port</code> 为 <code>null</code>，使用空值合并运算符可以安全地提供一个默认值，而不引发错误。</p><p>空值合并运算符与传统的逻辑运算符 <code>||</code> 相比，更明确地处理只有在值为 <code>null</code> 或 <code>undefined</code> 时才提供默认值的情况。这使得代码更容易理解，避免了一些潜在的意外行为</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：请简述-的机制"><a href="#Q3：请简述-的机制" class="headerlink" title="Q3：请简述 == 的机制"></a>Q3：请简述 == 的机制</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>==</code> 是 JavaScript 中的相等运算符，用于比较两个值是否相等。它的比较规则如下：</p><ol><li><strong>类型转换</strong>：<ul><li>如果比较的两个操作数类型相同，则直接进行值的比较。</li><li>如果比较的两个操作数类型不同，则 JavaScript 会尝试将它们转换为相同的类型再进行比较。</li></ul></li><li><strong>转换规则</strong>：<ul><li>如果一个操作数是布尔值，则将其转换为数值进行比较。<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>。</li><li>如果一个操作数是字符串，另一个是数字，则将字符串转换为数字再进行比较。</li><li>如果一个操作数是对象，另一个不是，则将对象转换为原始值（通过 <code>valueOf()</code> 和 <code>toString()</code> 方法），然后再进行比较。</li><li>如果一个操作数是 <code>null</code>，另一个是 <code>undefined</code>，则它们被认为是相等的。</li><li>如果一个操作数是 <code>NaN</code>，则它与任何其他值（包括自身）都不相等。</li></ul></li><li><strong>特殊情况</strong>：<ul><li>当比较的操作数是 <code>null</code> 或 <code>undefined</code> 时，它们相等。但如果其中一个是 <code>NaN</code>，则它们不相等。</li><li>如果其中一个操作数是对象，另一个是原始值（字符串、数字、布尔值），则将对象转换为原始值再进行比较。</li></ul></li><li><strong>注意事项</strong>：<ul><li>由于 <code>==</code> 运算符进行类型转换，因此可能会导致一些意想不到的结果。为了避免这种情况，通常应该优先使用严格相等运算符 <code>===</code>，它要求操作数的值和类型都相等才返回 <code>true</code>。</li><li>在条件语句中，使用 <code>==</code> 比较时要格外小心，确保理解其转换规则并且符合预期的结果。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：-和-有什么区别，分别在什么情况使用"><a href="#Q4：-和-有什么区别，分别在什么情况使用" class="headerlink" title="Q4：==和 ===有什么区别，分别在什么情况使用?"></a>Q4：==和 ===有什么区别，分别在什么情况使用?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>==</code> 和 <code>===</code> 都是 JavaScript 中的比较运算符，用于比较两个值是否相等，它们之间的区别如下：</p><ol><li><strong><code>==</code>（相等运算符）</strong>：<ul><li>使用 <code>==</code> 进行比较时，如果两个操作数的类型不同，会先进行类型转换，然后再比较值是否相等。</li><li>如果操作数的类型不同，则会尝试将它们转换为相同的类型，再进行比较。</li><li>如果操作数之一是对象，则比较它们是否引用了相同的对象，而不是对象的内容。</li><li>示例：<code>0 == &#39;0&#39;</code> 返回 <code>true</code>，因为 <code>&#39;0&#39;</code> 被转换为数字 <code>0</code> 进行比较。</li></ul></li><li><strong><code>===</code>（严格相等运算符）</strong>：<ul><li>使用 <code>===</code> 进行比较时，不会进行类型转换，而是严格比较两个操作数的值和类型是否完全相等。</li><li>只有在操作数的值和类型完全相等时，才会返回 <code>true</code>；否则返回 <code>false</code>。</li><li>示例：<code>0 === &#39;0&#39;</code> 返回 <code>false</code>，因为它们的类型不同。</li></ul></li></ol><p><strong>使用情况</strong>：</p><ul><li>通常情况下，推荐使用 <code>===</code> 进行严格相等比较，因为它不会进行隐式类型转换，更加安全和准确。</li><li>当需要忽略类型的差异时，或者需要进行隐式类型转换时，可以使用 <code>==</code> 进行相等比较，但需要注意可能会产生的意外结果。</li><li>在开发过程中，应根据具体的需求和情况选择合适的比较运算符。如果不确定应该使用哪个运算符，最好使用 <code>===</code> 进行严格相等比较</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：如果new一个箭头函数会怎么样"><a href="#Q5：如果new一个箭头函数会怎么样" class="headerlink" title="Q5：如果new一个箭头函数会怎么样"></a>Q5：如果new一个箭头函数会怎么样</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>如果你尝试用<code>new</code>操作符去实例化一个箭头函数，会抛出一个错误</p><p>这是因为箭头函数并没有自己的<code>this</code>，它们不绑定自己的<code>this</code>值，在箭头函数中的<code>this</code>实际上是继承自外围上下文</p><p>因此，箭头函数不能被用作构造函数</p><p>例如，以下代码将会抛出一个错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ArrowFunction</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">ArrowFunction</span>(); <span class="comment">// 错误 - ArrowFunction is not a constructor</span></span><br></pre></td></tr></table></figure><p>当你运行上述代码时，JavaScript将会抛出一个TypeError，指出ArrowFunction不是一个构造函数</p><p>这是因为你无法用<code>new</code>关键字来实例化一个箭头函数</p><p>因此，如果你想要创建一个可以使用<code>new</code>操作符的函数，你应该使用传统的函数声明或者函数表达式，不要使用箭头函数</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>new一个函数的时候，new操作符做了什么操作</strong></p><p>使用<code>new</code>操作符创建一个函数的实例时，它执行了几个步骤来构建和返回一个新对象。以下是详细的步骤：</p><ol><li><p><strong>创建空对象</strong></p><p><code>new</code>操作符首先创建一个空的JavaScript对象<code>{}</code></p></li><li><p><strong>设置原型</strong></p><p>新创建的对象的<code>__proto__</code>会被链接到构造函数的<code>prototype</code>对象，让新创建的对象可以访问构造函数原型链上的属性和方法</p></li><li><p><strong>绑定<code>this</code></strong></p><p>在构造函数中，<code>this</code>被改变并指向了新创建的对象</p><p>因此，在构造函数内部，我们可以使用<code>this</code>来引用和初始化新对象的属性</p></li><li><p><strong>运行构造函数中的代码</strong>（包括它定义的属性和方法）</p><p>这将定义新对象的属性和方法</p></li><li><p><strong>返回新对象</strong></p><p>如果构造函数没有显示地返回一个对象，那么<code>new</code>操作符将自动返回新创建的对象</p><p>需要注意的是，如果构造函数返回非空对象（Object或者Array）则<code>new</code>操作符返回的是这个对象，而不是新创建的对象</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：Object-is（）与比较操作符“-”、“-”的区别"><a href="#Q6：Object-is（）与比较操作符“-”、“-”的区别" class="headerlink" title="Q6：Object.is（）与比较操作符“===”、“==”的区别"></a>Q6：Object.is（）与比较操作符“===”、“==”的区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><code>Object.is()</code><ul><li><code>Object.is()</code>用于判断两个值是否为相同的值</li><li>它与<code>===</code>非常相似，但在两个特殊情况下有所不同：<ul><li>对于<code>NaN</code>，<code>Object.is(NaN, NaN)</code>返回<code>true</code>（而<code>NaN === NaN</code>返回<code>false</code>）</li><li>对于<code>+0</code>和<code>-0</code>，<code>Object.is(+0, -0)</code>返回<code>false</code>（而<code>+0 === -0</code>返回<code>true</code>）</li></ul></li></ul></li><li><code>===</code>（严格等于）<ul><li><code>===</code>不会进行类型转换，如果两个值的类型不同，它直接返回<code>false</code></li><li>对于大多数值，<code>===</code>的行为和<code>Object.is()</code>一样</li><li>除了上面提到的两个特殊情况，也就是<code>NaN</code>不等于自身，以及认为<code>+0</code>和<code>-0</code>是相等的</li></ul></li><li><code>==</code>（抽象等于）<ul><li><code>==</code>在比较前会进行类型转换，尝试将两个值转换为相同类型，然后再进行值的比较</li><li>由于涉及到类型转换，使用<code>==</code>时可能出现一些非直观的结果，尤其是当比较不同类型的值时</li><li>举个例子，<code>&#39;2&#39; == 2</code>会返回<code>true</code>，因为字符串<code>&#39;2&#39;</code>会被转换为数字<code>2</code></li></ul></li></ol><p>在编写代码时，推荐使用<code>===</code>来避免意外的类型转换，从而使代码的行为更加可预测</p><p><code>Object.is()</code>在需要区分<code>+0</code>和<code>-0</code>，或者判断<code>NaN</code>的相等性时很有用</p><p>而<code>==</code>由于其类型转换的特性，一般不推荐使用，除非明确需要这种行为</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：0-1-0-2为什么不等于0-3"><a href="#Q7：0-1-0-2为什么不等于0-3" class="headerlink" title="Q7：0.1+0.2为什么不等于0.3"></a>Q7：0.1+0.2为什么不等于0.3</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>0.1 + 0.2</code> 不等于 <code>0.3</code> 是浮点数精度问题的一个典型示例，这个问题存在于很多编程语言中，不仅仅是JavaScript。原因在于这些语言通常遵循IEEE 754标准来表示浮点数。</p><ol><li><p>浮点数和精度</p><p>在这个标准中，数字是以二进制格式存储的</p><p>整数可以精确地表示为二进制数，但很多分数在二进制中是无限循环小数</p><p>比如，<code>1/10</code> 和 <code>1/5</code> 在二进制中不能精确表示</p><p>在十进制中：</p><ul><li><code>1/10</code> 等于 `0.1``</li><li><code>`1/5</code> 等于 <code>0.2</code></li></ul><p>但在二进制中，它们是无限循环小数：</p><ul><li><code>1/10</code> 的二进制形式近似为 `0.0001100110011001100110011001100…``</li><li><code>`1/5</code> 的二进制形式近似为 <code>0.00110011001100110011001100110011...</code></li></ul><p>由于计算机存储容量是有限的，这些小数点后无限循环的二进制数必须在某处切断，这意味着它们是近似值，而不是精确值</p></li><li><p>精确性问题</p><p>当执行 <code>0.1 + 0.2</code> 这样的操作时，二进制中的近似值相加会产生一个比实际 <code>0.3</code> 略微不同的结果</p><p>在十进制中，这个结果经常是 <code>0.30000000000000004</code>，而不是我们期望的 <code>0.3</code></p></li><li><p>如何解决</p><p>为了应对这个问题，在处理金融或精度重要的数学计算时，采取特别的策略：</p><ul><li><p>四舍五入</p><p> JavaScript 提供了内置的 <code>toFixed</code> 方法，可以把浮点数四舍五入到指定的小数位</p><p>比如，<code>(0.1 + 0.2).toFixed(1)</code> 将返回字符串 “0.3”</p></li><li><p>使用整数进行计算</p><p>如果我们知道我们正在处理的小数点后的位数，我们可以把浮点数转换为整数，进行整数运算，然后再转回浮点数</p><p>比如，把 <code>0.1</code> 和 <code>0.2</code> 乘以10得到 <code>1</code> 和 <code>2</code>，然后相加得到 <code>3</code>，再除以10得到 <code>0.3</code></p></li><li><p>使用第三方库</p><p>有许多JavaScript库，比如 decimal.js、bignumber.js 或者 math.js，这些库提供了更精确的计算，可以解决浮点数精度的问题</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h3 id="Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？"><a href="#Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？" class="headerlink" title="Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？"></a>Q1：ES6中新增的Set跟Map两种数据结构该怎么理解？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>ES6 中新增的 Set 和 Map 是两种不同的数据结构，分别用于存储一组唯一的值和键值对。下面分别对 Set 和 Map 进行简要的理解：</p><p><strong>Set（集合）</strong></p><ol><li><strong>唯一性</strong>：<ul><li>Set 中的元素是唯一的，不能重复。</li><li>如果试图向 Set 中添加重复的元素，它会被忽略。</li></ul></li><li><strong>元素的顺序</strong>：<ul><li>Set 中的元素按照插入的顺序排列，不会像对象那样根据键排序。</li></ul></li><li><strong>API 方法</strong>：<ul><li><code>add(value)</code>：向 Set 中添加元素。</li><li><code>delete(value)</code>：删除 Set 中的指定元素。</li><li><code>has(value)</code>：检查 Set 中是否包含某个元素。</li><li><code>clear()</code>：清空 Set 中的所有元素。</li></ul></li><li><strong>应用场景</strong>：<ul><li>用于存储一组唯一的值，比如去重。</li></ul></li></ol><p><strong>Map（映射）</strong></p><ol><li><strong>键值对</strong>：<ul><li>Map 中存储的是键值对，其中键可以是任意数据类型。</li></ul></li><li><strong>键的唯一性</strong>：<ul><li>Map 中的键是唯一的，每个键只能对应一个值。</li></ul></li><li><strong>元素的顺序</strong>：<ul><li>Map 中的元素按照插入的顺序排列，与 Set 类似，不会根据键的顺序排序。</li></ul></li><li><strong>API 方法</strong>：<ul><li><code>set(key, value)</code>：向 Map 中添加键值对。</li><li><code>get(key)</code>：获取 Map 中指定键的值。</li><li><code>delete(key)</code>：删除 Map 中指定键的键值对。</li><li><code>has(key)</code>：检查 Map 中是否包含某个键。</li><li><code>clear()</code>：清空 Map 中的所有键值对。</li></ul></li><li><strong>应用场景</strong>：<ul><li>用于存储键值对，提供更灵活的数据结构，例如保存对象的属性和值。</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li>Set 适合存储一组唯一的值，不关心键值对的情况。</li><li>Map 适合存储键值对，每个键对应一个值。</li><li>它们都提供了高效的查找和删除操作，适用于各种场景，提供了更丰富的 API 方法。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：Math-ceil跟Meth-floor有什么区别"><a href="#Q2：Math-ceil跟Meth-floor有什么区别" class="headerlink" title="Q2：Math.ceil跟Meth.floor有什么区别"></a>Q2：Math.ceil跟Meth.floor有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Math.ceil</code> 和 <code>Math.floor</code> 是 JavaScript 中用于处理数字的 Math 对象的两个方法，它们分别用于向上取整和向下取整。</p><ol><li><p><strong><code>Math.ceil(x)</code>：</strong></p><ul><li><code>Math.ceil</code> 方法返回大于或等于传入数字 <code>x</code> 的最小整数。</li><li>例如，<code>Math.ceil(4.3)</code> 返回 <code>5</code>，因为 <code>5</code> 是大于 <code>4.3</code> 的最小整数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultCeil = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">4.3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultCeil); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.floor(x)</code>：</strong></p><ul><li><code>Math.floor</code> 方法返回小于或等于传入数字 <code>x</code> 的最大整数。</li><li>例如，<code>Math.floor(4.9)</code> 返回 <code>4</code>，因为 <code>4</code> 是小于或等于 <code>4.9</code> 的最大整数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultFloor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">4.9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultFloor); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ul><li><p><strong><code>Math.abs(x)</code>：</strong> 返回给定数字 <code>x</code> 的绝对值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> absoluteValue = <span class="title class_">Math</span>.<span class="title function_">abs</span>(-<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(absoluteValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.round(x)</code>：</strong> 返回给定数字 <code>x</code> 的四舍五入值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> roundedValue = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">4.6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(roundedValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.max(x, y, ...)</code>：</strong> 返回传入的一组数字中的最大值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> maxValue = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxValue); <span class="comment">// 输出 12</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.min(x, y, ...)</code>：</strong> 返回传入的一组数字中的最小值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> minValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(minValue); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>Math.sqrt(x)</code>：</strong> 返回给定数字 <code>x</code> 的平方根。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> squareRoot = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="number">25</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(squareRoot); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：document-write和innerHTML有什么区别"><a href="#Q3：document-write和innerHTML有什么区别" class="headerlink" title="Q3：document.write和innerHTML有什么区别"></a>Q3：document.write和innerHTML有什么区别</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong><code>document.write</code>：</strong></p><ul><li><code>document.write</code> 是 <code>Document</code> 对象的方法，可以直接在文档中写入字符串。</li><li>它通常用于在页面加载过程中动态生成内容，但不太推荐在页面加载后使用，因为它会覆盖整个文档。</li><li>如果在文档已加载后使用 <code>document.write</code>，它将重写整个文档，可能导致文档结构被破坏。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello, World!&lt;/p&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>innerHTML</code>：</strong></p><ul><li><code>innerHTML</code> 是 <code>Element</code> 对象的属性，允许你获取或设置元素的 HTML 内容。</li><li>它更适用于在已存在的元素中动态插入或更新内容。</li><li>使用 <code>innerHTML</code> 时，你只需操作需要更新的元素，而不会影响文档的其他部分。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素的 HTML 内容</span></span><br><span class="line"><span class="keyword">const</span> elementContent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>).<span class="property">innerHTML</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置元素的 HTML 内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;exampleElement&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;p&gt;New content&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>主要区别：</strong></p><ul><li><code>document.write</code> 是一个全局方法，它直接操作整个文档，可能导致文档结构被覆盖，而且在文档加载后使用时存在一些问题。</li><li><code>innerHTML</code> 是元素的属性，更适用于操作元素的 HTML 内容，且更安全可控。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：Math-max跟Math-min怎么用于数组里面取最值"><a href="#Q4：Math-max跟Math-min怎么用于数组里面取最值" class="headerlink" title="Q4：Math.max跟Math.min怎么用于数组里面取最值"></a>Q4：Math.max跟Math.min怎么用于数组里面取最值</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Math.max</code> 和 <code>Math.min</code> 分别用于获取数组中的最大值和最小值。这两个方法可以结合使用 <code>apply</code> 或扩展运算符 <code>...</code> 来处理数组。以下是使用示例：</p><p><strong>使用 <code>apply</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [2, 5, 1, 8, 3];</span><br><span class="line"></span><br><span class="line">const maxNumber = Math.max.apply(null, numbers);</span><br><span class="line">const minNumber = Math.min.apply(null, numbers);</span><br><span class="line"></span><br><span class="line">console.log(maxNumber); // 输出 8</span><br><span class="line">console.log(minNumber); // 输出 1</span><br></pre></td></tr></table></figure><p><strong>使用扩展运算符 <code>...</code>：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [2, 5, 1, 8, 3];</span><br><span class="line"></span><br><span class="line">const maxNumber = Math.max(...numbers);</span><br><span class="line">const minNumber = Math.min(...numbers);</span><br><span class="line"></span><br><span class="line">console.log(maxNumber); // 输出 8</span><br><span class="line">console.log(minNumber); // 输出 1</span><br></pre></td></tr></table></figure><p>在这两个示例中，<code>Math.max</code> 和 <code>Math.min</code> 都被用于处理数组 <code>numbers</code>，得到了数组中的最大值和最小值。</p><p>请注意，在处理非常大的数组时，可能会遇到 <code>apply</code> 或 <code>...</code> 的参数列表长度限制。在这种情况下，可以采用其他方法，如使用循环或使用 <code>reduce</code> 函数来找到最大值和最小值</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：对requestIdleCallback的理解"><a href="#Q5：对requestIdleCallback的理解" class="headerlink" title="Q5：对requestIdleCallback的理解"></a>Q5：对requestIdleCallback的理解</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>requestIdleCallback</code> 是浏览器提供的一个用于在浏览器空闲时执行任务的 API。它的主要目的是充分利用浏览器的空闲时间，执行一些不紧急但耗时较长的任务，而不影响用户界面的响应性能。</p><p><strong>使用方法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(callback[, options]);</span><br></pre></td></tr></table></figure><ul><li><code>callback</code>: 要在空闲时执行的函数。</li><li><code>options</code> (可选): 一个对象，用于指定调用 <code>callback</code> 的条件，例如 <code>timeout</code> 表示最长等待时间。</li></ul><p><strong>工作原理：</strong></p><ol><li>当浏览器空闲时，会执行注册的回调函数。</li><li>如果回调函数执行时间较长，浏览器会在执行过程中中断它，以确保其他高优先级任务（例如用户交互）的及时响应。</li><li>在下一个空闲周期继续执行未完成的部分。</li></ol><p><strong>适用场景：</strong></p><ul><li><strong>异步操作：</strong> 执行一些不需要立即完成的异步操作，如图片加载、数据请求等。</li><li><strong>性能优化：</strong> 执行一些耗时较长的性能优化任务，如计算复杂布局、懒加载等。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performIdleTask</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> ((deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> || deadline.<span class="property">didTimeout</span>) &amp;&amp; tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> task = tasks.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="title function_">task</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(performIdleTask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTask</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  tasks.<span class="title function_">push</span>(task);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(performIdleTask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">addTask</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task 1&#x27;</span>));</span><br><span class="line"><span class="title function_">addTask</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task 2&#x27;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上述代码创建了一个简单的任务队列，并通过 <code>requestIdleCallback</code> 在浏览器空闲时执行队列中的任务。这可以用于将一些非紧急的任务推迟到浏览器处于空闲状态时执行，以提高性能。</p><p><code>requestIdleCallback</code> 的作用就是将一些非关键性的任务从主线程中分离出来，等到浏览器闲置时再执行。这样就可以避免占用主线程，提高页面的响应速度和流畅度。</p><p>使用 <code>requestIdleCallback</code> 需要传入一个回调函数，该函数会在浏览器空闲时被调用。回调函数的参数是一个 IdleDeadline 对象，它包含有关浏览器还剩余多少时间可供执行任务的信息。根据该对象的时间戳信息，开发人员可以自行决定是否继续执行任务或推迟执行。</p><p><code>requestIdleCallback</code> 可以帮助我们优化 Web 应用程序的性能和响应速度，减少资源的浪费。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：map和和-filter-有什么区别"><a href="#Q6：map和和-filter-有什么区别" class="headerlink" title="Q6：map和和 filter 有什么区别?"></a>Q6：map和和 filter 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>map()</code> 和 <code>filter()</code> 都是 JavaScript 中常用的数组方法，用于对数组进行操作和转换，但它们的作用和使用方式有所不同。</p><p><strong>区别：</strong></p><ol><li><strong>作用</strong>：<ul><li><code>map()</code> 方法用于对数组中的每个元素执行指定的操作，并返回一个新的数组，新数组的每个元素都是原始数组对应位置元素经过操作后的结果。</li><li><code>filter()</code> 方法用于根据指定的条件过滤数组中的元素，并返回一个新的数组，新数组包含满足条件的元素。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>map()</code> 方法返回一个新的数组，包含每个元素经过操作后的结果。</li><li><code>filter()</code> 方法返回一个新的数组，包含满足指定条件的元素。</li></ul></li><li><strong>使用方式</strong>：<ul><li><code>map()</code> 方法接受一个回调函数作为参数，该回调函数会被传入数组中的每个元素和它们的索引，并返回操作后的结果。</li><li><code>filter()</code> 方法接受一个回调函数作为参数，该回调函数会被传入数组中的每个元素和它们的索引，并根据回调函数返回的布尔值来决定是否保留该元素。</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 map() 方法将数组中的每个元素乘以 2</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubledNumbers); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 filter() 方法过滤出数组中的偶数</span></span><br><span class="line"><span class="keyword">const</span> evenNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evenNumbers); <span class="comment">// 输出 [2, 4]</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>map()</code> 方法将数组中的每个元素乘以 2，并返回一个新的数组，而 <code>filter()</code> 方法则过滤出数组中的偶数，并返回一个新的数组。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：map-和-forEach-有什么区别"><a href="#Q7：map-和-forEach-有什么区别" class="headerlink" title="Q7：map 和 forEach 有什么区别?"></a>Q7：map 和 forEach 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>map()</code> 和 <code>forEach()</code> 都是 JavaScript 中用于处理数组的方法，但它们之间有一些重要的区别：</p><ol><li><strong>返回值</strong>：<ul><li><code>map()</code> 方法返回一个新的数组，该数组包含了对原数组中每个元素调用回调函数后的返回值组成的数组。</li><li><code>forEach()</code> 方法没有返回值（或者说返回值为 <code>undefined</code>），它仅用于迭代数组中的每个元素，执行回调函数但不会修改原数组。</li></ul></li><li><strong>使用场景</strong>：<ul><li><code>map()</code> 适合用于需要对数组中的每个元素进行某种转换或映射的场景，例如将每个元素乘以 2、转换为大写等。</li><li><code>forEach()</code> 适合用于需要对数组中的每个元素执行一些操作，但不需要返回新数组的场景，例如打印数组中的元素、向数组中添加新元素等。</li></ul></li><li><strong>对原数组的影响</strong>：<ul><li><code>map()</code> 方法不会修改原数组，它会返回一个新数组。</li><li><code>forEach()</code> 方法也不会修改原数组，但是可以在回调函数中对原数组进行修改，因为它在迭代过程中可以访问原数组的每个元素。</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 map() 方法将数组中的每个元素乘以 2，并返回一个新的数组</span></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> doubledNumbers = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubledNumbers); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 方法打印数组中的每个元素</span></span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(num)); <span class="comment">// 输出每个元素的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 方法向数组中添加新元素</span></span><br><span class="line"><span class="keyword">const</span> newArray = [];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function"><span class="params">num</span> =&gt;</span> newArray.<span class="title function_">push</span>(num * <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>map()</code> 方法将数组中的每个元素乘以 2，并返回一个新的数组，而 <code>forEach()</code> 方法用于打印数组中的每个元素以及向新数组中添加新元素。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：const声明了数组，还能push元素吗，为什么"><a href="#Q8：const声明了数组，还能push元素吗，为什么" class="headerlink" title="Q8：const声明了数组，还能push元素吗，为什么?"></a>Q8：const声明了数组，还能push元素吗，为什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，使用 <code>const</code> 声明的变量不允许重新分配（重新赋值），但是它并不限制对其引用的对象或数组进行修改。因此，虽然你不能给 <code>const</code> 声明的变量重新赋值，但是你可以修改其所引用的对象或数组的内容。</p><p>举例来说，你可以使用 <code>const</code> 声明一个数组，并且在之后调用数组的 <code>push</code> 方法向其中添加新元素。这是因为 <code>const</code> 保护的是变量本身的重新赋值，而不是其引用的对象或数组的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>); <span class="comment">// 可以正常执行，向数组添加了一个新元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>总之，<code>const</code> 保护的是变量的重新赋值，而不是变量所引用的对象或数组的内容，因此在使用 <code>const</code> 声明的数组中，你仍然可以修改数组的内容，包括使用 <code>push</code> 方法向数组中添加新元素。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：Math-ceil-、Math-round-、Math-floor-三者的区别是什么"><a href="#Q9-：Math-ceil-、Math-round-、Math-floor-三者的区别是什么" class="headerlink" title="Q9 ：Math.ceil()、Math.round()、Math.floor()三者的区别是什么?"></a>Q9 ：Math.ceil()、Math.round()、Math.floor()三者的区别是什么?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Math.ceil()</strong>：</p><ul><li><p><code>Math.ceil()</code> 方法返回大于或等于给定数字的最小整数。</p></li><li><p>如果参数是一个整数，则返回该整数。</p></li><li><p>如果参数是一个小数，则返回比它大的最小整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.ceil(5.3); // 输出 6</span><br><span class="line">Math.ceil(-5.3); // 输出 -5</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Math.round()</strong>：</p><ul><li><p><code>Math.round()</code> 方法返回最接近给定数字的整数，四舍五入到最接近的整数。</p></li><li><p>如果参数的小数部分大于或等于 0.5，则返回下一个更大的整数；否则返回前一个更小的整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.round(5.3); // 输出 5</span><br><span class="line">Math.round(5.6); // 输出 6</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Math.floor()</strong>：</p><ul><li><p><code>Math.floor()</code> 方法返回小于或等于给定数字的最大整数。</p></li><li><p>如果参数是一个整数，则返回该整数。</p></li><li><p>如果参数是一个小数，则返回比它小的最大整数。</p></li><li><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.floor(5.3); // 输出 5</span><br><span class="line">Math.floor(-5.3); // 输出 -6</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>总结来说，这三个方法都是用来对数字进行取整操作，但它们的取整规则略有不同。<code>Math.ceil()</code> 总是向上取整到最接近的整数，<code>Math.round()</code> 则是四舍五入到最接近的整数，而 <code>Math.floor()</code> 总是向下取整到最接近的整数。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：toPrecision-和-toFixed-和-Math-round-有什么区别"><a href="#Q10：toPrecision-和-toFixed-和-Math-round-有什么区别" class="headerlink" title="Q10：toPrecision 和 toFixed 和 Math.round 有什么区别?"></a>Q10：toPrecision 和 toFixed 和 Math.round 有什么区别?</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>toPrecision()</code>, <code>toFixed()</code>, 和 <code>Math.round()</code> 是 JavaScript 中用于处理数字的三种不同方法，它们有以下区别：</p><ol><li><strong>toPrecision()</strong>:<ul><li><code>toPrecision()</code> 是一个数字对象的方法，用于将数字转换为指定精度的字符串表示。</li><li>该方法接受一个参数，该参数表示数字的有效位数（包括整数部分和小数部分），并返回一个字符串表示该数字。</li><li>它可以处理较大或较小的数字，并以科学计数法的形式显示。</li><li>例如：<code>var num = 123.456789; num.toPrecision(4); // &quot;123.5&quot;</code></li></ul></li><li><strong>toFixed()</strong>:<ul><li><code>toFixed()</code> 是一个数字对象的方法，用于将数字转换为指定小数位数的字符串表示。</li><li>该方法接受一个参数，表示保留的小数位数，然后返回一个带有指定小数位数的字符串表示。</li><li>它会进行四舍五入并将结果舍入到指定的小数位数。</li><li>例如：<code>var num = 123.456789; num.toFixed(2); // &quot;123.46&quot;</code></li></ul></li><li><strong>Math.round()</strong>:<ul><li><code>Math.round()</code> 是一个全局对象 Math 的方法，用于将数字四舍五入到最接近的整数。</li><li>该方法接受一个数字参数，并返回最接近的整数。</li><li>它不会更改数字的小数部分，而是根据小数部分的值将数字舍入到最接近的整数。</li><li>例如：<code>Math.round(123.456789); // 123</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ul><li><code>toPrecision()</code> 和 <code>toFixed()</code> 都返回字符串，而 <code>Math.round()</code> 返回数字。</li><li><code>toPrecision()</code> 可以控制有效位数，包括小数点前后的位数。</li><li><code>toFixed()</code> 用于固定小数位数。</li><li><code>Math.round()</code> 用于简单的四舍五入到最接近的整数。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：什么是-Polyfil"><a href="#Q11：什么是-Polyfil" class="headerlink" title="Q11：什么是 Polyfil ?"></a>Q11：什么是 Polyfil ?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Polyfill（填充物）是用于模拟浏览器中缺失功能的代码块，通常用于使较新的Web技术能够在较旧的浏览器中正常运行。在Web开发中，不同的浏览器可能支持不同的JavaScript标准和API版本，这可能导致代码在某些浏览器中无法正常运行。</p><p>Polyfill 的目的是填补这些功能的缺失。通过在代码中包含 Polyfill，开发人员可以向较旧的浏览器提供与较新浏览器相同的功能，从而确保网站或应用程序在各种浏览器中具有一致的行为和体验。</p><p>Polyfill 通常是由开发者编写的 JavaScript 代码，其功能是检测浏览器是否支持某个特定的功能，如果不支持，则通过代码模拟这个功能。例如，如果某个浏览器不支持 <code>Array.prototype.forEach()</code> 方法，那么可以编写一个 Polyfill 来模拟这个方法的行为，使得在该浏览器中也可以使用 <code>forEach()</code>。</p><p>Polyfill 可以是个别功能的填充，也可以是一个包含多个功能填充的库。它们通常在需要时被引入到项目中，以解决特定的兼容性问题。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>下面是一个使用 Polyfill 的简单例子，假设我们想要在不支持 <code>Array.prototype.includes()</code> 方法的浏览器中使用这个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Polyfill for Array.prototype.includes()</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span> = <span class="keyword">function</span>(<span class="params">searchElement <span class="comment">/*, fromIndex*/</span></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array.prototype.includes called on null or undefined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">parseInt</span>(O.<span class="property">length</span>, <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n = <span class="built_in">parseInt</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>], <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> k;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      k = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = len + n;</span><br><span class="line">      <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentElement;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      currentElement = O[k];</span><br><span class="line">      <span class="keyword">if</span> (searchElement === currentElement ||</span><br><span class="line">         (searchElement !== searchElement &amp;&amp; currentElement !== currentElement)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (array.<span class="title function_">includes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数组包含 3&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数组不包含 3&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先检查是否存在 <code>Array.prototype.includes()</code> 方法。如果不存在，我们将定义一个 Polyfill 来模拟这个方法的行为。然后我们使用这个方法来检查数组中是否包含特定的元素。这样，即使浏览器不支持 <code>Array.prototype.includes()</code> 方法，我们也可以在代码中使用它。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：setTimeout-为什么不能保证能够及时执行"><a href="#Q12：setTimeout-为什么不能保证能够及时执行" class="headerlink" title="Q12：setTimeout 为什么不能保证能够及时执行?"></a>Q12：setTimeout 为什么不能保证能够及时执行?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>setTimeout()</code> 函数用于在指定的时间间隔之后执行一次 JavaScript 代码或函数。虽然在理论上 <code>setTimeout()</code> 应该在指定的时间间隔之后立即执行，但在实际应用中，它并不能保证能够及时执行的原因有几个：</p><ol><li><strong>JavaScript 单线程模型</strong>：JavaScript 在浏览器中是单线程执行的，意味着所有的代码都是按顺序执行的。如果前面的代码需要花费大量时间来执行，那么 <code>setTimeout()</code> 中的代码就会被推迟执行，直到前面的代码执行完成。这可能会导致 <code>setTimeout()</code> 中的代码延迟执行，即使指定的时间间隔已经到了。</li><li><strong>事件循环机制</strong>：在浏览器中，JavaScript 的执行是基于事件循环的。当执行栈中的任务执行完成后，浏览器会检查任务队列中是否有待执行的任务。如果有，它会将任务移到执行栈中执行。由于事件循环的机制，<code>setTimeout()</code> 中的代码可能需要等待前面的任务完成并且执行栈为空时才会被执行，这也会导致延迟执行的情况发生。</li><li><strong>最小延迟时间</strong>：<code>setTimeout()</code> 的精度受到浏览器和操作系统的限制，通常来说，<code>setTimeout()</code> 的最小延迟时间在几毫秒到几十毫秒之间。因此，如果你指定的延迟时间非常短，例如 1 毫秒，那么由于浏览器的限制，<code>setTimeout()</code> 也可能无法保证精确执行。</li></ol><p>综上所述，虽然 <code>setTimeout()</code> 是用来在指定的时间后执行代码的方法，但由于上述原因，它并不能保证能够及时执行。在编写代码时，应该考虑到这些因素，并避免依赖于严格的时间控制。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：Javascript字符串的常用方法有哪些"><a href="#Q13：Javascript字符串的常用方法有哪些" class="headerlink" title="Q13：Javascript字符串的常用方法有哪些?"></a>Q13：Javascript字符串的常用方法有哪些?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>charAt(index)</code>: 返回指定索引位置的字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">1</span>)); <span class="comment">// 输出 &quot;e&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>charCodeAt(index)</code>: 返回指定索引位置字符的 Unicode 值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure></li><li><p><code>concat(str1, str2, ...)</code>：连接两个或多个字符串，返回新的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">concat</span>(<span class="string">&quot;, &quot;</span>, str2)); <span class="comment">// 输出 &quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>includes(searchString, position)</code>：判断字符串中是否包含指定的子字符串，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>indexOf(searchValue, fromIndex)</code>：返回指定值在字符串中首次出现的位置，如果没有找到则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure></li><li><p><code>lastIndexOf(searchValue, fromIndex)</code>：返回指定值在字符串中最后一次出现的位置，如果没有找到则返回 -1。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure></li><li><p><code>slice(start, end)</code>：提取字符串的一个片段，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">11</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>substring(start, end)</code>：提取字符串的一个子串，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">11</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>substr(start, length)</code>：提取字符串中从指定位置开始的指定长度的子串，并返回一个新字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">6</span>, <span class="number">5</span>)); <span class="comment">// 输出 &quot;World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>split(separator, limit)</code>：将字符串分割成子串，返回一个由子串组成的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>)); <span class="comment">// 输出 [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>toLowerCase()</code>：将字符串转换为小写。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toLowerCase</span>()); <span class="comment">// 输出 &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>toUpperCase()</code>：将字符串转换为大写。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">toUpperCase</span>()); <span class="comment">// 输出 &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>trim()</code>：去除字符串两端的空白字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;   Hello World   &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">trim</span>()); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>replace(searchValue, replaceValue)</code>：替换字符串中的子串，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>)); <span class="comment">// 输出 &quot;Hello Universe&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>startsWith(searchString, position)</code>：判断字符串是否以指定的子串开头，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>endsWith(searchString, position)</code>：判断字符串是否以指定的子串结尾，返回 true 或 false。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&quot;World&quot;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li><li><p><code>match(regexp)</code>：检索字符串内指定的值，返回一个或多个匹配的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;The rain in Spain falls mainly in the plain&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/ain/g</span>)); <span class="comment">// 输出 [&quot;ain&quot;, &quot;ain&quot;, &quot;ain&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>search(regexp)</code>：检索与正则表达式相匹配的值，返回匹配的位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;The rain in Spain falls mainly in the plain&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">search</span>(<span class="regexp">/ain/g</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li><li><p><code>repeat(count)</code>：复制字符串指定次数，并返回一个新的字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">repeat</span>(<span class="number">3</span>)); <span class="comment">// 输出 &quot;HelloHelloHello&quot;</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：addEventListener-第三个参数是干什么的"><a href="#Q14：addEventListener-第三个参数是干什么的" class="headerlink" title="Q14：addEventListener 第三个参数是干什么的"></a>Q14：addEventListener 第三个参数是干什么的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 <code>addEventListener</code> 方法中，第三个参数是一个布尔值或者一个对象，用于指定事件处理函数的配置。常见的配置包括：</p><ol><li><strong>捕获或冒泡</strong>：布尔值，默认为 false（冒泡阶段）。如果设置为 true，则在捕获阶段触发事件。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">true</span>); <span class="comment">// 在捕获阶段触发事件</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, <span class="literal">false</span>); <span class="comment">// 在冒泡阶段触发事件（默认）</span></span><br></pre></td></tr></table></figure><ol><li><strong>可选参数对象</strong>：可以使用一个对象来指定更多的事件处理函数的配置，包括 <code>capture</code>、<code>once</code>、<code>passive</code> 等属性。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler, &#123;</span><br><span class="line">  <span class="attr">capture</span>: <span class="literal">true</span>, <span class="comment">// 在捕获阶段触发事件</span></span><br><span class="line">  <span class="attr">once</span>: <span class="literal">true</span>,    <span class="comment">// 仅触发一次，然后移除监听器</span></span><br><span class="line">  <span class="attr">passive</span>: <span class="literal">true</span>  <span class="comment">// 告知浏览器事件处理函数不会调用 preventDefault()</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>capture</code>：一个布尔值，表示事件是否在捕获阶段触发。默认为 false。</li><li><code>once</code>：一个布尔值，表示事件是否仅触发一次，触发后即移除事件监听器。默认为 false。</li><li><code>passive</code>：一个布尔值，表示事件处理函数是否调用了 <code>preventDefault()</code>。如果设置为 true，告知浏览器事件处理函数不会调用 <code>preventDefault()</code>，从而可以提高滚动性能。默认为 false。</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景"><a href="#Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景" class="headerlink" title="Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景?"></a>Q15：Javascript本地存储的方式有哪些，有什么区别，及有哪些应用场景?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th>存储方式</th><th>区别</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td>Cookies</td><td>浏览器提供的存储机制</td><td>- 客户端与服务器端都可以读取和写入；<br /> - 有大小限制，但可以设置过期时间；<br /> - 支持跨域传输，但存在安全性限制。</td><td>- 大小限制，一般只能存储几 KB 数据；<br /> - 每次请求都会自动发送，影响性能；<br /> - 受同源策略和安全性限制。</td><td>存储少量的用户身份验证信息、会话标识、用户偏好设置等。</td></tr><tr><td>localStorage</td><td>HTML5 提供的持久化本地存储机制</td><td>- 可以存储大量的数据，大小限制一般在几 MB；<br /> - 数据在浏览器关闭后仍然保留。</td><td>- 存储的数据仅限于字符串，不能存储复杂数据类型； <br />- 受同源策略限制，只能存储在同一个域名下；<br /> - 可能受浏览器隐私模式影响。</td><td>长期保存在客户端的数据，比如用户偏好设置、本地缓存数据等。</td></tr><tr><td>sessionStorage</td><td>HTML5 提供的临时本地存储机制</td><td>- 可以存储大量的数据，大小限制一般在几 MB； <br />- 数据在会话结束后被清除，不会保留到下一次会话。</td><td>- 存储的数据仅限于字符串，不能存储复杂数据类型；<br /> - 受同源策略限制，只能存储在同一个域名下；<br /> - 可能受浏览器隐私模式影响</td><td>临时存储在客户端的会话相关数据，比如表单数据、单次会话的状态等。</td></tr><tr><td>IndexedDB</td><td>HTML5 提供的客户端数据库系统</td><td>- 支持存储大量结构化数据； <br />- 提供灵活的查询和索引功能；<br /> - 支持事务和版本控制。</td><td>。- 相对复杂，学习曲线较陡；<br /> - API 不够简洁易用；<br /> - 可能受浏览器兼容性影响。</td><td>存储大量结构化数据，并需要进行复杂查询和索引的应用，比如离线 Web 应用、在线文件存储等。</td></tr><tr><td>WebSQL</td><td>HTML5 提供的关系型数据库（已废弃）</td><td>- 支持类似 SQL 的查询语言；<br /> - 提供事务支持和复杂的查询功能。</td><td>- 技术规范已废弃，不推荐在新项目中使用； <br />- 可能受浏览器兼容性和安全性限制。</td><td>已废弃，不建议在新项目中使用；仅适用于需要在客户端进行复杂查询和数据处理的应用，且无需考虑兼容性和未来性的项目。</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：var、let、const之间有什么区别"><a href="#Q16：var、let、const之间有什么区别" class="headerlink" title="Q16：var、let、const之间有什么区别?"></a>Q16：var、let、const之间有什么区别?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>var</code>、<code>let</code> 和 <code>const</code> 是 JavaScript 中用于声明变量的关键字，它们之间有以下区别：</p><ol><li><strong>作用域</strong>：<ul><li><code>var</code> 声明的变量具有函数作用域（function scope），即在函数内部声明的变量在整个函数内部都可见。</li><li><code>let</code> 和 <code>const</code> 声明的变量具有块级作用域（block scope），即在 <code>{}</code> 内部声明的变量只在该块内部可见，超出块作用域范围则无法访问。</li></ul></li><li><strong>变量提升</strong>：<ul><li>使用 <code>var</code> 声明的变量会发生变量提升（hoisting），即变量声明会被提升到当前作用域的顶部，但初始化操作不会被提升。</li><li>使用 <code>let</code> 和 <code>const</code> 声明的变量也存在变量提升，但在变量声明前访问该变量会抛出 ReferenceError 错误。</li></ul></li><li><strong>重复声明</strong>：<ul><li>使用 <code>var</code> 可以重复声明同名变量，不会报错，但会覆盖之前的值。</li><li>使用 <code>let</code> 和 <code>const</code> 在同一作用域内重复声明同名变量会导致 SyntaxError 错误。</li></ul></li><li><strong>赋值和重新赋值</strong>：<ul><li>使用 <code>var</code> 和 <code>let</code> 声明的变量可以进行赋值和重新赋值。</li><li>使用 <code>const</code> 声明的变量必须在声明时进行初始化，且初始化后不能再修改其值（常量）。</li></ul></li><li><strong>全局对象属性</strong>：<ul><li>使用 <code>var</code> 声明的变量会成为全局对象的属性（在全局作用域下声明的变量）。</li><li>使用 <code>let</code> 和 <code>const</code> 声明的变量不会成为全局对象的属性，它们仅在声明的作用域内可见。</li></ul></li></ol><p>综上所述，<code>let</code> 和 <code>const</code> 是 ES6 新引入的块级作用域变量声明方式，相较于 <code>var</code> 具有更加严格的作用域和行为。在实际开发中，推荐使用 <code>let</code> 和 <code>const</code> 来代替 <code>var</code>，以避免由于变量提升和作用域问题而引发的错误。同时，根据变量的特性选择合适的声明方式，如需要定义常量或避免重复赋值的情况下可以使用 <code>const</code>。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：Promise-then-第二个参数和catch的区别是什么"><a href="#Q17：Promise-then-第二个参数和catch的区别是什么" class="headerlink" title="Q17：Promise then 第二个参数和catch的区别是什么"></a>Q17：Promise then 第二个参数和catch的区别是什么</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong><code>Promise.then()</code>方法的第二个参数</strong></p><ul><li><code>Promise.then()</code>方法接收两个参数，第一个参数是用于处理Promise成功解决时的结果（成功处理函数），第二个参数是用于处理Promise拒绝时的错误（失败处理函数）</li><li>这意味着，如果Promise被拒绝，第二个参数（失败处理函数）将被调用，传递给它的参数是拒绝的原因</li><li>例子：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发拒绝</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resolved with:&quot;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rejected with:&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个例子中，如果Promise被拒绝，<code>then()</code>方法的第二个参数（失败处理函数）将被调用</p><p><strong><code>Promise.catch()</code>方法</strong></p><ul><li><code>Promise.catch()</code>方法是专门用于处理Promise拒绝的错误的。它等同于<code>Promise.then(null, failureHandler)</code></li><li><code>Promise.catch()</code>接收一个参数（失败处理函数），当Promise被拒绝时会调用这个函数</li><li>使用<code>Promise.catch()</code>可以使代码更清晰，因为它专门用于错误处理，而不是与<code>then()</code>方法的成功处理混在一起</li><li>例子：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发拒绝</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resolved with:&quot;</span>, result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rejected with:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>catch()</code>方法将处理Promise被拒绝的情况</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Promise.then()</code>方法和<code>Promise.catch()</code>方法都是用于处理Promise对象的结果和错误的，但它们在处理错误方面有不同的用法和行为</p><p><strong>区别</strong></p><ul><li><p><code>then()</code>方法的第二个参数和<code>catch()</code>方法在功能上非常相似</p><p>主要区别在于语义和可读性</p><p><code>catch()</code>明确表示只处理错误，而<code>then()</code>的第二个参数则是用于处理错误</p></li><li><p>使用<code>catch()</code>可以让代码更清晰，因为它明确表示了只处理错误的情况</p></li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：postMessage-有哪些使用场景"><a href="#Q18：postMessage-有哪些使用场景" class="headerlink" title="Q18：postMessage 有哪些使用场景"></a>Q18：postMessage 有哪些使用场景</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>postMessage</code> 是浏览器环境中的一种用于跨文档（例如 iframe 和其父页面之间）或跨窗口（例如弹出窗口和其父窗口之间）进行消息传递的机制。它允许一个文档向另一个文档发送异步消息，并且可以指定接收消息的目标来源（origin）。以下是 <code>postMessage</code> 的一些常见使用场景：</p><ol><li><strong>跨域通信</strong>：<ul><li>当你在一个页面内嵌入一个跨域的 iframe 时，你可以通过 <code>postMessage</code> 来与 iframe 进行通信。可以将数据从父页面发送到 iframe，也可以从 iframe 发送到父页面</li></ul></li><li><strong>父窗口和弹出窗口之间的通信</strong>：<ul><li>当一个页面打开一个新的弹出窗口时，你可以通过 <code>postMessage</code> 在父窗口和弹出窗口之间传递信息。这可以用于在父窗口中控制弹出窗口的内容，或者从弹出窗口中返回数据给父窗口</li></ul></li><li><strong>与 Web Workers 的通信</strong>：<ul><li>Web Workers 是一种在浏览器中执行并行任务的方式。<code>postMessage</code> 是与 Web Workers 通信的主要方式。你可以向 Web Worker 发送数据，并接收来自 Web Worker 的消息</li></ul></li><li><strong>与 Service Workers 的通信</strong>：<ul><li><code>postMessage</code> 也可以用于与 Service Workers 通信。这对于在离线模式下提供推送通知和缓存管理等功能非常有用</li></ul></li><li><strong>跨浏览器选项卡或窗口的通信</strong>：<ul><li>在某些情况下，你可能需要在同一个浏览器中打开的不同选项卡或窗口之间进行通信。通过共享同一个窗口对象并使用 <code>postMessage</code>，可以实现跨选项卡或窗口的消息传递</li></ul></li><li><strong>单页应用程序（SPA）与嵌入式第三方内容的通信</strong>：<ul><li>在单页应用程序中嵌入第三方内容（如广告或小部件）时，可以通过 <code>postMessage</code> 与这些内容进行通信，以确保数据的安全传递</li></ul></li></ol><p><strong>使用 <code>postMessage</code> 的注意事项：</strong></p><ul><li><strong>目标来源</strong>：<code>postMessage</code> 的第二个参数是目标来源（origin），即接收消息的目标文档的源。出于安全考虑，应该始终指定目标来源，以防止消息被发送到意外的接收方</li><li><strong>安全性</strong>：在接收 <code>postMessage</code> 消息时，注意验证消息的来源和内容，确保只处理来自可信源的消息，并且避免潜在的安全风险（例如跨站点脚本攻击）</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19-：async-await-怎么进行错误处理"><a href="#Q19-：async-await-怎么进行错误处理" class="headerlink" title="Q19 ：async/await 怎么进行错误处理"></a>Q19 ：async/await 怎么进行错误处理</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>async/await</code> 是一种基于 Promise 的异步编程模式，它使异步代码的写法更接近于同步代码。为了进行错误处理，你可以使用 <code>try...catch</code> 语句来捕获 <code>async/await</code> 中可能出现的错误</p><p>下面是一些常见的错误处理方式：</p><p><strong>1. <code>try...catch</code> 语句：</strong></p><p>使用 <code>try...catch</code> 块来捕获异步函数中的错误。当异步函数中的 Promise 拒绝（即发生错误）时，错误会被抛出，并在 <code>catch</code> 块中被捕获，你可以在 <code>catch</code> 块中进行相应的错误处理</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数</span></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，如果 <code>fetch</code> 请求失败或返回的状态码不是成功的状态（例如 404 或 500），会抛出错误，并在 <code>catch</code> 块中捕获。<code>catch</code> 块会输出错误信息</p><p><strong>2. <code>async</code> 函数的返回值：</strong></p><p>当你在一个异步函数中使用 <code>async/await</code> 时，函数的返回值将是一个 Promise。如果你想在异步函数调用时进行错误处理，可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理函数的返回值</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数并处理返回的 Promise</span></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>在这个示例中，异步函数 <code>fetchData</code> 返回的是一个 Promise，我们可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法处理该 Promise 的成功和失败情况</p><p><strong>总结：</strong></p><ul><li>使用 <code>try...catch</code> 块在异步函数内进行错误处理</li><li>在异步函数调用时，可以通过 <code>.then()</code> 和 <code>.catch()</code> 方法处理异步函数返回的 Promise</li><li>在 <code>catch</code> 块中，你可以记录错误、显示错误消息或采取其他错误处理措施</li><li>合理的错误处理有助于确保你的应用程序在发生错误时不会意外崩溃，并且能够提供良好的用户体验</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：script标签内的async跟defer有什么区别跟作用？"><a href="#Q20：script标签内的async跟defer有什么区别跟作用？" class="headerlink" title="Q20：script标签内的async跟defer有什么区别跟作用？"></a>Q20：script标签内的async跟defer有什么区别跟作用？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" grey><summary> 解析 </summary>
              <div class='content'>
              <p>在 HTML 中会遇到以下三类 script：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;xxx&#x27;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script标签用于加载脚本与执行脚本，直接使用script脚本时，html会按照顺序来加载并执行脚本，在脚本加载&amp;执行的过程中，会阻塞后续的DOM渲染。</p><p>比如现在大家习惯于在页面中引用各种第三方脚本，但如果第三方服务商出现了一些小问题，比如延迟之类的，就会使得页面白屏。</p><p>针对上述情况，script标签提供了两种方式来解决问题，就是加入属性async以及defer，这两个属性使得script标签加载都不会阻塞DOM的渲染。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">defer：此布尔属性被设置为向浏览器指示脚本在文档被解析后执行</span><br><span class="line">async：设置此布尔属性，以指示浏览器如果可能的话，应异步执行脚本</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>defer：设置这个属性的script标签，浏览器将会异步下载该文件并不影响后续dom渲染，多个defer标签则会按顺序执行，在文档渲染完之后的DOMContentLoaded事件调用前执行</p><p>async：脚本将会异步加载并且不按顺序执行，谁加载的快就会执行谁</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：setTimeout的延时写成0，一般在什么场景下使用？"><a href="#Q21：setTimeout的延时写成0，一般在什么场景下使用？" class="headerlink" title="Q21：setTimeout的延时写成0，一般在什么场景下使用？"></a>Q21：setTimeout的延时写成0，一般在什么场景下使用？</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>将 <code>setTimeout</code> 的延时设置为 0 的情况通常用于创建一个宏任务，让回调函数尽可能快地放入任务队列中等待执行。这种技术被称为“0 毫秒定时器”或“宏任务调度”。</p><p>需要注意的是，使用 0 毫秒延时并不能真正实现“立即执行”，而是将任务推迟到下一个宏任务。此外，滥用这种技术可能会导致性能问题，因此应该根据具体场景慎重使用。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>主要场景包括：</p><ol><li><strong>UI 渲染优化</strong>：<ul><li>在处理大量计算或操作时，通过将一部分任务延迟到下一个宏任务执行，可以优化 UI 渲染和响应速度，避免长时间的同步操作导致页面卡顿。</li></ul></li><li><strong>事件回调</strong>：<ul><li>在事件回调中使用 0 毫秒延时，可以确保回调函数在当前事件循环的末尾执行，而不会阻塞后续事件的处理。这对于确保一些状态的及时更新是有帮助的。</li></ul></li><li><strong>Promise 的微任务</strong>：<ul><li>在处理 Promise 的 <code>.then()</code> 或 <code>async/await</code> 时，通过 <code>setTimeout</code> 设置为 0，可以将后续的任务放入微任务队列，确保在当前任务执行完毕后立即执行。</li></ul></li><li><strong>模拟 nextTick</strong>：<ul><li>在一些前端框架（如 Vue.js）中，<code>nextTick</code> 方法的实现通常使用了 <code>setTimeout</code> 设置为 0，用于在下一个宏任务中执行回调，以确保在 DOM 更新后执行。</li></ul></li><li><strong>事件循环</strong>：<ul><li>通过 <code>setTimeout</code> 设置为 0，可以在当前事件循环的最后插入一个宏任务，用于处理一些异步操作，确保不会影响当前任务的执行。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：webSocket如何兼容低浏览器"><a href="#Q22：webSocket如何兼容低浏览器" class="headerlink" title="Q22：webSocket如何兼容低浏览器"></a>Q22：webSocket如何兼容低浏览器</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>Adobe Flash Socket</strong>：Flash 曾经是一种用于在浏览器中实现实时通信的常用技术，可以通过 Flash 插件来模拟 WebSocket 的行为。但需要注意的是，由于 Flash 的安全性问题和日益废弃的趋势，这不是一个长期可行的解决方案。</li><li><strong>ActiveX HTMLFile (IE)</strong>：在早期版本的 Internet Explorer 浏览器中，可以使用 ActiveX 控件 HTMLFile 来实现长轮询技术，以模拟实时通信。这种方法只能在 IE 浏览器中使用，并且不适用于其他浏览器。</li><li><strong>基于 multipart 编码发送 XHR</strong>：这种方法是通过使用 XMLHttpRequest 对象来模拟 WebSocket 的通信过程。数据会以 multipart 编码的方式发送，服务器需要进行解析。这种方法比较复杂，而且在性能上可能不如 WebSocket。</li><li><strong>基于长轮询的 XHR</strong>：长轮询是一种通过不断发起 HTTP 请求来模拟实时通信的技术。客户端发送一个 HTTP 请求给服务器，服务器只有在有新消息时才会响应，否则保持连接处于挂起状态。一旦收到响应，客户端立即发送另一个请求。这种方法可以实现实时性，但是效率较低，并且可能会产生较高的服务器负载。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：ajax、axios、fetch有什么区别"><a href="#Q23：ajax、axios、fetch有什么区别" class="headerlink" title="Q23：ajax、axios、fetch有什么区别"></a>Q23：ajax、axios、fetch有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">特性/库</th><th style="text-align:left">AJAX</th><th style="text-align:left">Axios</th><th style="text-align:left">Fetch</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基于</strong></td><td style="text-align:left">XMLHttpRequest 对象</td><td style="text-align:left">XMLHttpRequest \Promise</td><td style="text-align:left">原生js的Fetch API</td></tr><tr><td style="text-align:left"><strong>返回数据类型</strong></td><td style="text-align:left">默认为纯文本</td><td style="text-align:left">默认为JSON</td><td style="text-align:left">默认为Response对象（需要转换为JSON）</td></tr><tr><td style="text-align:left"><strong>优点</strong></td><td style="text-align:left">- 在老版本的浏览器上有广泛支持<br /> - 灵活，可以支持各种请求和内容类型</td><td style="text-align:left">- 支持Promise - 请求拦截器、响应拦截器<br /> - 自动转换JSON数据<br /> - 客户端支持防御XSRF</td><td style="text-align:left">- 基于Promise，语法简洁<br /> - 可以很容易地通过一个API处理所有的HTTP请求<br /> - 响应可以被多次读取</td></tr><tr><td style="text-align:left"><strong>缺点</strong></td><td style="text-align:left">- 不支持Promise，回调地狱<br /> - 代码可能会比较复杂</td><td style="text-align:left">- 不是浏览器内建，需要额外安装<br /> - 不能取消请求 - 浏览器兼容性问题</td><td style="text-align:left">- 默认不发送cookies<br /> - 可能需要多步骤来处理响应<br /> - 浏览器支持不如XHR</td></tr><tr><td style="text-align:left"><strong>相同点</strong></td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td><td style="text-align:left">- 都能发送HTTP请求<br /> - 都能在客户端与服务器进行数据交换</td></tr><tr><td style="text-align:left"><strong>不同点</strong></td><td style="text-align:left">- 基于底层接口XMLHttpRequest</td><td style="text-align:left">- 封装了XMLHttpRequest，提供了更现代的API<br /> - 提供拦截器，请求取消，全局的axios实例</td><td style="text-align:left">- 基于Promise的新技术<br /> - 更为简洁的API<br /> - 与Service Worker的集成</td></tr><tr><td style="text-align:left"><strong>开发封装</strong></td><td style="text-align:left">- 通常直接使用，或者基于jQuery等库进一步封装</td><td style="text-align:left">- 独立库，提供现代的API和特性</td><td style="text-align:left">- 内建在现代浏览器中，不需外部库</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：for…in和for…of有什么区别"><a href="#Q24：for…in和for…of有什么区别" class="headerlink" title="Q24：for…in和for…of有什么区别"></a>Q24：for…in和for…of有什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>for...in</code>循环和<code>for...of</code>循环在JavaScript中用于遍历数据，但它们之间有一些重要的区别。下面是对这两种循环方式的主要区别的概述：</p><p><strong>for…in循环</strong></p><ul><li><strong>用途</strong>：<code>for...in</code>循环主要用于遍历对象的属性。</li><li><strong>行为</strong>：遍历对象的所有可枚举属性，包括继承的可枚举属性。</li><li><strong>迭代值</strong>：在每次迭代中，迭代变量存储的是对象属性的键（即属性名）。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出 &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for…of循环</strong></p><ul><li><strong>用途</strong>：<code>for...of</code>循环主要用于遍历可迭代对象的元素，如数组、字符串、Map、Set等。</li><li><strong>行为</strong>：直接遍历可迭代对象的值。</li><li><strong>迭代值</strong>：在每次迭代中，迭代变量存储的是元素的值。</li></ul><p><strong>示例</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要区别</strong></p><ol><li><strong>遍历对象不同</strong>：<code>for...in</code>遍历对象的属性（键），适用于对象；而<code>for...of</code>主要遍历可迭代对象的元素值，适用于数组、字符串等。</li><li><strong>应用场景</strong>：<code>for...in</code>更适合于遍历对象的属性；<code>for...of</code>提供了一种简洁的方式来遍历数组、Map、Set、字符串等可迭代对象的元素。</li><li><strong>继承属性的遍历</strong>：<code>for...in</code>也可以遍历对象原型链上的可枚举属性，而<code>for...of</code>不会遍历原型链，它只遍历当前对象的值。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：Map跟WeakMap什么区别"><a href="#Q25：Map跟WeakMap什么区别" class="headerlink" title="Q25：Map跟WeakMap什么区别"></a>Q25：Map跟WeakMap什么区别</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Map</code> 和 <code>WeakMap</code> 都是JavaScript中的集合类型，用于存储键值对，但它们在某些关键特性上有所不同。</p><ol><li><p><code>map</code></p><p><code>Map</code> 是ECMAScript 2015规范中引入的一种新的数据结构，它类似于对象，也是键值映射，但键的范围不限于字符串，可以是任何类型的值</p><ul><li><strong>键的多样性</strong>: <code>Map</code> 的键可以是任意类型的值，包括函数、对象或任何基本类型</li><li><strong>有序性</strong>: <code>Map</code> 对象维护键插入的顺序</li><li><strong>大小可测</strong>: 通过 <code>Map.prototype.size</code> 属性可以直接获取一个 <code>Map</code> 的元素数量</li><li><strong>性能</strong>: 在频繁增删键值对的场景下，<code>Map</code> 有着比普通对象更好的性能</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>WeakMap</code></p><p><code>WeakMap</code> 是ECMAScript 2015规范中一起引入的一种集合类型。它与 <code>Map</code> 的主要差别在于它的键必须是对象，不能是原始值，而且<code>WeakMap</code> 中的键是弱引用的</p><ul><li><strong>键必须是对象</strong>: <code>WeakMap</code> 的键只能是对象引用</li><li><strong>弱引用</strong>: <code>WeakMap</code> 中的键所指向的对象是弱引用，这意味着如果没有其他引用和该对象相连，这些对象将会被垃圾回收机制回收。因此，<code>WeakMap</code> 适合做关联额外数据到对象上，而无需担心内存泄漏问题</li><li><strong>不可枚举</strong>: <code>WeakMap</code> 的内容不可枚举。这是出于垃圾回收机制的考虑。因为不能确切知道当前哪些键已经被回收，所以不可提供遍历其键或值的方法</li><li><strong>无法清空</strong>: <code>WeakMap</code> 没有 <code>clear</code> 方法，也无法获取大小，也就是说，没有办法直接清除 <code>WeakMap</code> 的所有键值对</li><li><strong>用途限定</strong>: 由于以上特性，<code>WeakMap</code> 多用于私有数据的存储，以及与对象生命周期绑定的信息存储</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> objKey = &#123;&#125;;</span><br><span class="line">weakMap.<span class="title function_">set</span>(objKey, <span class="string">&#x27;value1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，如果 <code>objKey</code> 外部没有其他引用，它最终会被垃圾回收掉，相应地，<code>weakMap</code> 对 <code>objKey</code> 的引用不会阻止回收</p></li></ol><p><strong>总结</strong></p><p><code>Map</code> 更适合做数据集合，而 <code>WeakMap</code> 用于细粒度的对象级别的数据存储，它不阻止垃圾回收器清理键所引用的对象</p><p>了解这两者的差别，有助于选择适合不同场景的数据结构</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：如何确保你的构造函数只能被new调用，而不能被普通调用"><a href="#Q26：如何确保你的构造函数只能被new调用，而不能被普通调用" class="headerlink" title="Q26：如何确保你的构造函数只能被new调用，而不能被普通调用"></a>Q26：如何确保你的构造函数只能被new调用，而不能被普通调用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>instanceof</code> 运算符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyConstructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">MyConstructor</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyConstructor must be called with new&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里写你的构造函数代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用方式，使用 new</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="title class_">MyConstructor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的调用方式，没有使用 new，将会抛出错误</span></span><br><span class="line"><span class="title class_">MyConstructor</span>();</span><br></pre></td></tr></table></figure><p>这段代码中使用的 <code>instanceof</code> 运算符检查 <code>this</code> 是否是 <code>MyConstructor</code> 的一个实例</p><p>如果不是，那就意味着构造函数是被作为普通函数调用的，就会抛出一个错误</p><p>所以当你尝试不使用 <code>new</code> 关键字调用 <code>MyConstructor</code> 时，就会触发这个错误</p></li><li><p><code>class</code> 关键字</p><p>随着ES6的引入，现在更普遍和推荐的做法是使用 <code>class</code> 关键字来定义构造函数</p><p>当试图执行不使用 <code>new</code> 的类构造方法时，JavaScript 会自动抛出错误</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在这里添加构造函数代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 正确的方式</span></span><br><span class="line"><span class="keyword">const</span> wrongInstance = <span class="title class_">MyClass</span>(); <span class="comment">// 这将会抛出TypeError: Class constructor MyClass cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure><p>在ES6类构造函数中，如果试图以普通函数的方式调用 <code>MyClass()</code>，JavaScript 会抛出 <code>TypeError</code>，因此在这种情况下不需要额外的检查</p></li><li><p><code>new.target</code> 属性</p><p>《ECMAScript 6 入门》中讲到: <code>ES6</code> 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数</p><p>如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，<code>new.target</code> 会返回 <code>undefined</code> ，<strong>因此这个属性可以用来确定构造函数是怎么调用的</strong></p><p><code>new.target</code> 在通过 <code>new</code> 调用函数时是定义过的，而通过普通函数方式调用时是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;MyFunction must be called with new&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在这里写你的构造函数代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用方式，使用 new</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的调用方式，没有使用 new，将会抛出错误</span></span><br><span class="line"><span class="title class_">MyFunction</span>();</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：怎么中断forEach循环"><a href="#Q27：怎么中断forEach循环" class="headerlink" title="Q27：怎么中断forEach循环"></a>Q27：怎么中断forEach循环</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在JavaScript中，<code>Array.prototype.forEach</code> 方法是无法在循环过程中被中断的</p><p>这是因为按照其设计，<code>Array.prototype.forEach</code> 是用来对数组的每一项都执行一遍给定的函数，无法直接中断或者跳出</p><p><br /></p><p>在出现错误的情况下，可以使用<code>try-catch</code>语句来停止 JavaScript <code>Array.prototype.forEach</code>中的循环，但这并非其设计初衷，如果需要在循环中实现某种条件的停止，不推荐使用这种方法</p><p>这是因为<code>try-catch</code>通常用于处理异常或错误，如果滥用<code>try-catch</code>来中断正常流程，可能会对代码的可读性和性能产生负面影响</p><p>例如，虽然我们能够通过抛出一个错误（<code>throw</code>）来退出<code>forEach</code>循环，然后在外层使用<code>try-catch</code>来捕捉这个错误，实现中止<code>forEach</code>循环的功能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// If element meets condition, throw error</span></span><br><span class="line">        <span class="keyword">if</span> (el === <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Stop loop&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">message</span> === <span class="string">&#x27;Stop loop&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Loop stopped.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Real error, handle it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，假设我们在遇到元素 <code>3</code> 时中止循环，当元素 <code>3</code> 出现时，我们抛出一个错误并立即停止 <code>forEach</code>。错误然后被 <code>catch</code> 块捕捉，并打印出 <code>&#39;Loop stopped.&#39;</code></p><p>但正如刚才我提到的，这并非<code>try-catch</code>的原始用途，如果只是想中止一个循环，应该选择更合适的循环结构，比如<code>for</code>，<code>while</code>或者<code>some</code>/<code>every</code>等方法</p><p><br /></p><p>替换方式</p><p><strong>1. 使用 <code>for</code> 循环或 <code>while</code> 循环：</strong><br><code>for</code> 和 <code>while</code> 两种循环在满足某种条件时，都可以使用 <code>break</code> 关键字来提前退出循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] === target) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用 <code>Array.prototype.some</code> 或 <code>Array.prototype.every</code></strong><br>这两个方法是用于判断数组中所有元素是否都满足（<code>every</code>）或者有至少一个元素满足（<code>some</code>）某个条件，如果一旦找到满足条件（或者不满足条件）的元素，就会立即停止迭代并返回</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：try…catch-可以捕获到异步代码中的错误吗"><a href="#Q28：try…catch-可以捕获到异步代码中的错误吗" class="headerlink" title="Q28：try…catch 可以捕获到异步代码中的错误吗"></a>Q28：try…catch 可以捕获到异步代码中的错误吗</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>try...catch</code> 结构在 JavaScript 中用于捕获和处理同步代码中的错误</p><p>对于异步代码，其行为会有所不同，这取决于异步代码的具体实现方式</p><ul><li><p>对于使用 <code>Promise</code> 或 <code>async/await</code> 的异步代码，<code>try...catch</code> 可以有效地捕获异步操作中的错误</p><p>这是因为 <code>async/await</code> 语法是基于 <code>Promise</code> 的，它允许你用看似同步的方式写异步代码</p><p>在这种情况下，<code>await</code> 关键字会等待 <code>Promise</code> 完成，并且如果 <code>Promise</code> 被拒绝，<code>await</code> 会抛出一个错误，这个错误可以被同一个<code>try...catch</code> 块捕获</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://example.com&quot;</span>);</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到错误：&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>对于传统的异步回调（如使用 <code>setTimeout</code>、<code>setInterval</code> 或者传统的异步回调模式），<code>try...catch</code> 无法直接捕获到异步操作中的错误</p><p>这是因为当 <code>try...catch</code> 代码块执行时，异步代码可能尚未执行，错误也就不会在 <code>try...catch</code> 中被捕获</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;错误！&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 无法捕获到错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到错误：&quot;</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>setTimeout</code> 中的错误不会被 <code>try...catch</code> 捕获，因为 <code>setTimeout</code> 是异步执行的，当错误发生时，<code>try...catch</code> 块已经执行完毕了</p><p>总结来说，<code>try...catch</code> 可以捕获到使用 <code>Promise</code>、<code>async/await</code> 等现代异步编程模式中的错误，但对于传统的异步回调模式，<code>try...catch</code> 无法直接捕获异步操作中的错误</p><p>对于这些情况，应该利用诸如 <code>Promise</code> 的 <code>.catch()</code> 方法或者 <code>async/await</code> 结合 <code>try...catch</code> 来处理错误</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：Generator是怎么做到中断和恢复的"><a href="#Q29：Generator是怎么做到中断和恢复的" class="headerlink" title="Q29：Generator是怎么做到中断和恢复的"></a>Q29：Generator是怎么做到中断和恢复的</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Generator 是 JavaScript ES6 引入的一种新的函数语法，它可以通过 <code>yield</code> 关键字来暂停函数的执行，然后通过外部控制恢复执行</p><p>一个 Generator 函数在初次调用时并不会执行，而是返回一个遵循迭代器协议的 Generator 对象</p><p>这个对象实际上是一个迭代器，它包含一个 <code>next()</code> 方法</p><p>每次调用迭代器的 <code>next()</code> 方法时，Generator 函数会执行到下一个 <code>yield</code> 表达式，并暂停，即“中断”的操作</p><p>此时，生成器代码的状态（包括变量的值和指令指针）都会被保留</p><p>在此状态下，代码外部可以处理当前 <code>yield</code> 出的值，然后再决定是否继续执行</p><p>以下是一个基本的 Generator 函数的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numberGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">numberGenerator</span>(); <span class="comment">// 获取到 Generator 对象，但函数尚未开始执行。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 1，并暂停执行。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 从上一次暂停的地方恢复执行，输出 2。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 3。</span></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ol><li>当 <code>numberGenerator()</code> 被调用时，它返回一个迭代器对象但不执行函数体内的代码</li><li>调用迭代器的 <code>next()</code> 方法时，Generator 函数开始执行，直到遇到第一个 <code>yield</code></li><li><code>yield</code> 暂停函数的执行并将值返回给迭代器的 <code>next()</code> 方法调用</li><li>当再次调用 <code>next()</code> 时，Generator 函数会从上一次暂停的地方 <code>yield</code> 继续执行，直到遇到下一个 <code>yield</code> 或 <code>return</code>，或者到达函数体的末尾</li><li>可以重复此过程，直到 Generator 函数内没有更多的 <code>yield</code>，或者直到到达 <code>return</code> 语句，这会导致 Generator 完全终止</li></ol><p>Generator 函数在可能涉及异步操作和需要暂停和恢复的场景中特别有用，因为它允许你编写看起来像同步代码的异步行为，并且在每个阶段都可以控制函数的执行</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：async-await、generator、promise-这三者的关联和区别是什么"><a href="#Q30：async-await、generator、promise-这三者的关联和区别是什么" class="headerlink" title="Q30：async/await、generator、promise 这三者的关联和区别是什么"></a>Q30：async/await、generator、promise 这三者的关联和区别是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Promise</strong></p><p>Promise 是一个代表了异步操作最终完成或者失败的对象</p><p>它是一个包装了异步操作结果的对象</p><p>每个 Promise 有三种状态：pending（等待中）、fulfilled（已完成）或rejected（已失败）</p><p>Promise的主要优点是可以链式调用（<code>.then()</code> 后可以继续 <code>.then()</code>），并且有统一的错误处理机制（<code>.catch()</code>）</p><p>但是，代码可能会因为 <code>.then()</code>的嵌套而变得难以阅读和维护</p></li><li><p><strong>Generator</strong></p><p>Generator 是 ES6 引入的一个特性，允许一个函数在执行过程中暂停，并在稍后重新开始，类似于线程的挂起和恢复</p><p>Generator 函数返回了一个遍历器对象，可以通过 <code>.next()</code> 方法来得到一个 <code>{ value, done }</code> 结构的对象，其中 <code>value</code> 是返回的结果，<code>done</code> 是一个布尔值表示函数是否执行完毕</p><p>Generator 通常和 yield 关键字一起使用，yield 可以将函数的执行“暂停”，再次调用 <code>.next()</code> 时从上次“暂停”的地方开始</p><p>Generator本身并没有异步处理能力，但可以配合 Promise 使用来处理异步操作</p></li><li><p><strong>Async/Await</strong></p><p>Async/Await 是 ES2017 引入，可以看作是 Generator 的语法糖，用于简化 Promise 的使用，并使异步的代码看起来就像同步的代码一样</p><p>一个 async 函数内部可以使用 await 关键字等待一个 Promise resolve，然后获取它的结果</p><p>这就好像是将异步代码暂停在那里，等待 Promise 完成</p><p>实际上，async/await 内部就是通过类似 Generator 的方式，使得函数在等待 Promise 时“暂停”，在 Promise 完成时“恢复”</p></li></ol><p><strong>简单的关系是</strong></p><p>Promise 提供了对异步操作的封装，解决了回调地狱的问题</p><p>Generator 提供了更进一步的流控制，使得代码可以在某个点“暂停”并在稍后“恢复”</p><p>而 Async/Await 是基于 Promise 和 Generator 的同步化处理异步操作的语法糖</p><p>同时，需要注意的是，虽然 async/await 让异步代码看起来就像同步代码一样，但实际上它们的行为仍然是异步的，只是语法变得更容易理解和阅读</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：如何让Promise-all在抛出异常后依然有效"><a href="#Q31：如何让Promise-all在抛出异常后依然有效" class="headerlink" title="Q31：如何让Promise.all在抛出异常后依然有效"></a>Q31：如何让Promise.all在抛出异常后依然有效</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在默认情况下，<code>Promise.all</code> 方法如果在等待所有<code>promise</code>解决（<code>resolve</code>）的过程中，有任何一个<code>promise</code>被拒绝（<code>reject</code>），那么它会立即结束，并返回一个拒绝（<code>reject</code>）状态的<code>promise</code></p><p>如果你希望即便有一个或多个<code>promise</code>被拒绝，<code>Promise.all</code> 依然能够继续执行并返回所有<code>promise</code>的结果，你需要自己处理每个<code>promise</code>，确保它们不会抛出异常</p><p>这可以通过在每个<code>promise</code>后面附加一个 <code>.catch()</code> 方法来实现，这样可以捕获并处理错误，你也可以仅仅返回错误信息而不是抛出，这样外层的 <code>Promise.all</code> 就不会因为<code>reject</code>而立即停止了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promises = [<span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint1&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint2&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;/api/endpoint3&#x27;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(results))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Some promise failed: &#x27;</span>, e));</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>promises.map</code> 方法遍历了所有的promise，并为每个promise附加了一个 <code>.catch</code> 方法</p><p>如果任何一个promise失败了，<code>.catch</code> 方法会处理异常，并且将错误信息作为结果返回</p><p>这会保证 <code>Promise.all</code> 方法得到的总是一个包含每个原promise结果的数组，无论它是成功的值还是错误</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>使用 <code>Promise.allSettled</code> 替代 <code>Promise.all()</code></p><blockquote><p><code>Promise.allSettled()</code>方法返回一个promise，该promise在所有给定的promise已被解析或被拒绝后解析，并且每个对象都描述每个promise的结果</p></blockquote>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么"><a href="#Q32：object-assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么" class="headerlink" title="Q32：object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么"></a>Q32：object.assign和扩展运算符是深拷贝还是浅拷贝，两者区别是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong>浅拷贝与深拷贝</strong></p><ul><li><p><strong>浅拷贝</strong></p><p>仅复制对象的第一层属性</p><p>如果一个对象的某个属性值是引用类型（如对象或数组），浅拷贝会复制这个引用，而不是复制引用所指向的真实对象</p><p>因此，原始对象与拷贝后的对象会共享这个引用类型的属性</p></li><li><p><strong>深拷贝</strong></p><p>复制对象的所有层级，创建完全独立的副本</p><p>如果原始对象中包含引用类型的属性，深拷贝会递归地复制这些属性所指向的对象，确保拷贝后的对象与原始对象之间完全独立，修改一个不会影响另一个</p></li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.assign()</code>方法和扩展运算符（<code>...</code>）都是用于对象克隆或者合并对象的操作，但重要的是，它们都执行的是<strong>浅拷贝</strong>，而不是深拷贝</p><blockquote><p>[!IMPORTANT]</p><p>当对象属性仅为第一层且全部为基本数据类型时，使用<code>Object.assign()</code>或扩展运算符（<code>...</code>）进行的实际上可以被视为深拷贝，因为这些基本类型的属性会被直接复制，而不是共享引用</p><p>因此，在这种特定情况下，修改拷贝对象的属性不会影响到原始对象，这表现得就像深拷贝一样</p></blockquote><p><strong><code>Object.assign()</code>与扩展运算符的共同点</strong></p><ol><li><p><strong>操作类型</strong></p><p>它们都可以用来克隆对象或合并对象</p></li><li><p><strong>拷贝方式</strong></p><p>它们都是浅拷贝。在拷贝过程中，对象的第一层属性会被复制到新对象中</p><p>如果属性值是引用类型，那么复制的将是这个引用，而不是引用所指向的值</p></li></ol><p><strong>不同点</strong></p><p>尽管在拷贝行为上类似，<code>Object.assign()</code>和扩展运算符在语法上还是有所差异，主要体现在用途和功能上</p><ol><li><p><strong>语法与应用场景</strong></p><ul><li><p><code>Object.assign(target, ...sources)</code>方法的第一个参数是目标对象，后续参数是一个或多个源对象</p><p>它会将所有源对象的可枚举和自有属性复制到目标对象</p></li><li><p>扩展运算符（<code>...</code>）用于将一个对象的所有可枚举属性，复制到了一个新的对象中</p><p>与<code>Object.assign()</code>不同，扩展运算符常用在变量解构（destructuring assignment）和数组合并等操作中</p></li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>Object.assign()</code>方法会直接修改目标对象，并返回这个修改后的目标对象</li><li>使用扩展运算符创建的是一个新对象，源对象保持不变</li></ul></li><li><p><strong>表达式简洁性</strong>：</p><ul><li>扩展运算符在写法上更为简洁，尤其是在需要克隆对象或与其他操作（如解构赋值）结合时</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：对window-requestAnimationFrame-的理解"><a href="#Q33：对window-requestAnimationFrame-的理解" class="headerlink" title="Q33：对window.requestAnimationFrame 的理解"></a>Q33：对window.requestAnimationFrame 的理解</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>window.requestAnimationFrame()</code> 是一种高效率的，专门为浏览器绘制动画设计的方法</p><p>相比之下，传统的 <code>setTimeout</code> 和 <code>setInterval</code> 方法不够精确和平滑，而且通常会耗费更多的CPU资源</p><p>以下是<code>window.requestAnimationFrame()</code>的一些要点：</p><ol><li><p>精准的帧控制</p><p><code>requestAnimationFrame()</code>方法可以让浏览器在每次重绘之前调用指定的函数，这意味着你的动画将尽可能平滑</p><p>而且这个函数的调用频率会自动调整为适合浏览器以及设备的最佳显示效果，一般而言，这个频率是每秒60次，也就是60帧</p></li><li><p>CPU和电池友好</p><p>requestAnimationFrame()<code>在未激活的标签页，隐藏的iframe中会被暂停，这对于未处于聚焦状态的标签页十分有用</code> </p><p><code>在这种情况下，动画将不会浪费CPU进行渲染</code></p><p><code>因此，</code>requestAnimationFrame()` 在使用起来更加省电，同时也不会因动画导致风扇过度运转</p></li><li><p>使用方式</p><p>调用 <code>requestAnimationFrame()</code> 需要传入一个函数作为参数，这个函数会在下次重绘之前调用</p><p>更常见的是在调用的函数内部继续递归调用 <code>requestAnimationFrame()</code>，以此创建一个动画循环</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是你的动画代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据动画的情况来决定是否需要继续下一帧的动画</span></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始动画</span></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>animate()</code> 函数会在浏览器每次重绘时被调用，从而实现了一个连续的动画效果</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：Object-defineProperty与-Proxy-的区别"><a href="#Q34：Object-defineProperty与-Proxy-的区别" class="headerlink" title="Q34：Object.defineProperty与 Proxy 的区别"></a>Q34：Object.defineProperty与 Proxy 的区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.defineProperty</code> 和 <code>Proxy</code> 都可以用来监视和干预对象的操作，但二者有一些重要区别</p><ol><li><p><strong>Object.defineProperty</strong></p><p><code>Object.defineProperty</code> 方法用于在对象上定义新属性，或者修改对象上的现有属性，然后返回对象</p><p>通过它可以精确地添加或修改对象的属性</p><p>你可以控制这些属性的值，是否可枚举，是否可配置，是否可写，甚至可以定义 get 和 set 函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;property&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">value</span>)&#123;...&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然而，<code>Object.defineProperty</code> 有一些限制：</p><ul><li>它只能监视单个对象上的单个属性，这就意味着如果你想监视多个属性或者整个对象，你需要手动为每个属性调用 <code>Object.defineProperty</code></li><li>它无法监视数组的变化</li><li>它无法监视对象属性的创建和删除</li></ul></li><li><p><strong>Proxy</strong></p><p><code>Proxy</code> 可以在 JavaScript 的许多对象操作中进行拦截，这使得它更加强大和灵活</p><p>它可以用来创建对象的代理，这些代理可以自定义原对象的行为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property, receiver</span>) &#123;...&#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>) &#123;...&#125;</span><br><span class="line">  <span class="comment">// 更多的 handler</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 相对 <code>Object.defineProperty</code> 的优点是：</p><ul><li><p><code>Proxy</code> 可以拦截并自定义更多的对象操作，不仅仅是属性访问</p><p>例如，<code>Proxy</code> 可以监视属性查询、赋值、删除，函数调用，对象构造等等</p></li><li><p><code>Proxy</code> 可以监视整个对象，而无需为每个属性单独设置</p></li><li><p><code>Proxy</code> 可以监视数组操作</p></li></ul><p>然而，<code>Proxy</code> 的兼容性不如 <code>Object.defineProperty</code>，在不支持 <code>Proxy</code> 的环境中无法使用</p></li></ol><p>最后，选择使用哪一个取决于你的具体需求和目标环境</p><p>如果需要更精细的控制或者操作更复杂的功能，<code>Proxy</code> 是一个更好的选择</p><p>但如果你只需要基本的属性监视，并且需要更好的兼容性，那么 <code>Object.defineProperty</code> 就足够了</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：ES6中的-Reflect-对象有什么用"><a href="#Q35：ES6中的-Reflect-对象有什么用" class="headerlink" title="Q35：ES6中的 Reflect 对象有什么用"></a>Q35：ES6中的 Reflect 对象有什么用</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>ES6（ECMAScript 2015）引入了<code>Reflect</code>对象，它为某些通常由操作符完成的操作提供新的函数式API</p><p><code>Reflect</code>对象提供了一系列静态方法，这些方法与<code>Proxy</code>对象的处理程序方法对应</p><p>这些方法的用途主要分为几个方面：</p><ol><li><p><strong>操作对象</strong></p><p><code>Reflect</code>提供了用于执行JavaScript对象基本操作的方法，例如属性的获取、设置、删除，属性描述符的获取，以及对象的扩展等</p><p>这些方法基本上与<code>Object</code>的相应方法功能相同，但用法略有不同</p><p>例如，<code>Reflect.get</code>、<code>Reflect.set</code>、<code>Reflect.deleteProperty</code>、<code>Reflect.getOwnPropertyDescriptor</code>等</p></li><li><p><strong>改善与代理（Proxy）对象的交互</strong></p><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的捕获器（trap）功能相对应</p><p>代理对象可以拦截并重定义基本语言操作（如读取属性、赋值、函数调用等）</p><p><code>Reflect</code>的方法可以在捕获器内部被调用，以实现默认行为</p><p>例如，当你在<code>Proxy</code>的<code>get</code>捕获器中需要获取一个属性的值时，可以使用<code>Reflect.get</code>来做到这一点</p></li><li><p><strong>提供更可靠的函数式API</strong></p><p>与直接使用操作符或全局函数不同，<code>Reflect</code>的方法总是期望对象作为它的第一个参数，这意味着它们能够在非对象值上抛出可预见的错误，而不是静默失败或者抛出非常不清晰的错误</p><p>这对于编写更加清晰、容错的代码非常有帮助</p></li><li><p><strong>动态地调用函数</strong></p><p><code>Reflect.construct</code>方法允许你动态地调用一个构造函数，类似于<code>new</code>操作符的作用，但提供了更多的灵活性</p><p><code>Reflect.apply</code>方法则允许动态地调用函数，这类似于<code>Function.prototype.apply</code>的作用，但用法更为简洁</p></li></ol><p>通过以上介绍，可以看出<code>Reflect</code>对象的引入主要是为了提供一种更规范、功能更强大且易于理解的方式来处理JavaScript中的基本操作，以及改善与<code>Proxy</code>对象的协同工作，使得元编程（metaprogramming）在JavaScript中变得更加容易和可控</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：详细的介绍一下ES6里面的迭代器"><a href="#Q36：详细的介绍一下ES6里面的迭代器" class="headerlink" title="Q36：详细的介绍一下ES6里面的迭代器"></a>Q36：详细的介绍一下ES6里面的迭代器</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在 ES6 (ECMAScript 2015) 中，迭代器（Iterator）是一个新引入的概念，它为创建和工作 with 集合（如数组、对象、集合 或其他可迭代的数据类型）提供了一种更一致、更简洁的方式</p><p>迭代器是一个对象，它提供了一个<code>next()</code> 方法，可以返回序列中的下一个元素</p><p>这个<code>next()</code> 方法返回一个包含两个属性的对象：<code>value</code> 和 <code>done</code>。<code>value</code> 属性表示当前的值，而 <code>done</code> 属性是一个布尔值，当没有更多的数据可供迭代时，其值为 <code>true</code></p><p>这是一个简单的迭代器例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterator = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>],</span><br><span class="line">  <span class="attr">currentIndex</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">currentIndex</span>++,], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;apple&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;orange&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;banana&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myIterator.<span class="title function_">next</span>().<span class="property">done</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 ES6 中，引入了一个叫做 <code>Iterable</code> 的协议</p><p>如果一个对象实现了 <code>Iterable</code> 接口（即该对象（或其原型链中的某个对象）包含一个名为 <code>Symbol.iterator</code> 的方法），那么它就可以被 <code>for...of</code> 循环遍历</p><p>Symbol.iterator` 方法应该返回一个迭代器对象</p><p>例如，数组就是一个内置的可迭代对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arrIterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;apple&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;orange&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">value</span>);  <span class="comment">// &#x27;banana&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrIterator.<span class="title function_">next</span>().<span class="property">done</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>此外，以新的 <code>Map</code> 和 <code>Set</code> 对象，以及新的字符串方法、<code>Array.from()</code> 和展开运算符等，这些新功能的引入，都依赖于 <code>Iterable</code> 和 <code>Iterator</code> 概念</p><p>通过迭代器，JavaScript开发者可以创建自定义的迭代逻辑，或者工作 with 一些可能不支持直接迭代的数据结构</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：forEach能不能用await"><a href="#Q37：forEach能不能用await" class="headerlink" title="Q37：forEach能不能用await"></a>Q37：forEach能不能用await</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>forEach</code>方法本身不能直接与<code>await</code>一起使用来实现数组中每个异步操作的顺序执行</p><p>这是因为<code>forEach</code>仅为数组中的每个元素执行提供的函数，但不会等待异步操作完成</p><p>如果在<code>forEach</code>的回调函数中使用<code>await</code>，它将不会按期望的方式工作，因为<code>forEach</code>不会等待异步操作完成，而是会立即继续执行下一个循环迭代</p><p>如果你需要按顺序等待每个异步操作完成，你可以使用<code>for...of</code>循环代替<code>forEach</code></p><p>在<code>for...of</code>循环中，你可以直接使用<code>await</code>等待每个异步操作：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFunction</span> = <span class="keyword">async</span> (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟异步操作</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sequentialAsync</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">asyncFunction</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sequentialAsync</span>();</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>asyncFunction</code>将会为数组中的每个元素依次被调用，并且每次调用都会等待前一个异步操作完成后才继续</p><p>这与直接在<code>forEach</code>中使用<code>await</code>达不到的效果是不同的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：为什么部分请求中，参数需要使用encodeURlComponent-进行转码"><a href="#Q38：为什么部分请求中，参数需要使用encodeURlComponent-进行转码" class="headerlink" title="Q38：为什么部分请求中，参数需要使用encodeURlComponent 进行转码"></a>Q38：为什么部分请求中，参数需要使用encodeURlComponent 进行转码</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在发送HTTP请求时，URL通常具有一定的格式和限制，这是由URI（统一资源标识符）标准规定的</p><p>如果请求的URL包含某些特殊字符，可能会影响URL的解析，导致请求无法正确处理，或者服务器解释请求参数的方式不正确</p><p>为了确保URL的特殊字符被正确地传输和接收，这些字符需要进行编码</p><p><code>encodeURIComponent</code> 函数用于对统一资源标识符（URI）的组成部分进行编码，以下是一些关键点解释为什么在某些情况下需要使用这个函数：</p><ol><li><p><strong>特殊字符</strong></p><p>URL中只允许一小部分字符的直接使用，如字母、数字和一些符号（<code>- _ . ~</code>）。其他字符，如空格 (), 冒号 (<code>:</code>), 斜杠 (<code>/</code>), 问号 (<code>?</code>), 和号 (<code>&amp;</code>), 等在URI中有特殊含义，所以它们必须被编码。</p></li><li><p><strong>保留字符</strong></p><p>即使某些字符在URI中是允许的，它们也可能有特殊的含义，比如<code>?</code>和<code>#</code>分别用于指示查询字符串开始和锚点的开始</p><p>如果你的参数值中包含了这样的字符，并且它们的意图并不是作为URL的这些特定部分，那么必须对它们进行编码</p></li><li><p><strong>不可见字符</strong></p><p>如空格在URL中不可见，或者在URL环境中无法直观理解，因此将它们转换为%20这样的编码很重要</p></li><li><p><strong>国际化内容</strong></p><p>对于非ASCII字符（如中文、阿拉伯文、俄文等），以及一些符号，如货币符号，也需要进行编码以确保它们能够正确传输</p></li><li><p><strong>服务器解析</strong></p><p>如果没有正确编码，服务器可能会错误地解析URL，或者甚至完全不接受这样的请求，因为它可能被视为不安全或无效的</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：Object-create跟new什么区别"><a href="#Q39：Object-create跟new什么区别" class="headerlink" title="Q39：Object.create跟new什么区别"></a>Q39：Object.create跟new什么区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><code>Object.create()</code> 和 <code>new</code> 关键字在JavaScript中都用于创建新的对象，但是它们在如何创建对象以及这些对象的性质方面有本质的区别：</p><ol><li><p><strong>原型链</strong>:</p><ul><li><p><code>Object.create(obj)</code></p><p>会创建一个新的对象，其原型指向你传递给它的对象<code>obj</code></p><p>这意味着新创建的对象将继承<code>obj</code>中的所有属性和方法</p></li><li><p><code>new Constructor()</code></p><p>会创建一个新的对象，并将这个对象的原型指向构造函数的<code>prototype</code>对象</p><p>该对象接着通过构造函数初始化，这通常意味着它会具有构造函数中定义的属性和方法，不过原型链上的属性和方法也会被继承</p></li></ul></li><li><p><strong>属性初始化</strong>:</p><ul><li><p><code>Object.create(obj)</code></p><p>不会自动调用构造器</p><p>如果有第二个参数，你可以为新对象定义额外的属性</p></li><li><p><code>new Constructor()</code></p><p>会执行构造函数，构造函数中的代码通常会初始化对象的属性</p></li></ul></li><li><p><strong>用法区别</strong>:</p><ul><li><code>Object.create(null)</code>可以创建一个干净的对象，它没有原型链，连基本的Object方法如<code>.toString()</code>等都不会继承</li><li><code>new Object()</code> 或者 <code>new Constructor()</code> 创建的对象，其原型至少会继承自<code>Object.prototype</code>，除非在构造函数中显式更改原型</li></ul></li></ol><p>举个例子来说明两者的使用差异：</p><p>假设我们有以下的构造函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>new</code>关键字创建的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">person1.<span class="title function_">greet</span>(); <span class="comment">// 输出: &quot;Hello, my name is Alice.&quot;</span></span><br></pre></td></tr></table></figure><p>这里，<code>person1</code>会继承<code>Person</code>的构造函数中的属性和<code>Person.prototype</code>中定义的方法。</p><p>使用<code>Object.create()</code>创建的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(person2, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">person2.<span class="title function_">greet</span>(); <span class="comment">// 输出: &quot;Hello, my name is Bob.&quot;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，<code>person2</code>直接继承自<code>Person.prototype</code></p><p>注意，我们需要显式地调用<code>Person</code>构造函数来初始化<code>person2</code>对象的<code>name</code>属性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：箭头函数跟普通函数之间的区别"><a href="#Q40：箭头函数跟普通函数之间的区别" class="headerlink" title="Q40：箭头函数跟普通函数之间的区别"></a>Q40：箭头函数跟普通函数之间的区别</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>箭头函数与传统的函数声明（function declaration）或函数表达式（function expression）在几个关键方面有所不同：</p><ol><li><p><strong><code>this</code>关键字的绑定</strong>：</p><ul><li><p>箭头函数</p><p>箭头函数不创建自己的<code>this</code>绑定。它们的<code>this</code>值继承自包裹它们的上下文</p><p>这使得箭头函数特别适合非方法的函数和回调，比如setTimeout</p></li><li><p>普通函数</p><p>传统函数和构造函数会为其内部代码块创建一个新的<code>this</code>上下文，通常，如果一个函数被作为一个对象的方法来调用，<code>this</code>就会引用那个对象</p><p>如果是在非严格模式下独立调用函数，<code>this</code>将会是全局对象（通常是<code>window</code>）</p><p>在严格模式下，<code>this</code>将是<code>undefined</code></p></li></ul></li><li><p><strong>是否可以用作构造函数</strong>：</p><ul><li><p>箭头函数</p><p>不能被用作构造函数，调用<code>new</code>会抛出错误</p></li><li><p>普通函数</p><p>可以使用<code>new</code>关键字来调用，并创建新的对象实例</p></li></ul></li><li><p><strong><code>arguments</code>对象</strong>：</p><ul><li><p>箭头函数</p><p>没有自己的<code>arguments</code>对象，只能访问包含它的普通函数的<code>arguments</code></p></li><li><p>普通函数</p><p>有自己的<code>arguments</code>对象，包含了被调用时传递的所有参数</p></li></ul></li><li><p><strong>语法简洁性</strong>：</p><ul><li><p>箭头函数</p><p>有更简洁的语法，没有<code>function</code>关键字，并且可以简化单个表达式的返回：<code>param =&gt; param + 1</code></p></li><li><p>普通函数</p><p>需要<code>function</code>关键字，并且需要<code>return</code>语句来返回结果（除非函数体指定为<code>{}</code>，在这种情况下，函数不返回任何内容）</p></li></ul></li><li><p><strong>函数名</strong>：</p><ul><li><p>箭头函数</p><p>通常是匿名的，除非它们被赋值给一个变量</p></li><li><p>普通函数</p><p>函数声明会创建一个具有其名称的函数，而函数表达式则是匿名的，除非它们被赋值给一个变量</p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q41：Websocket中的心跳是为了解决什么问题"><a href="#Q41：Websocket中的心跳是为了解决什么问题" class="headerlink" title="Q41：Websocket中的心跳是为了解决什么问题"></a>Q41：Websocket中的心跳是为了解决什么问题</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Websocket中的心跳机制主要用于解决以下几个问题：</p><ol><li><p><strong>维护连接状态</strong></p><p>在基于TCP的长连接如Websocket中，双方在建立连接后，如果一段时间内没有任何数据传输，那么网络设备（如路由器等）可能会认为连接已经不再使用，从而将其断开</p><p>通过在连接上定期发送心跳消息，可以让网络设备知道这个连接仍然在使用中，从而避免被断开</p></li><li><p><strong>检测网络故障</strong></p><p>如果一个连接在设定的时间间隔内没有收到心跳消息，可以认为连接可能已经不可用了</p><p>可以启用一些恢复机制，如尝试重新连接，或者报告错误</p></li><li><p><strong>检测对端是否存活</strong></p><p>如果Websocket的服务端或客户端崩溃或者处于非响应状态，对端是无法立即知道这个情况的</p><p>通过心跳机制，如果在规定时间内没有收到心跳回应，对端可以判断出网络对端可能已经不可用</p></li><li><p><strong>与服务器同步</strong></p><p>在某些场景下，也能利用心跳来进行时间同步或者执行定时任务</p><p>比如，客户端可以根据每次收到服务器心跳的时间，来校准自己的计时器</p></li></ol><p>心跳机制是网络编程中常见的技巧，它可以帮助软件更好地处理网络状态的变化，让软件运行得更加健壮</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：Axios的原理是什么"><a href="#Q42：Axios的原理是什么" class="headerlink" title="Q42：Axios的原理是什么"></a>Q42：Axios的原理是什么</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>Axios 是一个基于Promise用于浏览器和node.js的HTTP客户端，它提供了一套简洁的API用于处理XmlHttpRequests（浏览器环境）和http请求（node.js环境）</p><p>一些核心原理和特性：</p><ol><li><strong>请求和响应拦截器（Interceptors）</strong><ul><li>Axios 允许在请求或响应被 then 或 catch 处理之前拦截它们</li><li>实现方式是通过维护一个拦截器管理对象，管理用于处理请求和响应的拦截函数</li></ul></li><li><strong>适配器（Adapters）</strong><ul><li>Axios 使用适配器模式来定义对不同环境下发送HTTP请求的具体实现</li><li>在浏览器中使用XMLHttpRequest对象发送请求，在Node.js中使用HTTP模块</li></ul></li><li><strong>请求取消（Cancellation）</strong><ul><li>Axios 提供了取消请求的功能，让你可以使用取消令牌来中断HTTP请求</li><li>实现是基于<code>AbortController</code> 接口，这是一个 Web 标准，可以配合原生的 <code>fetch</code> 使用</li></ul></li><li><strong>错误处理（Error Handling）</strong><ul><li>Axios 在请求发生任何错误时，返回Promise的拒绝（reject）状态，并提供详细的错误信息</li></ul></li><li><strong>转换请求和响应数据（Transforming）</strong><ul><li>在请求或响应被 then 或 catch 处理之前，可以通过转换函数修改请求或响应数据</li></ul></li><li><strong>自动转换JSON数据</strong><ul><li>在发送请求时，如果数据类型是对象，Axios 会自动转换为JSON字符串</li><li>在接收响应数据时，如果发现响应的<code>Content-Type</code>是<code>application/json</code>，Axios 会尝试将字符串转换成JSON对象</li></ul></li></ol><p>待补充手写实现简易版<code>Axios</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：try…catch代码是否有问题"><a href="#Q43：try…catch代码是否有问题" class="headerlink" title="Q43：try…catch代码是否有问题"></a>Q43：try…catch代码是否有问题</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个代码有问题吗？如果有问题，应该怎么修改</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>这段代码有问题。原因在于JavaScript的错误处理机制和异步行为之间的交互</p><p>在 JavaScript 中，<code>try-catch</code> 结构只能捕获同步代码中的异常，因此，既不能捕获<code>setTimeout</code> 也不能捕获 <code>Promise</code> 中的错误，这是因为它们都是异步的</p><p>换句话说，<code>try-catch</code> 块在事件队列中添加的函数（异步函数）执行时已经退出了</p><p>解决这个问题的方法是在异步代码自身内部处理错误</p><p>确认要捕获每个可能抛出错误的 Promise，并对 <code>setTimeout</code> 异步代码进行适当的错误处理</p>
              </div>
            </details>
<p><br/></p>
<h1 id="代码运行题"><a href="#代码运行题" class="headerlink" title="代码运行题"></a>代码运行题</h1><p>查看本题需要严格学习<strong>概念Q12、Q19、Q26</strong></p>
<h3 id="Q1：Promise-1-输出结果"><a href="#Q1：Promise-1-输出结果" class="headerlink" title="Q1：Promise(1)输出结果"></a>Q1：Promise(1)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在浏览器环境中，Promise 的执行顺序是通过事件循环（Event Loop）和微任务队列来进行的。让我详细解释一下这段代码在浏览器中的执行过程：</p><ol><li><p><strong>第一个Promise链：</strong></p><ul><li><p>```<br>Promise.resolve().then(() =&gt; { console.log(0); return Promise.resolve(4); })</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     ：</span><br><span class="line"></span><br><span class="line">     - `console.log(0)` 输出 0，然后创建一个新的Promise。</span><br><span class="line">     - `return Promise.resolve(4);` 返回一个Promise，但它的微任务（Promise Resolution）被添加到微任务队列中。</span><br><span class="line">     - `.then((res) =&gt; &#123; console.log(res); &#125;)` 中的微任务被添加到微任务队列中。</span><br><span class="line"></span><br><span class="line">2. **第二个Promise链：**</span><br><span class="line"></span><br><span class="line">   - ```</span><br><span class="line">     Promise.resolve().then(() =&gt; &#123; console.log(1); &#125;)</span><br></pre></td></tr></table></figure><p>：</p><ul><li><code>console.log(1)</code> 输出 1，然后将微任务添加到微任务队列。</li></ul></li><li><p>后续的 <code>.then</code> 语句按顺序执行，每个 <code>.then</code> 中的 <code>console.log</code> 语句被添加到微任务队列中。</p></li></ul></li></ol><p>微任务队列是在当前事件循环结束后执行的，确保微任务按照它们被添加的顺序执行。所以，整体的执行顺序如下：</p><ol><li>执行 <code>console.log(0)</code>，输出 0。</li><li>将第一个 <code>.then</code> 中的 <code>return Promise.resolve(4);</code> 返回的Promise的微任务添加到微任务队列。</li><li>执行 <code>console.log(1)</code>，输出 1。</li><li>执行 <code>.then(() =&gt; { console.log(2); })</code> 的微任务，输出 2。</li><li>执行 <code>.then(() =&gt; { console.log(3); })</code> 的微任务，输出 3。</li><li>执行 <code>return Promise.resolve(4);</code> 返回的Promise的微任务，输出 4。</li><li>执行 <code>.then((res) =&gt; { console.log(res); })</code> 的微任务，输出 4。</li><li>执行 <code>.then(() =&gt; { console.log(5); })</code> 的微任务，输出 5。</li><li>执行 <code>.then(() =&gt; { console.log(6); })</code> 的微任务，输出 6。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：this指向（1）输出结果"><a href="#Q2：this指向（1）输出结果" class="headerlink" title="Q2：this指向（1）输出结果"></a>Q2：this指向（1）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line"> <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 <code>obj.print</code> 方法内部，有一个函数 <code>a</code>。在 JavaScript 中，函数内部的 <code>this</code> 默认指向全局对象（在浏览器中是 <code>window</code>）。因此，在函数 <code>a</code> 内部的 <code>console.log(this.name)</code> 中，<code>this.name</code> 实际上是访问了全局变量 <code>name</code>，其值为 <code>&#39;123&#39;</code>。</p><p>如果你想在函数 <code>a</code> 中访问到 <code>obj</code> 的 <code>name</code> 属性，可以使用箭头函数，因为箭头函数的 <code>this</code> 不会被重新绑定，而是沿用外层的 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line"> <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>(); <span class="comment">// 输出 &#x27;456&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个修改后的代码中，箭头函数 <code>a</code> 中的 <code>this</code> 将指向外部函数 <code>print</code> 的 <code>this</code>，因此能够正确地访问到 <code>obj</code> 的 <code>name</code> 属性</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码会输出 <code>&#39;123&#39;</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：类型判断（1）输出结果"><a href="#Q3：类型判断（1）输出结果" class="headerlink" title="Q3：类型判断（1）输出结果"></a>Q3：类型判断（1）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>typeof typeof typeof null</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li><code>typeof null</code> 返回 <code>&#39;object&#39;</code>，因为在 JavaScript 中 <code>null</code> 被认为是一个空的对象引用。</li><li>然后，<code>typeof &#39;object&#39;</code> 返回 <code>&#39;string&#39;</code>，因为 <code>&#39;object&#39;</code> 是一个字符串。</li><li>最后，<code>typeof &#39;string&#39;</code> 返回 <code>&#39;string&#39;</code>。</li></ul><p>所以，这个表达式的输出是 <code>&#39;string&#39;</code>。</p></li><li><p><code>typeof console.log(1)</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li><code>console.log(1)</code> 执行后，会先输出 <code>1</code> 到控制台，然后 <code>console.log</code> 返回 <code>undefined</code>。</li><li>接着，<code>typeof undefined</code> 返回 <code>&#39;undefined&#39;</code>。</li></ul><p>所以，这个表达式的输出是 <code>&#39;undefined&#39;</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>两个表达式的输出分别是 <code>&#39;string&#39;</code> 和 <code>&#39;undefined&#39;</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：变量提升（1）运行题"><a href="#Q4：变量提升（1）运行题" class="headerlink" title="Q4：变量提升（1）运行题"></a>Q4：变量提升（1）运行题</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码使用了自执行的匿名函数，并在函数内部声明了一个同名的函数 <code>b</code>。由于 JavaScript 具有变量提升，函数声明会被提升到作用域的顶部，因此这段代码的执行结果可能会令人困惑。</p><p>让我们来详细分析：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li><code>var b = 10;</code> 定义了全局变量 <code>b</code>，其值为 <code>10</code>。</li><li><code>(function b(){ ... })();</code> 创建了一个自执行的匿名函数，并在函数内部声明了一个同名的函数 <code>b</code>。这个函数 <code>b</code> 的作用域仅限于自执行函数内部。</li><li>在函数内部，<code>b = 20;</code> 尝试给函数 <code>b</code> 赋值为 <code>20</code>。然而，由于函数声明提升，这行代码实际上在执行之前已经被解释器解释为 <code>var b;</code>，因此它尝试给函数 <code>b</code> 赋值，而不是全局变量 <code>b</code>。</li><li>在 <code>console.log(b);</code> 中，输出的是自执行函数内部的 <code>b</code>，即该函数本身。因为在自执行函数内部，函数声明 <code>b</code> 会覆盖外部的全局变量 <code>b</code>。</li></ol><p>结果是，自执行函数内部的函数 <code>b</code> 被调用，输出函数本身，而全局变量 <code>b</code> 的值仍然是 <code>10</code>。这样做可能会导致混淆和不易理解的代码，通常应该避免在函数内部声明与外部变量同名的函数</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：代码结果（7）运行题"><a href="#Q5：代码结果（7）运行题" class="headerlink" title="Q5：代码结果（7）运行题"></a>Q5：代码结果（7）运行题</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span><span class="string">&#x27;,3].map(parselnt) </span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>map</code> 方法在每次迭代时会将当前元素、当前索引和数组本身作为参数传递给传入的回调函数。<code>parseInt</code> 函数接受两个参数：要转换的值和进制数。但是，<code>map</code> 方法传递的第二个参数是当前元素的索引，而不是进制数。这导致了 <code>parseInt</code> 函数的行为不同于预期。</p><p>让我们来详细解释一下每次迭代的情况：</p><ol><li>第一次迭代：<code>parseInt(&#39;1&#39;, 0)</code>，将 <code>&#39;1&#39;</code> 转换为十进制，返回 <code>1</code>。</li><li>第二次迭代：<code>parseInt(&#39;2&#39;, 1)</code>，将 <code>&#39;2&#39;</code> 转换为一进制，但是一进制无法表示 <code>&#39;2&#39;</code>，所以返回 <code>NaN</code>。</li><li>第三次迭代：<code>parseInt(&#39;3&#39;, 2)</code>，将 <code>&#39;3&#39;</code> 转换为二进制，但是二进制无法表示 <code>&#39;3&#39;</code>，所以返回 <code>NaN</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>最终的返回值是 <code>[1, NaN, NaN]</code></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>返回期望的结果 <code>[1, 2, 3]</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：this指向（2）输出结果"><a href="#Q6：this指向（2）输出结果" class="headerlink" title="Q6：this指向（2）输出结果"></a>Q6：this指向（2）输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">sayMyName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = obj.<span class="property">sayName</span></span><br><span class="line"><span class="keyword">const</span> fn2 = obj.<span class="property">sayMyName</span></span><br><span class="line"><span class="title function_">fn1</span>() </span><br><span class="line">obj.<span class="title function_">sayName</span>() </span><br><span class="line"><span class="title function_">fn2</span>() </span><br><span class="line">obj.<span class="title function_">sayMyName</span>() </span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，你定义了一个全局变量 <code>name</code> 并赋值为 <code>&#39;window&#39;</code>，然后创建了一个名为 <code>obj</code> 的对象，其中包含了两个方法 <code>sayName</code> 和 <code>sayMyName</code>。然后你将 <code>sayName</code> 方法赋值给了 <code>fn1</code> 变量，将 <code>sayMyName</code> 方法赋值给了 <code>fn2</code> 变量。</p><p>接下来，你调用了这些方法并打印出它们的执行结果。我们逐一分析：</p><ol><li><code>fn1()</code> 这里 <code>fn1</code> 是通过将 <code>obj.sayName</code> 方法赋值给变量得到的。由于函数调用时 <code>this</code> 的指向取决于调用方式，而不是定义方式，因此在这种情况下，<code>this</code> 指向全局对象（浏览器环境下是 <code>window</code>），所以打印的结果是 <code>&#39;window&#39;</code>。</li><li><code>obj.sayName()</code> 这是在 <code>obj</code> 上直接调用 <code>sayName</code> 方法，此时 <code>this</code> 指向的是 <code>obj</code> 对象，因此打印的结果是 <code>&#39;obj&#39;</code>。</li><li><code>fn2()</code> 这里 <code>fn2</code> 是通过将 <code>obj.sayMyName</code> 方法赋值给变量得到的。而箭头函数的 <code>this</code> 始终指向定义时所在的作用域，即全局作用域，在这个作用域中，<code>name</code> 变量被赋值为 <code>&#39;window&#39;</code>，因此打印的结果是 <code>&#39;window&#39;</code>。</li><li><code>obj.sayMyName()</code> 这是在 <code>obj</code> 上直接调用 <code>sayMyName</code> 方法，但是由于箭头函数的 <code>this</code> 绑定在定义时的作用域，因此此时的 <code>this</code> 也是指向的全局作用域，因此打印的结果也是 <code>&#39;window&#39;</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span></span><br><span class="line">obj</span><br><span class="line"><span class="variable language_">window</span></span><br><span class="line"><span class="variable language_">window</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：变量提升（2）运行题"><a href="#Q7：变量提升（2）运行题" class="headerlink" title="Q7：变量提升（2）运行题"></a>Q7：变量提升（2）运行题</h3><p>难度：⭐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line">var foo;</span><br><span class="line">function foo()&#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">foo = function()&#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，虽然函数 <code>foo()</code> 被声明了两次，但是 JavaScript 中的函数声明会被提升到作用域的顶部，因此函数声明会优先于变量声明。这种行为被称为“函数提升”。</p><p>下面是代码的执行过程：</p><ol><li>JavaScript 引擎首先会进行变量和函数声明的提升，将它们移动到作用域的顶部。所以，函数声明 <code>function foo()</code> 会被提升到作用域的顶部，而变量声明 <code>var foo</code> 也会被提升，但由于存在函数声明，它将被忽略。</li><li>因此，实际上代码的执行顺序会变成这样：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 此时输出 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接着，<code>foo()</code> 函数被调用，输出 1。</li><li>然后，<code>foo</code> 变量被赋值为一个新的函数，即匿名函数 <code>function() { console.log(2); }</code>。</li></ol><p>因此，最终的输出是 <code>1</code>，而不是 <code>2</code>。这是因为函数声明会在变量声明之前被处理，所以在执行时会使用函数声明定义的函数。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>输出 1</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：Promise-2-输出结果"><a href="#Q8：Promise-2-输出结果" class="headerlink" title="Q8：Promise(2)输出结果"></a>Q8：Promise(2)输出结果</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个 Promise 对象 <code>promise1</code>，然后输出了字符串 <code>&#39;1&#39;</code> 以及 <code>promise1</code> 的值。但是要注意，Promise 的构造函数中并没有调用 <code>resolve</code> 或 <code>reject</code>，所以 <code>promise1</code> 处于 pending（待定）状态。因此，即使 <code>promise1</code> 已经被创建，但其状态仍然是 pending，直到调用 <code>resolve</code> 或 <code>reject</code> 方法，Promise 的状态才会发生变化。</p><p>因此，虽然在创建 Promise 对象后立即输出 <code>promise1</code>，但它的状态仍然是 pending，因此输出的 <code>promise1</code> 可能并不包含实际的结果，而是一个 pending 状态的 Promise 对象。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：Promise-3-输出结果"><a href="#Q9-：Promise-3-输出结果" class="headerlink" title="Q9 ：Promise(3)输出结果"></a>Q9 ：Promise(3)输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码的执行过程如下：</p><ol><li>首先，定义了一个箭头函数 <code>fn</code>，该箭头函数返回一个 Promise 对象。</li><li>在箭头函数内部，立即执行了一个 Promise 构造函数，这个构造函数内部打印了 <code>1</code>，然后通过 <code>resolve</code> 方法将 Promise 的状态设置为 resolved，同时传递了 <code>&#39;success&#39;</code> 作为成功的返回值。</li><li>调用 <code>fn()</code>，这会立即执行箭头函数，而箭头函数中的 Promise 构造函数也会立即执行，因此会在控制台打印出 <code>1</code>。此时，Promise 对象被成功解决，但 <code>.then()</code> 方法尚未执行。</li><li>继续执行下一行代码，即 <code>console.log(&#39;start&#39;)</code>，打印出 <code>&#39;start&#39;</code>。</li><li>此时，整个脚本的主线程任务已经执行完毕，事件循环开始检查任务队列中是否有待执行的微任务。发现 Promise 对象的状态已经改变，并且有 <code>.then()</code> 方法注册了对应的处理函数，因此将这个微任务加入到微任务队列中。</li><li>事件循环开始处理微任务队列中的任务，执行 <code>.then()</code> 方法中的回调函数，即打印出 <code>&#39;success&#39;</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码的执行顺序是：</p><ol><li>首先打印出 <code>1</code>。</li><li>然后打印出 <code>&#39;start&#39;</code>。</li><li>最后打印出 <code>&#39;success&#39;</code>。</li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：Promise-4-输出结果"><a href="#Q10：Promise-4-输出结果" class="headerlink" title="Q10：Promise(4)输出结果"></a>Q10：Promise(4)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在给定的代码中，<code>runAsync</code> 函数会创建一个 Promise，在一秒后 resolve 该 Promise，并打印传入的参数 <code>x</code>，然后返回该 Promise。<code>Promise.all</code> 接受一个由 Promises 组成的数组作为参数，返回一个新的 Promise，当数组中所有的 Promise 都被解决时，该 Promise 也会被解决，解决值是一个数组，包含了每个 Promise 的解决值。</p><p>在这段代码中，<code>Promise.all</code> 会同时执行三个 <code>runAsync</code> 函数，每个函数都会在一秒后 resolve。然后，<code>then</code> 方法中的回调函数会在所有的 Promise 都被 resolve 后执行，并且传入的 <code>res</code> 参数是一个数组，包含了每个 Promise 的 resolve 值。</p><p>由于 <code>runAsync</code> 函数会在 resolve 时打印传入的参数 <code>x</code>，所以在输出结果中，我们会先看到 1、2、3 分别被打印出来，然后是整个数组 [1, 2, 3] 被打印出来，因为 <code>Promise.all</code> 返回的是一个包含所有 resolve 值的数组</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="meta">1, 2, 3</span>]</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：Promise-5-输出结果"><a href="#Q11：Promise-5-输出结果" class="headerlink" title="Q11：Promise(5)输出结果"></a>Q11：Promise(5)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个 Promise，Promise 的执行器函数会立即执行。在执行器函数中，首先输出 1，然后调用了 <code>resolve(&#39;success&#39;)</code>，接着输出 2。注意，调用 <code>resolve</code> 并不会立即结束 Promise 的执行器函数，后面的代码仍然会执行。</p><p>接着，创建的 Promise 对象 <code>promise</code> 会立即进入 resolved（解决）状态，并且传递了 ‘success’ 给后续的 <code>then</code> 方法。</p><p>然后，下面的 <code>then</code> 方法注册了一个回调函数，在 Promise 对象 <code>promise</code> 被 resolved 时执行。由于 Promise 已经在创建时立即 resolved，所以这个回调函数会被添加到微任务队列中，等待当前的执行栈清空后执行。在这个回调函数中，输出了 3。</p><p>最后，输出了 4。因为 JavaScript 是单线程的，代码是同步执行的，所以在执行 <code>console.log(4)</code> 之前，Promise 相关的微任务已经被添加到微任务队列中，等待执行栈清空后执行。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：Promise-6-输出结果"><a href="#Q12：Promise-6-输出结果" class="headerlink" title="Q12：Promise(6)输出结果"></a>Q12：Promise(6)输出结果</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，虽然创建了一个 Promise，但在 Promise 的执行器函数中并没有调用 <code>resolve</code> 或 <code>reject</code>，因此这个 Promise 不会进入 resolved 或 rejected 状态。因此，与该 Promise 关联的 <code>then</code> 方法中注册的回调函数也不会被执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：代码结果（1）运行题"><a href="#Q13：代码结果（1）运行题" class="headerlink" title="Q13：代码结果（1）运行题"></a>Q13：代码结果（1）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><strong>函数声明提升</strong>：<ul><li>JavaScript 中的函数声明会被提升到所在作用域的顶部，因此在函数声明之前调用函数是合法的。</li><li>因此，在执行 <code>foo(typeof a)</code> 之前，函数 <code>foo()</code> 已经被声明。</li></ul></li><li><strong>变量声明提升</strong>：<ul><li>与函数声明不同，变量声明会提升至作用域顶部，但不会被初始化，直到执行到定义的语句才会被赋值。</li><li>在函数 <code>foo()</code> 中，变量 <code>b</code> 的声明被提升到函数体的顶部，但在声明之前访问 <code>typeof b</code> 会得到 <code>undefined</code>。</li></ul></li></ol><p>因此，当执行 <code>foo(typeof a)</code> 时，会按照以下步骤执行：</p><ol><li>输出 <code>this</code>：由于 <code>foo()</code> 函数在全局作用域中调用，因此 <code>this</code> 指向全局对象（浏览器中是 <code>window</code> 对象）。</li><li>输出 <code>p</code>：<code>p</code> 的值为 <code>typeof a</code>，即字符串 <code>&quot;undefined&quot;</code>，因为在调用时变量 <code>a</code> 未定义，因此 <code>typeof a</code> 返回 <code>&quot;undefined&quot;</code>。</li><li>输出 <code>typeof b</code>：在声明 <code>let b = 0;</code> 之前访问变量 <code>b</code>，此时变量 <code>b</code> 已经被声明但尚未初始化，因此输出 <code>undefined</code>。</li><li>因为变量 <code>b</code> 是在声明之前使用，会导致 ReferenceError 错误。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window</span><br><span class="line">undefined</span><br><span class="line">ReferenceError 错误</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：代码结果（2）运行题"><a href="#Q14：代码结果（2）运行题" class="headerlink" title="Q14：代码结果（2）运行题"></a>Q14：代码结果（2）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">obj.<span class="title function_">a</span>();</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>Foo.a = function(){ console.log(4); }</code><br>这一行在函数 <code>Foo</code> 自身定义了一个静态方法 <code>a</code>。当调用 <code>Foo.a()</code> 时，它会打印 <code>4</code>。</li><li><code>Foo.a();</code><br>这行代码调用了刚刚定义的静态方法 <code>a</code>，所以它会打印 <code>4</code>。</li><li><code>let obj = new Foo();</code><br>这行代码创建了 <code>Foo</code> 的一个新实例。当使用 <code>new</code> 调用 <code>Foo</code> 函数时，它创建了一个新对象。构造函数运行，为实例设置了属性 <code>a</code>，这个属性是一个函数，当被调用时会打印 <code>2</code>。但是，<code>Foo</code> 自身的静态属性 <code>a</code> 保持不变。</li><li><code>obj.a();</code><br>这行代码调用了新对象 <code>obj</code> 上的实例方法 <code>a</code>。由于我们在构造函数中定义了 <code>this.a</code>，它会打印 <code>2</code>。</li><li><code>Foo.a();</code><br>这行代码再次调用 <code>Foo</code> 上的静态方法 <code>a</code>。由于自上次被调用以来它没有改变，它仍然会打印 <code>4</code>。</li></ol><p>在这个序列中没有使用 <code>Foo.prototype.a = function(){ console.log(3); }</code> 这个赋值，因为我们从未调用过没有自己的 <code>a</code> 属性的实例的 <code>a</code> 方法。如果我们在删除了 <code>obj</code> 自己的 <code>a</code> 属性（<code>delete obj.a;</code>）后调用 <code>obj.a()</code>，那么它会使用原型的 <code>a</code> 方法并打印 <code>3</code>。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：代码结果（3）运行题"><a href="#Q15：代码结果（3）运行题" class="headerlink" title="Q15：代码结果（3）运行题"></a>Q15：代码结果（3）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a=<span class="number">4</span>;</span><br><span class="line"> <span class="title function_">c</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，变量<code>a</code>被声明在全局作用域，并赋值为<code>3</code>。</li><li>然后，函数<code>c</code>被声明在全局作用域。当调用<code>c</code>函数时，它会弹出当前作用域链中可访问的变量<code>a</code>的值。</li><li>紧接着，一个立即执行函数表达式（IIFE）被创建并执行。在这个函数内部，又声明了一个局部变量<code>a</code>，并赋值为<code>4</code>。但是这个变量只在立即执行函数的局部作用域内有效。</li><li>在IIFE内部，我们调用了函数<code>c</code>。因为函数<code>c</code>是在全局作用域中定义的，所以当它查找变量<code>a</code>时，会沿作用域链向上查找直到全局作用域，找到全局变量<code>a</code>的值，即<code>3</code>。</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：this指向（3）输出结果"><a href="#Q16：this指向（3）输出结果" class="headerlink" title="Q16：this指向（3）输出结果"></a>Q16：this指向（3）输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.<span class="title function_">bind</span>(foo).<span class="title function_">bind</span>(sed);</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">    <span class="attr">x</span>:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = bar.<span class="title function_">bind</span>(foo).<span class="title function_">bind</span>(sed).<span class="title function_">bind</span>(fiv);</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>bind</code> 方法创建了一个新的函数，该函数的 <code>this</code> 关键字被绑定到传递给 <code>bind</code> 方法的第一个参数，并返回一个新的函数</p><p><code>bind</code> 方法还可以携带参数，这些参数将被应用到绑定函数的调用</p><p>在这个问题中，主要涉及到了 <code>bind</code> 方法的嵌套调用</p><p>需要注意的是，当你多次调用 <code>bind</code> 方法时，每次 <code>bind</code> 都会返回一个新的函数，并且绑定了第一次传递给 <code>bind</code> 的 <code>this</code> 值</p><p>后续的 <code>bind</code> 调用不会更改之前绑定的 <code>this</code> 值，因此后续传递的 <code>this</code> 值将被忽略</p><p><strong>示例分析：</strong></p><ul><li>在第一个示例中：<ul><li>首先，<code>bar.bind(foo)</code> 会创建一个新的函数，该函数的 <code>this</code> 值被绑定到 <code>foo</code></li><li>然后，再次调用 <code>bar.bind(foo).bind(sed)</code> 时，由于第一个 <code>bind</code> 已经绑定了 <code>foo</code>，第二个 <code>bind</code> 试图将 <code>this</code> 绑定到 <code>sed</code> 将被忽略，函数的 <code>this</code> 仍然保持绑定到 <code>foo</code></li><li>当 <code>func()</code> 被调用时，函数中的 <code>this.x</code> 仍然是 <code>foo.x</code>，即 <code>3</code></li></ul></li><li>在第二个示例中：<ul><li>首先，<code>bar.bind(foo)</code> 会创建一个新的函数，该函数的 <code>this</code> 值被绑定到 <code>foo</code></li><li>接着，再次调用 <code>bar.bind(foo).bind(sed)</code> 时，<code>this</code> 仍然绑定到 <code>foo</code>，而第二个 <code>bind</code> 的 <code>sed</code> 作为 <code>this</code> 参数会被忽略</li><li>再次调用 <code>bar.bind(foo).bind(sed).bind(fiv)</code> 时，<code>this</code> 仍然保持绑定到 <code>foo</code>，第三个 <code>bind</code> 的 <code>fiv</code> 作为 <code>this</code> 参数也被忽略</li><li>因此，当 <code>func()</code> 被调用时，函数中的 <code>this.x</code> 仍然是 <code>foo.x</code>，即 <code>3</code></li></ul></li></ul><p><strong>总结：</strong></p><p>在这两个示例中，由于多次 <code>bind</code> 的 <code>this</code> 值已经被绑定到最初传递的 <code>foo</code>，后续 <code>bind</code> 的 <code>this</code> 参数将被忽略</p><p>因此，无论在 <code>bar.bind(foo).bind(sed)</code> 还是 <code>bar.bind(foo).bind(sed).bind(fiv)</code> 中调用 <code>func()</code>，函数中的 <code>this</code> 值都将保持绑定到 <code>foo</code>，并且 <code>func()</code> 调用的结果将始终是输出 <code>3</code></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：Promise-7-输出结果"><a href="#Q17：Promise-7-输出结果" class="headerlink" title="Q17：Promise(7)输出结果"></a>Q17：Promise(7)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>JavaScript运行时包括一个包含消息队列的事件循环和一个微任务队列</p><p><code>async/await</code>和<code>Promise</code>相关的回调会进入微任务队列，而像<code>setTimeout</code>这样的函数设置的回调会进入消息队列</p><p>微任务队列在每次事件循环迭代的末尾执行，而消息队列中的事件则需要等到下一个迭代</p><p>根据这个信息，我们可以确定代码的输出顺序：</p><ol><li>首先，<code>async1</code>函数被调用，打印 <code>&quot;async1 start&quot;</code></li><li>然后，<code>async1</code>函数中调用<code>await async2()</code>。<code>async2</code>函数被调用</li><li>在<code>async2</code>函数中，<code>setTimeout</code>将<code>console.log(&#39;timer2&#39;)</code>回调排入消息队列</li><li>然后，<code>async2</code>继续执行，打印 <code>&quot;async2&quot;</code></li><li><code>async2</code>执行完毕，控制权返回到<code>async1</code>，但是<code>async1</code>中<code>await</code>之后的代码需要等待微任务队列中的所有任务完成后才能执行</li><li><code>async1</code>函数暂停执行，事件循环继续，执行全局的<code>setTimeout</code>，将<code>console.log(&#39;timer3&#39;)</code>排入消息队列</li><li>然后，全局上下文中的最后一条语句<code>console.log(&quot;start&quot;)</code>被执行</li><li>此时，主线程代码执行完毕，事件循环开始处理微任务队列。<code>async1</code>中<code>await</code>之后的代码<code>console.log(&quot;async1 end&quot;)</code>被执行</li><li><code>async1</code>中的<code>setTimeout</code>将<code>console.log(&#39;timer1&#39;)</code>排入消息队列</li><li>主线程代码和微任务队列都清空后，事件循环开始处理消息队列中的宏任务，按照它们被添加到队列的顺序执行。首先是<code>timer2</code>的回调，打印 <code>&quot;timer2&quot;</code></li><li>接下来是<code>timer3</code>的回调，打印 <code>&quot;timer3&quot;</code></li><li>最后是<code>timer1</code>的回调，打印 <code>&quot;timer1&quot;</code></li></ol><p>所以，输出的顺序将是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure><p>请注意，虽然<code>setTimeout</code>的延时被设置为0，它仍然会在当前执行堆栈清空后的下一个事件循环迭代中执行</p><p>这意味着<code>async/await</code>和其他同步代码总是先于<code>setTimeout</code>回调执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：Promise-8-输出结果"><a href="#Q18：Promise-8-输出结果" class="headerlink" title="Q18：Promise(8)输出结果"></a>Q18：Promise(8)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">runReject</span>(<span class="number">0</span>), <span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runAsync</span>(<span class="number">2</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>)])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result: &quot;</span>, res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err));</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是一个 JavaScript 的 Promise 相关的示例，它创建了两个异步函数 <code>runAsync</code> 和 <code>runReject</code>，然后使用 <code>Promise.race()</code> 方法来竞争它们的执行</p><p>逐步拆解这段代码，并解释其输出顺序：</p><ol><li><code>runAsync</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 resolve 这个 Promise，并打印参数 <code>x</code> 的值</li><li><code>runReject</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 reject 这个 Promise，并打印一个错误信息以及参数 <code>x</code> 的值</li><li><code>Promise.race()</code> 方法：接受一个 Promise 数组，并返回一个新的 Promise 对象，该 Promise 对象会在数组中的任意一个 Promise 状态发生改变时立即改变</li></ol><p>现在，让我们来解释输出顺序：</p><ul><li>首先，<code>runReject(0)</code> 会立即执行，并在 0 秒后 reject，但因为 <code>setTimeout()</code> 的延迟设定为 0，所以在这个阶段并不会立即输出任何内容</li><li>然后，<code>runAsync(1)</code>、<code>runAsync(2)</code> 和 <code>runAsync(3)</code> 会同时执行，并在 1 秒、2 秒和 3 秒后分别 resolve，同时输出它们的参数值</li><li>由于 <code>Promise.race()</code> 返回的 Promise 对象会在最先解决或拒绝的 Promise 状态发生改变时立即改变，因此最终的输出将会是第一个解决的 Promise 对象的结果</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="title class_">Error</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时输出的值不是Promise.race返回的</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.race()</code> 是 JavaScript 中的一个静态方法，用于创建一个新的 Promise</p><p>该 Promise 在传入的可迭代对象中的任何一个 Promise 解决或拒绝时解决或拒绝，而不管其他 Promise 的状态如何</p><p>具体来说，<code>Promise.race()</code> 接受一个可迭代对象（通常是一个数组），并返回一个新的 Promise 对象</p><p>这个新的 Promise 对象将会在可迭代对象中的第一个 Promise 状态改变时采用该 Promise 的状态和值。如果可迭代对象为空，则返回的 Promise 将永远保持挂起状态</p><p>例如，在一个包含多个 Promise 的数组中，如果其中一个 Promise 解决或拒绝了，<code>Promise.race()</code> 返回的 Promise 将立即采用该解决或拒绝的状态和值，而不会等待其他 Promise 的解决或拒绝</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19：Promise-9-输出结果"><a href="#Q19：Promise-9-输出结果" class="headerlink" title="Q19：Promise(9)输出结果"></a>Q19：Promise(9)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span> (x) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">r</span>(x, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runReject</span> (x) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">`Error: <span class="subst">$&#123;x&#125;</span>`</span>, <span class="variable language_">console</span>.<span class="title function_">log</span>(x)), <span class="number">1000</span> * x))</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">runAsync</span>(<span class="number">1</span>), <span class="title function_">runReject</span>(<span class="number">4</span>), <span class="title function_">runAsync</span>(<span class="number">3</span>), <span class="title function_">runReject</span>(<span class="number">2</span>)])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码使用了 <code>Promise.all()</code> 方法来等待所有的 Promise 都解决（resolve）或有一个被拒绝（reject），然后返回一个包含所有 Promise 解决值的数组</p><p>现在，让我们来拆解这段代码，并解释其输出顺序：</p><ol><li><code>runAsync</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 resolve 这个 Promise，并打印参数 <code>x</code> 的值</li><li><code>runReject</code> 函数：接受一个参数 <code>x</code>，返回一个 Promise 对象，在指定的时间后 reject 这个 Promise，并打印一个错误信息以及参数 <code>x</code> 的值</li><li><code>Promise.all()</code> 方法：接受一个 Promise 数组，并返回一个新的 Promise 对象，该 Promise 对象会在数组中所有的 Promise 都解决时 resolve，或者其中任意一个被拒绝时 reject</li></ol><p>逐步详细地解释代码在浏览器中的执行过程：</p><ol><li><strong>开始执行代码</strong>：<ul><li>调用 <code>Promise.all()</code>，传入一个包含了四个 Promise 的数组：<code>[runAsync(1), runReject(4), runAsync(3), runReject(2)]</code></li><li>每个 Promise 开始执行，并且计划在一定时间后解决或拒绝</li></ul></li><li><strong>1 秒后</strong>：<ul><li><code>runAsync(1)</code> 解决并输出 1。</li><li><code>runReject(2)</code> 被拒绝并输出错误信息 “Error: 2”</li><li><code>runAsync(3)</code> 继续执行但尚未解决</li></ul></li><li><strong>2 秒后</strong>：<ul><li><code>runAsync(3)</code> 解决并输出 3</li><li><code>runReject(4)</code> 继续执行但尚未拒绝</li></ul></li><li><strong>4 秒后</strong>：<ul><li><code>runReject(4)</code> 被拒绝并输出错误信息 “4”</li></ul></li></ol><p>因此，整个执行过程如下：</p><ul><li>1 秒后输出：1（来自 <code>runAsync(1)</code>）、3（来自 <code>runAsync(3)</code>）</li><li>2 秒后输出：2（来自 <code>runReject(2)</code> 的错误信息）</li><li>4 秒后输出：4（来自 <code>runReject(4)</code> 的错误信息）</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1s后输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">// 2s后输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="number">2</span></span><br><span class="line"><span class="comment">// 4s后输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.all()</code> 是 JavaScript 中的一个静态方法，用于创建一个新的 Promise，该 Promise 在传入的可迭代对象中的所有 Promise 都解决（resolve）时才会解决，如果任何一个 Promise 被拒绝（reject）了，则该 Promise 也会被拒绝</p><p>具体来说，<code>Promise.all()</code> 接受一个可迭代对象（通常是一个数组），并返回一个新的 Promise 对象</p><p>这个新的 Promise 对象将会在传入的所有 Promise 都解决时才会解决，并且它的解决值是一个包含了所有 Promise 解决值的数组。如果传入的任何一个 Promise 被拒绝，则返回的 Promise 将立即被拒绝，其拒绝原因是第一个被拒绝的 Promise 的拒绝原因</p><p><code>Promise.all()</code> 在处理多个异步操作时非常有用，特别是当你需要等待多个异步操作都完成后才能继续执行下一步操作时</p><p>例如，你可以用它来等待多个网络请求都返回后再更新页面，或者等待多个文件的读取完成后再进行处理等</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：Promise-10-输出结果"><a href="#Q20：Promise-10-输出结果" class="headerlink" title="Q20：Promise(10)输出结果"></a>Q20：Promise(10)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  &#125;, function fail1 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail1&#x27;, err)</span><br><span class="line">  &#125;).catch(function fail2 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail2&#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>Promise.resolve()</code> 创建一个立即解决的 Promise，并进入微任务队列</li><li>由于 Promise 是立即解决的，进入微任务队列中的任务会立即执行。因此，<code>.then()</code> 方法中的回调函数会被添加到微任务队列中，等待执行</li><li>微任务队列中的任务开始执行。由于 Promise 是成功状态，所以成功的回调函数 <code>function success(res)</code> 被调用，传入的参数 <code>res</code> 是 Promise 解决的值（在这个例子中是 <code>undefined</code>）</li><li>在成功的回调函数中，<code>throw new Error(&#39;error!!!&#39;)</code> 抛出了一个错误</li><li>由于在成功的回调函数中抛出了错误，Promise 状态被改变为拒绝（rejected）。错误会被传递给下一个可用的拒绝回调函数</li><li>因为在 <code>.then()</code> 方法中提供了失败（reject）的回调函数 <code>function fail1(err)</code>，所以这个失败的回调函数被调用，并接收到抛出的错误作为参数</li><li><code>console.log(&#39;fail1&#39;, err)</code> 打印了错误信息</li><li>由于没有错误处理链继续执行，这个错误会被传递到 <code>.catch()</code> 方法中</li><li><code>.catch()</code> 方法中的回调函数 <code>function fail2(err)</code> 被调用，并接收到抛出的错误作为参数</li><li><code>console.log(&#39;fail2&#39;, err)</code> 打印了错误信息</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fail2 <span class="title class_">Error</span>: error!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：Promise-11-输出结果"><a href="#Q21：Promise-11-输出结果" class="headerlink" title="Q21：Promise(11)输出结果"></a>Q21：Promise(11)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timerStart&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timerEnd&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>new Promise(...)</code> 的代码块立即执行，创建了一个 Promise 实例。传入的函数中包含了一个异步操作，即 <code>setTimeout</code></li><li><code>console.log(1)</code> 打印了数字 1</li><li><code>setTimeout</code> 被调用，设置了一个定时器，该定时器会在 0 毫秒后执行回调函数</li><li><code>console.log(2)</code> 打印了数字 2</li><li>控制流程离开了 Promise 构造函数，继续执行下一行代码</li><li><code>console.log(4)</code> 打印了数字 4</li><li>这个时候，JavaScript 主线程中的同步代码执行完毕，事件循环开始检查是否有微任务需要执行</li><li>由于 Promise 的状态是异步确定的，它的回调函数不会立即执行，而是会被放入微任务队列中等待执行</li><li>在微任务队列中，<code>promise.then(...)</code> 中的回调函数被添加，等待执行</li><li>控制流程返回到微任务队列，开始执行微任务</li><li>执行 <code>promise.then(...)</code> 中的回调函数，传入的参数 <code>res</code> 是 Promise 解决的值（在这里是字符串 “success”）</li><li><code>console.log(res)</code> 打印了解决值 “success”</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">timerStart</span><br><span class="line">timerEnd</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：Promise-12-输出结果"><a href="#Q22：Promise-12-输出结果" class="headerlink" title="Q22：Promise(12)输出结果"></a>Q22：Promise(12)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;time&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>console.log(&#39;start&#39;)</code> 打印了字符串 <code>&#39;start&#39;</code></li><li><code>setTimeout(() =&gt; { console.log(&#39;time&#39;) })</code> 被调用，设置了一个定时器，该定时器会在默认时间后执行回调函数</li><li><code>Promise.resolve()</code> 创建了一个立即解决的 Promise，并进入微任务队列</li><li><code>console.log(&#39;end&#39;)</code> 打印了字符串 <code>&#39;end&#39;</code></li><li>控制流程离开了当前同步代码块，开始执行微任务</li><li>微任务队列中的任务开始执行，<code>.then()</code> 方法中的回调函数被添加到微任务队列中</li><li>控制流程再次回到微任务队列，开始执行微任务</li><li><code>.then()</code> 方法中的回调函数被执行，打印了字符串 <code>&#39;resolve&#39;</code></li><li>执行到这里，所有的同步代码执行完毕，事件循环开始检查是否有宏任务需要执行</li><li>定时器的回调函数被触发执行，打印了字符串 <code>&#39;time&#39;</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">resolve</span><br><span class="line">time</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：Promise-13-输出结果"><a href="#Q23：Promise-13-输出结果" class="headerlink" title="Q23：Promise(13)输出结果"></a>Q23：Promise(13)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>定义了一个名为 <code>fn</code> 的箭头函数，该函数返回一个 Promise 实例</p><p>在 Promise 构造函数中，会立即执行传入的函数，这里会打印数字 1，然后解决（resolve）Promise 并传递字符串 “success”</p></li><li><p><code>console.log(&quot;start&quot;)</code> 打印了字符串 <code>&quot;start&quot;</code></p></li><li><p>调用 <code>fn()</code>，执行函数体。这时候会执行 Promise 构造函数中的内容，打印了数字 1，并立即解决 Promise，并传递字符串 “success”</p></li><li><p><code>fn()</code> 返回的 Promise 实例进入微任务队列</p></li><li><p>控制流程离开了当前同步代码块，开始执行微任务</p></li><li><p>微任务队列中的任务开始执行，<code>.then()</code> 方法中的回调函数被添加到微任务队列中</p></li><li><p>控制流程再次回到微任务队列，开始执行微任务</p></li><li><p><code>.then()</code> 方法中的回调函数被执行，接收到解决值 <code>&quot;success&quot;</code>，然后打印了 <code>&quot;success&quot;</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line"><span class="number">1</span></span><br><span class="line">success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：Promise-14-输出结果"><a href="#Q24：Promise-14-输出结果" class="headerlink" title="Q24：Promise(14)输出结果"></a>Q24：Promise(14)输出结果</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>, promise1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>, promise2);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>promise1</code> 是通过 <code>new Promise()</code> 创建的，立即执行 Promise 构造函数中的函数体<ul><li><code>console.log(&#39;promise1&#39;)</code> 打印了字符串 <code>&#39;promise1&#39;</code></li></ul></li><li>在 <code>promise1</code> 的执行过程中，<code>resolve(&#39;resolve1&#39;)</code> 被调用，将 Promise 状态设置为 resolved，并传递了解决值 <code>&#39;resolve1&#39;</code></li><li><code>promise2</code> 是通过 <code>promise1.then()</code> 方法创建的，它绑定在 <code>promise1</code> 上。这时候，<code>promise2</code> 并不会立即执行，它会在 <code>promise1</code> 被解决后才会执行</li><li><code>console.log(&#39;1&#39;, promise1)</code> 打印了 <code>&#39;1&#39;</code> 和 <code>promise1</code>。由于 <code>promise1</code> 已经被解决，所以输出时会显示 <code>promise1</code> 的状态和解决值（状态为 resolved，解决值为 <code>&#39;resolve1&#39;</code>）</li><li><code>console.log(&#39;2&#39;, promise2)</code> 打印了 <code>&#39;2&#39;</code> 和 <code>promise2</code>。此时，<code>promise2</code> 还未被解决，因为它是由 <code>promise1.then()</code> 创建的，而 <code>promise1</code> 的状态是 resolved，但 <code>promise2</code> 的回调函数还未执行，所以 <code>promise2</code> 的状态为 pending（待定）</li><li>在微任务队列中，<code>promise1.then()</code> 中的回调函数被添加，等待执行</li><li>控制流程离开了当前同步代码块，开始执行微任务</li><li>微任务队列中的任务开始执行，<code>promise1.then()</code> 中的回调函数被执行，打印了解决值 <code>&#39;resolve1&#39;</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;promise1&#x27;</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> <span class="title class_">Promise</span>&#123;&lt;resolved&gt;: <span class="string">&#x27;resolve1&#x27;</span>&#125;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="title class_">Promise</span>&#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="string">&#x27;resolve1&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：代码结果（4）运行题"><a href="#Q25：代码结果（4）运行题" class="headerlink" title="Q25：代码结果（4）运行题"></a>Q25：代码结果（4）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;10&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，<code>map</code>函数的回调函数可以接受三个参数：当前元素、当前元素的索引和整个数组</p><p>而<code>parseInt</code>函数可以接受两个参数：一个是要解析的字符串，另一个是解析时使用的基数（进制）</p><p>当你执行<code>[&#39;10&#39;, &#39;10&#39;, &#39;10&#39;, &#39;10&#39;, &#39;10&#39;].map(parseInt)</code>时，实际上你对每个元素调用了<code>parseInt</code>函数，并传入了两个参数：元素本身和它的索引</p><p>因此，实际调用是这样的：</p><ol><li><code>parseInt(&#39;10&#39;, 0)</code> // 第一个元素，基数为0，返回10（0被当作10进制来解析）</li><li><code>parseInt(&#39;10&#39;, 1)</code> // 第二个元素，基数为1，但1不是有效基数，返回NaN</li><li><code>parseInt(&#39;10&#39;, 2)</code> // 第三个元素，基数为2，返回2（因为’10’在二进制表示为2）</li><li><code>parseInt(&#39;10&#39;, 3)</code> // 第四个元素，基数为3，返回3（因为’10’在三进制中表示为3）</li><li><code>parseInt(&#39;10&#39;, 4)</code> // 第五个元素，基数为4，返回4（因为’10’在四进制中表示为4）</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="title class_">NaN</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：代码结果（5）运行题"><a href="#Q26：代码结果（5）运行题" class="headerlink" title="Q26：代码结果（5）运行题"></a>Q26：代码结果（5）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> +<span class="number">123</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在JavaScript中，当你看到 <code>123[&quot;toString&quot;]</code> 这样的表达式时，实际上是在访问数字123的 <code>toString</code> 方法</p><p>数字字面量123被自动装箱成一个临时的 <code>Number</code> 对象，并访问其 <code>toString</code> 方法</p><p><code>123[&quot;toString&quot;].length</code> 这部分表达式求的是 <code>toString</code> 方法的 <code>length</code> 属性</p><p>在JavaScript中，函数的 <code>length</code> 属性表示该函数期望接收的参数个数</p><p><code>Number</code> 的 <code>toString</code> 方法可以接受一个可选参数，该参数指定要转换的基数，因此 <code>toString</code> 方法的 <code>length</code> 值为1</p><p>所以，<code>123[&quot;toString&quot;].length</code> 的值为1</p><p>接下来，你将这个值1与123进行加法操作</p><p>在JavaScript中，加法操作符可以用于数字的算术加法或字符串的连接。当其中一个操作数是数字而另一个是数字时，JavaScript会执行算术加法</p><p>因此，<code>123[&quot;toString&quot;].length + 123</code> 的计算过程是 <code>1 + 123</code>，结果为 <code>124</code></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">124</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：代码结果（6）运行题"><a href="#Q27：代码结果（6）运行题" class="headerlink" title="Q27：代码结果（6）运行题"></a>Q27：代码结果（6）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码创建了一个<code>for</code>循环，用于设置5个<code>setTimeout</code></p><p>每个<code>setTimeout</code>都有一个回调函数<code>timer</code>，在推迟0毫秒（实际会受到浏览器最小延时的限制）之后执行</p><p>由于<code>setTimeout</code>是异步执行的，因此所有的<code>setTimeout</code>回调都会在当前执行栈清空之后才会执行</p><p>关键点在于这里使用了<code>var</code>来声明变量<code>i</code>，而<code>var</code>声明的变量具有函数作用域，而不是块级作用域</p><p>这意味着在for循环结束时，变量<code>i</code>的值将是6（因为最后一次循环在执行<code>i++</code>后，<code>i</code>变为6且不满足<code>i &lt;= 5</code>的条件而终止循环）</p><p>当事件循环执行这些<code>setTimeout</code>回调时，它们都会访问到同一个变量<code>i</code>，而此时<code>i</code>已经是6了</p><p>因为所有的<code>setTimeout</code>都在一个事件循环队列中，因此它们并不会彼此间有任何延迟</p><p>因此，输出不会按照1到5的顺序打印，而是会打印5次6</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>解决这个问题</p><ol><li><p>闭包</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>let</code>来声明<code>i</code>（ES6）, <code>let</code>会在每次迭代的循环块中创建一个新的<code>i</code>绑定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：代码结果（8）运行题"><a href="#Q28：代码结果（8）运行题" class="headerlink" title="Q28：代码结果（8）运行题"></a>Q28：代码结果（8）运行题</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] == ![]的结果是什么</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>取反操作</p><p><code>![]</code> 首先计算右边的表达式</p><p><code>!</code> 操作符将对 <code>[]</code>（空数组）进行布尔取反操作</p><p>在JavaScript中，一个空数组是一个真值（truthy）</p><p>因此对它取反后，将得到布尔值 <code>false</code></p></li><li><p>等于操作</p><p>现在原始的比较已经变成了 <code>[] == false</code></p><p>在这个比较中，因为一边是对象（空数组）而另一边是布尔值</p><p>根据抽象相等性比较（Abstract Equality Comparison）的规则，JavaScript将尝试将这两边转换成一个共同的类型</p></li><li><p>类型转换<br><code>false</code> 需要转换为数值型以便跟数组进行比较</p><p>布尔值 <code>false</code> 转换为数字时值是 <code>0</code></p><p>这样，现在的比较变成了 <code>[] == 0</code></p></li><li><p>数组到字符串的转换</p><p>接下来，JavaScript会尝试将对象（本例中的空数组 <code>[]</code>）转换为原始值</p><p>数组对象转换为原始值时，会先转换为字符串</p><p>由于空数组转换为字符串是一个空字符串（<code>&quot;&quot;</code>），现在的比较就变成了 <code>&quot;&quot; == 0</code></p></li><li><p>字符串到数字的转换</p><p>因为另一边是数字，JavaScript会进一步将字符串转换为数字，空字符串转换为数字是 <code>0</code></p><p>最后，比较就变成了 <code>0 == 0</code></p></li><li><p>比较结果</p><p><code>0</code> 等于 <code>0</code>，这个比较的结果为 <code>true</code></p></li></ol><p>因此，最终 <code>[] == ![]</code> 的结果就是 <code>true</code>，这是由于JavaScript内部类型转换规则的结果</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：Promise-15-输出结果"><a href="#Q29：Promise-15-输出结果" class="headerlink" title="Q29：Promise(15)输出结果"></a>Q29：Promise(15)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;promise resolve&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 success&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt start&#x27;</span>)</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，执行全局代码，<code>console.log(&#39;script start&#39;)</code> 是第一个被执行的，所以首先输出 <code>script start</code></li><li>然后，遇到了异步函数 <code>async1()</code>。这是一个异步调用，但在内部 <code>console.log(&#39;async1 start&#39;)</code> 会首先同步执行，所以第二个输出 <code>async1 start</code></li><li>之后，遇到了 <code>await</code> 关键字，它会返回一个新的 Promise 对象。在这个 Promise 的执行器函数中，有一个 console.log(‘promise1’) 的同步操作，因此第三个输出 <code>promise1</code></li><li>Promise 对象在状态变更（这里是调用了 <code>resolve</code> 方法）前的代码属于微任务，在当前宏任务内执行。但由于 <code>async/await</code> 的特殊性，<code>await</code> 后面的代码 (<code>console.log(&#39;async1 success&#39;)</code>) 会被打包为一个微任务，等待当前的 Promise 状态变为 resolved 后进入微任务队列等待执行，至此当前的异步函数 <code>async1</code> 执行完毕</li><li>接着，继续执行全局代码，遇到另一处 Promise 构造，此时执行器函数内的 console.log(‘promise2’) 同步执行，所以第四个输出 <code>promise2</code></li><li>再下来遇到setTimeout，这是一个宏任务，会被派发到宏任务事件队列中，由于Javascript是单线程执行，所以需要等待前面的任务处理完毕，此处就先不输出 ‘timer’</li><li>此时，全局的同步代码执行完毕，开始执行微任务队列中的任务。第一个待执行的微任务是 <code>async1()</code> 中 <code>await</code> 后面的代码，所以第五个输出 <code>async1 success</code></li><li><code>async1()</code> 代码执行完毕后，它的 <code>.then()</code> 方法被调用，返回的结果是 <code>async1 end</code>，所以第六个输出 <code>async1 end</code></li><li>这时，微任务队列已经为空，开始执行宏任务队列中的任务，输出 <code>timer</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;srcipt start&quot;</span></span><br><span class="line"><span class="string">&quot;async1 start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;promise2&quot;</span></span><br><span class="line"><span class="string">&quot;async1 success&quot;</span></span><br><span class="line"><span class="string">&quot;async1 end&quot;</span></span><br><span class="line"><span class="string">&quot;timer&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：Promise-16-输出结果"><a href="#Q30：Promise-16-输出结果" class="headerlink" title="Q30：Promise(16)输出结果"></a>Q30：Promise(16)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 success&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt start&#x27;</span>)</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;srcipt end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，<code>console.log(&#39;script start&#39;)</code> 这行代码在全局脚本中，它将首先执行，所以输出 <code>script start</code></p></li><li><p>接着，遇到 <code>async1()</code> 函数调用</p><p>由于 <code>async1</code> 是一个异步函数，它将被立即调用，但里面的代码可能不会立即完成</p></li><li><p>进入 <code>async1()</code> 函数内部，<code>console.log(&#39;async1 start&#39;)</code> 首先被同步执行，所以会输出 <code>async1 start</code></p></li><li><p>然后，代码遇到 <code>await</code> 关键词和一个新的 Promise</p><p><code>await</code> 将暂停 <code>async1</code> 函数后面的代码执行，在这个例子中就是 <code>console.log(&#39;async1 success&#39;)</code>，直到 Promise 被解决（resolve）</p><p>此时，Promise 内部调用了 <code>console.log(&#39;promise1&#39;)</code>，所以输出 <code>promise1</code></p><p>但是这个Promise从未被解决，因为它内部没有调用resolve函数，这将影响程序的后续行为，此部分的代码输出结束在此</p></li><li><p>跳出 <code>async1()</code> 函数，回到全局执行环境，紧接着执行 <code>console.log(&#39;script end&#39;)</code>，所以接下来输出 <code>script end</code></p></li><li><p>此时，全局的同步代码已经执行完毕，但是 <code>async1()</code> 中 <code>await</code> 后面的 <code>console.log(&#39;async1 success&#39;)</code> 依赖于之前的 Promise 解决</p><p>由于该 Promise 没有解决（因为没有调用 <code>resolve</code> 或者 <code>reject</code>），它将永远挂起在那里，导致紧随其后的 <code>console.log(&#39;async1 success&#39;)</code> 和 <code>.then(res =&gt; console.log(res))</code> 都不会执行</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;srcipt start&quot;</span></span><br><span class="line"><span class="string">&quot;async1 start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;srcipt end&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：Promise-17-输出结果"><a href="#Q31：Promise-17-输出结果" class="headerlink" title="Q31：Promise(17)输出结果"></a>Q31：Promise(17)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span> () &#123;</span><br><span class="line">  <span class="comment">// return await 1234</span></span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>一个用async关键字声明的异步函数<code>fn</code>，它的功能是返回一个数值</p><p>尽管函数内有两行被注释的代码，但我们只关注未被注释的那行</p><p>这段代码在执行时的行为如下：</p><ol><li><p>函数<code>fn</code>是异步的，也就是说它返回的始终是一个<code>Promise</code>对象</p><p>由于<code>async</code>函数允许你直接返回一个值（如这里的数字123），它会自动将这个值包裹在<code>Promise.resolve</code>中，即相当于返回了<code>Promise.resolve(123)</code></p></li><li><p>当<code>fn</code>被调用时，由于其返回的是一个Promise，可以链式调用<code>.then()</code>方法处理当这个Promise被解决（resolved）时的值</p></li><li><p><code>.then()</code>中的回调函数将接收到<code>fn</code>函数返回的结果作为参数，这里是数字123</p></li><li><p><code>.then()</code>回调函数调用<code>console.log(res)</code>会将这个结果输出到控制台</p></li></ol><p>因此，整个过程结束后，控制台上会输出<code>123</code></p><p>这是因为<code>fn()</code>函数返回的Promise立即被解决了，并且有值123</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：Promise-18-输出结果"><a href="#Q32：Promise-18-输出结果" class="headerlink" title="Q32：Promise(18)输出结果"></a>Q32：Promise(18)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;我是finally2返回的值&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2后面的then函数&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>代码使用了<code>Promise.resolve</code>来创建已经解决的Promise，并使用<code>.then()</code>和<code>.finally()</code>来处理这些Promise</p><p>以下是这段代码执行时的顺序和输出分析：</p><ol><li><code>Promise.resolve(&#39;1&#39;)</code>：创建一个已经解析（resolved）的Promise对象，其解析值为字符串’1’</li><li><code>.then(res =&gt; console.log(res))</code>：<code>.then</code>方法返回一个新的Promise对象，并接受resolved值为参数的调用函数。该调用函数（匿名函数<code>res =&gt; console.log(res)</code>）会在Promise完成（resolved）时被调用，并打印出res的值，也就是打印’1’</li><li><code>.finally(() =&gt; console.log(&#39;finally&#39;))</code>：不论Promise是fulfilled还是rejected，都会执行控制台打印’finally’的操作。不过，需要注意的是，<code>finally</code>的回调函数是不接受任何参数的，不影响原有的Promise的值</li></ol><p>接下来，关于第二个Promise的执行步骤如下：</p><ol><li><code>Promise.resolve(&#39;2&#39;)</code>：创建一个已经解析（resolved）的Promise对象，其解析值为字符串’2’</li><li><code>.finally(() =&gt; console.log(&#39;finally2&#39;))</code>：同样的，不论Promise是fulfilled还是rejected，都会执行打印’finally2’的操作。并且返回了一个字符串，但这个返回值会被忽略，不会传递到下一个Promise</li><li><code>.then(res =&gt; console.log(&#39;finally2后面的then函数&#39;, res))</code>：这时，因为<code>finally</code>并没有改变值，所以这里的<code>res</code>会继承前一个Promise的解析值’2’，也就是打印出’finally2后面的then函数’后面输出的是’2’</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;finally2&quot;</span></span><br><span class="line"><span class="string">&quot;finally&quot;</span></span><br><span class="line"><span class="string">&quot;finally2后面的then函数&quot;</span> <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：Promise-19-输出结果"><a href="#Q33：Promise-19-输出结果" class="headerlink" title="Q33：Promise(19)输出结果"></a>Q33：Promise(19)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then2: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then3: &quot;</span>, res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>创建了一个新的<code>Promise</code>实例，其中传递的执行器（executor）函数是立即执行的。<ul><li>在执行器内部，首先调用<code>reject(&quot;error&quot;)</code>，这将导致Promise变为拒绝（rejected）状态，并将其理由设置为字符串<code>&quot;error&quot;</code></li><li>紧接着有一个<code>resolve(&quot;success2&quot;)</code>调用。但是，一旦Promise被拒绝或解决，它的状态就不能再改变了。因此，这行调用是没有任何效果的，所以<code>resolve</code>不会执行，Promise的拒绝理由保持为<code>&quot;error&quot;</code></li></ul></li><li>跟随这个<code>Promise</code>实例的是一个<code>.then()</code>方法的调用链，其中包含两个<code>.then()</code>和一个<code>.catch()</code><ul><li>第一个<code>.then(res =&gt; console.log(&quot;then1: &quot;, res))</code>：通常情况下，<code>.then()</code>会接收到Promise的解析值，但是由于Promise是被拒绝的，所以这个<code>.then()</code>是被跳过的</li></ul></li><li><code>.then()</code>的跳过直接导致<code>.catch(err =&gt; console.log(&quot;catch: &quot;, err))</code>的执行<ul><li><code>.catch()</code>方法是用来捕获前面<code>Promise</code>链上的错误的，由于之前的Promise已经被拒绝，并带有理由<code>&quot;error&quot;</code>，所以<code>.catch()</code>会捕获到这个拒绝，并输出<code>catch: error</code></li></ul></li><li><code>.catch()</code>后面跟着另一个<code>.then(res =&gt; console.log(&quot;then3: &quot;, res))</code><ul><li><code>.catch()</code>可以处理错误，并且也返回一个新的Promise，这个Promise默认情况下是解决状态（resolved）的，除非你在<code>.catch()</code>里再抛出错误。因为在这个场景中<code>.catch()</code>里没有抛出新的错误，所以<code>.catch()</code>之后的<code>.then()</code>得到的Promise是解决状态的</li><li>这个<code>.then()</code>没有被显式给定解析值，因为它是跟在<code>.catch()</code>后面的，所以它接收的解析值是<code>undefined</code>，因此输出<code>then3: undefined</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;catch: &quot;</span> <span class="string">&quot;error&quot;</span></span><br><span class="line"><span class="string">&quot;then3: &quot;</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：Promise-20-输出结果"><a href="#Q34：Promise-20-输出结果" class="headerlink" title="Q34：Promise(20)输出结果"></a>Q34：Promise(20)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> timer2 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>Promise.resolve().then...</code> 这是一个立即解决的 Promise，其 <code>.then()</code> 方法中的回调加入到微任务队列</p></li><li><p><code>const timer1 = setTimeout(...)</code> 定义了一个宏任务，将它放入宏任务队列中等待执行</p></li><li><p><code>console.log(&#39;start&#39;);</code> 直接执行，打印 <code>start</code></p><p>执行结果到目前为止：<code>start</code></p></li><li><p>此时，主线程的同步代码执行完成，事件循环首先检查微任务队列，遇到 <code>Promise.resolve().then...</code> 中的回调，执行它：</p><ul><li>打印 <code>promise1</code></li><li>定义并启动另一个宏任务 <code>timer2</code><br>执行结果累计：<code>start</code> → <code>promise1</code></li></ul></li><li><p>现在，微任务队列已为空，事件循环移向宏任务队列。第一个遇到的宏任务是 <code>timer1</code> 的回调：</p><ul><li>打印 <code>timer1</code></li><li>然后，<code>Promise.resolve().then...</code> 再次创建一个新的微任务，加入到微任务队列<br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code></li></ul></li><li><p><code>timer1</code> 执行结束后，再次检查微任务队列，发现刚刚添加的 <code>Promise.resolve().then...</code> 中的回调，执行它：</p><ul><li>打印 <code>promise2</code><br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code> → <code>promise2</code></li></ul></li><li><p>最后，执行 <code>timer2</code> 的回调（前面<code>timer1</code>和<code>timer2</code>由于几乎同时设定，执行顺序在某些环境下可能会有细微差别，但基于大多数实现，<code>timer1</code> 因为在代码中先出现，通常会先执行）：</p><ul><li>打印 <code>timer2</code><br>执行结果累计：<code>start</code> → <code>promise1</code> → <code>timer1</code> → <code>promise2</code> → <code>timer2</code></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="string">&quot;promise1&quot;</span></span><br><span class="line"><span class="string">&quot;timer1&quot;</span></span><br><span class="line"><span class="string">&quot;promise2&quot;</span></span><br><span class="line"><span class="string">&quot;timer2&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：Promise-21-输出结果"><a href="#Q35：Promise-21-输出结果" class="headerlink" title="Q35：Promise(21)输出结果"></a>Q35：Promise(21)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>首先，两个 <code>Promise.resolve()</code> 几乎同时执行</p><p>因为它们都是微任务，JavaScript 会在当前执行栈清空后，立即执行这些微任务</p><p>执行顺序如下：</p><ol><li>第一个 <code>.then()</code> 回调执行，打印出 <code>0</code></li><li>同时，第二个 <code>Promise.resolve().then(() =&gt; { console.log(1) })</code> 开始执行其链中的第一个 <code>.then()</code>，打印出 <code>1</code></li><li>第一个 <code>.then()</code> 回调返回了 <code>Promise.resolve(4)</code>，这个返回值会被传递给链中的下一个 <code>.then()</code>，所以接下来的 <code>.then((res) =&gt; { console.log(res) })</code> 会在微任务队列中等待执行，这里的 <code>res</code> 将是 <code>4</code></li><li>回到第二个 Promise 链，它的第二个 <code>.then()</code> 执行，打印出 <code>2</code></li><li>第二个 Promise 链的第三个 <code>.then()</code> 执行，打印出 <code>3</code></li><li>现在回到第一个 Promise 的第二个 <code>.then()</code>，它打印出之前等待的 <code>4</code></li><li>第二个 Promise 链的剩下的 <code>.then()</code> 依次执行，打印出 <code>5</code> 和 <code>6</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：this指向（4）输出结果"><a href="#Q36：this指向（4）输出结果" class="headerlink" title="Q36：this指向（4）输出结果"></a>Q36：this指向（4）输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">fn1</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),</span><br><span class="line"> <span class="attr">fn2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn1</span>();</span><br><span class="line">obj.<span class="title function_">fn2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> obj.<span class="title function_">fn1</span>();</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> obj.<span class="title function_">fn2</span>();</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>先了解箭头函数和普通函数（在此示例中用作方法）之间的区别，尤其是在它们如何处理<code>this</code>关键字方面</p><ul><li>箭头函数<strong>不</strong>绑定<code>this</code>，它们会捕获其所在上下文的<code>this</code>值作为自己的<code>this</code>值，无论是否被new调用</li><li>普通函数（使用<code>function</code>关键字定义的函数）的<code>this</code>指向调用它时的对象，或者在使用<code>new</code>构造函数时，指向新创建的对象</li></ul><p>首先，定义一个对象<code>obj1</code>，该对象有两个函数作为属性，一个是以函数表达式方式定义，一个是以箭头函数方式定义：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line"> <span class="attr">fn1</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),  <span class="comment">// 这是一个箭头函数，它不会绑定自身的this</span></span><br><span class="line"> <span class="attr">fn2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;  <span class="comment">// 这是一个普通函数，它会绑定自身的this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>obj1.fn1();</code></p><p>当你在控制台调用<code>obj1.fn1()</code>时，将会执行<code>fn1</code></p><p>由于<code>fn1</code>是一个箭头函数，它不绑定自身的<code>this</code>，<code>this</code>的值取决于定义<code>fn1</code>时的上下文</p><p>又因为<code>fn1</code>在全局作用域定义，所以在非严格模式下，<code>this</code>将指向全局对象，也就是浏览器环境下的<code>window</code>对象（严格模式下，<code>this</code>将是<code>undefined</code>）</p><p>所以第一个<code>console.log</code>将打印全局对象<code>window</code></p></li><li><p><code>obj1.fn2();</code></p><p>然后你调用<code>obj1.fn2()</code>，将会执行<code>fn2</code></p><p><code>fn2</code>是一个普通方法，当它作为对象的方法被调用时，<code>this</code>会指向调用它的对象，也就是<code>obj1</code></p><p>所以第二个<code>console.log</code>将打印出<code>obj1</code></p></li><li><p><code>const x = new obj1.fn1();</code></p><p>接下来你尝试存储一个新的<code>fn1</code>实例到<code>x</code>变量</p><p>这里会产生一个问题，因为箭头函数不能用作构造函数</p><p><code>new</code>关键字需要用在包含<code>this</code>和<code>prototype</code>的普通函数上，而箭头函数不具备这二者</p><p>所以这里会抛出一个类型错误，表明<code>obj1.fn1</code>不是构造函数</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span></span><br><span class="line">&#123;<span class="attr">fn1</span>: ƒ, <span class="attr">fn2</span>: ƒ&#125;</span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: obj.<span class="property">fn1</span> is not a constructor</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：Promise-22-输出结果"><a href="#Q37：Promise-22-输出结果" class="headerlink" title="Q37：Promise(22)输出结果"></a>Q37：Promise(22)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;async1 success&#x27;</span>) </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先定义了一个异步函数<code>async1</code>，它包含一个错误处理的<code>try...catch</code>块和一些控制台日志输出</p><p>然后执行这个异步函数并在其返回的<code>Promise</code>上附加了一个<code>.then</code>处理程序</p><p>最后，代码执行一个<code>console.log</code></p><p>现在，让我们详细了解代码的执行流程：</p><ol><li>调用<code>async1()</code>函数</li><li>控制台输出<code>&#39;script start&#39;</code></li><li>在<code>async1</code>中，异步等待(<code>await</code>)一个被拒绝(<code>reject</code>)的<code>Promise</code></li><li><code>Promise</code>被拒绝，因此错误被抛出，接着<code>catch</code>块捕获这个错误</li><li>控制台输出捕获的错误<code>&#39;error!!!&#39;</code></li><li><code>catch</code>块完成执行后，控制台输出<code>&#39;async1&#39;</code></li><li><code>async1</code>返回一个解决(<code>resolve</code>)的<code>Promise</code></li><li>最后，<code>.then</code>处理程序接收到返回的<code>Promise</code>中的值，控制台输出<code>&#39;async1 success&#39;</code></li></ol><p>这个顺序描述了异步操作的副作用和<code>.then</code>处理程序的调用顺序</p><p>由于<code>async</code>函数使得异步代码看起来像是同步的，它可以在<code>await</code>表达式上暂停执行，直到<code>Promise</code>解决或拒绝</p><p>这也是为什么即使有错误发生，<code>async1</code>之后的代码还是会执行的原因，因为错误被<code>catch</code>块捕获处理了</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">error!!!</span><br><span class="line">async1</span><br><span class="line">async1 success</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：Promise-23-输出结果"><a href="#Q38：Promise-23-输出结果" class="headerlink" title="Q38：Promise(23)输出结果"></a>Q38：Promise(23)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span> () &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这里有两个异步函数：<code>async1</code>和<code>async2</code></p><p>在函数<code>async1</code>中，有一个暂停点`await async2()``</p><p><code>`await</code>关键字使得JavaScript运行时等待直到<code>Promise settles</code>，并返回其结果</p><p>现在，让我们理解一下这段代码：</p><ol><li>调用<code>async1()</code>函数</li><li>在<code>async1</code>函数内部，执行到<code>await async2()</code>，调用<code>async2()</code>函数</li><li><code>async2</code>函数开始执行，输出 <code>async2</code> ，然后返回一个Promise对象，并且这个Promise是以错误状态结束(rejected)</li><li><code>await</code>操作在碰到rejected状态的Promise时，会抛出一场错误，并立即结束当前函数的执行</li></ol><p>在这段代码中，我们没有在<code>async1</code>函数中捕获可能发生的错误(<code>async2</code>函数返回的Promise被拒绝)，所以当<code>async2</code>返回的Promise被拒绝时，它会在<code>async1</code>函数中抛出一个错误，导致<code>async1</code>函数立即结束，而且不会输出’async1’，也不会返回’async1 success’</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async2</span><br><span class="line"><span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="string">&#x27;error&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：Promise-24-输出结果"><a href="#Q39：Promise-24-输出结果" class="headerlink" title="Q39：Promise(24)输出结果"></a>Q39：Promise(24)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testSometing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行testSometing&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;testSometing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">testAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行testAsync&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test start...&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> <span class="title function_">testSometing</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v1);</span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> <span class="title function_">testAsync</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v2);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise start...&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test end...&quot;</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>首先执行</strong> <code>test()</code> 函数，在控制台上打印 <code>&quot;test start...&quot;</code></p></li><li><p>然后进入 <code>testSomething()</code> 函数，在控制台上打印 <code>&quot;执行testSometing&quot;</code></p><p>这个函数返回一个字符串 <code>&quot;testSometing&quot;</code>，但因为是异步函数，这个返回值会被包装在一个解析的 <code>Promise</code> 对象中</p></li><li><p><strong>然后执行</strong> <code>Promise</code> 构造函数的回调，打印 <code>&quot;promise start...&quot;</code></p><p>这个 <code>Promise</code> 立即被解析为 <code>&quot;promise&quot;</code>，此时 <code>Promise</code> 的解析在任务队列中等待执行</p></li><li><p>在所有同步代码执行完成后（此时包括在 <code>test()</code> 函数外部立即执行的 <code>console.log(&quot;test end...&quot;)</code>），打印 <code>&quot;test end...&quot;</code></p></li><li><p>之后，异步函数 <code>test()</code> 再次回到执行的控制下，<code>testSomething()</code> 函数返回的结果，也就是 <code>&quot;testSometing&quot;</code> 已经准备好，打印出来</p></li><li><p>接着，<code>testAsync()</code> 函数被调用，在控制台上打印 <code>&quot;执行testAsync&quot;</code></p><p>它返回 <code>&quot;hello async&quot;</code>，这个值封装在一个Promise中，由于已经是resolve的状态，会在后面的事件循环中输出</p></li><li><p>由于我们先前的 <code>Promise</code> 已经处于解析状态，在 <code>testAsync()</code> 完成之前，任务队列中的 <code>Promise</code> 解析输出 <code>&quot;promise&quot;</code> 实际先于 <code>hello async</code> 执行</p></li><li><p>紧接着，<code>testAsync()</code> 函数返回的 <code>&quot;hello async&quot;</code> 输出到控制台</p></li><li><p>最后，打印出包含 <code>v1</code>(<code>testSometing</code>) 和 <code>v2</code>(<code>hello async</code>) 的结果</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test start...</span><br><span class="line">执行testSometing</span><br><span class="line">promise start...</span><br><span class="line">test end...</span><br><span class="line">testSometing</span><br><span class="line">执行testAsync</span><br><span class="line">promise</span><br><span class="line">hello <span class="keyword">async</span></span><br><span class="line">testSometing hello <span class="keyword">async</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：Promise-25-输出结果"><a href="#Q40：Promise-25-输出结果" class="headerlink" title="Q40：Promise(25)输出结果"></a>Q40：Promise(25)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>调用<code>async1()</code>，这个异步函数开始执行</li><li><code>&quot;async1 start&quot;</code>被打印到控制台</li><li>在<code>async1()</code>内部，<code>await async2()</code>暂停了<code>async1()</code>的进一步执行，直到<code>async2()</code>完成。接下来，<code>async2()</code>被调用</li><li><code>async2()</code>执行并立即将一个<code>setTimeout</code>计划为0毫秒后执行。这会将回调函数（打印<code>&#39;timer&#39;</code>）加入到宏任务队列中，但实际的调用会在当前执行栈清空以及当前宏任务完成之后才发生</li><li><code>&quot;async2&quot;</code>被打印到控制台，这是<code>async2()</code>内直接执行的代码</li><li><code>async2()</code>执行完成，执行权返回到<code>async1()</code>，因为<code>async1()</code>在等待<code>async2()</code></li><li>现在回到全局上下文，执行最后的<code>console.log(&quot;start&quot;)</code>，打印 <code>&quot;start&quot;</code> 到控制台</li><li>此时，当前的调用栈和宏任务队列（当前宏任务是调用<code>async1()</code>与之后的全局上下文中的代码）都已清空。JS引擎现在会从宏任务队列中取出下一个任务，也就是<code>setTimeout</code>的回调函数</li><li><code>setTimeout</code>的回调函数执行并在控制台打印出<code>&#39;timer&#39;</code></li><li><code>&quot;async1 end&quot;</code>是在<code>async2()</code>之后在<code>async1()</code>中打印的，但由于<code>async1()</code>函数内部是由<code>await async2()</code>暂停的，所以会在<code>&quot;start&quot;</code>和<code>&#39;timer&#39;</code>之间打印</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q41：Promise-26-输出结果"><a href="#Q41：Promise-26-输出结果" class="headerlink" title="Q41：Promise(26)输出结果"></a>Q41：Promise(26)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;err!!!&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>, res)</span><br><span class="line">  &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>, err)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，你正在创建一个被拒绝的Promise，然后使用 <code>then</code> 方法来处理它的结果</p><p>这个 <code>then</code> 方法有两个参数：一个成功回调和一个失败回调</p><p>因为你的Promise是被拒绝的，所以失败的回调会被触发并接收到你传递的值 ‘err!!!’</p><p>注意，<code>catch</code> 并不会被执行</p><p>因为当你提供了 <code>then</code> 的失败回调后，这个回调就接管了错误处理，所以 <code>catch</code> 不会再被调用</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">error err!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：Promise-27-输出结果"><a href="#Q42：Promise-27-输出结果" class="headerlink" title="Q42：Promise(27)输出结果"></a>Q42：Promise(27)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">err</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码中，首先，你创建了一个已解决的 Promise 对象，然后你在 <code>then</code> 函数中返回了相同的 Promise 对象</p><p>这会导致 Promise 陷入一个循环状态，因为它在等待自己完成</p><p>因此，这样的写法会抛出一个类型错误，表示 Promise 不能返回自身</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">TypeError</span>: <span class="title class_">Chaining</span> cycle detected <span class="keyword">for</span> promise #</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：Promise-28-输出结果"><a href="#Q43：Promise-28-输出结果" class="headerlink" title="Q43：Promise(28)输出结果"></a>Q43：Promise(28)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then: &quot;</span>, res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码中，你创建了一个已解决的 Promise 对象，在它的 <code>then</code> 方法中返回了一个新的错误对象 <code>new Error(&#39;error!!!&#39;)</code></p><p>但这样并不会导致 promise 被拒绝</p><p>如你所见，<code>then</code> 代码块中返回一个错误对象，它并不会自动地把 promise 状态变为 rejected，这就是为什么错误信息会被传递给下一个 <code>then</code> 而非 <code>catch</code></p><p>这意味着即使你创建了一个 Error 对象，并把它作为结果返回，Promise 也仍然会保持其解析状态（Resolved，也就是说状态是完成的而不是被拒绝的）</p><p>然后代码进入下一个 <code>then</code>，打印出结果 “then: Error: error!!!”</p><p>如果你想抛出错误并让其被 <code>catch</code> 捕捉，有两种方法：</p><ol><li>你可以抛出一个错误 <code>throw new Error(&#39;error!!!&#39;)</code>，而不是返回它</li><li>或者你可以返回一个被拒绝（rejected）的 Promise，比如 <code>return Promise.reject(new Error(&#39;error!!!&#39;))</code></li></ol><p>在这两种情况下，错误都会被 <code>catch</code> 块捕获并处理</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">then</span>:  <span class="title class_">Error</span>: error!!!</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q44：Promise-29-输出结果"><a href="#Q44：Promise-29-输出结果" class="headerlink" title="Q44：Promise(29)输出结果"></a>Q44：Promise(29)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，首先创建了一个新的 Promise 对象 <code>promise</code></p><p>在 Promise 的执行器函数中，通过 <code>setTimeout()</code> 方法设置了一个定时器，1秒（1000毫秒）后，打印 <code>&#39;timer&#39;</code> 到控制台，并且将 Promise 的状态改为已解决（resolved），解决值为字符串 <code>&#39;success&#39;</code></p><p>随后，有两个 <code>then</code> 方法被链式调用在 <code>promise</code> 上</p><p>每个 <code>then</code> 方法都注册了一个回调函数，用于处理 Promise 解决时的情形</p><p>在这个回调函数中，你打印出了 Promise 的解决值 <code>&#39;success&#39;</code> 以及从变量 <code>start</code> 至当前的时间差</p><p>由于 <code>start</code> 是在 Promise 被创建之前就记录的，这个时间差大致上代表了从 Promise 创建到它解决时经过的时间</p><p>因为设置了一个1秒的延迟，打印出的时间应该大约是1000毫秒（可能会稍微多一点，取决于执行环境和其他延迟）</p><p>两个 <code>then</code> 方法几乎会同时接收到解决值 <code>&#39;success&#39;</code>，所以它们打印出的时间差应该也会非常接近</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">timer</span><br><span class="line">success <span class="number">1004</span></span><br><span class="line">success <span class="number">1004</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q45：Promise-30-输出结果"><a href="#Q45：Promise-30-输出结果" class="headerlink" title="Q45：Promise(30)输出结果"></a>Q45：Promise(30)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码展示了 Promise 的处理流程，包括了拒绝（reject），捕获错误（catch），以及成功解析（resolve）的处理</p><ol><li><code>Promise.reject(1)</code> 创建了一个被拒绝的 Promise，其拒绝理由是数字 <code>1</code></li><li>随后，<code>.then(res =&gt; { console.log(res); return 2; })</code> 是一个处理解析（resolve）的 <code>then</code> 方法。但由于 Promise 已经被拒绝，这个 <code>then</code> 方法中的回调函数将不会被调用</li><li>接着，<code>.catch(err =&gt; { console.log(err); return 3 })</code> 是用于捕获错误的 <code>catch</code> 方法。由于前面的 Promise 被拒绝且没有被任何 <code>then</code> 的第二个回调参数（用于处理拒绝）捕获，所以这个 <code>catch</code> 方法将会被调用，打印出拒绝理由 <code>1</code>，并返回一个新的值 <code>3</code></li><li>最后，<code>.then(res =&gt; { console.log(res); })</code> 会处理上一个 <code>.catch</code> 返回的结果。由于 <code>.catch</code> 返回了 <code>3</code>，这个 <code>then</code> 方法将被调用，结果 <code>3</code> 会被打印出来</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q46：Promise-31-输出结果"><a href="#Q46：Promise-31-输出结果" class="headerlink" title="Q46：Promise(31)输出结果"></a>Q46：Promise(31)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码呈现了一个典型的 <code>Promise</code> 链式调用流程</p><ol><li>首先是通过 <code>Promise.resolve(1)</code> 创建了一个立即解决的 <code>Promise</code>，其解决值为数字 <code>1</code></li><li><code>.then(res =&gt; { console.log(res); return 2; })</code> 链接到了这个 <code>Promise</code>，并提供了一个回调函数。这个回调被调用时，会打印出解决值 <code>1</code>，然后返回数字 <code>2</code></li><li><code>.catch(err =&gt; { return 3; })</code> 是一个错误处理函数，但由于前面的 <code>Promise</code> 被成功解决，而不是拒绝，这个回调不会被调用</li><li>最后是另一个 <code>.then(res =&gt; { console.log(res); })</code>，它处理了前一个 <code>.then</code> 方法返回的 <code>2</code>。它的回调会打印出 <code>2</code></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q47：Promise-32-输出结果"><a href="#Q47：Promise-32-输出结果" class="headerlink" title="Q47：Promise(32)输出结果"></a>Q47：Promise(32)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then: &quot;</span>, res);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch: &quot;</span>, err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在这段代码中，<code>promise</code> 被初始化为一个新的 <code>Promise</code> 对象</p><p>在其执行器函数中，依次调用了 <code>resolve</code> 和 <code>reject</code> 方法，最后又尝试调用了 <code>resolve</code></p><p>然而，<code>Promise</code> 的状态一旦改变（从“pending”变为“fulfilled”或“rejected”）就会固定下来，后续的 <code>resolve</code> 或 <code>reject</code> 调用将不会有任何效果</p><p>因此，第一次调用 <code>resolve(&quot;success1&quot;)</code> 会将 <code>promise</code> 的状态从“pending”更改为“fulfilled”，并设置其结果值为 <code>&quot;success1&quot;</code></p><p>紧接着的 <code>reject(&quot;error&quot;)</code> 和再次的 <code>resolve(&quot;success2&quot;)</code> 调用将被忽略，因为 Promise 的状态已经确定，且为“fulfilled”</p><p>接下来的 <code>.then(res =&gt; { console.log(&quot;then: &quot;, res); })</code> 用于处理 Promise 解决时的情形</p><p>因为 Promise 已经成功解决，故此回调将被调用，并打印出 <code>then: success1</code></p><p><code>.catch(err =&gt; { console.log(&quot;catch: &quot;, err); })</code> 用于捕获任何可能的拒绝情况，但由于 <code>promise</code> 成功解决而无需调用</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">then</span>:  success1</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q48：Promise-33-输出结果"><a href="#Q48：Promise-33-输出结果" class="headerlink" title="Q48：Promise(33)输出结果"></a>Q48：Promise(33)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1里的内容&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error!!!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>, promise1);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，<code>promise1</code> 被初始化为一个新的 <code>Promise</code> 对象，其内部包含一个异步操作（<code>setTimeout</code>），该操作在 1000 毫秒（1秒）后执行，将 <code>promise1</code> 的状态从“pending”更改为“fulfilled”，且解决值为 <code>&quot;success&quot;</code></p><p>在这之前，会立即打印出 <code>&quot;promise1里的内容&quot;</code></p></li><li><p>然后，几乎同时（由于事件循环，这些都是在初始化阶段同步完成的），由控制台输出 <code>&quot;promise1&quot;, promise1</code> 和 <code>&quot;promise2&quot;, promise2</code></p><p>由于JS的异步特性，这两个 <code>Promise</code> 对象此时都处于“pending”状态</p></li><li><p>接下来，第一个 <code>setTimeout</code> 的回调函数（延迟了 1 秒）执行，打印 <code>&quot;timer1&quot;</code> 并解决 <code>promise1</code></p><p>因为 <code>promise2</code> 是通过 <code>promise1.then()</code> 产生的，并在其回调中抛出了一个错误，所以 <code>promise2</code> 将会被拒绝</p></li><li><p>最后，第二个 <code>setTimeout</code>（延迟了 2 秒）的回调函数执行，打印出 <code>&quot;timer2&quot;</code> 和此时 <code>promise1</code> 和 <code>promise2</code> 的状态</p><p>此时，<code>promise1</code> 已经解决（fulfilled）且其值为 <code>&quot;success&quot;</code>，而 <code>promise2</code> 由于之前的错误抛出已经被拒绝（rejected）</p></li></ol><p>根据这个流程，控制台的输出顺序和内容应该如下：</p><ul><li><code>&quot;promise1里的内容&quot;</code>：同步打印，表示 <code>Promise</code> 初始化</li><li><code>&quot;promise1&quot;, Promise {&lt;pending&gt;}</code>：初始化时 <code>promise1</code> 的状态</li><li><code>&quot;promise2&quot;, Promise {&lt;pending&gt;}</code>：初始化时 <code>promise2</code> 的状态</li><li><code>&quot;timer1&quot;</code>：1秒后的异步打印</li><li><code>&quot;timer2&quot;</code>：2秒后的异步打印</li><li><code>&quot;promise1&quot;, Promise {&lt;fulfilled&gt;: &quot;success&quot;}</code>：2秒时 <code>promise1</code> 的状态和解决值</li><li><code>&quot;promise2&quot;, Promise {&lt;rejected&gt;: Error: error!!!}</code>：2秒时 <code>promise2</code> 的状态和拒绝原因</li></ul>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise1里的内容</span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="string">&#x27;success&#x27;</span>&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="title class_">Error</span>: error!!!</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">9</span>:<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q49：Promise-34-输出结果"><a href="#Q49：Promise-34-输出结果" class="headerlink" title="Q49：Promise(34)输出结果"></a>Q49：Promise(34)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>, promise1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，创建了一个名为<code>promise1</code>的新 Promise</p><p>这个 Promise 在1秒后解决(‘success’)</p></li><li><p>然后，通过调用<code>promise1.then()</code>创建了另一个名为 <code>promise2</code> 的 Promise</p><p><code>promise2</code> 的回调函数在 <code>promise1</code> 解决时立即抛出一个错误，导致 <code>promise2</code> 被立即拒绝</p></li><li><p>同时，在创建 Promise 后，立即打印 <code>promise1</code> 和 <code>promise2</code></p><p>由于此时两个 Promise 都处于 pending 状态，所以看到的是两个 pending 的 Promise：<code>Promise {&lt;pending&gt;}</code></p></li><li><p>在2秒后，通过 setTimeout 打印了 <code>promise1</code> 和 <code>promise2</code> 的状态</p><p>此时，<code>promise1</code> 应该已经完成并解决 (‘success’)，而 <code>promise2</code> 由于在其 then 方法中抛出了错误，应该已经被拒绝</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="comment">// 1秒后</span></span><br><span class="line"><span class="comment">// 无输出，但是已经抛出错误</span></span><br><span class="line"><span class="comment">// 2秒后</span></span><br><span class="line">promise1 <span class="title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="string">&quot;success&quot;</span>&#125;</span><br><span class="line">promise2 <span class="title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="title class_">Error</span>: error!!!&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q50：Promise-35-输出结果"><a href="#Q50：Promise-35-输出结果" class="headerlink" title="Q50：Promise(35)输出结果"></a>Q50：Promise(35)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>首先，两个 <code>setTimeout</code> 函数作为异步操作被添加到任务队列中</p><p>它们都设定为延迟为0毫秒，但其实并不意味着它们会立即执行，相反地，它们会等到当前的同步代码全部执行完毕后，才会执行</p></li><li><p>然后，<code>console.log(&#39;start&#39;);</code>作为同步代码首先被执行并打印出<code>start</code></p></li><li><p>同步代码执行完毕后，开始执行队列中的异步任务，首先执行的是第一个添加到队列的 <code>setTimeout</code>，它会打印出<code>timer1</code>，并且在其回调函数中添加了另一个 <code>setTimeout</code></p></li><li><p>然后，继续执行下一个 <code>setTimeout</code>，打印出<code>timer2</code></p></li><li><p>最后，执行最后添加到队列中的 <code>setTimeout</code>，打印出<code>timer3</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer1&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer2&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer3&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q51：Promise-36-输出结果"><a href="#Q51：Promise-36-输出结果" class="headerlink" title="Q51：Promise(36)输出结果"></a>Q51：Promise(36)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p>两个<code>setTimeout</code>调用被排定为宏任务，它们将在当前执行栈清空后的下一个事件循环迭代中执行</p></li><li><p><code>console.log(&#39;start&#39;)</code>是同步代码，会立刻执行，打印<code>start</code>到控制台</p></li><li><p>当当前的执行栈清空时，即同步代码执行完毕后，事件循环将检查微任务队列</p><p>此时，微任务队列是空的，因此事件循环进入下一步，开始执行宏任务队列中的任务</p></li><li><p>第一个<code>setTimeout</code>回调执行，打印<code>timer1</code></p><p>它内部的<code>Promise.resolve().then()</code>会创建一个微任务，该微任务会在当前宏任务完成后、下个宏任务开始前执行</p></li><li><p>第一个宏任务的微任务（<code>console.log(&#39;promise&#39;)</code>）现在执行，打印<code>promise</code></p></li><li><p>第一个<code>setTimeout</code>的宏任务及其微任务执行完毕后，事件循环继续执行下一个宏任务，即第二个<code>setTimeout</code>回调，打印<code>timer2</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;start&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer1&#x27;</span></span><br><span class="line"><span class="string">&#x27;promise&#x27;</span></span><br><span class="line"><span class="string">&#x27;timer2&#x27;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q52：Promise-37-输出结果"><a href="#Q52：Promise-37-输出结果" class="headerlink" title="Q52：Promise(37)输出结果"></a>Q52：Promise(37)输出结果</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这里 <code>.then(2)</code> 并不会改变 Promise 链中的值，因为 2 不是一个函数</p><p>.then()` 接受一个函数作为参数，如果你传递一个非函数的值，它将会被忽略，Promise 链中的值将不会变</p><p>然后，<code>.then(Promise.resolve(3))</code> 也同样不会改变 Promise 链中的值</p><p>这是因为 <code>.then</code> 期望一个函数作为参数，即使你给出的是一个已决的 Promise，它也不会改变当前 Promise 链中的值</p><p>你只能通过一个返回 Promise 或返回一个新值的函数来改变 Promise 链中的值</p><p>再接下来的 <code>.then(console.log)</code> 则会在控制台打印出来Promise链中的值，也就是 <code>1</code></p><p>这段代码的执行过程可以描述为：</p><ol><li><p><code>Promise.resolve(1)</code> 创建并立即解析了一个含有值 <code>1</code> 的 Promise</p><p>这个 Promise 中的值现在可以在其后的链中的 <code>.then()</code> 调用中被访问到</p></li><li><p><code>.then(2)</code> 试图将链中的值改变为 <code>2</code>，但由于 <code>2</code> 不是一个函数，所以这一步并未改变链中的值，链中的值仍为 <code>1</code></p></li><li><p><code>.then(Promise.resolve(3))</code> 试图将链中的值改变为从 <code>Promise.resolve(3)</code> 得到的 Promise 的解析值，即 <code>3</code></p><p>但同样因为 <code>Promise.resolve(3)</code> 不是一个函数，所以这一步也并未改变链中的值，链中的值仍然为 <code>1</code></p></li><li><p><code>.then(console.log)</code> 打印出当前链中的值，即 <code>1</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q53：Promise-38-输出结果"><a href="#Q53：Promise-38-输出结果" class="headerlink" title="Q53：Promise(38)输出结果"></a>Q53：Promise(38)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;resolve3&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resovle1&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resolve2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p1)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>p1</code>是一个<code>Promise</code>实例，其构造函数中包含一个异步操作（<code>setTimeout</code>）和两次立即的<code>resolve</code>调用</p></li><li><p>在<code>Promise</code>的执行器（executor）函数中，首先通过<code>setTimeout</code>设置了一个宏任务，延迟0ms后执行。然后立即执行了两次<code>resolve</code></p></li><li><p>根据<code>Promise</code>的特性，一个<code>Promise</code>对象的状态只能从<code>pending</code>变为<code>fulfilled</code>或<code>rejected</code>，且状态变化后不会再改变</p><p>因此，第一次调用<code>resolve(&#39;resovle1&#39;)</code>将会决定<code>p1</code>的状态和结果，后续的<code>resolve(&#39;resolve2&#39;)</code>和<code>setTimeout</code>中的<code>resolve(&#39;resolve3&#39;)</code>不会改变<code>p1</code>的状态或结果</p></li><li><p>第一个<code>then</code>注册的回调函数取得的<code>res</code>值是<code>&#39;resovle1&#39;</code>（由于上面提到的<code>Promise</code>的状态变化特性），所以控制台会先打印出”resovle1”</p></li><li><p>在这个<code>then</code>的回调函数中，又设置了一个<code>setTimeout</code>，延迟1000ms后执行</p><p>因为<code>setTimeout</code>会创建一个宏任务，所以这里的<code>console.log(p1)</code>会在延迟1000ms之后执行，打印出<code>p1</code>的当前状态</p><p>此时<code>p1</code>已经完成，所以会显示<code>Promise</code>完成态的相关信息</p></li><li><p>在<code>Promise</code>链的最后有一个<code>finally</code>调用</p><p>finally<code>注册的回调函数是在</code>Promise<code>完成（不管是fulfilled还是rejected）后调用的，</code>finally`不接受任何参数，所以这里打印出的是”finally undefined”</p></li><li><p><code>setTimeout</code>中设置的打印<code>&#39;timer1&#39;</code>会在所有同步代码执行完毕、事件循环到达对应的宏任务队列时执行，因此<code>&#39;timer1&#39;</code>会在<code>&#39;resovle1&#39;</code>之后、<code>&#39;finally undefined&#39;</code>之后打印</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;resolve1&#x27;</span><br><span class="line">&#x27;finally&#x27; undefined</span><br><span class="line">&#x27;timer1&#x27;</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q54：Promise-39-输出结果"><a href="#Q54：Promise-39-输出结果" class="headerlink" title="Q54：Promise(39)输出结果"></a>Q54：Promise(39)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">async1</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;async1 success&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="number">2</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="number">4</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>&quot;script start&quot;</code>首先被同步输出</p></li><li><p>调用<code>async1</code>函数，该函数首先同步输出<code>&quot;async1&quot;</code></p></li><li><p>接着设置一个定时器（<code>timer1</code>），延迟2000ms后打印<code>&quot;timer1&quot;</code>，此定时器会被放入宏任务队列中等待执行</p></li><li><p>接下来，<code>async1</code>里执行到<code>await new Promise(...)</code>，在这个Promise中<code>&quot;promise1&quot;</code>被同步输出</p><p>然而，这个Promise从未被<code>resolve</code>，导致<code>await</code>后面的代码（包括<code>&quot;async1 end&quot;</code>及函数返回值<code>&quot;async1 success&quot;</code>）不会立即执行，<code>async1</code>函数会在这里暂停执行</p></li><li><p>主线程继续执行，同步输出<code>&quot;script end&quot;</code></p></li><li><p>然后执行<code>Promise.resolve(1)</code>链</p><p>但是<code>.then(2)</code>是错误的用法，因为<code>.then</code>里应该传入函数。由于不是函数，这个<code>.then</code>不会对结果产生影响，直接传递给下一个<code>.then</code></p><p><code>Promise.resolve(3)</code>也是一个Promise，但由于它不是在<code>.then</code>的回调函数中返回，因此它也不会对链上的流程产生影响，<code>1</code>直接传递给最后一个<code>.then</code>的回调函数，导致输出<code>1</code></p></li><li><p>设置第二个定时器（<code>timer2</code>），延迟1000ms执行，也被加入宏任务队列</p></li></ol><p>需要注意的是，由于<code>async1</code>中的Promise没有<code>resolve</code>，<code>&quot;async1 end&quot;</code>和<code>&quot;async1 success&quot;</code>不会被输出，因为<code>async1</code>函数在遇到<code>await</code>操作符时暂停了执行，等待Promise解决，但这个Promise实际上永远不会被解决</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br><span class="line">1</span><br><span class="line">&#x27;timer2&#x27;</span><br><span class="line">&#x27;timer1&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q55：Promise-40-输出结果"><a href="#Q55：Promise-40-输出结果" class="headerlink" title="Q55：Promise(40)输出结果"></a>Q55：Promise(40)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">6</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="title function_">first</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><code>first</code> 函数被调用：<ul><li>首先，在 <code>first</code> 函数的 Promise 中打印 <code>3</code></li><li>然后，创建 <code>p</code> Promise，在 <code>p</code> 的执行器函数中首先打印 <code>7</code></li><li>在 <code>p</code> 的执行器中，<code>setTimeout</code> 被设置，预计在下一轮事件循环的宏任务中打印 <code>5</code> 并且解决该 Promise</li><li><code>p</code> 的 Promise 立即被解决，其解决值为 <code>1</code></li><li><code>first</code> 函数中的 Promise 被解决，解决值为 <code>2</code></li><li>接着，将 <code>p.then</code> 放置在微任务队列中，预计在当前执行栈清空后打印已解决的 <code>p</code> 的值 <code>1</code></li></ul></li><li>然后，同步打印 <code>4</code></li></ol><p>到这里，同步任务已经完成。接下来，事件循环检查微任务队列：</p><ol><li>它找到 <code>p.then</code>，并且打印 <code>1</code></li><li>然后找到 <code>first().then</code> 并且打印 <code>2</code></li></ol><p>这样，微任务队列清空后，事件循环继续检查宏任务队列：</p><ol><li><p>第一个宏任务是 <code>setTimeout</code> 中的回调，它打印 <code>5</code></p></li><li><p><code>setTimeout</code>的回调执行时，控制台打印出 <code>p</code> 的状态</p><p>由于此时 <code>p</code> 的状态已经解决了，它应该是一个带有解决值 <code>1</code> 的 <code>Promise {&lt;fulfilled&gt;: 1}</code></p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">Promise&#123;&lt;fulfilled&gt;: 1&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q56：Promise-41-输出结果"><a href="#Q56：Promise-41-输出结果" class="headerlink" title="Q56：Promise(41)输出结果"></a>Q56：Promise(41)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li>首先，打印”script start”</li><li>然后，设置一个0ms后执行的setTimeout回调，这是一个宏任务被加入到宏任务队列中，等待后续的事件循环执行</li><li>调用<code>async1()</code>函数<ul><li>“async1 start”被打印</li><li>执行<code>async1()</code>中的<code>await async2()</code></li><li>调用<code>async2()</code>，”async2”被打印</li><li>然后,await操作会将<code>async1</code>函数后续的操作包装成一个微任务（这个微任务包含打印”async1 end”的操作），并将其加入微任务队列</li></ul></li><li>创建一个新的Promise，执行器中打印”promise1”</li><li>使用<code>.then</code>方法注册Promise的成功回调，在Promise状态变为fulfilled时打印”promise2”。这个回调被加入到微任务队列中</li><li>打印”script end”</li></ol><p>到这里，程序的同步部分已经完成，开始进行事件循环，处理任务队列中的微任务和宏任务</p><ol><li>由于微任务队列优先于宏任务队列执行，因此会先执行两个微任务：<ul><li>首先是<code>async1</code>函数中的微任务，打印”async1 end”</li><li>然后执行Promise的成功回调，打印”promise2”</li></ul></li><li>所有微任务执行完后，执行宏任务队列中的setTimeout回调，打印”setTimeout”</li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;script start&#x27;</span><br><span class="line">&#x27;async1 start&#x27;</span><br><span class="line">&#x27;async2&#x27;</span><br><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;script end&#x27;</span><br><span class="line">&#x27;async1 end&#x27;</span><br><span class="line">&#x27;promise2&#x27;</span><br><span class="line">&#x27;setTimeout&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q57：Promise-42-输出结果"><a href="#Q57：Promise-42-输出结果" class="headerlink" title="Q57：Promise(42)输出结果"></a>Q57：Promise(42)输出结果</h3><p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">promise1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally1&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="title function_">promise2</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally2&#x27;</span>))</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>第一个Promise链 —— <code>promise1()</code>:</p><ol><li><code>promise1</code> 函数被调用，创建并返回一个新的<code>Promise</code>对象<code>p</code></li><li>在<code>p</code>的executor函数内部，”promise1”被打印到控制台</li><li>紧接着，<code>resolve(&#39;1&#39;)</code>调用使得Promise<code>p</code>的状态变为fulfilled</li><li><code>then</code> 方法被调用，在其中会打印出来自<code>promise1</code>的结果<code>&quot;1&quot;</code></li><li>由于<code>then</code>已经处理了Promise的fulfilled状态，<code>catch</code>块将被跳过</li><li><code>finally</code> 块始终会执行，打印”finally1”</li></ol><p>第二个Promise链 —— <code>promise2()</code>:</p><ol><li><code>promise2</code> 函数被调用，创建并返回一个新的<code>Promise</code>对象</li><li>这个新的Promise立即走向reject状态，并带有值”error”</li><li>由于没有设置<code>then</code>方法的第二个参数（为rejected状态的处理函数），所以Promise的rejected状态会被后续的<code>catch</code>块捕获</li><li><code>catch</code>块执行并打印出”error”</li><li><code>finally</code>块始终会执行，打印”finally2”</li></ol><p>以上两个Promise链是独立的，它们的输出也会独立地显示到控制台</p><p>由于JavaScript事件循环和浏览器的微任务队列的执行顺序，这些Promises的回调（<code>then</code>, <code>catch</code>, <code>finally</code>）会在同步代码执行完毕后，按照它们被添加到队列中的顺序执行</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;promise1&#x27;</span><br><span class="line">&#x27;1&#x27;</span><br><span class="line">&#x27;error&#x27;</span><br><span class="line">&#x27;finally1&#x27;</span><br><span class="line">&#x27;finally2&#x27;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《GitHub贡献日历》</title>
    <url>/posts/a26574b3/</url>
    <content><![CDATA[<h2 id="执行-npm-安装操作"><a href="#执行-npm-安装操作" class="headerlink" title="执行 npm 安装操作"></a>执行 npm 安装操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-githubcalendar --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ice Kano Plus_in</span></span><br><span class="line"><span class="comment"># Hexo Github Canlendar</span></span><br><span class="line"><span class="comment"># Author: Ice Kano</span></span><br><span class="line"><span class="comment"># Modify: Lete乐特</span></span><br><span class="line"><span class="attr">githubcalendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">your</span> <span class="string">user</span> <span class="string">name</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">githubcalendar_html:</span> <span class="string">&#x27;&lt;div class=&quot;recent-post-item&quot; style=&quot;width:100%;height:auto;padding:10px;&quot;&gt;&lt;div id=&quot;github_loading&quot; style=&quot;height:100%;display: flex;align-items: center;justify-content: center;&quot;&gt;&lt;svg style=&quot;height:50px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  viewBox=&quot;0 0 50 50&quot; style=&quot;enable-background:new 0 0 50 50&quot; xml:space=&quot;preserve&quot;&gt;&lt;path fill=&quot;#d0d0d0&quot; d=&quot;M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z&quot; transform=&quot;rotate(275.098 25 25)&quot;&gt;&lt;animateTransform attributeType=&quot;xml&quot; attributeName=&quot;transform&quot; type=&quot;rotate&quot; from=&quot;0 25 25&quot; to=&quot;360 25 25&quot; dur=&quot;0.6s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animateTransform&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div id=&quot;github_container&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">  <span class="attr">pc_minheight:</span> <span class="string">248px</span></span><br><span class="line">  <span class="attr">mobile_minheight:</span> <span class="string">0px</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;[&#x27;#ebedf0&#x27;, &#x27;#fdcdec&#x27;, &#x27;#fc9bd9&#x27;, &#x27;#fa6ac5&#x27;, &#x27;#f838b2&#x27;, &#x27;#f5089f&#x27;, &#x27;#c4067e&#x27;, &#x27;#92055e&#x27;, &#x27;#540336&#x27;, &#x27;#48022f&#x27;, &#x27;#30021f&#x27;]&quot;</span></span><br><span class="line">  <span class="attr">api:</span> <span class="string">your</span> <span class="string">api</span></span><br><span class="line">  <span class="attr">calendar_js:</span> <span class="string">https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js</span></span><br><span class="line">  <span class="attr">plus_style:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="api获取"><a href="#api获取" class="headerlink" title="api获取"></a>api获取</h2><p>这一步是这个魔改的关键，由于免费的公用api被墙了，所以我们需要自己去搭建一个属于自己的api获取我们github的贡献日历</p>
<p>我们需要<code>Vercel</code>、<code>Github项目</code></p>
<p>进入这个<a href="https://vercel.com/dashboard"><code>Vercel</code>官网</a>，然后首先是注册你自己的账号，最好是使用我们自己的<code>github</code>账号去注册，关联一下自己的邮箱</p>
<p>右上角头像点击打开<code>dashboard</code>，进入到我们的项目添加页里面</p>
<p><img src="https://s2.loli.net/2024/01/03/RpEhL6q2O9sawrJ.png" alt="image-20240103164952174"></p>
<p>然后点击右上角<code>Add New</code>，选择<code>Project</code></p>
<p><img src="https://s2.loli.net/2024/01/03/ECb4cvYxSa7ouD2.png" alt="image-20240103165047752"></p>
<p>点击导入第三方库</p>
<p><img src="https://s2.loli.net/2024/01/03/JcqsztAk3OS9RT1.png" alt="image-20240103165147867"></p>
<p>这里填上我给的链接</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//github.com/wutiaowu5t5/hexo-circle-of-friends-api</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/01/03/CJdA2nZ6QNBrELc.png" alt="image-20240103165208016"></p>
<p>点击完成之后，写你自定义的仓库名称，最后再点击部署，等待部署成功就可以使用这个api了</p>
<p>最后就是我们的验证步骤</p>
<p>你部署好的项目里面有一个这个<code>Domains</code>，点进去之后，复制搜索框里面的<code>link</code></p>
<p><img src="https://s2.loli.net/2024/01/03/OAQluoe4JdkXfVK.png" alt="image-20240103165530480"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;search link&gt; + /api + ?<span class="language-xml"><span class="tag">&lt;<span class="name">your</span> <span class="attr">username</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果出来数据就是成功，填入我们的配置里面只需要<code>&lt;search link&gt; + /api</code></p>
<p><br/></p>
<h2 id="修订记录"><a href="#修订记录" class="headerlink" title="修订记录"></a>修订记录</h2><div class="note danger modern"><p>2024-04-22</p>
<p><code>vercel</code>的传参方式改变了，需要带上=，否则将会获取不到数据</p>
<p>修改方式：</p>
<ol>
<li><p>找到自己的github导入的第三方库项目，修改py文件</p>
<p><a href="https://github.com/wutiaowu5t5/hexo-circle-of-friends-api/blob/main/api/index.py">源码复制地址</a></p>
</li>
<li><p>修改_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">user=&lt;your</span> <span class="string">username&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</div>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《侧边栏个性定位欢迎语》</title>
    <url>/posts/7ca07026/</url>
    <content><![CDATA[<h2 id="获取key"><a href="#获取key" class="headerlink" title="获取key"></a>获取key</h2><p>进入 <a href="https://lbs.qq.com/dev/console/application/mine">腾讯位置服务</a> 应用管理界面</p>
<p>点击创建应用，应用名称和类型随便填</p>
<p>在新创建的应用中点击添加 key ，产品选择 <code>WebServiceAPI</code> ，域名白名单填自己的域名或不填</p>
<p>把得到的 <code>key</code> 记下; 如果开启白名单记得把<code>localhost</code>也加上</p>
<p><br/></p>
<h2 id="新建js文件"><a href="#新建js文件" class="headerlink" title="新建js文件"></a>新建js文件</h2><p>创建一个<code>js</code>文件，并写入以下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">welcometxmap</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//请求数据</span></span><br><span class="line">    ipLoacation = <span class="variable language_">window</span>.<span class="property">saveToLocal</span>.<span class="title function_">get</span>(<span class="string">&#x27;ipLocation&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipLoacation) &#123;</span><br><span class="line">        <span class="comment">// 使用 ipLocation</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据已过期或不存在</span></span><br><span class="line">        <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> url = <span class="string">`https://apis.map.qq.com/ws/location/v1/ip?key=<span class="subst">$&#123;txkey&#125;</span>&amp;output=jsonp`</span>;</span><br><span class="line">        script.<span class="property">src</span> = url;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">QQmap</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            ipLoacation = data;</span><br><span class="line">            <span class="comment">// 将数据保存到 localStorage，过期时间设置为 1 天</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">saveToLocal</span>.<span class="title function_">set</span>(<span class="string">&#x27;ipLocation&#x27;</span>, ipLoacation, <span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script);</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">QQmap</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">showWelcome</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDistance</span>(<span class="params">e1, n1, e2, n2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> R = <span class="number">6371</span></span><br><span class="line">    <span class="keyword">const</span> &#123; sin, cos, asin, <span class="variable constant_">PI</span>, hypot &#125; = <span class="title class_">Math</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">getPoint</span> = (<span class="params">e, n</span>) =&gt; &#123;</span><br><span class="line">        e *= <span class="variable constant_">PI</span> / <span class="number">180</span></span><br><span class="line">        n *= <span class="variable constant_">PI</span> / <span class="number">180</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="title function_">cos</span>(n) * <span class="title function_">cos</span>(e), <span class="attr">y</span>: <span class="title function_">cos</span>(n) * <span class="title function_">sin</span>(e), <span class="attr">z</span>: <span class="title function_">sin</span>(n) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = <span class="title function_">getPoint</span>(e1, n1)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="title function_">getPoint</span>(e2, n2)</span><br><span class="line">    <span class="keyword">let</span> c = <span class="title function_">hypot</span>(a.<span class="property">x</span> - b.<span class="property">x</span>, a.<span class="property">y</span> - b.<span class="property">y</span>, a.<span class="property">z</span> - b.<span class="property">z</span>)</span><br><span class="line">    <span class="keyword">let</span> r = <span class="title function_">asin</span>(c / <span class="number">2</span>) * <span class="number">2</span> * R</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showWelcome</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dist = <span class="title function_">getDistance</span>(longitude, <span class="title class_">Latitude</span>, ipLoacation.<span class="property">result</span>.<span class="property">location</span>.<span class="property">lng</span>, ipLoacation.<span class="property">result</span>.<span class="property">location</span>.<span class="property">lat</span>);</span><br><span class="line">    <span class="keyword">let</span> pos = ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">nation</span>;</span><br><span class="line">    <span class="keyword">let</span> ip;</span><br><span class="line">    <span class="keyword">let</span> posdesc;</span><br><span class="line">    <span class="comment">//根据国家、省份、城市信息自定义欢迎语</span></span><br><span class="line">    <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">nation</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;日本&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;よろしく，一起去看樱花吗&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;美国&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;Let us live in peace!&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;英国&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;想同你一起夜乘伦敦眼&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;俄罗斯&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;干了这瓶伏特加！&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;法国&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;C&#x27;est La Vie&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;德国&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;Die Zeit verging im Fluge.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;澳大利亚&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;一起去大堡礁吧！&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;加拿大&quot;</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;拾起一片枫叶赠予你&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;中国&quot;</span>:</span><br><span class="line">            pos = ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">province</span> + <span class="string">&quot; &quot;</span> + ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span> + <span class="string">&quot; &quot;</span> + ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">district</span>;</span><br><span class="line">            ip = ipLoacation.<span class="property">result</span>.<span class="property">ip</span>;</span><br><span class="line">            <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">province</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;北京市&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;北——京——欢迎你~~~&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;天津市&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;讲段相声吧&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;河北省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;山势巍巍成壁垒，天下雄关铁马金戈由此向，无限江山&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;山西省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;展开坐具长三尺，已占山河五百余&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;内蒙古自治区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;天苍苍，野茫茫，风吹草低见牛羊&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;辽宁省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;我想吃烤鸡架！&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;吉林省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;状元阁就是东北烧烤之王&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;黑龙江省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;很喜欢哈尔滨大剧院&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;上海市&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;众所周知，中国只有两个城市&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;江苏省&quot;</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span>) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;南京市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;这是我挺想去的城市啦&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;苏州市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;上有天堂，下有苏杭&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="attr">default</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;散装是必须要散装的&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;浙江省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;东风渐绿西湖柳，雁已还人未南归&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;河南省&quot;</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span>) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;郑州市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;豫州之域，天地之中&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;南阳市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;臣本布衣，躬耕于南阳此南阳非彼南阳！&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;驻马店市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;峰峰有奇石，石石挟仙气嵖岈山的花很美哦！&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;开封市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;刚正不阿包青天&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;洛阳市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;洛阳牡丹甲天下&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="attr">default</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;可否带我品尝河南烩面啦？&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;安徽省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;蚌埠住了，芜湖起飞&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;福建省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;井邑白云间，岩城远带山&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;江西省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;落霞与孤鹜齐飞，秋水共长天一色&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;山东省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;遥望齐州九点烟，一泓海水杯中泻&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;湖北省&quot;</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span>) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;黄冈市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;红安将军县！辈出将才！&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="attr">default</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;来碗热干面~&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;湖南省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;74751，长沙斯塔克&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;广东省&quot;</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span>) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;广州市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;看小蛮腰，喝早茶了嘛~&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;深圳市&quot;</span>:</span><br><span class="line">                            <span class="keyword">switch</span> (ipLoacation.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">district</span>) &#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">&quot;宝安区&quot;</span>:</span><br><span class="line">                                    posdesc = <span class="string">&quot;好巧！博主也在宝安区生活喔~&quot;</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="attr">default</span>:</span><br><span class="line">                                    posdesc = <span class="string">&quot;今天你996了嘛~&quot;</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&quot;阳江市&quot;</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;阳春合水！博主家乡~ 欢迎来玩~&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="attr">default</span>:</span><br><span class="line">                            posdesc = <span class="string">&quot;来两斤福建人~&quot;</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;广西壮族自治区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;桂林山水甲天下&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;海南省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;朝观日出逐白浪，夕看云起收霞光&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;四川省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;康康川妹子&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;贵州省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;茅台，学生，再塞200&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;云南省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;玉龙飞舞云缠绕，万仞冰川直耸天&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;西藏自治区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;躺在茫茫草原上，仰望蓝天&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;陕西省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;来份臊子面加馍&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;甘肃省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;羌笛何须怨杨柳，春风不度玉门关&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;青海省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;牛肉干和老酸奶都好好吃&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;宁夏回族自治区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;大漠孤烟直，长河落日圆&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;新疆维吾尔自治区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;驼铃古道丝绸路，胡马犹闻唐汉风&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;台湾省&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;我在这头，大陆在那头&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;香港特别行政区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;永定贼有残留地鬼嚎，迎击光非岁玉&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;澳门特别行政区&quot;</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;性感荷官，在线发牌&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="attr">default</span>:</span><br><span class="line">                    posdesc = <span class="string">&quot;带我去你的城市逛逛吧！&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            posdesc = <span class="string">&quot;带我去你的国家逛逛吧&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据本地时间切换欢迎语</span></span><br><span class="line">    <span class="keyword">let</span> timeChange;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (date.<span class="title function_">getHours</span>() &gt;= <span class="number">5</span> &amp;&amp; date.<span class="title function_">getHours</span>() &lt; <span class="number">11</span>) timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;🌤️ 早上好，一日之计在于晨&lt;/span&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (date.<span class="title function_">getHours</span>() &gt;= <span class="number">11</span> &amp;&amp; date.<span class="title function_">getHours</span>() &lt; <span class="number">13</span>) timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;☀️ 中午好，记得午休喔~&lt;/span&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (date.<span class="title function_">getHours</span>() &gt;= <span class="number">13</span> &amp;&amp; date.<span class="title function_">getHours</span>() &lt; <span class="number">17</span>) timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;🕞 下午好，饮茶先啦！&lt;/span&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (date.<span class="title function_">getHours</span>() &gt;= <span class="number">17</span> &amp;&amp; date.<span class="title function_">getHours</span>() &lt; <span class="number">19</span>) timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;🚶‍♂️ 即将下班，记得按时吃饭~&lt;/span&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (date.<span class="title function_">getHours</span>() &gt;= <span class="number">19</span> &amp;&amp; date.<span class="title function_">getHours</span>() &lt; <span class="number">24</span>) timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;🌙 晚上好，夜生活嗨起来！&lt;/span&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> timeChange = <span class="string">&quot;&lt;span class=&#x27;welcome-time&#x27;&gt;夜深了，早点休息，少熬夜&lt;/span&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//自定义文本和需要放的位置</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;welcome-info&quot;</span>).<span class="property">innerHTML</span> =</span><br><span class="line">            <span class="string">`&lt;span&gt;热烈欢迎来自~&lt;/span&gt;&lt;br&gt;&lt;span&gt;&lt;span style=&quot;color: var(--icat-card-welcome);font-weight: bold;&quot;&gt;<span class="subst">$&#123;pos&#125;</span>&lt;/span&gt; 的喵友&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;welcome-message&quot;&gt;<span class="subst">$&#123;posdesc&#125;</span>&lt;/span&gt;&lt;br&gt;您当前位置距博主约 &lt;b&gt;&lt;span style=&quot;color: var(--icat-card-welcome);font-weight: bold;&quot;&gt;<span class="subst">$&#123;dist&#125;</span>&lt;/span&gt;&lt;/b&gt; 公里！&lt;br&gt;&lt;span&gt;您的IP地址为：<span class="subst">$&#123;ip&#125;</span>&lt;/span&gt;&lt;br&gt;<span class="subst">$&#123;timeChange&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// console.log(&quot;Pjax无法获取#welcome-info元素🙄🙄🙄&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建css文件"><a href="#新建css文件" class="headerlink" title="新建css文件"></a>新建css文件</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#welcome-info</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attr">--icat-card-welcome</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#welcome-info</span> <span class="selector-class">.welcome-time</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">12px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#welcome-info</span> <span class="selector-class">.welcome-message</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#welcome-info</span> <span class="selector-class">.welcome-region</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--card-bg);</span><br><span class="line">  <span class="attribute">border</span>: <span class="built_in">var</span>(--hr-border);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">6px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 欢迎信息栏样式 */</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="在-config-butterfly-yml-主题配置文件中-inject-下的-bottom-引入js，head引入css"><a href="#在-config-butterfly-yml-主题配置文件中-inject-下的-bottom-引入js，head引入css" class="headerlink" title="在 _config.butterfly.yml 主题配置文件中 inject 下的 bottom 引入js，head引入css"></a>在 _config.butterfly.yml 主题配置文件中 inject 下的 bottom 引入js，head引入css</h2><p><br/></p>
<h2 id="在-blogRoot-source-data-widget-yml-文件，新增-name-icon-html-项的内容"><a href="#在-blogRoot-source-data-widget-yml-文件，新增-name-icon-html-项的内容" class="headerlink" title="在[blogRoot]/source/_data/widget.yml 文件，新增 name icon html 项的内容"></a>在[blogRoot]/source/_data/widget.yml 文件，新增 name icon html 项的内容</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">top:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">class_name:</span></span><br><span class="line">    <span class="attr">id_name:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">来访者</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">iconfont</span> <span class="string">icat-visitor</span></span><br><span class="line">    <span class="attr">html:</span> <span class="string">&lt;div</span> <span class="string">id=&quot;welcome-info&quot;&gt;&lt;/div&gt;&lt;script</span> <span class="string">data-pjax&gt;var</span> <span class="string">longitude=&quot;经度&quot;;var</span> <span class="string">Latitude=&quot;纬度&quot;;var</span> <span class="string">txkey=&quot;腾讯定位Key&quot;;var</span> <span class="string">ipLoacation;window.onload</span> <span class="string">=</span> <span class="string">()</span> <span class="string">=&gt;</span> &#123;<span class="string">welcometxmap()</span>&#125;<span class="string">;document.addEventListener(&quot;pjax:complete&quot;,</span> <span class="string">welcometxmap())&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将上方的 经度、纬度 以及 腾讯定位Key 替换成你自己的</p>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《侧边栏那年今日》</title>
    <url>/posts/1bf8e8b1/</url>
    <content><![CDATA[<h2 id="安装NPM插件"><a href="#安装NPM插件" class="headerlink" title="安装NPM插件"></a>安装NPM插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-history-calendar --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="config-yml添加配置信息"><a href="#config-yml添加配置信息" class="headerlink" title="_config.yml添加配置信息"></a>_config.yml添加配置信息</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">history_calendar:</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">temple_html:</span> <span class="string">&#x27;&lt;div class=&quot;card-widget card-history&quot;&gt;&lt;div class=&quot;card-content&quot;&gt;&lt;div class=&quot;item-headline&quot;&gt;&lt;i class=&quot;fas fa-clock fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;那年今日&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;history-baidu&quot; style=&quot;height: 100px;overflow: hidden&quot;&gt;&lt;div class=&quot;history_swiper-container&quot; id=&quot;history-container&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;div class=&quot;swiper-wrapper&quot; id=&quot;history_container_wrapper&quot; style=&quot;height:20px&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="配置字段解析"><a href="#配置字段解析" class="headerlink" title="配置字段解析"></a>配置字段解析</h2><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>备选值/类型</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>enable</td>
<td>true/false</td>
<td>【必选】控制开关</td>
</tr>
<tr>
<td>enable_page</td>
<td>path/all</td>
<td>【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’/‘,分类页面就填’/categories/‘。若要应用于所有页面，就填’all’，默认为 all</td>
</tr>
<tr>
<td>layout.type</td>
<td>id/class</td>
<td>【可选】挂载容器类型，填写 id 或 class，不填则默认为 id</td>
</tr>
<tr>
<td>layout.name</td>
<td>text</td>
<td>【必选】挂载容器名称</td>
</tr>
<tr>
<td>layout.index</td>
<td>0 和正整数</td>
<td>【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位</td>
</tr>
<tr>
<td>temple_html</td>
<td>html 模板字段</td>
<td>【必选】包含挂载容器</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《友链页面》</title>
    <url>/posts/a7837527/</url>
    <content><![CDATA[<h2 id="新建文件输入友链格式"><a href="#新建文件输入友链格式" class="headerlink" title="新建文件输入友链格式"></a>新建文件输入友链格式</h2><p>路径： <code>[Blogroot]\source\_data\link.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">糖果屋のVIP</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">售后服务享五折优惠2333</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Akilar</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://akilar.top</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">/img/siteicon/favicon.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">欢迎光临糖果屋</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改flink-pug"><a href="#修改flink-pug" class="headerlink" title="修改flink.pug"></a>修改flink.pug</h2><p>路径：<code>[Blogroot]\themes\butterfly\layout\includes\page\flink.pug</code></p>
<p>此处添加判断机制，使得可以通过修改配置文件来切换友链风格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case theme.flink_style</span><br><span class="line">  when &#x27;volantis&#x27;</span><br><span class="line">    include ./flink_style/volantis.pug</span><br><span class="line">  when &#x27;flexcard&#x27;</span><br><span class="line">    include ./flink_style/flexcard.pug</span><br><span class="line">  default</span><br><span class="line">    include ./flink_style/butterfly.pug</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建butterfly-pug"><a href="#新建butterfly-pug" class="headerlink" title="新建butterfly.pug"></a>新建butterfly.pug</h2><p>路径： <code>[Blogroot]\themes\butterfly\layout\includes\page\flink_style\butterfly.pug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#article-container</span><br><span class="line">  if top_img === false</span><br><span class="line">    h1.page-title= page.title</span><br><span class="line">  .flink</span><br><span class="line">    if site.data.link</span><br><span class="line">      each i in site.data.link</span><br><span class="line">        if i.class_name</span><br><span class="line">          h2!= i.class_name</span><br><span class="line">        if i.class_desc</span><br><span class="line">          .flink-desc!=i.class_desc</span><br><span class="line">        .flink-list</span><br><span class="line">          each item in i.link_list</span><br><span class="line">            .flink-list-item</span><br><span class="line">              a(href=url_for(item.link)  title=item.name target=&quot;_blank&quot;)</span><br><span class="line">                .flink-item-icon</span><br><span class="line">                  img.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=item.name )</span><br><span class="line">                .flink-item-name= item.name</span><br><span class="line">                .flink-item-desc(title=item.descr)= item.descr</span><br><span class="line">  != page.content</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建volantis-pug"><a href="#新建volantis-pug" class="headerlink" title="新建volantis.pug"></a>新建volantis.pug</h2><p>路径： <code>[Blogroot]\themes\butterfly\layout\includes\page\flink_style\volantis.pug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#article-container</span><br><span class="line">  if top_img === false</span><br><span class="line">    h1.page-title= page.title</span><br><span class="line">  .flink</span><br><span class="line">    if site.data.link</span><br><span class="line">      each i in site.data.link</span><br><span class="line">        if i.class_name</span><br><span class="line">          h2!= i.class_name</span><br><span class="line">        if i.class_desc</span><br><span class="line">          .flink-desc!=i.class_desc</span><br><span class="line">        .site-card-group</span><br><span class="line">          each item in i.link_list</span><br><span class="line">            a.site-card(target=&#x27;_blank&#x27; rel=&#x27;noopener&#x27; href=url_for(item.link))</span><br><span class="line">              .img</span><br><span class="line">                - var siteshot = item.siteshot ? url_for(item.siteshot) : &#x27;https://image.thum.io/get/width/400/crop/800/allowJPG/wait/20/noanimate/&#x27; + item.link</span><br><span class="line">                img.no-lightbox(src=siteshot onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; )</span><br><span class="line">              .info</span><br><span class="line">                img.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&#x27;&#x27; )</span><br><span class="line">                span.title= item.name</span><br><span class="line">                span.desc(title=item.descr)= item.descr</span><br><span class="line">  != page.content</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建flexcard-pug"><a href="#新建flexcard-pug" class="headerlink" title="新建flexcard.pug"></a>新建flexcard.pug</h2><p>路径： <code>[Blogroot]\themes\butterfly\layout\includes\page\flink_style\flexcard.pug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#article-container</span><br><span class="line">  if top_img === false</span><br><span class="line">    h1.page-title= page.title</span><br><span class="line">  .flink</span><br><span class="line">    if site.data.link</span><br><span class="line">      each i in site.data.link</span><br><span class="line">        if i.class_name</span><br><span class="line">          h2!= i.class_name</span><br><span class="line">        if i.class_desc</span><br><span class="line">          .flink-desc!=i.class_desc</span><br><span class="line">        .flink-list</span><br><span class="line">          each item in i.link_list</span><br><span class="line">            a.flink-list-card(href=url_for(item.link) target=&#x27;_blank&#x27; data-title=item.descr)</span><br><span class="line">              .wrapper.cover</span><br><span class="line">                - var siteshot = item.siteshot ? url_for(item.siteshot) : &#x27;https://image.thum.io/get/width/400/crop/800/allowJPG/wait/20/noanimate/&#x27; + item.link</span><br><span class="line">                img.no-lightbox.cover.fadeIn(src=siteshot onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; )    </span><br><span class="line">              .info</span><br><span class="line">                img.no-lightbox(src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&#x27;&#x27; )</span><br><span class="line">                span.flink-sitename= item.name</span><br><span class="line">  != page.content</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改flink-styl"><a href="#修改flink-styl" class="headerlink" title="修改flink.styl"></a>修改flink.styl</h2><p>路径： <code>[Blogroot]\themes\butterfly\source\css\_page\flink.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;flink_style&#x27;</span>) == <span class="string">&#x27;butterfly&#x27;</span></span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;./_flink_style/butterfly&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;flink_style&#x27;</span>) == <span class="string">&#x27;volantis&#x27;</span></span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;./_flink_style/volantis&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;flink_style&#x27;</span>) == <span class="string">&#x27;flexcard&#x27;</span></span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&#x27;./_flink_style/flexcard&#x27;</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建butterfly-styl"><a href="#新建butterfly-styl" class="headerlink" title="新建butterfly.styl"></a>新建butterfly.styl</h2><p>路径： <code>[Blogroot]\themes\butterfly\source\css\_flink_style\butterfly.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.flink<span class="selector-id">#article-container</span></span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span></span><br><span class="line"><span class="selector-class">.flink-desc</span></span><br><span class="line">  <span class="attribute">margin</span>: .<span class="number">2rem</span> <span class="number">0</span> .<span class="number">5rem</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flink-list</span></span><br><span class="line">  <span class="attribute">overflow</span>: auto</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line"></span><br><span class="line">  &amp; &gt; <span class="selector-class">.flink-list-item</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    <span class="attribute">float</span>: left</span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> <span class="number">7px</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> / <span class="number">3</span> - <span class="number">15px</span>)</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">90px</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">17px</span></span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    +<span class="built_in">maxWidth1024</span>()</span><br><span class="line">      <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">15px</span>) <span class="meta">!important</span></span><br><span class="line"></span><br><span class="line">    +<span class="built_in">maxWidth600</span>()</span><br><span class="line">      <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">15px</span>) <span class="meta">!important</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">      <span class="selector-class">.flink-item-icon</span></span><br><span class="line">        <span class="attribute">margin-left</span>: -<span class="number">10px</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">bottom</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span></span><br><span class="line">      <span class="attribute">z-index</span>: -<span class="number">1</span></span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">var</span>(--text-bg-hover)</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attribute">transition</span>: transform .<span class="number">3s</span> ease-out</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-pseudo">&amp;:hover</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-pseudo">&amp;:focus</span><span class="selector-pseudo">:before</span>,</span><br><span class="line">    <span class="selector-pseudo">&amp;:active</span><span class="selector-pseudo">:before</span></span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">a</span></span><br><span class="line">      <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color)</span><br><span class="line">      <span class="attribute">text-decoration</span>: none</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.flink-item-icon</span></span><br><span class="line">        <span class="attribute">float</span>: left</span><br><span class="line">        <span class="attribute">overflow</span>: hidden</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">15px</span> <span class="number">10px</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">60px</span></span><br><span class="line">        <span class="attribute">height</span>: <span class="number">60px</span></span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">35px</span></span><br><span class="line">        <span class="attribute">transition</span>: width .<span class="number">3s</span> ease-out</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">img</span></span><br><span class="line">          <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">          <span class="attribute">height</span>: <span class="number">100%</span></span><br><span class="line">          <span class="attribute">transition</span>: filter <span class="number">375ms</span> ease-in .<span class="number">2s</span>, transform .<span class="number">3s</span></span><br><span class="line">          <span class="attribute">object-fit</span>: cover</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.img-alt</span></span><br><span class="line">        <span class="attribute">display</span>: none</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flink-item-name</span></span><br><span class="line">  <span class="keyword">@extend</span> <span class="selector-class">.limit-one-line</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span></span><br><span class="line">  <span class="attribute">font-weight</span>: bold</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.43em</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flink-item-desc</span></span><br><span class="line">  <span class="keyword">@extend</span> <span class="selector-class">.limit-one-line</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span> <span class="number">10px</span> <span class="number">16px</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span></span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">93em</span></span><br><span class="line"><span class="selector-class">.flink-name</span></span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span></span><br><span class="line">  <span class="attribute">font-weight</span>: bold</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建volantis-styl"><a href="#新建volantis-styl" class="headerlink" title="新建volantis.styl"></a>新建volantis.styl</h2><p>路径： <code>[Blogroot]\themes\butterfly\source\css\_flink_style\volantis.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">trans</span><span class="params">(<span class="variable">$time</span> = <span class="number">0.28s</span>)</span></span></span><br><span class="line">  <span class="attribute">transition</span>: all <span class="variable">$time</span> ease</span><br><span class="line">  -moz-<span class="attribute">transition</span>: all <span class="variable">$time</span> ease</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all <span class="variable">$time</span> ease</span><br><span class="line">  -o-<span class="attribute">transition</span>: all <span class="variable">$time</span> ease</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-card-group</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">0.5</span> * <span class="number">16px</span></span><br><span class="line">  <span class="attribute">align-items</span>: stretch</span><br><span class="line"><span class="selector-class">.site-card</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">16px</span> * <span class="number">0.5</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="string">&quot;calc(100% / 4 - %s)&quot;</span> % <span class="number">16px</span></span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">2048px</span>)</span><br><span class="line">      <span class="attribute">width</span>: &quot;calc(<span class="number">100%</span> / <span class="number">5</span> - %s)&quot; % <span class="number">16px</span></span><br><span class="line">  @media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">      <span class="attribute">width</span>: &quot;calc(<span class="number">100%</span> / <span class="number">3</span> - %s)&quot; % <span class="number">16px</span></span><br><span class="line">  @media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>)</span><br><span class="line">      <span class="attribute">width</span>: &quot;calc(<span class="number">100%</span> / <span class="number">2</span> - %s)&quot; % <span class="number">16px</span></span><br><span class="line">  display: block</span><br><span class="line">  line-height: <span class="number">1.4</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">100%</span></span><br><span class="line">  .img</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">120px</span></span><br><span class="line">    @media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>)</span><br><span class="line">      <span class="attribute">height</span> <span class="number">100px</span></span><br><span class="line">    overflow: hidden</span><br><span class="line">    border-radius: <span class="number">12px</span> * <span class="number">0.5</span></span><br><span class="line">    box-shadow: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">0px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>)</span><br><span class="line">    background: #f6f6f6</span><br><span class="line">    img</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br><span class="line">      <span class="attribute">height</span> <span class="number">100%</span></span><br><span class="line">      pointer-events:none;</span><br><span class="line">      <span class="comment">// trans(.75s)</span></span><br><span class="line">      <span class="attribute">transition</span>: transform <span class="number">2s</span> ease</span><br><span class="line">      <span class="attribute">object-fit</span>: cover</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.info</span></span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">16px</span> * <span class="number">0.5</span></span><br><span class="line">    <span class="selector-tag">img</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">32px</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">32px</span></span><br><span class="line">      <span class="attribute">pointer-events</span>:none;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">16px</span></span><br><span class="line">      <span class="attribute">float</span>: left</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="number">8px</span></span><br><span class="line">      <span class="attribute">margin-top</span>: <span class="number">2px</span></span><br><span class="line">    <span class="selector-tag">span</span></span><br><span class="line">      <span class="attribute">display</span>: block</span><br><span class="line">    <span class="selector-class">.title</span></span><br><span class="line">      <span class="attribute">font-weight</span>: <span class="number">600</span></span><br><span class="line">      <span class="attribute">font-size</span>: <span class="built_in">var</span>(--global-font-size)</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#444</span></span><br><span class="line">      <span class="attribute">display</span>: -webkit-box</span><br><span class="line">      -webkit-box-orient: vertical</span><br><span class="line">      <span class="attribute">overflow</span>: hidden</span><br><span class="line">      -webkit-line-clamp: <span class="number">1</span></span><br><span class="line">      <span class="built_in">trans</span>()</span><br><span class="line">    <span class="selector-class">.desc</span></span><br><span class="line">      <span class="attribute">font-size</span>: <span class="built_in">var</span>(--global-font-size)</span><br><span class="line">      <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">1.2</span></span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#888</span></span><br><span class="line">      <span class="attribute">display</span>: -webkit-box</span><br><span class="line">      -webkit-box-orient: vertical</span><br><span class="line">      <span class="attribute">overflow</span>: hidden</span><br><span class="line">      -webkit-line-clamp: <span class="number">2</span></span><br><span class="line">  <span class="selector-class">.img</span></span><br><span class="line">    <span class="built_in">trans</span>()</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">    <span class="selector-class">.img</span></span><br><span class="line">      <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">8px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>), <span class="number">0</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>), <span class="number">0</span> <span class="number">4px</span> <span class="number">8px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>), <span class="number">0</span> <span class="number">8px</span> <span class="number">16px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>)</span><br><span class="line">    <span class="selector-class">.info</span> <span class="selector-class">.title</span></span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#ff5722</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建flexcard-styl"><a href="#新建flexcard-styl" class="headerlink" title="新建flexcard.styl"></a>新建flexcard.styl</h2><p>路径： <code>[Blogroot]\themes\butterfly\source\css\_flink_style\flexcard.styl</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">img</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span> auto<span class="meta">!important</span></span><br><span class="line"><span class="selector-class">.flink-list</span></span><br><span class="line">  <span class="attribute">overflow</span> auto</span><br><span class="line">  &amp; &gt; <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">width</span> <span class="built_in">calc</span>(<span class="number">25%</span> - <span class="number">15px</span>)</span><br><span class="line">    <span class="attribute">height</span> <span class="number">130px</span></span><br><span class="line">    <span class="attribute">position</span> relative</span><br><span class="line">    <span class="attribute">display</span> block</span><br><span class="line">    <span class="attribute">margin</span> <span class="number">15px</span> <span class="number">7px</span></span><br><span class="line">    <span class="attribute">float</span> left</span><br><span class="line">    <span class="attribute">overflow</span> hidden</span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">10px</span></span><br><span class="line">    <span class="attribute">transition</span> all .<span class="number">3s</span> ease <span class="number">0s</span>, transform .<span class="number">6s</span> <span class="built_in">cubic-bezier</span>(.<span class="number">6</span>, .<span class="number">2</span>, .<span class="number">1</span>, <span class="number">1</span>) <span class="number">0s</span></span><br><span class="line">    <span class="attribute">box-shadow</span> <span class="number">0</span> <span class="number">14px</span> <span class="number">38px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">08</span>), <span class="number">0</span> <span class="number">3px</span> <span class="number">8px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">06</span>)</span><br><span class="line">    <span class="selector-pseudo">&amp;:hover</span></span><br><span class="line">      <span class="selector-class">.info</span></span><br><span class="line">        <span class="attribute">transform</span> <span class="built_in">translateY</span>(-<span class="number">100%</span>)</span><br><span class="line">      <span class="selector-class">.wrapper</span></span><br><span class="line">        <span class="selector-tag">img</span></span><br><span class="line">          <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">1.2</span>)</span><br><span class="line">      <span class="selector-pseudo">&amp;::before</span></span><br><span class="line">        <span class="attribute">position</span>: fixed</span><br><span class="line">        <span class="attribute">width</span>:inherit</span><br><span class="line">        <span class="attribute">margin</span>:auto</span><br><span class="line">        <span class="attribute">left</span>:<span class="number">0</span></span><br><span class="line">        <span class="attribute">right</span>:<span class="number">0</span></span><br><span class="line">        <span class="attribute">top</span>:<span class="number">10%</span></span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">10px</span></span><br><span class="line">        <span class="attribute">text-align</span>: center</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">100</span></span><br><span class="line">        <span class="attribute">content</span>: <span class="built_in">attr</span>(data-title)</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span></span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#fff</span></span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">10px</span></span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="variable">$theme</span>-color,<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.cover</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">      <span class="attribute">transition</span> transform .<span class="number">5s</span> ease-out</span><br><span class="line">    <span class="selector-class">.wrapper</span></span><br><span class="line">      <span class="attribute">position</span> relative</span><br><span class="line">      <span class="selector-class">.fadeIn</span></span><br><span class="line">        <span class="attribute">animation</span> coverIn .<span class="number">8s</span> ease-out forwards</span><br><span class="line">      <span class="selector-tag">img</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">130px</span></span><br><span class="line">        <span class="attribute">pointer-events</span> none</span><br><span class="line">    <span class="selector-class">.info</span></span><br><span class="line">      <span class="attribute">display</span> flex</span><br><span class="line">      <span class="attribute">flex-direction</span> column</span><br><span class="line">      <span class="attribute">justify-content</span> center</span><br><span class="line">      <span class="attribute">align-items</span> center</span><br><span class="line">      <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">      <span class="attribute">height</span> <span class="number">100%</span></span><br><span class="line">      <span class="attribute">overflow</span> hidden</span><br><span class="line">      <span class="attribute">border-radius</span> <span class="number">3px</span></span><br><span class="line">      <span class="attribute">background-color</span> <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">7</span>)</span><br><span class="line">      <span class="attribute">transition</span> transform .<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.<span class="number">6</span>, .<span class="number">2</span>, .<span class="number">1</span>, <span class="number">1</span>) <span class="number">0s</span></span><br><span class="line">      <span class="selector-tag">img</span></span><br><span class="line">        <span class="attribute">position</span> relative</span><br><span class="line">        <span class="attribute">top</span> <span class="number">22px</span></span><br><span class="line">        <span class="attribute">width</span> <span class="number">66px</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">66px</span></span><br><span class="line">        <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">        <span class="attribute">box-shadow</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>)</span><br><span class="line">        <span class="attribute">z-index</span> <span class="number">1</span></span><br><span class="line">        <span class="attribute">text-align</span> center</span><br><span class="line">        <span class="attribute">pointer-events</span> none</span><br><span class="line">      <span class="selector-tag">span</span></span><br><span class="line">        <span class="attribute">padding</span> <span class="number">20px</span> <span class="number">10%</span> <span class="number">60px</span> <span class="number">10%</span></span><br><span class="line">        <span class="attribute">font-size</span> <span class="number">16px</span></span><br><span class="line">        <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">        <span class="attribute">text-align</span> center</span><br><span class="line">        <span class="attribute">box-shadow</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>)</span><br><span class="line">        <span class="attribute">background-color</span> <span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">7</span>)</span><br><span class="line">        <span class="attribute">color</span> <span class="built_in">var</span>(--font-color)</span><br><span class="line">        <span class="attribute">white-space</span> nowrap</span><br><span class="line">        <span class="attribute">overflow</span> hidden</span><br><span class="line">        <span class="attribute">text-overflow</span> ellipsis</span><br><span class="line">.flink-list&gt;<span class="selector-tag">a</span> <span class="selector-class">.info</span>,</span><br><span class="line">.flink-list&gt;<span class="selector-tag">a</span> <span class="selector-class">.wrapper</span> <span class="selector-class">.cover</span></span><br><span class="line">  <span class="attribute">position</span> absolute</span><br><span class="line">  <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1024px</span>)</span><br><span class="line">  .flink-list</span><br><span class="line">    &amp; &gt; a</span><br><span class="line">      <span class="attribute">width</span> calc(<span class="number">33.33333%</span> - <span class="number">15px</span>)</span><br><span class="line"></span><br><span class="line">@media screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>)</span><br><span class="line">  .flink-list</span><br><span class="line">    &amp; &gt; a</span><br><span class="line">      <span class="attribute">width</span> calc(<span class="number">50%</span> - <span class="number">15px</span>)</span><br><span class="line"></span><br><span class="line">[data-theme=dark]</span><br><span class="line">  .flink-list a .info,</span><br><span class="line">  .flink-list a .info span</span><br><span class="line">    background-color rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">6</span>)</span><br><span class="line">  .flink-list</span><br><span class="line">    &amp; &gt; a</span><br><span class="line">      &amp;:<span class="attribute">hover</span></span><br><span class="line">        &amp;:before</span><br><span class="line">          background-color: rgba(#<span class="number">121212</span>,<span class="number">0.8</span>);</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">figure</span> &gt; <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">figure</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">img</span>,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">a</span> &gt; svg,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">div</span> &gt; svg,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">figure</span> &gt; svg,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">a</span> &gt; <span class="selector-tag">a</span> &gt; svg,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">a</span> &gt; svg,</span><br><span class="line"><span class="selector-class">.justified-gallery</span> &gt; <span class="selector-tag">figure</span> &gt; <span class="selector-tag">a</span> &gt; svg</span><br><span class="line">  <span class="attribute">position</span> static<span class="meta">!important</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《侧边栏电子时钟》</title>
    <url>/posts/6d4c5f23/</url>
    <content><![CDATA[<h2 id="安装NPM插件"><a href="#安装NPM插件" class="headerlink" title="安装NPM插件"></a>安装NPM插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-clock-anzhiyu --save</span><br></pre></td></tr></table></figure>
<p>如果有安装过其他的电子时钟，需要先卸载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall &lt;package name&gt;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="config-yml添加配置信息"><a href="#config-yml添加配置信息" class="headerlink" title="_config.yml添加配置信息"></a>_config.yml添加配置信息</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># electric_clock</span></span><br><span class="line"><span class="comment"># see https://blog.anheyu.com/posts/fc18.html</span></span><br><span class="line"><span class="attr">electric_clock:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">all</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">  <span class="comment"># - /posts/</span></span><br><span class="line">  <span class="comment"># - /about/</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sticky_layout</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">loading:</span> <span class="string">https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif</span> <span class="comment">#加载动画自定义</span></span><br><span class="line">  <span class="attr">clock_css:</span> <span class="string">https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css</span></span><br><span class="line">  <span class="attr">clock_js:</span> <span class="string">https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js</span></span><br><span class="line">  <span class="attr">ip_api:</span> <span class="string">https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0</span></span><br><span class="line">  <span class="attr">qweather_key:</span> <span class="comment"># 和风天气key</span></span><br><span class="line">  <span class="attr">gaud_map_key:</span> <span class="comment"># 高得地图web服务key</span></span><br><span class="line">  <span class="attr">default_rectangle:</span> <span class="literal">false</span> <span class="comment"># 开启后将一直显示rectangle位置的天气，否则将获取访问者的地理位置与天气</span></span><br><span class="line">  <span class="attr">rectangle:</span> <span class="number">112.982279</span><span class="string">,28.19409</span> <span class="comment"># 获取访问者位置失败时会显示该位置的天气，同时该位置为开启default_rectangle后的位置</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="qweather-key获取"><a href="#qweather-key获取" class="headerlink" title="qweather_key获取"></a>qweather_key获取</h2><p>这个是和风天气的<code>api</code>，我们需要去<a href="https://id.qweather.com/#/login">官网</a>申请</p>
<p>注册登录之后进去控制台</p>
<p><img src="https://s2.loli.net/2024/01/04/aKxb3ZDwVJi4gle.png" alt="image-20240104145936838"></p>
<p>创建自己的应用</p>
<p><img src="https://s2.loli.net/2024/01/04/MUw8V45keYzvLJx.png" alt="image-20240104150033959"></p>
<p><img src="https://s2.loli.net/2024/01/04/PelExOqjIKzc9oC.png" alt="image-20240104150112592"></p>
<p>key选择web API，应用名称跟key名随意</p>
<p>复制key值</p>
<h2 id="gaud-map-key获取"><a href="#gaud-map-key获取" class="headerlink" title="gaud_map_key获取"></a>gaud_map_key获取</h2><p>重复跟和风天气一样的步骤，但是服务平台要选Web服务，不需要配置key，之后复制key值到配置项对应的字段里面就好</p>
<p><br/></p>
<h2 id="配置字段解析"><a href="#配置字段解析" class="headerlink" title="配置字段解析"></a>配置字段解析</h2><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>备选值/类型</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>priority</td>
<td>number</td>
<td>【可选】过滤器优先级，数值越小，执行越早，默认为 10，选填</td>
</tr>
<tr>
<td>enable</td>
<td>true/false</td>
<td>【必选】控制开关</td>
</tr>
<tr>
<td>enable_page</td>
<td>path/all</td>
<td>【可选】填写想要应用的页面的相对路径（即路由地址）,如根目录就填’/‘,分类页面就填’/categories/‘。若要应用于所有页面，就填’all’，默认为 all</td>
</tr>
<tr>
<td>exclude</td>
<td>path</td>
<td>【可选】填写想要屏蔽的页面，可以多个。写法见示例。原理是将屏蔽项的内容逐个放到当前路径去匹配，若当前路径包含任一屏蔽项，则不会挂载。</td>
</tr>
<tr>
<td>layout.type</td>
<td>id/class</td>
<td>【可选】挂载容器类型，填写 id 或 class，不填则默认为 id</td>
</tr>
<tr>
<td>layout.name</td>
<td>text</td>
<td>【必选】挂载容器名称</td>
</tr>
<tr>
<td>layout.index</td>
<td>0 和正整数</td>
<td>【可选】前提是 layout.type 为 class，因为同一页面可能有多个 class，此项用来确认究竟排在第几个顺位</td>
</tr>
<tr>
<td>loading</td>
<td>URL</td>
<td>【可选】电子钟加载动画的图片</td>
</tr>
<tr>
<td>clock_css</td>
<td>URL</td>
<td>【可选】电子钟样式 CDN 资源</td>
</tr>
<tr>
<td>clock_js</td>
<td>URL</td>
<td>【可选】电子钟执行脚本 CDN 资源</td>
</tr>
<tr>
<td>ip_api</td>
<td>URL</td>
<td>【可选】获取时钟 IP 的 API</td>
</tr>
<tr>
<td>qweather_key</td>
<td>text</td>
<td>【可选】和风天气 key</td>
</tr>
<tr>
<td>gaud_map_key</td>
<td>text</td>
<td>【可选】高得地图 web 服务 key</td>
</tr>
<tr>
<td>default_rectangle</td>
<td>text</td>
<td>【可选】开启后将一直显示 rectangle 位置的天气，否则将获取访问者的地理位置与天气</td>
</tr>
<tr>
<td>rectangle</td>
<td>text</td>
<td>【可选】获取访问者位置失败时会显示该位置的天气，同时该位置为开启 default_rectangle 后的位置</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《夜间-白天模式切换动画》</title>
    <url>/posts/2abb07ec/</url>
    <content><![CDATA[<h2 id="新建sun-moon-pug"><a href="#新建sun-moon-pug" class="headerlink" title="新建sun_moon.pug"></a>新建<code>sun_moon.pug</code></h2><p>路径：<code>[BlogRoot]\themes\butterfly\layout\includes\custom\</code></p>
<p>这部分其实实质上就是一个svg文件，通过js操作它的旋转显隐，淡入淡出实现动画效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">svg</span>(aria-hidden=<span class="string">&#x27;true&#x27;</span>, style=<span class="string">&#x27;position:absolute; overflow:hidden; width:0; height:0&#x27;</span>)</span><br><span class="line">  symbol#icon-<span class="title function_">sun</span>(viewBox=<span class="string">&#x27;0 0 1024 1024&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z&#x27;</span>, fill=<span class="string">&#x27;#FFD878&#x27;</span>, p-id=<span class="string">&#x27;8420&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z&#x27;</span>, fill=<span class="string">&#x27;#FFE4A9&#x27;</span>, p-id=<span class="string">&#x27;8421&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z&#x27;</span>, fill=<span class="string">&#x27;#4D5152&#x27;</span>, p-id=<span class="string">&#x27;8422&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z&#x27;</span>, fill=<span class="string">&#x27;#4D5152&#x27;</span>, p-id=<span class="string">&#x27;8423&#x27;</span>)</span><br><span class="line">  symbol#icon-<span class="title function_">moon</span>(viewBox=<span class="string">&#x27;0 0 1024 1024&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z&#x27;</span>, fill=<span class="string">&#x27;#FFB531&#x27;</span>, p-id=<span class="string">&#x27;11345&#x27;</span>)</span><br><span class="line">    <span class="title function_">path</span>(d=<span class="string">&#x27;M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z&#x27;</span>, fill=<span class="string">&#x27;#030835&#x27;</span>, p-id=<span class="string">&#x27;11346&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建sun-moon-styl"><a href="#新建sun-moon-styl" class="headerlink" title="新建sun_moon.styl"></a>新建<code>sun_moon.styl</code></h2><p>路径：<code>[BlogRoot]\themes\butterfly\source\css\_layout\</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.Cuteen_DarkSky</span>,</span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span><span class="selector-pseudo">:before</span></span><br><span class="line">  <span class="attribute">content</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attribute">position</span> fixed</span><br><span class="line">  <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">88888888</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span></span><br><span class="line">  <span class="attribute">background</span> <span class="built_in">linear-gradient</span>(to top, <span class="number">#f8cd71</span> <span class="number">0</span>, <span class="number">#5bfde9</span> <span class="number">80%</span>)</span><br><span class="line">  <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="attribute">transition</span> <span class="number">2s</span> ease all</span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">background</span> <span class="built_in">linear-gradient</span>(to top, <span class="number">#30cfd0</span> <span class="number">0</span>, <span class="number">#330867</span> <span class="number">100%</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.DarkMode</span></span><br><span class="line">  <span class="selector-class">.Cuteen_DarkSky</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span></span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">99999999</span></span><br><span class="line">  <span class="attribute">position</span> fixed</span><br><span class="line">  <span class="attribute">left</span> -<span class="number">50%</span></span><br><span class="line">  <span class="attribute">top</span> -<span class="number">50%</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">200%</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">200%</span></span><br><span class="line">  -webkit-<span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="attribute">transform-origin</span> center bottom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> CuteenPlanetMove &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> CuteenPlanetMove &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span></span><br><span class="line">  <span class="selector-id">#sun</span></span><br><span class="line">    <span class="attribute">position</span> absolute</span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">100%</span></span><br><span class="line">    <span class="attribute">left</span> <span class="number">44%</span></span><br><span class="line">    <span class="attribute">top</span> <span class="number">30%</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">6rem</span></span><br><span class="line">    <span class="attribute">width</span> <span class="number">6rem</span></span><br><span class="line">    <span class="attribute">background</span> <span class="number">#ffee94</span></span><br><span class="line">    <span class="attribute">box-shadow</span> <span class="number">0</span> <span class="number">0</span> <span class="number">40px</span> <span class="number">#ffee94</span></span><br><span class="line">    <span class="comment">// opacity 0</span></span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#moon</span></span><br><span class="line">    <span class="attribute">position</span> absolute</span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">100%</span></span><br><span class="line">    <span class="attribute">left</span> <span class="number">44%</span></span><br><span class="line">    <span class="attribute">top</span> <span class="number">30%</span></span><br><span class="line">    <span class="attribute">position</span> absolute</span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">100%</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">6rem</span></span><br><span class="line">    <span class="attribute">width</span> <span class="number">6rem</span></span><br><span class="line">    <span class="attribute">box-shadow</span> -<span class="number">1.8em</span> <span class="number">1.8em</span> <span class="number">0</span> <span class="number">0.2em</span> <span class="number">#fff</span></span><br><span class="line">    <span class="comment">// opacity 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// &amp;:after</span></span><br><span class="line">  <span class="comment">//   position absolute</span></span><br><span class="line">  <span class="comment">//   left 42%</span></span><br><span class="line">  <span class="comment">//   top 30%</span></span><br><span class="line">  <span class="comment">//   width 6rem</span></span><br><span class="line">  <span class="comment">//   height 6rem</span></span><br><span class="line">  <span class="comment">//   border-radius 50%</span></span><br><span class="line">  <span class="comment">//   content &#x27;&#x27;</span></span><br><span class="line">  <span class="comment">//   background #ffef9e</span></span><br><span class="line">  <span class="comment">//   box-shadow 0 0 30px #ffef9e</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.search</span></span><br><span class="line">  <span class="selector-tag">span</span></span><br><span class="line">    <span class="attribute">display</span> none</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menus_item</span></span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">text-decoration</span> none<span class="meta">!important</span></span><br><span class="line"><span class="comment">//按钮相关，对侧栏按钮做过魔改的可以调整这里的数值</span></span><br><span class="line"><span class="comment">// .icon-V</span></span><br><span class="line"><span class="comment">//   padding 5px</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建sun-moon-js"><a href="#新建sun-moon-js" class="headerlink" title="新建sun_moon.js"></a>新建<code>sun_moon.js</code></h2><p>路径：<code>[BlogRoot]\themes\butterfly\source\js\</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">switchNightMode</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;beforeend&#x27;</span>, <span class="string">&#x27;&lt;div class=&quot;Cuteen_DarkSky&quot;&gt;&lt;div class=&quot;Cuteen_DarkPlanet&quot;&gt;&lt;div id=&quot;sun&quot;&gt;&lt;/div&gt;&lt;div id=&quot;moon&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>),</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;DarkMode&#x27;</span>) ? (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;0&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)) : (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)),</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;opacity 3s&#x27;</span>;</span><br><span class="line">                    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="title function_">remove</span>();</span><br><span class="line">                    &#125;, <span class="number">1e3</span>);</span><br><span class="line">                &#125;, <span class="number">2e3</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">const</span> nowMode = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 先设置太阳月亮透明度</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sun&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;moon&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sun&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;moon&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">activateDarkMode</span>()</span><br><span class="line">        saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night)</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)</span><br><span class="line">        <span class="comment">// 延时弹窗提醒</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.$notify(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&quot;关灯啦🌙&quot;</span>,</span><br><span class="line">                        <span class="attr">message</span>: <span class="string">&quot;当前已成功切换至夜间模式！&quot;</span>,</span><br><span class="line">                        <span class="attr">position</span>: <span class="string">&#x27;top-left&#x27;</span>,</span><br><span class="line">                        <span class="attr">offset</span>: <span class="number">50</span>,</span><br><span class="line">                        <span class="attr">showClose</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                        <span class="attr">duration</span>: <span class="number">5000</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先设置太阳月亮透明度</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sun&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;moon&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sun&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;moon&quot;</span>).<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">activateLightMode</span>()</span><br><span class="line">        saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">                <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.$notify(&#123;</span><br><span class="line">                        <span class="attr">title</span>: <span class="string">&quot;开灯啦🌞&quot;</span>,</span><br><span class="line">                        <span class="attr">message</span>: <span class="string">&quot;当前已成功切换至白天模式！&quot;</span>,</span><br><span class="line">                        <span class="attr">position</span>: <span class="string">&#x27;top-left&#x27;</span>,</span><br><span class="line">                        <span class="attr">offset</span>: <span class="number">50</span>,</span><br><span class="line">                        <span class="attr">showClose</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">type</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">                        <span class="attr">duration</span>: <span class="number">5000</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// handle some cases</span></span><br><span class="line">    <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">utterancesTheme</span>()</span><br><span class="line">    <span class="keyword">typeof</span> <span class="variable constant_">FB</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">loadFBComment</span>()</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">DISQUS</span> &amp;&amp; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disqus_thread&#x27;</span>).<span class="property">children</span>.<span class="property">length</span> &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">disqusReset</span>(), <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改head-pug"><a href="#修改head-pug" class="headerlink" title="修改head.pug"></a>修改<code>head.pug</code></h2><p>路径：<code>[BlogRoot]\themes\butterfly\layout\includes\</code></p>
<p>在文件末位加上一行</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  //- global config</span><br><span class="line">  !=partial(&#x27;includes/head/config&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">  include ./head/config_site.pug</span><br><span class="line">  include ./head/noscript.pug</span><br><span class="line"></span><br><span class="line">  !=fragment_cache(&#x27;injectHeadJs&#x27;, function()&#123;return inject_head_js()&#125;)</span><br><span class="line"></span><br><span class="line">  !=fragment_cache(&#x27;injectHead&#x27;, function()&#123;return injectHtml(theme.inject.head)&#125;)</span><br><span class="line"><span class="addition">+ include ./custom/sun_moon.pug</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改rightside-pug"><a href="#修改rightside-pug" class="headerlink" title="修改rightside.pug"></a>修改<code>rightside.pug</code></h2><p>路径：<code>[BlogRoot]\themes\butterfly\layout\includes\</code></p>
<p>把原本的昼夜切换按钮替换掉</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  when &#x27;translate&#x27;</span><br><span class="line">    if translate.enable</span><br><span class="line">      button#translateLink(type=&quot;button&quot; title=_p(&#x27;rightside.translate_title&#x27;))= translate.default</span><br><span class="line">  when &#x27;darkmode&#x27;</span><br><span class="line">    if darkmode.enable &amp;&amp; darkmode.button</span><br><span class="line"><span class="deletion">-     button#darkmode(type=&quot;button&quot; title=_p(&#x27;rightside.night_mode_title&#x27;))</span></span><br><span class="line"><span class="deletion">-       i.fas.fa-adjust</span></span><br><span class="line"><span class="addition">+     a.icon-V.hidden(onclick=&#x27;switchNightMode()&#x27;,  title=_p(&#x27;rightside.night_mode_title&#x27;))</span></span><br><span class="line"><span class="addition">+       svg(width=&#x27;25&#x27;, height=&#x27;25&#x27;, viewBox=&#x27;0 0 1024 1024&#x27;)</span></span><br><span class="line"><span class="addition">+         use#modeicon(xlink:href=&#x27;#icon-moon&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改<code>_config.butterfly.yml</code></h2><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  bottom:</span><br><span class="line"><span class="addition">+    - &lt;script src=&quot;/js/sun_moon.js&quot; async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《图片模糊变清晰》</title>
    <url>/posts/d7cf5170/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/</span></span><br><span class="line"><span class="selector-id">#page-header</span>,</span><br><span class="line"><span class="selector-id">#web_bg</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: imgblur <span class="number">10s</span> <span class="number">1</span> ease-in-out;</span><br><span class="line">    <span class="attribute">animation</span>: imgblur <span class="number">10s</span> <span class="number">1</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> imgblur &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*适配使用-webkit内核的浏览器 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> imgblur &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">0px</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="指定页面"><a href="#指定页面" class="headerlink" title="指定页面"></a>指定页面</h2><p>在对应页面的<code>markdown</code>里面写入以下代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line">/<span class="emphasis">*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*</span>/</span><br><span class="line"><span class="section">#page-header,</span></span><br><span class="line"><span class="section">#web<span class="emphasis">_bg &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    -webkit-animation: imgblur 10s 1 ease-in-out;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    animation: imgblur 10s 1 ease-in-out;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">&#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">@keyframes imgblur &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  0% &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    filter: blur(5px);</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  &#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  100% &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    filter: blur(0px);</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  &#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">&#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">/*适配使用-webkit内核的浏览器 */</span></span></span><br><span class="line"><span class="emphasis"><span class="section">@-webkit-keyframes imgblur &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  0% &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    -webkit-filter: blur(5px);</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  &#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  100% &#123;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">    -webkit-filter: blur(0px);</span></span></span><br><span class="line"><span class="emphasis"><span class="section">  &#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section">&#125;</span></span></span><br><span class="line"><span class="emphasis"><span class="section"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="section">&#123;% endraw %&#125;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《右键菜单》</title>
    <url>/posts/2f105087/</url>
    <content><![CDATA[<h2 id="修改PUG"><a href="#修改PUG" class="headerlink" title="修改PUG"></a>修改PUG</h2><p>新建 <code>[blogRoot]\themes\butterfly\layout\includes\rightmenu.pug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rightMenu.js-pjax</span><br><span class="line">  .rightMenu-group.rightMenu-small</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:window.history.back();&quot;)</span><br><span class="line">      i.fa.fa-arrow-left</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:window.history.forward();&quot;)</span><br><span class="line">      i.fa.fa-arrow-right</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:window.location.reload();&quot;)</span><br><span class="line">      i.fa.fa-refresh</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.scrollToTop();&quot;)</span><br><span class="line">      i.fa.fa-arrow-up</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-text</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.copySelect();&quot;)</span><br><span class="line">      i.fa.fa-copy</span><br><span class="line">      span=&#x27;复制&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:window.open(\&quot;https://www.baidu.com/s?wd=\&quot;+window.getSelection().toString());window.location.reload();&quot;)</span><br><span class="line">      i.iconfont.icon-baidu</span><br><span class="line">      span=&#x27;百度搜索&#x27;</span><br><span class="line">    //a.rightMenu-item(href=&quot;javascript:rmf.searchinThisPage();&quot;)</span><br><span class="line">    //  i.fas.fa-search</span><br><span class="line">    //  span=&#x27;站内搜索&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;#post-comment&quot; onclick=&quot;rmf.yinyong()&quot;)</span><br><span class="line">      i.fa-solid.fa-message</span><br><span class="line">      span=&#x27;引用文本评论&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-too</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:window.open(window.getSelection().toString());window.location.reload();&quot;)</span><br><span class="line">      i.fa.fa-link</span><br><span class="line">      span=&#x27;转到链接&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-paste</span><br><span class="line">    a.rightMenu-item(href=&#x27;javascript:rmf.paste()&#x27;)</span><br><span class="line">      i.fa.fa-copy</span><br><span class="line">      span=&#x27;粘贴&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-post</span><br><span class="line">    a.rightMenu-item(href=&quot;#post-comment&quot;)</span><br><span class="line">      i.fas.fa-comment</span><br><span class="line">      span=&#x27;空降评论&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.copyWordsLink()&quot;)</span><br><span class="line">      i.fa.fa-link</span><br><span class="line">      span=&#x27;复制本文地址&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-to</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.openWithNewTab()&quot;)</span><br><span class="line">      i.fa.fa-window-restore</span><br><span class="line">      span=&#x27;新窗口打开&#x27;</span><br><span class="line">    a.rightMenu-item#menu-too(href=&quot;javascript:rmf.open()&quot;)</span><br><span class="line">      i.fa.fa-link</span><br><span class="line">      span=&#x27;转到链接&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.copyLink()&quot;)</span><br><span class="line">      i.fa.fa-copy</span><br><span class="line">      span=&#x27;复制链接&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line.hide#menu-img</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.saveAs()&quot;)</span><br><span class="line">      i.fa.fa-download</span><br><span class="line">      span=&#x27;保存图片&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.openWithNewTab()&quot;)</span><br><span class="line">      i.fa.fa-window-restore</span><br><span class="line">      span=&#x27;在新窗口打开&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.click()&quot;)</span><br><span class="line">      i.fa.fa-arrows-alt</span><br><span class="line">      span=&#x27;全屏显示&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.copyLink()&quot;)</span><br><span class="line">      i.fa.fa-copy</span><br><span class="line">      span=&#x27;复制图片链接&#x27;</span><br><span class="line">  .rightMenu-group.rightMenu-line</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:randomPost()&quot;)</span><br><span class="line">      i.fa.fa-paper-plane</span><br><span class="line">      span=&#x27;随便逛逛&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.switchDarkMode();&quot;)</span><br><span class="line">      i.fa.fa-moon</span><br><span class="line">      span=&#x27;昼夜切换&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.translate();&quot;)</span><br><span class="line">      i.iconfont.icon-fanti</span><br><span class="line">      span=&#x27;繁简转换&#x27;</span><br><span class="line">    if is_post()||is_page()</span><br><span class="line">      a.rightMenu-item(href=&quot;javascript:rmf.switchReadMode();&quot;)</span><br><span class="line">        i.fa.fa-book</span><br><span class="line">        span=&#x27;阅读模式&#x27;</span><br><span class="line">    //a.rightMenu-item(href=&quot;javascript:toggleWinbox();&quot;)</span><br><span class="line">    //  i.fas.fa-cog</span><br><span class="line">    //  span=&#x27;博客设置&#x27;</span><br><span class="line">    a.rightMenu-item(href=&quot;javascript:rmf.fullScreen();&quot;)</span><br><span class="line">      i.fas.fa-expand</span><br><span class="line">      span#fullScreenText=&#x27;进入全屏&#x27;</span><br></pre></td></tr></table></figure>
<p>里面有一些图标用的iconfont的，请自行替换</p>
<p><br/></p>
<h2 id="添加CSS"><a href="#添加CSS" class="headerlink" title="添加CSS"></a>添加CSS</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rightMenu */</span></span><br><span class="line"><span class="selector-id">#rightMenu</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">height</span>: fit-content;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--card-bg);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">var</span>(--font-color);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">7px</span> <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>))&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="built_in">var</span>(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span><span class="selector-class">.rightMenu-small</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span> <span class="selector-class">.rightMenu-item</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span><span class="selector-class">.rightMenu-line</span> <span class="selector-class">.rightMenu-item</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span> <span class="selector-class">.rightMenu-item</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--text-bg-hover);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span> <span class="selector-class">.rightMenu-item</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span> <span class="selector-class">.rightMenu-item</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#rightMenu</span> <span class="selector-class">.rightMenu-group</span><span class="selector-class">.rightMenu-line</span> <span class="selector-class">.rightMenu-item</span> *&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rightMenu-group</span><span class="selector-class">.hide</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主题配置文件<code>_config.butterfly.yml</code>添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/rightMenu.css&quot;&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="Javascript添加"><a href="#Javascript添加" class="headerlink" title="Javascript添加"></a>Javascript添加</h2><p>创建 <code>[blogRoot]/source/js/rightMenu.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 右键菜单js</span></span><br><span class="line"><span class="comment"> * @Author: 5t5</span></span><br><span class="line"><span class="comment"> * @Time: 2024/1/26 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//22.12.8 update：add mask</span></span><br><span class="line"><span class="comment">//22.12.9 update: add search in this page</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setMask</span>(<span class="params"></span>)&#123;<span class="comment">//设置遮罩层</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;rmMask&quot;</span>)[<span class="number">0</span>] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;rmMask&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  mask = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  mask.<span class="property">className</span> = <span class="string">&quot;rmMask&quot;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">width</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">height</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;.0&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  mask.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="number">998</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mask);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;rightMenu&quot;</span>).<span class="property">style</span>.<span class="property">zIndex</span>=<span class="number">19198</span>;</span><br><span class="line">  <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertAtCursor</span>(<span class="params">myField, myValue</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//IE 浏览器</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">selection</span>) &#123;</span><br><span class="line">    myField.<span class="title function_">focus</span>();</span><br><span class="line">    sel = <span class="variable language_">document</span>.<span class="property">selection</span>.<span class="title function_">createRange</span>();</span><br><span class="line">    sel.<span class="property">text</span> = myValue;</span><br><span class="line">    sel.<span class="title function_">select</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//FireFox、Chrome等</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (myField.<span class="property">selectionStart</span> || myField.<span class="property">selectionStart</span> == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> startPos = myField.<span class="property">selectionStart</span>;</span><br><span class="line">    <span class="keyword">var</span> endPos = myField.<span class="property">selectionEnd</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存滚动条</span></span><br><span class="line">    <span class="keyword">var</span> restoreTop = myField.<span class="property">scrollTop</span>;</span><br><span class="line">    myField.<span class="property">value</span> = myField.<span class="property">value</span>.<span class="title function_">substring</span>(<span class="number">0</span>, startPos) + myValue + myField.<span class="property">value</span>.<span class="title function_">substring</span>(endPos, myField.<span class="property">value</span>.<span class="property">length</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (restoreTop &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      myField.<span class="property">scrollTop</span> = restoreTop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myField.<span class="title function_">focus</span>();</span><br><span class="line">    myField.<span class="property">selectionStart</span> = startPos + myValue.<span class="property">length</span>;</span><br><span class="line">    myField.<span class="property">selectionEnd</span> = startPos + myValue.<span class="property">length</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    myField.<span class="property">value</span> += myValue;</span><br><span class="line">    myField.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rmf = &#123;&#125;;</span><br><span class="line">rmf.<span class="property">showRightMenu</span> = <span class="keyword">function</span> (<span class="params">isTrue, x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> $rightMenu = $(<span class="string">&#x27;#rightMenu&#x27;</span>);</span><br><span class="line">  $rightMenu.<span class="title function_">css</span>(<span class="string">&#x27;top&#x27;</span>, x + <span class="string">&#x27;px&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;left&#x27;</span>, y + <span class="string">&#x27;px&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isTrue) &#123;</span><br><span class="line">    $rightMenu.<span class="title function_">show</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $rightMenu.<span class="title function_">hide</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">switchDarkMode</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nowMode = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">activateDarkMode</span>()</span><br><span class="line">    saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span> !== <span class="literal">undefined</span> &amp;&amp; btf.<span class="title function_">snackbarShow</span>(<span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>.<span class="property">day_to_night</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">activateLightMode</span>()</span><br><span class="line">    saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span> !== <span class="literal">undefined</span> &amp;&amp; btf.<span class="title function_">snackbarShow</span>(<span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>.<span class="property">night_to_day</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// handle some cases</span></span><br><span class="line">  <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">utterancesTheme</span>()</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable constant_">FB</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">loadFBComment</span>()</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">DISQUS</span> &amp;&amp; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disqus_thread&#x27;</span>).<span class="property">children</span>.<span class="property">length</span> &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">disqusReset</span>(), <span class="number">200</span>)</span><br><span class="line">&#125;;</span><br><span class="line">rmf.<span class="property">yinyong</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;el-textarea__inner&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">    t = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;HTMLEvents&quot;</span>);</span><br><span class="line">  t.<span class="title function_">initEvent</span>(<span class="string">&quot;input&quot;</span>, !<span class="number">0</span>, !<span class="number">0</span>), e.<span class="property">value</span> = d.<span class="property">value</span> = <span class="string">&quot;&gt; &quot;</span>+<span class="title function_">getSelection</span>().<span class="title function_">toString</span>()+<span class="string">&quot;\n\n&quot;</span>, e.<span class="title function_">dispatchEvent</span>(t);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSelection</span>().<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;el-textarea__inner&quot;</span>)[<span class="number">0</span>].<span class="property">value</span>=<span class="string">&quot;&gt; &quot;</span>+<span class="title function_">getSelection</span>().<span class="title function_">toString</span>()+<span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  <span class="title class_">Snackbar</span>.<span class="title function_">show</span>(&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;为保证最佳评论阅读体验，建议不要删除空行&#x27;</span>,</span><br><span class="line">    <span class="attr">pos</span>: <span class="string">&#x27;top-center&#x27;</span>,</span><br><span class="line">    <span class="attr">showAction</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">copyWordsLink</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">  <span class="keyword">let</span> txa = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">  txa.<span class="property">value</span> = url;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(txa)</span><br><span class="line">  txa.<span class="title function_">select</span>();</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&quot;Copy&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(txa);</span><br><span class="line">  <span class="title class_">Snackbar</span>.<span class="title function_">show</span>(&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;链接复制成功！快去分享吧！&#x27;</span>,</span><br><span class="line">    <span class="attr">pos</span>: <span class="string">&#x27;top-right&#x27;</span>,</span><br><span class="line">    <span class="attr">showAction</span>: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">switchReadMode</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> $body = <span class="variable language_">document</span>.<span class="property">body</span></span><br><span class="line">  $body.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;read-mode&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> newEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">  newEle.<span class="property">type</span> = <span class="string">&#x27;button&#x27;</span></span><br><span class="line">  newEle.<span class="property">className</span> = <span class="string">&#x27;fas fa-sign-out-alt exit-readmode&#x27;</span></span><br><span class="line">  $body.<span class="title function_">appendChild</span>(newEle)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">clickFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $body.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;read-mode&#x27;</span>)</span><br><span class="line">    newEle.<span class="title function_">remove</span>()</span><br><span class="line">    newEle.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clickFn)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  newEle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, clickFn)</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">fullScreen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fullScreenText = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fullScreenText&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!rmf.<span class="property">isFull</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取页面元素</span></span><br><span class="line">    <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断浏览器是否支持全屏API</span></span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">requestFullscreen</span>) &#123;</span><br><span class="line">      <span class="comment">// 进入全屏</span></span><br><span class="line">      element.<span class="title function_">requestFullscreen</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 在进入全屏时，将控制台内容隐藏</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">clear</span>(); <span class="comment">// 清除控制台内容</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Entering fullscreen. Console content is cleared.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Fullscreen API is not supported in this browser.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rmf.<span class="property">isFull</span> = <span class="literal">true</span>;</span><br><span class="line">    fullScreenText.<span class="property">textContent</span> = <span class="string">&quot;退出全屏&quot;</span>; <span class="comment">// 设置 span 内容</span></span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 退出全屏</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">exitFullscreen</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">exitFullscreen</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Exiting fullscreen.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Fullscreen exit is not supported in this browser.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rmf.<span class="property">isFull</span> = <span class="literal">false</span>;</span><br><span class="line">    fullScreenText.<span class="property">textContent</span> = <span class="string">&quot;进入全屏&quot;</span>; <span class="comment">// 设置 span 内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制选中文字</span></span><br><span class="line">rmf.<span class="property">copySelect</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;Copy&#x27;</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//这里可以写点东西提示一下 已复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回到顶部</span></span><br><span class="line">rmf.<span class="property">scrollToTop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">//document.getElementById(&quot;name-container&quot;).setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span></span><br><span class="line">  btf.<span class="title function_">scrollToDest</span>(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">translate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;translateLink&quot;</span>).<span class="title function_">click</span>();</span><br><span class="line">&#125;</span><br><span class="line">rmf.<span class="property">searchinThisPage</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> searchTarget = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#algolia-search .search-dialog&#x27;</span>)</span><br><span class="line">  searchTarget.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">  <span class="comment">// 获取搜索框元素</span></span><br><span class="line">  <span class="keyword">const</span> searchBoxInput = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;ais-SearchBox-input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 设置搜索框的值为当前选中的文本</span></span><br><span class="line">  searchBoxInput.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line">  <span class="comment">// 模拟按下回车键的事件</span></span><br><span class="line">  <span class="keyword">const</span> enterKeyEvent = <span class="keyword">new</span> <span class="title class_">KeyboardEvent</span>(<span class="string">&#x27;keyup&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&#x27;Enter&#x27;</span>, <span class="attr">keyCode</span>: <span class="number">13</span> &#125;);</span><br><span class="line">  searchBoxInput.<span class="title function_">dispatchEvent</span>(enterKeyEvent);</span><br><span class="line">  <span class="comment">//var evt = document.createEvent(&quot;HTMLEvents&quot;);</span></span><br><span class="line">  <span class="comment">//evt.initEvent(&quot;input&quot;, false, false);</span></span><br><span class="line">  <span class="comment">//document.getElementsByClassName(&quot;local-search-box--input&quot;)[0].dispatchEvent(evt);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">popupMenu</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//window.oncontextmenu=function()&#123;return false;&#125;</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">ctrlKey</span>||<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>&lt;<span class="number">900</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    $(<span class="string">&#x27;.rightMenu-group.hide&#x27;</span>).<span class="title function_">hide</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>()) &#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-text&#x27;</span>).<span class="title function_">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;post&#x27;</span>)) &#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-post&#x27;</span>).<span class="title function_">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;page&#x27;</span>)) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#menu-post&#x27;</span>).<span class="title function_">show</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">body</span>;</span><br><span class="line">    el = event.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="regexp">/^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&amp;&#x27;\*\+,;=.]+$/</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="title function_">test</span>(<span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>())&amp;&amp;el.<span class="property">tagName</span>!=<span class="string">&quot;A&quot;</span>)&#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-too&#x27;</span>).<span class="title function_">show</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">tagName</span> == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-to&#x27;</span>).<span class="title function_">show</span>()</span><br><span class="line">      rmf.<span class="property">open</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(el.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;http://&quot;</span>)==-<span class="number">1</span>&amp;&amp;el.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;https://&quot;</span>)==-<span class="number">1</span>||el.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;yisous.xyz&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">          pjax.<span class="title function_">loadUrl</span>(el.<span class="property">href</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          location.<span class="property">href</span> = el.<span class="property">href</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      rmf.<span class="property">openWithNewTab</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">open</span>(el.<span class="property">href</span>);</span><br><span class="line">        <span class="comment">// window.location.reload();</span></span><br><span class="line">      &#125;</span><br><span class="line">      rmf.<span class="property">copyLink</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> url = el.<span class="property">href</span></span><br><span class="line">        <span class="keyword">let</span> txa = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">        txa.<span class="property">value</span> = url;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(txa)</span><br><span class="line">        txa.<span class="title function_">select</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&quot;Copy&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(txa);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (el.<span class="property">tagName</span> == <span class="string">&#x27;IMG&#x27;</span>) &#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-img&#x27;</span>).<span class="title function_">show</span>()</span><br><span class="line">      rmf.<span class="property">openWithNewTab</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">open</span>(el.<span class="property">src</span>);</span><br><span class="line">        <span class="comment">// window.location.reload();</span></span><br><span class="line">      &#125;</span><br><span class="line">      rmf.<span class="property">click</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        el.<span class="title function_">click</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      rmf.<span class="property">copyLink</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> url = el.<span class="property">src</span></span><br><span class="line">        <span class="keyword">let</span> txa = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;textarea&quot;</span>);</span><br><span class="line">        txa.<span class="property">value</span> = url;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(txa)</span><br><span class="line">        txa.<span class="title function_">select</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&quot;Copy&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(txa);</span><br><span class="line">      &#125;</span><br><span class="line">      rmf.<span class="property">saveAs</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> url = el.<span class="property">src</span>;</span><br><span class="line">        <span class="keyword">var</span> filename = url.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>];</span><br><span class="line">        a.<span class="property">href</span> = url;</span><br><span class="line">        a.<span class="property">download</span> = filename;</span><br><span class="line">        a.<span class="title function_">click</span>();</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tagName</span> == <span class="string">&quot;TEXTAREA&quot;</span> || el.<span class="property">tagName</span> == <span class="string">&quot;INPUT&quot;</span>) &#123;</span><br><span class="line">      $(<span class="string">&#x27;#menu-paste&#x27;</span>).<span class="title function_">show</span>();</span><br><span class="line">      <span class="comment">// rmf.paste=function()&#123;</span></span><br><span class="line">      <span class="comment">//     input.addEventListener(&#x27;paste&#x27;, async event =&gt; &#123;</span></span><br><span class="line">      <span class="comment">//         event.preventDefault();</span></span><br><span class="line">      <span class="comment">//         const text = await navigator.clipboard.readText();</span></span><br><span class="line">      <span class="comment">//         el.value+=text;</span></span><br><span class="line">      <span class="comment">//       &#125;);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      rmf.<span class="property">paste</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        navigator.<span class="property">permissions</span></span><br><span class="line">          .<span class="title function_">query</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;clipboard-read&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="property">state</span> == <span class="string">&#x27;granted&#x27;</span> || result.<span class="property">state</span> == <span class="string">&#x27;prompt&#x27;</span>) &#123;</span><br><span class="line">              <span class="comment">//读取剪贴板</span></span><br><span class="line">              navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>().<span class="title function_">then</span>(<span class="function"><span class="params">text</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line">                <span class="title function_">insertAtCursor</span>(el, text)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title class_">Snackbar</span>.<span class="title function_">show</span>(&#123;</span><br><span class="line">                <span class="attr">text</span>: <span class="string">&#x27;请允许读取剪贴板！&#x27;</span>,</span><br><span class="line">                <span class="attr">pos</span>: <span class="string">&#x27;top-center&#x27;</span>,</span><br><span class="line">                <span class="attr">showAction</span>: <span class="literal">false</span>,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pageX = event.<span class="property">clientX</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> pageY = event.<span class="property">clientY</span>;</span><br><span class="line">    <span class="keyword">let</span> rmWidth = $(<span class="string">&#x27;#rightMenu&#x27;</span>).<span class="title function_">width</span>();</span><br><span class="line">    <span class="keyword">let</span> rmHeight = $(<span class="string">&#x27;#rightMenu&#x27;</span>).<span class="title function_">height</span>();</span><br><span class="line">    <span class="keyword">if</span> (pageX + rmWidth &gt; <span class="variable language_">window</span>.<span class="property">innerWidth</span>) &#123;</span><br><span class="line">      pageX -= rmWidth + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pageY + rmHeight &gt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>) &#123;</span><br><span class="line">      pageY -= pageY + rmHeight - <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mask=<span class="title function_">setMask</span>();</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onscroll</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      rmf.<span class="title function_">showRightMenu</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">onscroll</span>=<span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (mask) &#123;</span><br><span class="line">        <span class="comment">// 判断 mask 是否有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (mask.<span class="property">parentNode</span>) &#123;</span><br><span class="line">          <span class="comment">// 移除 mask 的父节点中的 mask</span></span><br><span class="line">          mask.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(mask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Mask does not have a parent node.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">&quot;.rightMenu-item&quot;</span>).<span class="title function_">click</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mask) &#123;</span><br><span class="line">        <span class="comment">// 判断 mask 是否有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (mask.<span class="property">parentNode</span>) &#123;</span><br><span class="line">          <span class="comment">// 移除 mask 的父节点中的 mask</span></span><br><span class="line">          mask.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(mask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Mask does not have a parent node.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    $(<span class="variable language_">window</span>).<span class="title function_">resize</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      rmf.<span class="title function_">showRightMenu</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (mask) &#123;</span><br><span class="line">        <span class="comment">// 判断 mask 是否有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (mask.<span class="property">parentNode</span>) &#123;</span><br><span class="line">          <span class="comment">// 移除 mask 的父节点中的 mask</span></span><br><span class="line">          mask.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(mask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Mask does not have a parent node.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    mask.<span class="property">onclick</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mask) &#123;</span><br><span class="line">        <span class="comment">// 判断 mask 是否有父节点</span></span><br><span class="line">        <span class="keyword">if</span> (mask.<span class="property">parentNode</span>) &#123;</span><br><span class="line">          <span class="comment">// 移除 mask 的父节点中的 mask</span></span><br><span class="line">          mask.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(mask);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Mask does not have a parent node.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rmf.<span class="title function_">showRightMenu</span>(<span class="literal">true</span>, pageY, pageX);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    rmf.<span class="title function_">showRightMenu</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">  <span class="title function_">popupMenu</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addLongtabListener</span>(<span class="params">target, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span> <span class="comment">// 初始化timer</span></span><br><span class="line">  </span><br><span class="line">  target.<span class="property">ontouchstart</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="number">0</span> <span class="comment">// 重置timer</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>();</span><br><span class="line">      timer = <span class="number">0</span></span><br><span class="line">    &#125;, <span class="number">380</span>) <span class="comment">// 超时器能成功执行，说明是长按</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  target.<span class="property">ontouchmove</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer) <span class="comment">// 如果来到这里，说明是滑动</span></span><br><span class="line">    timer = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  target.<span class="property">ontouchend</span> = <span class="function">() =&gt;</span> &#123; <span class="comment">// 到这里如果timer有值，说明此触摸时间不足380ms，是点击</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addLongtabListener</span>(box, popupMenu)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主题配置文件<code>_config.butterfly.yml</code>添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/rightMenu.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>本站测试效果</p>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《宽屏适配》</title>
    <url>/posts/fc66d6d5/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局宽度 */</span></span><br><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 侧边卡片栏宽度 */</span></span><br><span class="line"><span class="selector-class">.aside-content</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">318px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 平板尺寸自适应(不启用侧边栏宽度限制) */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.aside-content</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="指定页面"><a href="#指定页面" class="headerlink" title="指定页面"></a>指定页面</h2><p>不想再非首页的地方显示侧边栏，那就需要给非首页的页面加上标记，<code>修改 [BlogRoot]\themes\butterfly\layout\includes\layout.pug</code>为以下内容</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> - var htmlClassHideAside = theme.aside.enable &amp;&amp; theme.aside.hide ? &#x27;hide-aside&#x27; : &#x27;&#x27;</span><br><span class="line"> - page.aside = is_archive() ? theme.aside.display.archive: is_category() ? theme.aside.display.category : is_tag() ? theme.aside.display.tag : page.aside</span><br><span class="line"> - var hideAside = !theme.aside.enable || page.aside <span class="comment">=== false ? &#x27;hide-aside&#x27; : &#x27;&#x27;</span></span><br><span class="line"><span class="deletion">- - var pageType = is_post() ? &#x27;post&#x27; : &#x27;page&#x27;</span></span><br><span class="line"><span class="addition">+ - var pageType = is_home() ? &#x27;page home&#x27; : is_post() ? &#x27;post&#x27; : &#x27;page&#x27;</span></span><br><span class="line"></span><br><span class="line">doctype html</span><br><span class="line">html(lang=config.language data-theme=theme.display_mode class=htmlClassHideAside)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>或者（4.3.1可以食用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- var htmlClassHideAside = theme.aside.enable &amp;&amp; theme.aside.hide ? &#x27;hide-aside&#x27; : &#x27;&#x27;</span><br><span class="line">- page.aside = is_archive() ? theme.aside.display.archive: is_category() ? theme.aside.display.category : is_tag() ? theme.aside.display.tag : page.aside</span><br><span class="line">- var hideAside = !theme.aside.enable || page.aside === false ? &#x27;hide-aside&#x27; : &#x27;&#x27;</span><br><span class="line">- var pageType = is_home() ? &#x27;page home&#x27; : is_post() ? &#x27;post&#x27; : &#x27;page&#x27;</span><br><span class="line"></span><br><span class="line">doctype html</span><br><span class="line">html(lang=config.language data-theme=theme.display_mode class=htmlClassHideAside) </span><br><span class="line">  head</span><br><span class="line">    include ./head.pug</span><br><span class="line">  body</span><br><span class="line">    if theme.preloader.enable</span><br><span class="line">      !=partial(&#x27;includes/loading/loading&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    - var DefaultBg = page.defaultbg ? page.defaultbg : theme.background.default</span><br><span class="line">    - var DDMBg = theme.background.darkmode ? theme.background.darkmode : DefaultBg</span><br><span class="line">    - var DarkmodeBg = page.darkmodebg ? page.darkmodebg : DDMBg</span><br><span class="line">    if theme.background</span><br><span class="line">      if page.background</span><br><span class="line">        #web_bg(style=`background:`+ page.background + `;background-attachment: local;background-position: center;background-size: cover;background-repeat: no-repeat;`)</span><br><span class="line">      else</span><br><span class="line">        #web_bg</span><br><span class="line"></span><br><span class="line">        if page.defaultbg || page.darkmodebg</span><br><span class="line">          style.</span><br><span class="line">            #web_bg&#123;</span><br><span class="line">              background: #&#123;DefaultBg&#125; !important;</span><br><span class="line">              background-attachment: local!important;</span><br><span class="line">              background-position: center!important;</span><br><span class="line">              background-size: cover!important;</span><br><span class="line">              background-repeat: no-repeat!important;</span><br><span class="line">            &#125;</span><br><span class="line">            [data-theme=&quot;dark&quot;]</span><br><span class="line">              #web_bg&#123;</span><br><span class="line">                background: #&#123;DarkmodeBg&#125; !important;</span><br><span class="line">                background-attachment: local!important;</span><br><span class="line">                background-position: center!important;</span><br><span class="line">                background-size: cover!important;</span><br><span class="line">                background-repeat: no-repeat!important;</span><br><span class="line">              &#125;      </span><br><span class="line"></span><br><span class="line">    !=partial(&#x27;includes/sidebar&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    if page.type !== &#x27;404&#x27;</span><br><span class="line">      #body-wrap(class=pageType)</span><br><span class="line">        include ./header/index.pug</span><br><span class="line"></span><br><span class="line">        main#content-inner.layout(class=hideAside)</span><br><span class="line">          if body</span><br><span class="line">            div!= body</span><br><span class="line">          else</span><br><span class="line">            block content</span><br><span class="line">            if theme.aside.enable &amp;&amp; page.aside !== false</span><br><span class="line">              include widget/index.pug</span><br><span class="line"></span><br><span class="line">        - var footerBg = theme.footer_bg</span><br><span class="line">        if !is_post()</span><br><span class="line">          if (footerBg === true)</span><br><span class="line">            - var footer_bg = &#x27;background-color: transparent;&#x27;</span><br><span class="line">          else</span><br><span class="line">            - var footer_bg = &#x27;background-color: transparent;&#x27;</span><br><span class="line">        else</span><br><span class="line">          - var footer_bg = &#x27;background-color: transparent;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        footer#footer(style=footer_bg)</span><br><span class="line">          !=partial(&#x27;includes/footer&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">      include ./404.pug</span><br><span class="line"></span><br><span class="line">    include ./rightside.pug</span><br><span class="line">    !=partial(&#x27;includes/third-party/search/index&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    !=partial(&#x27;includes/rightmenu&#x27;,&#123;&#125;, &#123;cache:true&#125;)</span><br><span class="line">    include ./additional-js.pug</span><br></pre></td></tr></table></figure>
<p>现在主页的class就变成<code>page home</code>了，我们再在<code>custom.css</code>加入如下css，主题就能智能区分主页和分页了，可以自动选择卡片显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 除了首页以外其他页面隐藏卡片，并采用宽屏显示 */</span></span><br><span class="line"><span class="selector-id">#archive</span>,</span><br><span class="line"><span class="selector-id">#page</span>,</span><br><span class="line"><span class="selector-id">#category</span>,</span><br><span class="line"><span class="selector-id">#tag</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.page</span><span class="selector-class">.home</span>) <span class="selector-class">.aside-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《头像呼吸灯》</title>
    <url>/posts/f5cf8425/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>颜色可以根据自己的喜好调节</p>
<p>写好之后插入到头部里面</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 头像呼吸灯 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-class">.avatar-img</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: huxi_light <span class="number">4s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.avatar-img</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: huxi_dark <span class="number">4s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> huxi_light &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#e9f5fa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> huxi_dark &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#39c5bb</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《字体修改》</title>
    <url>/posts/d32bf76c/</url>
    <content><![CDATA[<h2 id="字体下载"><a href="#字体下载" class="headerlink" title="字体下载"></a>字体下载</h2><p>免费的字体下载参考网站</p>
<div class="tag link"><a class="link-card" title="自由字体网" href="https://ziyouziti.com/"><div class="left"><img src="https://ziyouziti.com/favicon.ico"/></div><div class="right"><p class="text">自由字体网</p><p class="url">https://ziyouziti.com/</p></div></a></div><br/>

<br/>

## 具体操作

1. 将下载好的字体命名好，放在你的`[Blogroot]\source\fonts\`下

2. 在你inject头部的css文件里面写入以下代码

   <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">@font-face</span> &#123;</span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">&#x27;你的命名&#x27;</span><span class="string">;</span> <span class="string">/*</span> <span class="string">字体名自定义即可</span> <span class="string">*/</span></span><br><span class="line">  <span class="attr">src:</span> <span class="string">url(&#x27;/fonts/你的命名.ttf&#x27;);</span> <span class="string">/*</span> <span class="string">字体文件路径</span> <span class="string">*/</span></span><br><span class="line">  <span class="attr">font-display:</span> <span class="string">swap;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>修改<code>_config.butterfly.yml</code>目录下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span> <span class="string">16px</span></span><br><span class="line">  <span class="attr">code-font-size:</span> <span class="string">16px</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">你的命名</span></span><br><span class="line">  <span class="attr">code-font-family:</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《控制台输出》</title>
    <url>/posts/9007e4b2/</url>
    <content><![CDATA[<h2 id="ASCII字符画生成器"><a href="#ASCII字符画生成器" class="headerlink" title="ASCII字符画生成器"></a>ASCII字符画生成器</h2><ol>
<li><p>根据文字生成字符画</p>
<p><a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a></p>
<p><a href="http://www.network-science.de/ascii/">http://www.network-science.de/ascii/</a></p>
</li>
<li><p>根据图片生成字符画</p>
<p><a href="http://www.degraeve.com/img2txt.php">http://www.degraeve.com/img2txt.php</a><br><a href="http://life.chacuo.net/convertphoto2char">http://life.chacuo.net/convertphoto2char</a></p>
</li>
<li><p>根据流程图生成字符画</p>
<p><a href="http://asciiflow.com/">http://asciiflow.com/</a></p>
</li>
</ol>
<p><br/></p>
<h2 id="新建Js文件"><a href="#新建Js文件" class="headerlink" title="新建Js文件"></a>新建Js文件</h2><p>路径：<code>[BlogRoot]\source\js\</code></p>
<p>然后<code>inject</code>到底部</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now1 = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createtime1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> grt = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;01/01/2023 00:00:00&quot;</span>); <span class="comment">//此处修改你的建站时间或者网站上线时间</span></span><br><span class="line">  now1.<span class="title function_">setTime</span>(now1.<span class="title function_">getTime</span>() + <span class="number">250</span>);</span><br><span class="line">  <span class="keyword">var</span> days = (now1 - grt) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">var</span> dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> ascll = [</span><br><span class="line">    <span class="string">`欢迎来到Nanami Kento的Blog!`</span>,</span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">         ,--.                                                                            ,--.</span></span><br><span class="line"><span class="string">       ,--.&#x27;|                                              ____                      ,--/  /|                         ___</span></span><br><span class="line"><span class="string">   ,--,:  : |                                            ,&#x27;  , \`.  ,--,           ,---,&#x27;: / &#x27;                       ,--.&#x27;|_</span></span><br><span class="line"><span class="string">,\`--.&#x27;\`|  &#x27; :                  ,---,                  ,-+-,.&#x27; _ |,--.&#x27;|           :   : &#x27;/ /                ,---,   |  | :,&#x27;   ,---.</span></span><br><span class="line"><span class="string">|   :  :  | |              ,-+-. /  |              ,-+-. ;   , |||  |,            |   &#x27;   ,             ,-+-. /  |  :  : &#x27; :  &#x27;   ,&#x27;\\</span></span><br><span class="line"><span class="string">:   |   \\ | :  ,--.--.    ,--.&#x27;|&#x27;   |  ,--.--.    ,--.&#x27;|&#x27;   |  ||\`--&#x27;_            &#x27;   |  /      ,---.  ,--.&#x27;|&#x27;   |.;__,&#x27;  /  /   /   |</span></span><br><span class="line"><span class="string">|   : &#x27;  &#x27;; | /       \\  |   |  ,&quot;&#x27; | /       \\  |   |  ,&#x27;, |  |,,&#x27; ,&#x27;|           |   ;  ;     /     \\|   |  ,&quot;&#x27; ||  |   |  .   ; ,. :</span></span><br><span class="line"><span class="string">&#x27;   &#x27; ;.    ;.--.  .-. | |   | /  | |.--.  .-. | |   | /  | |--&#x27; &#x27;  | |           :   &#x27;   \\   /    /  |   | /  | |:__,&#x27;| :  &#x27;   | |: :</span></span><br><span class="line"><span class="string">|   | | \\   | \\__\\/: . . |   | |  | | \\__\\/: . . |   : |  | ,    |  | :           |   |    &#x27; .    &#x27; / |   | |  | |  &#x27;  : |__&#x27;   | .; :</span></span><br><span class="line"><span class="string">&#x27;   : |  ; .&#x27; ,&quot; .--.; | |   | |  |/  ,&quot; .--.; | |   : |  |/     &#x27;  : |__         &#x27;   : |.  \\&#x27;   ;   /|   | |  |/   |  | &#x27;.&#x27;|   :    |</span></span><br><span class="line"><span class="string">|   | &#x27;\`--&#x27;  /  /  ,.  | |   | |--&#x27;  /  /  ,.  | |   | |\`-&#x27;      |  | &#x27;.&#x27;|        |   | &#x27;_\\.&#x27;&#x27;   |  / |   | |--&#x27;    ;  :    ;\\   \\  /</span></span><br><span class="line"><span class="string">&#x27;   : |     ;  :   .&#x27;   \\|   |/     ;  :   .&#x27;   \\|   ;/          ;  :    ;        &#x27;   : |    |   :    |   |/        |  ,   /  \`----&#x27;</span></span><br><span class="line"><span class="string">;   |.&#x27;     |  ,     .-./&#x27;---&#x27;      |  ,     .-./&#x27;---&#x27;           |  ,   /         ;   |,&#x27;     \\   \\  /&#x27;---&#x27;          ---\`-&#x27;</span></span><br><span class="line"><span class="string">&#x27;---&#x27;        \`--\`---&#x27;                \`--\`---&#x27;                     ---\`-&#x27;          &#x27;---&#x27;        \`----&#x27;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    <span class="string">&quot;已运行&quot;</span>,</span><br><span class="line">    dnum,</span><br><span class="line">    <span class="string">&quot;天  ©2022 By Nanami Kento&quot;</span>,</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(</span><br><span class="line">      <span class="variable language_">console</span>,</span><br><span class="line">      <span class="string">`\n%c<span class="subst">$&#123;ascll[<span class="number">0</span>]&#125;</span> %c <span class="subst">$&#123;ascll[<span class="number">1</span>]&#125;</span> %c <span class="subst">$&#123;ascll[<span class="number">2</span>]&#125;</span> %c<span class="subst">$&#123;ascll[<span class="number">3</span>]&#125;</span>%c <span class="subst">$&#123;ascll[<span class="number">4</span>]&#125;</span>`</span>,</span><br><span class="line">      <span class="string">&quot;color:#39c5bb&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;color:#39c5bb&quot;</span>,</span><br><span class="line">      <span class="string">&quot;color:#39c5bb&quot;</span>,</span><br><span class="line">      <span class="string">&quot;color:#39c5bb&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createtime1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createtime2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ascll2 = [<span class="string">`NCC2-036`</span>, <span class="string">`调用前置摄像头拍照成功，识别为「客人」`</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(</span><br><span class="line">      <span class="variable language_">console</span>,</span><br><span class="line">      <span class="string">`%c <span class="subst">$&#123;ascll2[<span class="number">0</span>]&#125;</span> %c <span class="subst">$&#123;ascll2[<span class="number">1</span>]&#125;</span>`</span>,</span><br><span class="line">      <span class="string">&quot;color:white; background-color:#10bcc0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&quot;%c WELCOME %c 欢迎光临&quot;</span>, <span class="string">&quot;color:white; background-color:#23c682&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">warn</span>.<span class="title function_">bind</span>(</span><br><span class="line">      <span class="variable language_">console</span>,</span><br><span class="line">      <span class="string">&quot;%c ⚡ Powered by Nanami Kento %c 你正在访问Nanami Kento的Blog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;color:white; background-color:#f0ad4e&quot;</span>,</span><br><span class="line">      <span class="string">&quot;&quot;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&quot;%c W23-12 %c 系统监测到你已打开控制台&quot;</span>, <span class="string">&quot;color:white; background-color:#4f90d9&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">warn</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&quot;%c S013-782 %c 你现在正处于监控中&quot;</span>, <span class="string">&quot;color:white; background-color:#d9534f&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createtime2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写console方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">error</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">warn</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《导航栏居中》</title>
    <url>/posts/4f4b07e8/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 一级菜单居中 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: fit-content <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 子菜单横向展示 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.menus_item_child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */</span></span><br><span class="line"><span class="selector-class">.menus_items</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) <span class="selector-class">.menus_item_child</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">125px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《搜索》</title>
    <url>/posts/fbb05bae/</url>
    <content><![CDATA[<h1 id="第三方搜索"><a href="#第三方搜索" class="headerlink" title="第三方搜索"></a>第三方搜索</h1><details class="folding-tag" red><summary> 第三方 </summary>
              <div class='content'>
              <h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="注册-Algolia-并获取配置"><a href="#注册-Algolia-并获取配置" class="headerlink" title="注册 Algolia 并获取配置"></a>注册 Algolia 并获取配置</h2><div class="tag link"><a class="link-card" title="Algolia" href="https://www.algolia.com/"><div class="left"><img src="https://www.algolia.com/algoliaweb-static-favicons/light-mode/apple-touch-icon.png"/></div><div class="right"><p class="text">Algolia</p><p class="url">https://www.algolia.com/</p></div></a></div><ol><li><p>注册algolia，创建新建index</p><p><img src="https://s2.loli.net/2024/01/26/Q2uYH6gZahMWUEs.png" alt=""></p></li><li><p>Setting-&gt;打开API Keys</p><p><img src="https://s2.loli.net/2024/01/26/SJTgClQjrKM8hkY.png" alt="image-20240126112253402"></p></li><li><p>选择All API Keys，新建一个拥有CRUD权限的api key（指定相应的index）</p><p><img src="https://s2.loli.net/2024/01/26/LZSpT79hOjuXPIY.png" alt="image-20240126112303154"></p></li></ol><p><br/></p><h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><p>在文件添加如下代码</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网站搜索功能 hexo-algoliasearch</span></span><br><span class="line"><span class="attr">algolia:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">&quot;your appId&quot;</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="string">&quot;your apiKey&quot;</span></span><br><span class="line">  <span class="attr">adminApiKey:</span> <span class="string">&quot;your adminApiKey&quot;</span></span><br><span class="line">  <span class="attr">chunkSize:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">indexName:</span> <span class="string">&quot;your indexName&quot;</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">content:strip:truncate,0,500</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">excerpt:strip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gallery</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">permalink</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">photos</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">slug</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">title</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><p>将<code>algolia_search</code>修改成如下，并把<code>algolia</code>注释</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot;</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&quot;找到$&#123;hits&#125;条结果（用时$&#123;time&#125; ms）&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#algolia:</span></span><br><span class="line"><span class="comment">#  applicationID: &#x27;applicationID&#x27;</span></span><br><span class="line"><span class="comment">#  apiKey: &#x27;apiKey&#x27;</span></span><br><span class="line"><span class="comment">#  indexName: &#x27;...&#x27;</span></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>分别运行下面的两段代码，重新跑项目，打开就可以看到效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h1 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h1><p>我实在是忍不了algolia了，每次需要运行一次命令，还需要科学上网，字数多了又有限制</p>
<p>所以现在我更换了本地搜索</p>
<h2 id="更换插件"><a href="#更换插件" class="headerlink" title="更换插件"></a>更换插件</h2><p>如果你是上面第三方搜索方式换成本地搜索，请先运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-algoliasearch hexo-algolia</span><br></pre></td></tr></table></figure>
<p>本地搜索需要更换插件，运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改<code>_config.butterfly.yml</code></h2><p>修改<code>_config.butterfly.yml</code>里面的代码</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">    # Algolia search</span><br><span class="line">    algolia_search:</span><br><span class="line"><span class="addition">+      enable: false</span></span><br><span class="line"><span class="deletion">-      enable: true</span></span><br><span class="line">      hits:</span><br><span class="line">        per_page: 10</span><br><span class="line">      labels:</span><br><span class="line">        input_placeholder: Search for Posts</span><br><span class="line">        hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot;</span><br><span class="line">        hits_stats: &quot;找到$&#123;hits&#125;条结果（用时$&#123;time&#125; ms）&quot;</span><br></pre></td></tr></table></figure>
<p>对<code>local_search</code>进行修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;目前没有找到任何搜索结果: $&#123;query&#125;&quot;</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">&quot;找到$&#123;hits&#125;条结果（用时$&#123;time&#125; ms）&quot;</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改<code>_config.yml</code></h2><p>注释<code>_config.yml</code>里面的代码</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#algolia:</span></span><br><span class="line"><span class="comment">#  appId: &quot;Q0YZ3KDM7W&quot;</span></span><br><span class="line"><span class="comment">#  apiKey: &quot;f78b69a464eb0261eece32ccd2f67487&quot;</span></span><br><span class="line"><span class="comment">#  adminApiKey: &quot;440c1443788a6a0dd4a97d33367c4a95&quot;</span></span><br><span class="line"><span class="comment">#  chunkSize: 5000</span></span><br><span class="line"><span class="comment">#  indexName: &quot;blog&quot;</span></span><br><span class="line"><span class="comment">#  fields:</span></span><br><span class="line"><span class="comment">#    - content:strip:truncate,0,10000</span></span><br><span class="line"><span class="comment">#    - excerpt:strip</span></span><br><span class="line"><span class="comment">#    - gallery</span></span><br><span class="line"><span class="comment">#    - permalink</span></span><br><span class="line"><span class="comment">#    - photos</span></span><br><span class="line"><span class="comment">#    - slug</span></span><br><span class="line"><span class="comment">#    - tags</span></span><br><span class="line"><span class="comment">#    - title</span></span><br></pre></td></tr></table></figure>
<p>新增</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章加密》</title>
    <url>/posts/52e2801c/</url>
    <content><![CDATA[<h2 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">	<span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>xxxxxxxxxx # Beautify (美化頁面顯示)beautify:  enable: true  field: post # station/post  title-prefix-icon: ‘\f863’  title-prefix-icon-color: ‘#F47466’yml</p>
<h2 id="对应加密文章添加"><a href="#对应加密文章添加" class="headerlink" title="对应加密文章添加"></a>对应加密文章添加</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Article Name</span><br><span class="line">... 其他配置 ...</span><br><span class="line">password: your password   </span><br><span class="line">abstract: Welcome to my blog, enter password to read. </span><br><span class="line">message: your message</span><br><span class="line"><span class="section">... 其他配置 ...</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章Echarts统计》</title>
    <url>/posts/ec39a271/</url>
    <content><![CDATA[<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Menu 目錄</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="string">统计:</span> <span class="string">/articleCount/</span> <span class="string">||</span> <span class="string">iconfont</span> <span class="string">icon-tongji</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新增统计页面"><a href="#新增统计页面" class="headerlink" title="新增统计页面"></a>新增统计页面</h2><p>在 <code>[Blogroot]\source\</code> 目录下新建 <code>articleCount</code> 文件夹</p>
<p>并在新建的 <code>articleCount</code> 文件夹下新建 <code>index.md</code> 文件</p>
<p>添加以下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: ARTICLE STATISTICS</span><br><span class="line">date: 2024-02-01 16:39:59</span><br><span class="line">updated:</span><br><span class="line">type: &#x27;articleCount&#x27;</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside: false</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line"><span class="section">random:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&lt;!-- 文章发布时间统计图 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;posts-chart&quot;</span> <span class="attr">data-start</span>=<span class="string">&quot;自定义图表开始统计时间&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 8px; height: 300px; padding: 10px;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 文章标签统计图 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tags-chart&quot;</span> <span class="attr">data-length</span>=<span class="string">&quot;10&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 8px; height: 300px; padding: 10px;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 文章分类统计图 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;categories-chart&quot;</span> <span class="attr">data-parent</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 8px; height: 300px; padding: 10px;&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="引入Echarts"><a href="#引入Echarts" class="headerlink" title="引入Echarts"></a>引入Echarts</h2><p>修改<code>_config.butterfly.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建js文件"><a href="#新建js文件" class="headerlink" title="新建js文件"></a>新建js文件</h2><p>在 <code>[Blogroot]\themes\butterfly\scripts\helpers\</code> 目录下新建 <code>charts.js</code> 文件</p>
<p>然后添加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_render:html&#x27;</span>, <span class="keyword">function</span> (<span class="params">locals</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(locals)</span><br><span class="line">  <span class="keyword">const</span> post = $(<span class="string">&#x27;#posts-chart&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> tag = $(<span class="string">&#x27;#tags-chart&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> category = $(<span class="string">&#x27;#categories-chart&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> htmlEncode = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post.<span class="property">length</span> &gt; <span class="number">0</span> || tag.<span class="property">length</span> &gt; <span class="number">0</span> || category.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (post.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; $(<span class="string">&#x27;#postsChart&#x27;</span>).<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (post.<span class="title function_">attr</span>(<span class="string">&#x27;data-encode&#x27;</span>) === <span class="string">&#x27;true&#x27;</span>) htmlEncode = <span class="literal">true</span></span><br><span class="line">      post.<span class="title function_">after</span>(<span class="title function_">postsChart</span>(post.<span class="title function_">attr</span>(<span class="string">&#x27;data-start&#x27;</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; $(<span class="string">&#x27;#tagsChart&#x27;</span>).<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tag.<span class="title function_">attr</span>(<span class="string">&#x27;data-encode&#x27;</span>) === <span class="string">&#x27;true&#x27;</span>) htmlEncode = <span class="literal">true</span></span><br><span class="line">      tag.<span class="title function_">after</span>(<span class="title function_">tagsChart</span>(tag.<span class="title function_">attr</span>(<span class="string">&#x27;data-length&#x27;</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (category.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; $(<span class="string">&#x27;#categoriesChart&#x27;</span>).<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (category.<span class="title function_">attr</span>(<span class="string">&#x27;data-encode&#x27;</span>) === <span class="string">&#x27;true&#x27;</span>) htmlEncode = <span class="literal">true</span></span><br><span class="line">      category.<span class="title function_">after</span>(<span class="title function_">categoriesChart</span>(category.<span class="title function_">attr</span>(<span class="string">&#x27;data-parent&#x27;</span>)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (htmlEncode) &#123;</span><br><span class="line">      <span class="keyword">return</span> $.<span class="title function_">root</span>().<span class="title function_">html</span>().<span class="title function_">replace</span>(<span class="regexp">/&amp;amp;#/g</span>, <span class="string">&#x27;&amp;#&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> $.<span class="title function_">root</span>().<span class="title function_">html</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> locals</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">postsChart</span> (startMonth) &#123;</span><br><span class="line">  <span class="keyword">const</span> startDate = <span class="title function_">moment</span>(startMonth || <span class="string">&#x27;2020-01&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> endDate = <span class="title function_">moment</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> monthMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">const</span> dayTime = <span class="number">3600</span> * <span class="number">24</span> * <span class="number">1000</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> time = startDate; time &lt;= endDate; time += dayTime) &#123;</span><br><span class="line">    <span class="keyword">const</span> month = <span class="title function_">moment</span>(time).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!monthMap.<span class="title function_">has</span>(month)) &#123;</span><br><span class="line">      monthMap.<span class="title function_">set</span>(month, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hexo.<span class="property">locals</span>.<span class="title function_">get</span>(<span class="string">&#x27;posts&#x27;</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> month = post.<span class="property">date</span>.<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (monthMap.<span class="title function_">has</span>(month)) &#123;</span><br><span class="line">      monthMap.<span class="title function_">set</span>(month, monthMap.<span class="title function_">get</span>(month) + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> monthArr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...monthMap.<span class="title function_">keys</span>()])</span><br><span class="line">  <span class="keyword">const</span> monthValueArr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...monthMap.<span class="title function_">values</span>()])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;script id=&quot;postsChart&quot;&gt;</span></span><br><span class="line"><span class="string">    var color = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;light&#x27; ? &#x27;#4c4948&#x27; : &#x27;rgba(255,255,255,0.7)&#x27;</span></span><br><span class="line"><span class="string">    var postsChart = echarts.init(document.getElementById(&#x27;posts-chart&#x27;), &#x27;light&#x27;);</span></span><br><span class="line"><span class="string">    var postsOption = &#123;</span></span><br><span class="line"><span class="string">      title: &#123;</span></span><br><span class="line"><span class="string">        text: &#x27;文章发布统计图&#x27;,</span></span><br><span class="line"><span class="string">        x: &#x27;center&#x27;,</span></span><br><span class="line"><span class="string">        textStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      tooltip: &#123;</span></span><br><span class="line"><span class="string">        trigger: &#x27;axis&#x27;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      xAxis: &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;日期&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;category&#x27;,</span></span><br><span class="line"><span class="string">        boundaryGap: false,</span></span><br><span class="line"><span class="string">        nameTextStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisTick: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLabel: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLine: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          lineStyle: &#123;</span></span><br><span class="line"><span class="string">            color: color</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;monthArr&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      yAxis: &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;value&#x27;,</span></span><br><span class="line"><span class="string">        nameTextStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        splitLine: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisTick: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLabel: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLine: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          lineStyle: &#123;</span></span><br><span class="line"><span class="string">            color: color</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      series: [&#123;</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;line&#x27;,</span></span><br><span class="line"><span class="string">        smooth: true,</span></span><br><span class="line"><span class="string">        lineStyle: &#123;</span></span><br><span class="line"><span class="string">            width: 0</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        showSymbol: false,</span></span><br><span class="line"><span class="string">        itemStyle: &#123;</span></span><br><span class="line"><span class="string">          opacity: 1,</span></span><br><span class="line"><span class="string">          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [&#123;</span></span><br><span class="line"><span class="string">            offset: 0,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(128, 255, 165)&#x27;</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            offset: 1,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(1, 191, 236)&#x27;</span></span><br><span class="line"><span class="string">          &#125;])</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        areaStyle: &#123;</span></span><br><span class="line"><span class="string">          opacity: 1,</span></span><br><span class="line"><span class="string">          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [&#123;</span></span><br><span class="line"><span class="string">            offset: 0,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(128, 255, 165)&#x27;</span></span><br><span class="line"><span class="string">          &#125;, &#123;</span></span><br><span class="line"><span class="string">            offset: 1,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(1, 191, 236)&#x27;</span></span><br><span class="line"><span class="string">          &#125;])</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;monthValueArr&#125;</span>,</span></span><br><span class="line"><span class="string">        markLine: &#123;</span></span><br><span class="line"><span class="string">          data: [&#123;</span></span><br><span class="line"><span class="string">            name: &#x27;平均值&#x27;,</span></span><br><span class="line"><span class="string">            type: &#x27;average&#x27;,</span></span><br><span class="line"><span class="string">            label: &#123;</span></span><br><span class="line"><span class="string">              color: color</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;]</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    postsChart.setOption(postsOption);</span></span><br><span class="line"><span class="string">    window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; </span></span><br><span class="line"><span class="string">      postsChart.resize();</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    postsChart.on(&#x27;click&#x27;, &#x27;series&#x27;, (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">      if (event.componentType === &#x27;series&#x27;) window.location.href = &#x27;/archives/&#x27; + event.name.replace(&#x27;-&#x27;, &#x27;/&#x27;);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tagsChart</span> (len) &#123;</span><br><span class="line">  <span class="keyword">const</span> tagArr = []</span><br><span class="line">  hexo.<span class="property">locals</span>.<span class="title function_">get</span>(<span class="string">&#x27;tags&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">tag</span>) &#123;</span><br><span class="line">    tagArr.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: tag.<span class="property">name</span>, <span class="attr">value</span>: tag.<span class="property">length</span>, <span class="attr">path</span>: tag.<span class="property">path</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  tagArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> b.<span class="property">value</span> - a.<span class="property">value</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dataLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(tagArr.<span class="property">length</span>, len) || tagArr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">const</span> tagNameArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dataLength; i++) &#123;</span><br><span class="line">    tagNameArr.<span class="title function_">push</span>(tagArr[i].<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tagNameArrJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tagNameArr)</span><br><span class="line">  <span class="keyword">const</span> tagArrJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tagArr)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;script id=&quot;tagsChart&quot;&gt;</span></span><br><span class="line"><span class="string">    var color = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;light&#x27; ? &#x27;#4c4948&#x27; : &#x27;rgba(255,255,255,0.7)&#x27;</span></span><br><span class="line"><span class="string">    var tagsChart = echarts.init(document.getElementById(&#x27;tags-chart&#x27;), &#x27;light&#x27;);</span></span><br><span class="line"><span class="string">    var tagsOption = &#123;</span></span><br><span class="line"><span class="string">      title: &#123;</span></span><br><span class="line"><span class="string">        text: &#x27;Top <span class="subst">$&#123;dataLength&#125;</span> 标签统计图&#x27;,</span></span><br><span class="line"><span class="string">        x: &#x27;center&#x27;,</span></span><br><span class="line"><span class="string">        textStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      tooltip: &#123;&#125;,</span></span><br><span class="line"><span class="string">      xAxis: &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;标签&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;category&#x27;,</span></span><br><span class="line"><span class="string">        nameTextStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisTick: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLabel: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          color: color,</span></span><br><span class="line"><span class="string">          interval: 0</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLine: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          lineStyle: &#123;</span></span><br><span class="line"><span class="string">            color: color</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;tagNameArrJson&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      yAxis: &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;value&#x27;,</span></span><br><span class="line"><span class="string">        splitLine: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        nameTextStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisTick: &#123;</span></span><br><span class="line"><span class="string">          show: false</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLabel: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        axisLine: &#123;</span></span><br><span class="line"><span class="string">          show: true,</span></span><br><span class="line"><span class="string">          lineStyle: &#123;</span></span><br><span class="line"><span class="string">            color: color</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      series: [&#123;</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;bar&#x27;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;tagArrJson&#125;</span>,</span></span><br><span class="line"><span class="string">        itemStyle: &#123;</span></span><br><span class="line"><span class="string">          borderRadius: [5, 5, 0, 0],</span></span><br><span class="line"><span class="string">          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [&#123;</span></span><br><span class="line"><span class="string">            offset: 0,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(128, 255, 165)&#x27;</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            offset: 1,</span></span><br><span class="line"><span class="string">            color: &#x27;rgba(1, 191, 236)&#x27;</span></span><br><span class="line"><span class="string">          &#125;])</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        emphasis: &#123;</span></span><br><span class="line"><span class="string">          itemStyle: &#123;</span></span><br><span class="line"><span class="string">            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [&#123;</span></span><br><span class="line"><span class="string">              offset: 0,</span></span><br><span class="line"><span class="string">              color: &#x27;rgba(128, 255, 195)&#x27;</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">              offset: 1,</span></span><br><span class="line"><span class="string">              color: &#x27;rgba(1, 211, 255)&#x27;</span></span><br><span class="line"><span class="string">            &#125;])</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        markLine: &#123;</span></span><br><span class="line"><span class="string">          data: [&#123;</span></span><br><span class="line"><span class="string">            name: &#x27;平均值&#x27;,</span></span><br><span class="line"><span class="string">            type: &#x27;average&#x27;,</span></span><br><span class="line"><span class="string">            label: &#123;</span></span><br><span class="line"><span class="string">              color: color</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;]</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    tagsChart.setOption(tagsOption);</span></span><br><span class="line"><span class="string">    window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; </span></span><br><span class="line"><span class="string">      tagsChart.resize();</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    tagsChart.on(&#x27;click&#x27;, &#x27;series&#x27;, (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">      if(event.data.path) window.location.href = &#x27;/&#x27; + event.data.path;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">categoriesChart</span> (dataParent) &#123;</span><br><span class="line">  <span class="keyword">const</span> categoryArr = []</span><br><span class="line">  <span class="keyword">let</span> categoryParentFlag = <span class="literal">false</span></span><br><span class="line">  hexo.<span class="property">locals</span>.<span class="title function_">get</span>(<span class="string">&#x27;categories&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">category</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (category.<span class="property">parent</span>) categoryParentFlag = <span class="literal">true</span></span><br><span class="line">    categoryArr.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: category.<span class="property">name</span>,</span><br><span class="line">      <span class="attr">value</span>: category.<span class="property">length</span>,</span><br><span class="line">      <span class="attr">path</span>: category.<span class="property">path</span>,</span><br><span class="line">      <span class="attr">id</span>: category.<span class="property">_id</span>,</span><br><span class="line">      <span class="attr">parentId</span>: category.<span class="property">parent</span> || <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  categoryParentFlag = categoryParentFlag &amp;&amp; dataParent === <span class="string">&#x27;true&#x27;</span></span><br><span class="line">  categoryArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> b.<span class="property">value</span> - a.<span class="property">value</span> &#125;)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">translateListToTree</span> (data, parent) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree = []</span><br><span class="line">    <span class="keyword">let</span> temp</span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data[index].<span class="property">parentId</span> == parent) &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = data[index];</span><br><span class="line">        temp = <span class="title function_">translateListToTree</span>(data, data[index].<span class="property">id</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          obj.<span class="property">children</span> = temp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.<span class="title function_">indexOf</span>())</span><br><span class="line">          tree.<span class="title function_">push</span>(obj)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> categoryNameJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(categoryArr.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">category</span>) &#123; <span class="keyword">return</span> category.<span class="property">name</span> &#125;))</span><br><span class="line">  <span class="keyword">const</span> categoryArrJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(categoryArr)</span><br><span class="line">  <span class="keyword">const</span> categoryArrParentJson = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">translateListToTree</span>(categoryArr, <span class="string">&#x27;0&#x27;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;script id=&quot;categoriesChart&quot;&gt;</span></span><br><span class="line"><span class="string">    var color = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;light&#x27; ? &#x27;#4c4948&#x27; : &#x27;rgba(255,255,255,0.7)&#x27;</span></span><br><span class="line"><span class="string">    var categoriesChart = echarts.init(document.getElementById(&#x27;categories-chart&#x27;), &#x27;light&#x27;);</span></span><br><span class="line"><span class="string">    var categoryParentFlag = <span class="subst">$&#123;categoryParentFlag&#125;</span></span></span><br><span class="line"><span class="string">    var categoriesOption = &#123;</span></span><br><span class="line"><span class="string">      title: &#123;</span></span><br><span class="line"><span class="string">        text: &#x27;文章分类统计图&#x27;,</span></span><br><span class="line"><span class="string">        x: &#x27;center&#x27;,</span></span><br><span class="line"><span class="string">        textStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      legend: &#123;</span></span><br><span class="line"><span class="string">        top: &#x27;bottom&#x27;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;categoryNameJson&#125;</span>,</span></span><br><span class="line"><span class="string">        textStyle: &#123;</span></span><br><span class="line"><span class="string">          color: color</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      tooltip: &#123;</span></span><br><span class="line"><span class="string">        trigger: &#x27;item&#x27;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      series: []</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    categoriesOption.series.push(</span></span><br><span class="line"><span class="string">      categoryParentFlag ? </span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        nodeClick :false,</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;sunburst&#x27;,</span></span><br><span class="line"><span class="string">        radius: [&#x27;15%&#x27;, &#x27;90%&#x27;],</span></span><br><span class="line"><span class="string">        center: [&#x27;50%&#x27;, &#x27;55%&#x27;],</span></span><br><span class="line"><span class="string">        sort: &#x27;desc&#x27;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;categoryArrParentJson&#125;</span>,</span></span><br><span class="line"><span class="string">        itemStyle: &#123;</span></span><br><span class="line"><span class="string">          borderColor: &#x27;#fff&#x27;,</span></span><br><span class="line"><span class="string">          borderWidth: 2,</span></span><br><span class="line"><span class="string">          emphasis: &#123;</span></span><br><span class="line"><span class="string">            focus: &#x27;ancestor&#x27;,</span></span><br><span class="line"><span class="string">            shadowBlur: 10,</span></span><br><span class="line"><span class="string">            shadowOffsetX: 0,</span></span><br><span class="line"><span class="string">            shadowColor: &#x27;rgba(255, 255, 255, 0.5)&#x27;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      :</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        name: &#x27;文章篇数&#x27;,</span></span><br><span class="line"><span class="string">        type: &#x27;pie&#x27;,</span></span><br><span class="line"><span class="string">        radius: [30, 80],</span></span><br><span class="line"><span class="string">        roseType: &#x27;area&#x27;,</span></span><br><span class="line"><span class="string">        label: &#123;</span></span><br><span class="line"><span class="string">          color: color,</span></span><br><span class="line"><span class="string">          formatter: &#x27;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        data: <span class="subst">$&#123;categoryArrJson&#125;</span>,</span></span><br><span class="line"><span class="string">        itemStyle: &#123;</span></span><br><span class="line"><span class="string">          emphasis: &#123;</span></span><br><span class="line"><span class="string">            shadowBlur: 10,</span></span><br><span class="line"><span class="string">            shadowOffsetX: 0,</span></span><br><span class="line"><span class="string">            shadowColor: &#x27;rgba(255, 255, 255, 0.5)&#x27;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    categoriesChart.setOption(categoriesOption);</span></span><br><span class="line"><span class="string">    window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; </span></span><br><span class="line"><span class="string">      categoriesChart.resize();</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    categoriesChart.on(&#x27;click&#x27;, &#x27;series&#x27;, (event) =&gt; &#123;</span></span><br><span class="line"><span class="string">      if(event.data.path) window.location.href = &#x27;/&#x27; + event.data.path;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="统计图代码插入"><a href="#统计图代码插入" class="headerlink" title="统计图代码插入"></a>统计图代码插入</h2><ol>
<li><p>在归档页使用统计图</p>
<p>路径：<code>[Blogroot]\themes\butterfly\layout\archive.pug</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  include ./includes/mixins/article-sort.pug</span><br><span class="line">  #archive</span><br><span class="line"><span class="addition">+   &lt;div id=&quot;posts-chart&quot; data-start=&quot;2021-01&quot; style=&quot;height: 300px; padding: 10px;&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者写成 pug 文件语法 <code>#posts-chart(data-start=&quot;2021-01&quot; style=&quot;height: 300px; padding: 10px;&quot;)</code></p>
</li>
<li><p>在分类页使用统计图</p>
<p>总分类页路径： <code>[Blogroot]\themes\butterfly\layout\includes\page\categories.pug</code> </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  .category-lists!= list_categories()</span><br><span class="line"><span class="addition">+ &lt;div id=&quot;categories-chart&quot; data-parent=&quot;true&quot; style=&quot;height: 300px; padding: 10px;&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>各分类页路径： <code>[Blogroot]\themes\butterfly\layout\category.pug</code> </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line">   </span><br><span class="line">   block content</span><br><span class="line">     if theme.category_ui == &#x27;index&#x27;</span><br><span class="line">       include ./includes/mixins/post-ui.pug</span><br><span class="line">       #recent-posts.recent-posts.category_ui</span><br><span class="line">         +postUI</span><br><span class="line">         include includes/pagination.pug</span><br><span class="line">     else</span><br><span class="line">       include ./includes/mixins/article-sort.pug</span><br><span class="line">       #category</span><br><span class="line">   +     &lt;div id=&quot;categories-chart&quot; data-parent=&quot;true&quot; style=&quot;height: 300px; padding: 10px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>或者写成 pug 文件语法 <code>#categories-chart(data-parent=&quot;true&quot; style=&quot;height: 300px; padding: 10px;&quot;)</code></p>
</li>
<li><p>在标签页使用统计图</p>
<p>总标签页路径： <code>[Blogroot]\themes\butterfly\layout\includes\page\tags.pug</code> </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  .tag-cloud-list.is-center</span><br><span class="line">    !=cloudTags(&#123;source: site.tags, orderby: page.orderby || &#x27;random&#x27;, order: page.order || 1, minfontsize: 1.2, maxfontsize: 2.1, limit: 0, unit: &#x27;em&#x27;&#125;)</span><br><span class="line"><span class="addition">+ &lt;div id=&quot;tags-chart&quot; data-length=&quot;10&quot; style=&quot;height: 300px; padding: 10px;&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>各标签页路径： <code>[Blogroot]\themes\butterfly\layout\tag.pug</code> </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  if theme.tag_ui == &#x27;index&#x27;</span><br><span class="line">    include ./includes/mixins/post-ui.pug</span><br><span class="line">    #recent-posts.recent-posts</span><br><span class="line">      +postUI</span><br><span class="line">      include includes/pagination.pug</span><br><span class="line">  else</span><br><span class="line">    include ./includes/mixins/article-sort.pug</span><br><span class="line">    #tag</span><br><span class="line"><span class="addition">+     &lt;div id=&quot;tags-chart&quot; data-length=&quot;10&quot; style=&quot;height: 300px; padding: 10px;&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者写成 pug 文件语法 <code>#tags-chart(data-length=&quot;10&quot; style=&quot;height: 300px; padding: 10px;&quot;)</code></p>
</li>
</ol>
<p><br/></p>
<h2 id="适配明暗模式"><a href="#适配明暗模式" class="headerlink" title="适配明暗模式"></a>适配明暗模式</h2><p>新建一个js文件</p>
<p>路径： <code>[Blogroot]\source\js\articleEchartsDarkMode.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 文章echarts图适配黑暗模式</span></span><br><span class="line"><span class="comment"> * @Author: 5t5</span></span><br><span class="line"><span class="comment"> * @Time: 2024/1/31 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">switchPostChart</span> () &#123;</span><br><span class="line">  <span class="comment">// 这里为了统一颜色选取的是“明暗模式”下的两种字体颜色，也可以自己定义</span></span><br><span class="line">  <span class="keyword">let</span> color = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;light&#x27;</span> ? <span class="string">&#x27;#4C4948&#x27;</span> : <span class="string">&#x27;rgba(255,255,255,0.7)&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;posts-chart&#x27;</span>) &amp;&amp; postsOption) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> postsOptionNew = postsOption</span><br><span class="line">      postsOptionNew.<span class="property">title</span>.<span class="property">textStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">xAxis</span>.<span class="property">nameTextStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">yAxis</span>.<span class="property">nameTextStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">xAxis</span>.<span class="property">axisLabel</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">yAxis</span>.<span class="property">axisLabel</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">xAxis</span>.<span class="property">axisLine</span>.<span class="property">lineStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">yAxis</span>.<span class="property">axisLine</span>.<span class="property">lineStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      postsOptionNew.<span class="property">series</span>[<span class="number">0</span>].<span class="property">markLine</span>.<span class="property">data</span>[<span class="number">0</span>].<span class="property">label</span>.<span class="property">color</span> = color</span><br><span class="line">      postsChart.<span class="title function_">setOption</span>(postsOptionNew)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tags-chart&#x27;</span>) &amp;&amp; tagsOption) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> tagsOptionNew = tagsOption</span><br><span class="line">      tagsOptionNew.<span class="property">title</span>.<span class="property">textStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">xAxis</span>.<span class="property">nameTextStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">yAxis</span>.<span class="property">nameTextStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">xAxis</span>.<span class="property">axisLabel</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">yAxis</span>.<span class="property">axisLabel</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">xAxis</span>.<span class="property">axisLine</span>.<span class="property">lineStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">yAxis</span>.<span class="property">axisLine</span>.<span class="property">lineStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsOptionNew.<span class="property">series</span>[<span class="number">0</span>].<span class="property">markLine</span>.<span class="property">data</span>[<span class="number">0</span>].<span class="property">label</span>.<span class="property">color</span> = color</span><br><span class="line">      tagsChart.<span class="title function_">setOption</span>(tagsOptionNew)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;categories-chart&#x27;</span>) &amp;&amp; categoriesOption) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> categoriesOptionNew = categoriesOption</span><br><span class="line">      categoriesOptionNew.<span class="property">title</span>.<span class="property">textStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      categoriesOptionNew.<span class="property">legend</span>.<span class="property">textStyle</span>.<span class="property">color</span> = color</span><br><span class="line">      <span class="keyword">if</span> (!categoryParentFlag) &#123; categoriesOptionNew.<span class="property">series</span>[<span class="number">0</span>].<span class="property">label</span>.<span class="property">color</span> = color &#125;</span><br><span class="line">      categoriesChart.<span class="title function_">setOption</span>(categoriesOptionNew)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;你的转换黑暗模式按钮的ID&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="built_in">setTimeout</span>(switchPostChart, <span class="number">100</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>如果你不知道id是什么 或者是class是什么，那就在<code>rightside.pug</code>查看，</p>
<p>路径：<code>[Blogroot]\themes\butterfly\layout\includes\rightside.pug</code></p>
<p><img src="https://s2.loli.net/2024/01/31/fF283CHU97anKQt.png" alt="image-20240131121327303"></p>
<p>以这张图为例，找到<code>darkmode</code>，下面的<code>a</code>，<code>#</code>是<code>id</code>，.是<code>class</code>，你可以加个<code>#</code>自己定义一个<code>id</code>，然后在<code>js</code>文件里面替换掉</p>
<p><br/></p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><ul>
<li><p>控制台报错 <code>Uncaught ReferenceError: require is not defined</code></p>
<p><strong>解决方案：</strong></p>
<p>不能直接在页面引用 <code>charts.js</code>，是放在主题文件夹 <code>[Blogroot]\themes\butterfly\scripts\helpers\</code> 里面，<code>hexo g</code> 的时候会在 <code>div</code> 后面追加 echarts 图的 js。页面不需要引入 。</p>
</li>
<li><p>控制台报错 <code>Uncaught ReferenceError: echarts is not defined</code>。</p>
<p><strong>解决方案：</strong></p>
<p>需要在统计图的前引入 <code>echarts.js</code> 文件，最好是在页面的头部引入。</p>
</li>
<li><p>控制台报错 <code>Cannot find module &#39;cheerio&#39;</code>。</p>
<p><strong>解决方案：</strong></p>
<p>安装 <code>cheerio</code>，控制台执行 <code>npm i cheerio --save</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章标题图标改小风车》</title>
    <url>/posts/a6103189/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文章页H1-H6图标样式效果 */</span></span><br><span class="line"><span class="comment">/* 控制风车转动速度 4s那里可以自己调节快慢 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h3</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h4</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">h6</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: ccc <span class="number">4s</span> linear infinite;</span><br><span class="line">    <span class="attribute">animation</span>: ccc <span class="number">4s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> ccc &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">1turn</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 设置风车颜色 */</span></span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ef50a8</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.55rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.3rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.23rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fb7061</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.35rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.1rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.12rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffbf00</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.22rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.95rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.09rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a9e000</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1.05rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">0.09rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#57c850</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">0.9rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.7rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5ec1e0</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">0.9rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.66rem</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* s设置风车hover动效 6s那里可以自己调节快慢*/</span></span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h1</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h3</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h4</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h5</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-id">#content-inner</span><span class="selector-class">.layout</span> <span class="selector-tag">h6</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: ccc <span class="number">6s</span> linear infinite;</span><br><span class="line">    <span class="attribute">animation</span>: ccc <span class="number">6s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Beautify (美化頁面顯示)</span></span><br><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># station/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f863&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章评论》</title>
    <url>/posts/12ca6b81/</url>
    <content><![CDATA[<h2 id="app构建"><a href="#app构建" class="headerlink" title="app构建"></a>app构建</h2><p>登录github账号，随后访问<code>settings -&gt; Develpoer setting -&gt; OAuth Apps</code>生成一个自定义<code>app</code>用于<code>gitalk</code>链接</p>
<p><img src="https://s2.loli.net/2024/01/26/4k92qQmZFnU5usr.png" alt="image-20240126143302967"></p>
<p>配置完成，可进一步完善，主要获取到Client ID、Client secrets两个参数（注意保护好参数信息，避免被滥用）</p>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config_butterfly.yml"></a>修改_config_butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Gitalk</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in Home Page</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="attr">gitalk:</span></span><br><span class="line">   <span class="attr">client_id:</span> <span class="string">对应Client</span> <span class="string">ID</span></span><br><span class="line">   <span class="attr">client_secret:</span> <span class="string">对应Client</span> <span class="string">secrets</span></span><br><span class="line">   <span class="attr">repo:</span> <span class="string">对应存储的仓库名</span></span><br><span class="line">   <span class="attr">owner:</span> <span class="string">github用户名</span></span><br><span class="line">   <span class="attr">admin:</span> <span class="string">仓库的拥有者、协作者</span></span><br><span class="line">   <span class="attr">option:</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>本地只能看看gittalk是否已启动，想要测试完整效果需要部署到自己项目里面</p>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章链接持久化》</title>
    <url>/posts/1bf8e8b1/</url>
    <content><![CDATA[<h2 id="安装NPM插件"><a href="#安装NPM插件" class="headerlink" title="安装NPM插件"></a>安装NPM插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="config-yml添加配置信息"><a href="#config-yml添加配置信息" class="headerlink" title="_config.yml添加配置信息"></a>_config.yml添加配置信息</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章链接持久化</span></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#支持crc16（默认）和crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#支持dec（默认）和hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#（true）处理草稿，（false）不处理草稿。false（默认）</span></span><br><span class="line">  <span class="comment"># 从目录树生成类别</span></span><br><span class="line">  <span class="comment"># depth: 要生成的目录树的最大深度，应大于0</span></span><br><span class="line">  <span class="attr">auto_category:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment">#true(默认)</span></span><br><span class="line">    <span class="attr">depth:</span>        <span class="comment">#3(默认)</span></span><br><span class="line">    <span class="attr">over_write:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_title:</span> <span class="literal">false</span> <span class="comment">#启用自动标题，可按路径自动填充标题</span></span><br><span class="line">  <span class="attr">auto_date:</span> <span class="literal">false</span> <span class="comment">#启用自动日期功能，可以按今天的时间自动填充日期</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span> <span class="comment">#启用强制模式，在此模式下，插件将忽略缓存，并为每个帖子计算abbrlink，即使它已经有了abbrlink。</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="清除缓存重新跑"><a href="#清除缓存重新跑" class="headerlink" title="清除缓存重新跑"></a>清除缓存重新跑</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>《手写JavaScript 面试题》</title>
    <url>/posts/cb2af883/</url>
    <content><![CDATA[<h2 id="实现目标功能"><a href="#实现目标功能" class="headerlink" title="实现目标功能"></a>实现目标功能</h2><h3 id="Q1：二分查找"><a href="#Q1：二分查找" class="headerlink" title="Q1：二分查找"></a>Q1：二分查找</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在 JavaScript 中，可以使用几种不同的方法来实现二分查找算法，具体取决于个人的编程偏好和问题的特性。以下是几种常见的实现方式：</p><ol><li><p>迭代法</p><p>使用 while 循环来不断缩小搜索范围，直到找到目标值或确定目标值不存在于数组中。</p></li><li><p>递归法</p><p>通过递归调用来实现二分查找算法，将数组分割成更小的部分</p></li></ol><p>无论使用哪种方法，二分查找的核心思想都是将搜索范围一分为二，通过比较中间元素和目标值的大小关系来决定继续搜索的方向，从而达到快速查找的目的</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (target &lt; arr[left] || target &gt; arr[right]) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 避免数值溢出</span></span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> guess = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (guess === target) &#123;</span><br><span class="line">            <span class="comment">// 继续向左扫描，找到第一个等于目标值的索引</span></span><br><span class="line">            <span class="keyword">while</span> (arr[mid - <span class="number">1</span>] === target) &#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 返回第一个等于目标值的索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标值不存在于数组中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法：</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">binarySearch</span>(arr, target);</span><br><span class="line"><span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 的第一个索引为：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 不存在于数组中。`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>递归法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearchRecursive</span>(<span class="params">arr, target, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right || left &lt; <span class="number">0</span> || right &gt;= arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 目标值不存在于数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算中间索引</span></span><br><span class="line">    <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> guess = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (guess === target) &#123;</span><br><span class="line">        <span class="comment">// 继续向左扫描，找到第一个等于目标值的索引</span></span><br><span class="line">        <span class="keyword">while</span> (arr[mid - <span class="number">1</span>] === target) &#123;</span><br><span class="line">            mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// 返回第一个等于目标值的索引</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearchRecursive</span>(arr, target, mid + <span class="number">1</span>, right); <span class="comment">// 在右半部分继续查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">binarySearchRecursive</span>(arr, target, left, mid - <span class="number">1</span>); <span class="comment">// 在左半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法：</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">binarySearchRecursive</span>(arr, target);</span><br><span class="line"><span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 的第一个索引为：<span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`目标值 <span class="subst">$&#123;target&#125;</span> 不存在于数组中。`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q2：怎么预防用户连续快速点击，造成数据多次提交？"><a href="#Q2：怎么预防用户连续快速点击，造成数据多次提交？" class="headerlink" title="Q2：怎么预防用户连续快速点击，造成数据多次提交？"></a>Q2：怎么预防用户连续快速点击，造成数据多次提交？</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>为了防止用户连续快速点击造成数据多次提交，你可以考虑以下几种方法：</p><ol><li><p><strong>防抖（Debouncing）</strong>：</p><ul><li><p>防抖是一种控制函数调用频率的技术，通过延迟执行函数来确保在一定时间内只触发一次。当用户连续快速点击时，只有最后一次点击会触发实际的操作。</p></li><li><p>在前端中，你可以使用 JavaScript 中的 <code>setTimeout</code>和 clearTimeout</p><p>来实现防抖。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在点击事件中使用防抖</span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">debounce</span>(submitData, <span class="number">1000</span>); <span class="comment">// 1000 毫秒内只会触发一次 submitData 函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>禁用按钮</strong>：</p><ul><li><p>在用户点击后，禁用提交按钮，防止连续点击。可以在提交后添加一个 loading 状态，完成后再启用按钮。</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  button.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">submitData</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>点击间隔判断</strong>：</p><ul><li><p>记录上一次点击的时间戳，在点击时判断与上一次点击的时间间隔，只有在时间间隔足够长时才执行实际的提交操作。</p></li><li><p>例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastClickTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">if</span> (currentTime - lastClickTime &gt; <span class="number">1000</span>) &#123; <span class="comment">// 限定间隔为 1000 毫秒</span></span><br><span class="line">    <span class="title function_">submitData</span>();</span><br><span class="line">    lastClickTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数"><a href="#Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数" class="headerlink" title="Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数"></a>Q3：实现温度转换函数，让华氏度跟摄氏度可以互相转换，结果保留两位小数</h3><p>难度：⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><strong>公式：(摄氏度 * 9/5) + 32</strong></p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将摄氏度转换为华氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">celsiusToFahrenheit</span>(<span class="params">celsius</span>) &#123;</span><br><span class="line">  <span class="comment">// 公式：(摄氏度 * 9/5) + 32</span></span><br><span class="line">  <span class="keyword">const</span> fahrenheit = (celsius * <span class="number">9</span>/<span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(fahrenheit.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 保留两位小数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将华氏度转换为摄氏度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fahrenheitToCelsius</span>(<span class="params">fahrenheit</span>) &#123;</span><br><span class="line">  <span class="comment">// 公式：(华氏度 - 32) * 5/9</span></span><br><span class="line">  <span class="keyword">const</span> celsius = (fahrenheit - <span class="number">32</span>) * <span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseFloat</span>(celsius.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 保留两位小数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> celsiusValue = <span class="number">25</span>; <span class="comment">// 25摄氏度</span></span><br><span class="line"><span class="keyword">const</span> fahrenheitValue = <span class="number">77</span>; <span class="comment">// 77华氏度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> convertedToFahrenheit = <span class="title function_">celsiusToFahrenheit</span>(celsiusValue);</span><br><span class="line"><span class="keyword">const</span> convertedToCelsius = <span class="title function_">fahrenheitToCelsius</span>(fahrenheitValue);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;celsiusValue&#125;</span>摄氏度 = <span class="subst">$&#123;convertedToFahrenheit&#125;</span>华氏度`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;fahrenheitValue&#125;</span>华氏度 = <span class="subst">$&#123;convertedToCelsius&#125;</span>摄氏度`</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q4：使用原生js给一个按钮绑定两个onclick事件"><a href="#Q4：使用原生js给一个按钮绑定两个onclick事件" class="headerlink" title="Q4：使用原生js给一个按钮绑定两个onclick事件"></a>Q4：使用原生js给一个按钮绑定两个onclick事件</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Multiple Click Events<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 获取按钮元素</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> myButton = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 第一个click事件处理函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">handleClick1</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;First click event!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 第二个click事件处理函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">handleClick2</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&#x27;Second click event!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 给按钮添加第一个click事件</span></span></span><br><span class="line"><span class="language-javascript">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick1);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 给按钮添加第二个click事件</span></span></span><br><span class="line"><span class="language-javascript">myButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick2);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：给某个资源的链接，如-https-www-baidu-com-index-html请实现一个方法，获取该资源的后缀，如-html"><a href="#Q5：给某个资源的链接，如-https-www-baidu-com-index-html请实现一个方法，获取该资源的后缀，如-html" class="headerlink" title="Q5：给某个资源的链接，如 https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如 html"></a>Q5：给某个资源的链接，如 <a href="https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如">https://www.baidu.com/index.html请实现一个方法，获取该资源的后缀，如</a> html</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>切割</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取最后一个斜杠后面的内容</span></span><br><span class="line">    <span class="keyword">const</span> filename = url.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 获取最后一个点后面的内容作为后缀</span></span><br><span class="line">    <span class="keyword">const</span> extension = filename.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> extension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法首先通过拆分URL来获取文件名，然后再从文件名中获取后缀。需要注意的是，这个方法假设文件名中只有一个点作为后缀名的分隔符，并且后缀名在点后面。如果URL中包含查询参数或片段标识符，可能需要进行额外的处理以避免错误。</p></li><li><p>正则</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用正则表达式匹配最后一个点后面的内容作为后缀</span></span><br><span class="line">    <span class="keyword">const</span> extension = url.<span class="title function_">match</span>(<span class="regexp">/\.([^.]+)$/</span>);</span><br><span class="line">    <span class="keyword">if</span> (extension) &#123;</span><br><span class="line">        <span class="keyword">return</span> extension[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果没有后缀，则返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法使用正则表达式 <code>\.[^.]+$</code> 来匹配最后一个点后面的内容作为后缀，然后返回匹配到的结果。如果没有找到后缀，则返回空字符串。与之前的方法相比，这种方法更加灵活，可以处理更多可能的情况。</p></li><li><p>获取索引</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFileExtension</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到最后一个点的索引</span></span><br><span class="line">    <span class="keyword">const</span> lastDotIndex = url.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastDotIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 切片并获取后缀</span></span><br><span class="line">        <span class="keyword">const</span> extension = url.<span class="title function_">slice</span>(lastDotIndex + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 如果没有后缀，则返回空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://www.baidu.com/index.html&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fileExtension = <span class="title function_">getFileExtension</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fileExtension); <span class="comment">// 输出 &quot;html&quot;</span></span><br></pre></td></tr></table></figure><p>这个方法首先使用 <code>lastIndexOf()</code> 方法找到最后一个点的索引，然后通过切片获取后缀。如果没有找到后缀，则返回空字符串。这种方法比较简洁，并且与正则表达式相比，可能具有更好的性能。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放"><a href="#Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放" class="headerlink" title="Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放?"></a>Q6：一个滚动公告组件，如何在鼠标滑入时停止播放，在鼠标离开时继续等待滑入时的剩余等待时间后播放?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>要实现这样的滚动公告组件，你可以使用 JavaScript 来控制滑入和滑出事件，并结合定时器来暂停和恢复播放。下面是一个基本的实现示例：</p><p>HTML：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;announcement&quot;</span>&gt;</span>这是滚动公告内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取公告元素</span></span><br><span class="line"><span class="keyword">const</span> announcementElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;announcement&quot;</span>);</span><br><span class="line"><span class="comment">// 设置滚动公告的内容和滚动速度</span></span><br><span class="line"><span class="keyword">const</span> announcementContent = <span class="string">&quot;这是滚动公告内容，这是滚动公告内容，这是滚动公告内容&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> scrollSpeed = <span class="number">50</span>; <span class="comment">// 滚动速度（单位：毫秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义滚动公告函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollAnnouncement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    announcementElement.<span class="property">innerText</span> += <span class="string">&quot; &quot;</span> + announcementContent; <span class="comment">// 添加滚动内容</span></span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要停止滚动</span></span><br><span class="line">        <span class="keyword">if</span> (!announcementElement.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-paused&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 滚动内容</span></span><br><span class="line">            announcementElement.<span class="property">scrollLeft</span> += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果内容滚动到末尾，则重置滚动位置</span></span><br><span class="line">            <span class="keyword">if</span> (announcementElement.<span class="property">scrollLeft</span> &gt;= announcementElement.<span class="property">scrollWidth</span> - announcementElement.<span class="property">clientWidth</span>) &#123;</span><br><span class="line">                announcementElement.<span class="property">scrollLeft</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, scrollSpeed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将定时器ID存储在元素的自定义属性中</span></span><br><span class="line">    announcementElement.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-interval-id&quot;</span>, intervalId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始滚动</span></span><br><span class="line"><span class="title function_">scrollAnnouncement</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移入时暂停滚动</span></span><br><span class="line">announcementElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseenter&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取剩余等待时间</span></span><br><span class="line">    <span class="keyword">const</span> remainingTime = scrollSpeed - (announcementElement.<span class="property">scrollWidth</span> - announcementElement.<span class="property">scrollLeft</span>) % scrollSpeed;</span><br><span class="line">    <span class="comment">// 停止滚动</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(announcementElement.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-interval-id&quot;</span>));</span><br><span class="line">    announcementElement.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-paused&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 等待剩余时间后继续滚动</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        announcementElement.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-paused&quot;</span>);</span><br><span class="line">        <span class="title function_">scrollAnnouncement</span>();</span><br><span class="line">    &#125;, remainingTime);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移出时继续滚动</span></span><br><span class="line">announcementElement.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseleave&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继续滚动</span></span><br><span class="line">    announcementElement.<span class="title function_">removeAttribute</span>(<span class="string">&quot;data-paused&quot;</span>);</span><br><span class="line">    <span class="title function_">scrollAnnouncement</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个代码片段首先定义了一个滚动公告的容器，然后设置了滚动的速度和内容。接着定义了一个函数 <code>scrollAnnouncement()</code> 来执行滚动公告的动作，并设置了一个定时器来控制滚动的频率。在鼠标移入和移出事件中，暂停和恢复滚动的操作通过设置一个自定义属性 <code>data-paused</code> 来实现。当鼠标移入时，先暂停滚动，然后等待剩余的滚动时间后再继续滚动。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q7：怎么把十进制的-0-2-转换成二进制"><a href="#Q7：怎么把十进制的-0-2-转换成二进制" class="headerlink" title="Q7：怎么把十进制的 0.2 转换成二进制?"></a>Q7：怎么把十进制的 0.2 转换成二进制?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decimalToBinary</span>(<span class="params">decimal, precision</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> binary = <span class="string">&quot;0.&quot;</span>; <span class="comment">// 二进制结果的初始部分</span></span><br><span class="line">    <span class="keyword">let</span> remainder = decimal; <span class="comment">// 初始余数为十进制数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环指定的精度，进行乘以 2 取整操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; precision; i++) &#123;</span><br><span class="line">        <span class="comment">// 将余数乘以 2</span></span><br><span class="line">        remainder *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果结果大于等于 1，则整数部分为 1，否则为 0</span></span><br><span class="line">        <span class="keyword">if</span> (remainder &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            binary += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            remainder -= <span class="number">1</span>; <span class="comment">// 更新余数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            binary += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> binary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数进行转换，精度为 16 位</span></span><br><span class="line"><span class="keyword">const</span> binaryRepresentation = <span class="title function_">decimalToBinary</span>(<span class="number">0.2</span>, <span class="number">16</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binaryRepresentation); <span class="comment">// 输出 &quot;0.0011001100110011&quot;</span></span><br></pre></td></tr></table></figure><p>这个函数 <code>decimalToBinary()</code> 接受两个参数：要转换的十进制数和转换后二进制的精度（即位数）。然后通过循环将小数不断乘以 2，并根据结果的整数部分确定二进制的相应位数。最终返回的二进制字符串即为所需的结果。</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>乘以 2 取整法和除以 2 取余法</strong></p><ol><li><strong>乘以 2 取整法</strong>：<ul><li>优点：<ul><li>不涉及除法运算，乘法运算通常比除法运算更高效，因此在某些情况下可能更快。</li><li>适用于不需要精确表示小数的情况，例如计算机中的浮点数表示。</li></ul></li><li>计算方式：<ul><li>首先将十进制数乘以 2，然后取整部分作为二进制的下一位数。</li><li>如果乘以 2 的结果大于等于 1，则记录为 1，并将结果减去 1；否则记录为 0。</li><li>然后将结果乘以 2，继续重复以上步骤，直到得到所需的位数或者小数部分为 0。</li></ul></li><li>适用场景：<ul><li>在计算机程序中，特别是涉及到浮点数转换为二进制表示时，可能更常用乘以 2 取整法。</li></ul></li></ul></li><li><strong>除以 2 取余法</strong>：<ul><li>优点：<ul><li>更直观易懂，与人们对十进制到二进制的转换过程更为熟悉。</li><li>对于需要精确表示小数的情况，除以 2 取余法可以提供更准确的结果。</li></ul></li><li>计算方式：<ul><li>首先将十进制数除以 2，然后取余数作为二进制的下一位数。</li><li>将商作为新的要除以 2 的十进制数。</li><li>继续重复以上步骤，直到得到的商为 0。</li></ul></li><li>适用场景：<ul><li>在需要精确表示小数的情况下，例如数学计算、金融领域等，除以 2 取余法可能更为适用。</li></ul></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q8：请对以下数组，根据born”的值降序排列"><a href="#Q8：请对以下数组，根据born”的值降序排列" class="headerlink" title="Q8：请对以下数组，根据born”的值降序排列"></a>Q8：请对以下数组，根据born”的值降序排列</h3><p>难度：⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> singers = [  </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Steven Tyler&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Aerosmith&#x27;</span>, <span class="attr">born</span>: <span class="number">1948</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Karen Carpenter&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;The Carpenters&#x27;</span>, <span class="attr">born</span>: <span class="number">1950</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Kurt Cobain&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Nirvana&#x27;</span>, <span class="attr">born</span>: <span class="number">1967</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Stevie Nicks&#x27;</span>, <span class="attr">band</span>: <span class="string">&#x27;Fleetwood Mac&#x27;</span>, <span class="attr">born</span>: <span class="number">1948</span> &#125;, </span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>使用 <code>sort()</code> 方法和箭头函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">singers.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.<span class="property">born</span> - a.<span class="property">born</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>使用 reduce() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = singers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> insertIndex = acc.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; cur.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (insertIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        acc.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acc.<span class="title function_">splice</span>(insertIndex, <span class="number">0</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>这种方法使用了 reduce() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.concat() 和 for…of 循环</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> singer <span class="keyword">of</span> singers) &#123;</span><br><span class="line">    <span class="keyword">let</span> inserted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sortedSingers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singer.<span class="property">born</span> &gt; sortedSingers[i].<span class="property">born</span>) &#123;</span><br><span class="line">            sortedSingers.<span class="title function_">splice</span>(i, <span class="number">0</span>, singer);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inserted) &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">push</span>(singer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用了 for…of 循环遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.unshift() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sortedSingers[i] &amp;&amp; singer.<span class="property">born</span> &lt; sortedSingers[i].<span class="property">born</span>) i++;</span><br><span class="line">    sortedSingers.<span class="title function_">splice</span>(i, <span class="number">0</span>, singer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.push() 和 Array.prototype.pop() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = sortedSingers.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; singer.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">push</span>(singer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sortedSingers.<span class="title function_">splice</span>(index, <span class="number">0</span>, singer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.push() 和 Math.max() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = [];</span><br><span class="line">singers.<span class="title function_">forEach</span>(<span class="function"><span class="params">singer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">max</span>(...sortedSingers.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; singer.<span class="property">born</span> ? sortedSingers.<span class="title function_">indexOf</span>(item) : -<span class="number">1</span>));</span><br><span class="line">    sortedSingers.<span class="title function_">splice</span>(index + <span class="number">1</span>, <span class="number">0</span>, singer);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种方法使用了 forEach() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li><li><p><strong>使用 Array.prototype.reduceRight() 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedSingers = singers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> insertIndex = acc.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">born</span> &lt; cur.<span class="property">born</span>);</span><br><span class="line">    <span class="keyword">if</span> (insertIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        acc.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        acc.<span class="title function_">splice</span>(insertIndex, <span class="number">0</span>, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>这种方法使用了 reduceRight() 方法遍历原数组，然后根据 born 属性的值将元素插入到新数组的适当位置，最终得到的新数组就是按 born 属性的值降序排列的数组。</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q9-：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果"><a href="#Q9-：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果" class="headerlink" title="Q9 ：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果?"></a>Q9 ：遍历一个任意长度的list中的元素并依次创建异步任务如何获取所有任务的执行结果?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作，例如请求数据或其他耗时任务</span></span><br><span class="line">        <span class="comment">// 假设这里是一个异步任务，返回处理结果</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">`Processed item: <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">        &#125;, <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> promises = myList.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">asyncTask</span>(item));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise.all()：</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All tasks completed successfully:&quot;</span>, results);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error processing tasks:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 Promise.allSettled()：</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> successfulResults = results.<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">const</span> failedResults = results.<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">reason</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Successful tasks:&quot;</span>, successfulResults);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Failed tasks:&quot;</span>, failedResults);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><code>Promise.all()</code> 和 <code>Promise.allSettled()</code> 是两种不同的 Promise 组合方法，它们之间有一些关键的区别：</p><ol><li><strong>Promise.all()</strong>：<ul><li>当所有 Promise 都成功解决时，返回一个包含所有 Promise 结果的数组。</li><li>如果其中任何一个 Promise 被拒绝（rejected），则立即将返回的 Promise 对象标记为拒绝，并且会传递第一个被拒绝的 Promise 的拒因（rejection reason）。</li><li>如果有一个 Promise 被拒绝，那么其他 Promise 的执行依然会继续，但 <code>Promise.all()</code> 返回的 Promise 对象将被标记为拒绝，无法获取其他 Promise 的结果。</li></ul></li><li><strong>Promise.allSettled()</strong>：<ul><li>等待所有 Promise 执行完成，不管是成功还是失败，都会返回一个包含所有 Promise 执行结果的数组。</li><li>返回的 Promise 对象状态总是成功的，不会因为其中的某个 Promise 被拒绝而导致整个组合 Promise 被拒绝。</li><li>返回的数组中的每个元素都是一个对象，代表对应的 Promise 执行结果，包括状态（fulfilled 或 rejected）和对应的值或拒因。</li></ul></li></ol><p>简而言之，<code>Promise.all()</code> 等待所有 Promise 解决，如果有一个被拒绝则整个组合 Promise 被拒绝；而 <code>Promise.allSettled()</code> 等待所有 Promise 执行完成，无论成功或失败，返回的 Promise 总是成功的，并提供每个 Promise 的执行结果。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q10：怎么把函数中的-arguments-转成数组"><a href="#Q10：怎么把函数中的-arguments-转成数组" class="headerlink" title="Q10：怎么把函数中的 arguments 转成数组?"></a>Q10：怎么把函数中的 arguments 转成数组?</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Array.from() 方法</strong>：</p><ul><li>使用 <code>Array.from()</code> 方法可以将类数组对象转换为数组。</li><li>实现原理：<code>Array.from()</code> 方法从一个类数组或可迭代对象中创建一个新的数组实例。它会遍历类数组对象的每个元素，并将其添加到新数组中。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Array.prototype.slice.call() 方法</strong>：</p><ul><li>使用 <code>Array.prototype.slice.call()</code> 方法通过调用数组的 <code>slice()</code> 方法，将一个类数组对象转换为数组。</li><li>实现原理：<code>slice()</code> 方法可以接受两个参数，第一个参数是开始截取的索引，第二个参数是结束截取的索引。如果省略第二个参数，则从开始索引截取到数组末尾。因为我们没有传入任何参数，所以它会将整个类数组对象转换为数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>扩展运算符 <code>...</code></strong>：</p><ul><li>使用扩展运算符 <code>...</code> 可以将一个可迭代对象展开为多个元素，并创建一个包含所有参数的数组。</li><li>实现原理：扩展运算符 <code>...</code> 可以将一个可迭代对象展开为多个元素。在这种情况下，<code>arguments</code> 对象是一个可迭代对象，因此使用 <code>...arguments</code> 可以将其展开为多个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argsArray = [...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="keyword">return</span> argsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">myFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，<code>arguments</code> 是一个特殊的对象，用于在函数内部访问传递给函数的参数列表。它类似于数组，但并不是一个真正的数组，而是一个类数组对象（Array-like Object）。<code>arguments</code> 对象包含了所有传递给函数的参数，可以通过索引来访问每个参数。</p><p><code>arguments</code> 对象有以下特点：</p><ol><li><strong>类数组对象</strong>：<code>arguments</code> 对象类似于数组，但不是一个真正的数组，因为它没有数组的方法和属性。</li><li><strong>自动创建</strong>：<code>arguments</code> 对象在函数内部自动创建，无需显式声明或定义。</li><li><strong>包含所有参数</strong>：<code>arguments</code> 对象包含了所有传递给函数的参数，包括函数定义时声明的参数以及调用函数时传递的参数。</li><li><strong>索引访问</strong>：可以通过索引来访问 <code>arguments</code> 对象中的每个参数，索引从 0 开始。</li><li><strong>length 属性</strong>：<code>arguments</code> 对象具有 <code>length</code> 属性，表示传递给函数的参数数量。</li></ol><p>使用 <code>arguments</code> 对象可以使函数更加灵活，因为它允许函数接受任意数量的参数，而不需要提前定义函数参数的个数。然而，由于 <code>arguments</code> 对象不是一个真正的数组，因此不能直接使用数组的方法，例如 <code>push()</code> 和 <code>pop()</code>。 若要在 <code>arguments</code> 对象上使用数组方法，需要先将其转换为真正的数组。</p><p><strong>数组和类数组之间的主要区别：</strong></p><div class="table-container"><table><thead><tr><th>特点</th><th>数组（Array）</th><th>类数组对象（Array-like Object）</th></tr></thead><tbody><tr><td>数据类型</td><td>存储任意类型的数据，可以是基本类型和对象等</td><td>只能存储元素，通常是单一类型的</td></tr><tr><td>长度（Length）属性</td><td>有长度属性 <code>length</code></td><td>通常没有 <code>length</code> 属性，除非明确添加</td></tr><tr><td>可迭代性（Iterable）</td><td>可以使用迭代器方法（如 <code>forEach</code>, <code>map</code>）</td><td>通常不能直接使用数组方法，但可以通过其他方式进行遍历，如 <code>for...of</code> 或 <code>Array.from()</code></td></tr><tr><td>方法和属性</td><td>拥有数组方法和属性，如 <code>push</code>, <code>pop</code>, <code>slice</code></td><td>通常没有数组方法和属性</td></tr></tbody></table></div><p>总的来说，数组是 JavaScript 中的一种特殊对象，拥有一系列方法和属性，可以轻松地操作其元素。而类数组对象通常只能存储元素，缺乏数组的方法和属性，但有时可以通过一些技巧或转换方法来模拟数组的行为。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q11：写一个repeat-方法，实现字符串的复制拼接"><a href="#Q11：写一个repeat-方法，实现字符串的复制拼接" class="headerlink" title="Q11：写一个repeat 方法，实现字符串的复制拼接"></a>Q11：写一个repeat 方法，实现字符串的复制拼接</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>String.prototype.repeat() 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">repeat</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.fill() 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(str).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.join() 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">join</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.map() 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;, <span class="function">() =&gt;</span> str).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>String.prototype.padStart() 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">padStart</span>(str.<span class="property">length</span> * n, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while 循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result += str;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="title function_">repeatString</span>(str, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>reduce 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repeatString</span>(<span class="params">str, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc</span>) =&gt;</span> acc + str, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Polyfill 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">repeat</span>) &#123;</span><br><span class="line">    <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">repeat</span> = <span class="keyword">function</span>(<span class="params">count</span>) &#123;</span><br><span class="line">        <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;can\&#x27;t convert &#x27;</span> + <span class="variable language_">this</span> + <span class="string">&#x27; to object&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span> + <span class="variable language_">this</span>;</span><br><span class="line">        <span class="comment">// To convert string to integer.</span></span><br><span class="line">        count = +count;</span><br><span class="line">        <span class="comment">// Check NaN</span></span><br><span class="line">        <span class="keyword">if</span> (count != count)</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must be non-negative&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="title class_">Infinity</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must be less than infinity&#x27;</span>);</span><br><span class="line">        count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(count);</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="property">length</span> == <span class="number">0</span> || count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="comment">// Ensuring count is a 31-bit integer allows us to heavily optimize the</span></span><br><span class="line">        <span class="comment">// main part. But anyway, most current (August 2014) browsers can&#x27;t handle</span></span><br><span class="line">        <span class="comment">// strings 1 &lt;&lt; 28 chars or longer, so:</span></span><br><span class="line">        <span class="keyword">if</span> (str.<span class="property">length</span> * count &gt;= <span class="number">1</span> &lt;&lt; <span class="number">28</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;repeat count must not overflow maximum string size&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> maxCount = str.<span class="property">length</span> * count;</span><br><span class="line">        count = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">log</span>(count) / <span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">while</span> (count) &#123;</span><br><span class="line">            str += str;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        str += str.<span class="title function_">substring</span>(<span class="number">0</span>, maxCount - str.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><strong>String.prototype.repeat() 方法</strong>：<ul><li>API：<code>String.prototype.repeat(count)</code></li><li>参数：<code>count</code>，一个非负整数，表示要重复字符串的次数。</li><li>返回值：返回一个新的字符串，该字符串包含指定次数的原始字符串拼接在一起的结果。</li></ul></li><li><strong>Array.prototype.fill() 方法</strong>：<ul><li>API：<code>Array.prototype.fill(value, start, end)</code></li><li>参数：<code>value</code>，要填充到数组中的值；<code>start</code>，填充的起始索引（可选，默认为0）；<code>end</code>，填充的结束索引（可选，默认为数组末尾）。</li><li>返回值：修改后的数组。</li></ul></li><li><strong>Array.prototype.join() 方法</strong>：<ul><li>API：<code>Array.prototype.join(separator)</code></li><li>参数：<code>separator</code>，一个可选的字符串，用作分隔符，将数组中的每个元素连接在一起。如果省略，则默认使用逗号作为分隔符。</li><li>返回值：返回一个由数组元素组成的字符串，每个元素之间由分隔符分隔。</li></ul></li><li><strong>Array.prototype.map() 方法</strong>：<ul><li>API：<code>Array.prototype.map(callback, thisArg)</code></li><li>参数：<code>callback</code>，一个用于处理数组元素的函数，该函数接收三个参数：当前值（currentValue）、当前索引（index）、原数组（array）；<code>thisArg</code>，可选参数，用作执行回调时的 this 值。</li><li>返回值：返回一个新数组，数组中的每个元素都是回调函数的结果。</li></ul></li><li><strong>String.prototype.padStart() 方法</strong>：<ul><li>API：<code>String.prototype.padStart(targetLength, padString)</code></li><li>参数：<code>targetLength</code>，目标字符串的长度；<code>padString</code>，一个可选的填充字符串，默认为空格。</li><li>返回值：返回一个新的字符串，该字符串由原始字符串重复填充至目标长度后返回。</li></ul></li><li><strong>Polyfill 方法</strong>：<ul><li>这是一个用于解决在不支持 <code>String.prototype.repeat()</code> 方法的环境中提供兼容性的方法。</li><li>它检查是否存在 <code>String.prototype.repeat()</code> 方法，如果不存在则定义一个 Polyfill 方法，否则不做任何操作。</li><li>该 Polyfill 方法实现了重复字符串的功能，与原生的 <code>String.prototype.repeat()</code> 方法功能相同。</li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q12：使用is生成1-10000的数组"><a href="#Q12：使用is生成1-10000的数组" class="headerlink" title="Q12：使用is生成1-10000的数组"></a>Q12：使用is生成1-10000的数组</h3><p>难度：⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10000</span> &#125;, <span class="function">(<span class="params">_, index</span>) =&gt;</span> index + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这段代码将创建一个长度为 10000 的数组，并使用箭头函数来填充数组的每个元素，使其从 1 到 10000。</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q13：移动端的点击事件的有延迟，时间是多久，为什么会有-怎么解决这个延时"><a href="#Q13：移动端的点击事件的有延迟，时间是多久，为什么会有-怎么解决这个延时" class="headerlink" title="Q13：移动端的点击事件的有延迟，时间是多久，为什么会有?怎么解决这个延时?"></a>Q13：移动端的点击事件的有延迟，时间是多久，为什么会有?怎么解决这个延时?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>移动端点击事件的延迟通常称为”点击延迟”（Click Delay），在某些移动设备和浏览器中会存在这个问题。这种延迟的主要原因是浏览器为了等待可能的双击事件（double tap），以便在用户进行双击时执行相应的操作。</p><p>这个点击延迟的时间通常在 300 毫秒左右，具体时间可能因浏览器和设备而异。</p><p>解决这个延时的常见方法包括：</p><ol><li><p><strong>使用 <code>touchstart</code> 事件</strong></p><p><code>touchstart</code> 事件触发的速度更快，可以替代 <code>click</code> 事件</p><p>但需要注意的是，<code>touchstart</code> 事件与 <code>click</code> 事件有一些区别，如在移动设备上长按屏幕时不会触发 <code>click</code> 事件，但会触发 <code>touchstart</code> 事件</p></li><li><p><strong>使用 CSS 属性 <code>touch-action: none</code></strong></p><p>通过在元素上设置 <code>touch-action: none</code> CSS 属性来禁用浏览器的默认行为，从而避免点击延迟</p><p>这个方法可能会影响到页面的默认滚动行为，需要根据具体情况来决定是否使用</p></li><li><p><strong>使用第三方库或框架</strong></p><p>一些 JavaScript 库或框架（如 FastClick、TapJS 等）专门用于解决移动端点击延迟的问题</p><p>这些库通常会在内部优化事件处理逻辑，以提供更快的响应速度</p></li><li><p><strong>meta 标签设置</strong></p><p>可以使用 <code>&lt;meta&gt;</code> 标签中的 <code>viewport</code> 属性来控制页面的缩放行为，通过设置 <code>user-scalable=no</code> 来禁止用户缩放页面，可以减少点击延迟</p><p>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，禁止用户缩放页面可能会影响用户体验，因此需要谨慎使用</p></li><li><p><strong>优化页面性能</strong></p><p>优化页面的性能和加载速度，减少资源的请求和加载时间，可以间接地减少点击延迟</p><p>特别是减少 JavaScript 和 CSS 文件的大小和数量，以及优化图片资源的加载方式</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q14：如何判断当前脚本运行在浏览器还是-node-环境中"><a href="#Q14：如何判断当前脚本运行在浏览器还是-node-环境中" class="headerlink" title="Q14：如何判断当前脚本运行在浏览器还是 node 环境中?"></a>Q14：如何判断当前脚本运行在浏览器还是 node 环境中?</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在浏览器环境中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前环境是浏览器&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 在 Node.js 环境中</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前环境是 Node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未知环境</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未知环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在 JavaScript 中，可以通过检查全局对象来判断当前脚本是在浏览器环境还是 Node.js 环境中运行。在浏览器环境中，全局对象是 <code>window</code>，而在 Node.js 环境中，全局对象是 <code>global</code></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q15：前端路由’a-gt-b-gt-c-这样前进，也可以返回c-gt-b-gt-a，用什么数据结构来存比较高效"><a href="#Q15：前端路由’a-gt-b-gt-c-这样前进，也可以返回c-gt-b-gt-a，用什么数据结构来存比较高效" class="headerlink" title="Q15：前端路由’a -&gt;b-&gt;c`这样前进，也可以返回c-&gt;b-&gt;a，用什么数据结构来存比较高效"></a>Q15：前端路由’a -&gt;b-&gt;c`这样前进，也可以返回c-&gt;b-&gt;a，用什么数据结构来存比较高效</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">backStack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">forwardStack</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">navigate</span>(<span class="params">page</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = page;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// 清空前进栈，因为导航到新页面后不能再前进</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">back</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">forward</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">backStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">current</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">forwardStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 用户导航到a</span></span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 用户从a导航到b</span></span><br><span class="line">router.<span class="title function_">navigate</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 用户从b导航到c</span></span><br><span class="line"></span><br><span class="line">router.<span class="title function_">back</span>();    <span class="comment">// 用户点击后退，从c回到b</span></span><br><span class="line">router.<span class="title function_">back</span>();    <span class="comment">// 用户再次点击后退，从b回到a</span></span><br><span class="line">router.<span class="title function_">forward</span>(); <span class="comment">// 用户点击前进，从a前进到b</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>navigate</code>方法用于模拟用户导航到新页面的行为，<code>back</code>方法和<code>forward</code>方法分别用于后退和前进。使用栈结构允许我们保持一个清晰的历史记录，并且能够以逆序访问这些记录，这正是我们在浏览器历史中所期望的行为。</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><strong>前进栈（Forward Stack）</strong>: 当用户从一个页面导航到另一个页面时，将当前页面推入前进栈。</li><li><strong>后退栈（Back Stack）</strong>: 当用户点击后退时，将当前页面推入后退栈，并从前进栈中弹出顶部页面来显示。</li><li><strong>前进</strong>: 当用户点击前进按钮时，将当前页面推入后退栈，并从前进栈中弹出顶部页面来显示。</li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>在计算机科学中，管理这种前进和后退（前进和后退导航）的一种有效方法是使用两个栈（堆栈）——一个用于前进历史，另一个用于后退历史。这种方法在许多浏览器的历史功能的实现中被采用</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q16：怎么预防用户快速连续点击，造成数据多次提交"><a href="#Q16：怎么预防用户快速连续点击，造成数据多次提交" class="headerlink" title="Q16：怎么预防用户快速连续点击，造成数据多次提交"></a>Q16：怎么预防用户快速连续点击，造成数据多次提交</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>为了防止重复提交，前端一般会在第一次提交的结果返回前，将提交按钮禁用</p><ol><li><p><strong>禁用按钮</strong>：</p><ul><li><p>在提交操作后立即禁用按钮，防止用户再次点击，直到操作完成或过一段时间后重新启用按钮。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#submitButton&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    button.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> button.<span class="property">disabled</span> = <span class="literal">false</span>)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> button.<span class="property">disabled</span> = <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>节流（Throttle）或防抖（Debounce）</strong>：</p><ul><li><p>使用节流或防抖函数控制点击事件的频率，限制在特定时间内只允许触发一次。</p></li><li><p>示例代码（防抖）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timeoutId;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line">        timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> submitDataDebounced = <span class="title function_">debounce</span>(submitData, <span class="number">3000</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, submitDataDebounced);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>状态管理</strong>：</p><ul><li><p>使用状态管理追踪提交的状态，如果某次提交尚未完成，则拒绝新的提交。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isSubmitting = <span class="literal">false</span>;</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSubmitting) <span class="keyword">return</span>;</span><br><span class="line">    isSubmitting = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> isSubmitting = <span class="literal">false</span>)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> isSubmitting = <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全屏遮罩</strong>：</p><ul><li><p>显示一个全屏遮罩元素阻止用户在关键操作期间与页面交互。</p></li><li><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mask = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">mask.<span class="property">style</span> = <span class="string">&#x27;position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; display: none;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mask);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">showMask</span> = (<span class="params"></span>) =&gt; mask.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hideMask</span> = (<span class="params"></span>) =&gt; mask.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">showMask</span>();</span><br><span class="line">    <span class="title function_">submitData</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">hideMask</span>())</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="title function_">hideMask</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q17：实现以下转换，合并连续的数字"><a href="#Q17：实现以下转换，合并连续的数字" class="headerlink" title="Q17：实现以下转换，合并连续的数字"></a>Q17：实现以下转换，合并连续的数字</h3><p>难度：⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">15</span>]=&gt;[<span class="string">&#x27;1-&gt;4&#x27;</span>,<span class="string">&#x27;6-&gt;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="string">&#x27;15&#x27;</span>]</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p><code>mergeConsecutiveNumbers</code> 函数的思路是将输入数组中的连续数字范围合并成字符串形式，然后返回这些合并后的字符串列表。具体的思路如下：</p><ol><li><strong>参数验证</strong>：<ul><li>首先，函数会验证输入是否为非空数组，以避免空数组或非数组的输入导致的潜在错误</li><li>如果输入不是数组或者数组为空，则函数直接返回空数组</li></ul></li><li><strong>初始化</strong>：<ul><li>初始化一个结果数组 <code>result</code>，用于存储最终的合并结果</li><li>定义变量 <code>start</code> 和 <code>end</code>，表示当前连续数字范围的开始和结束。初始值均为输入数组的第一个元素</li></ul></li><li><strong>帮助函数</strong>：<ul><li>定义一个名为 <code>addRangeToResult</code> 的帮助函数，用于将连续数字范围添加到结果数组 <code>result</code> 中</li><li>如果开始和结束是相同的，则表示这是一个单独的数字；否则表示这是一个连续的数字范围</li></ul></li><li><strong>遍历输入数组</strong>：<ul><li>遍历输入数组，从索引 1 开始（因为初始值已经处理了第一个元素）</li><li>对于每一个元素 <code>current</code>，检查其是否与 <code>end + 1</code> 相等。如果是，说明 <code>current</code> 是连续的数字，更新 <code>end</code> 变量</li><li>如果 <code>current</code> 不等于 <code>end + 1</code>，则表示当前元素不是连续数字的一部分。在这种情况下，调用 <code>addRangeToResult</code> 函数将当前范围添加到结果数组中，然后重置 <code>start</code> 和 <code>end</code> 为当前元素</li></ul></li><li><strong>处理最后一个范围</strong>：<ul><li>在循环结束后，函数调用 <code>addRangeToResult</code> 函数来处理最后一个范围（因为在遍历结束后，可能还有未处理的范围）</li></ul></li><li><strong>返回结果</strong>：<ul><li>最后，函数返回结果数组 <code>result</code>，其中包含了输入数组中的合并后的连续数字范围</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeConsecutiveNumbers</span>(<span class="params">input</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(input) || input.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化范围的开始和结束</span></span><br><span class="line">    <span class="keyword">let</span> start = input[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> end = start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 帮助函数来添加范围到结果数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addRangeToResult</span> = (<span class="params">start, end</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (start === end) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(start.<span class="title function_">toString</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;start&#125;</span>-&gt;<span class="subst">$&#123;end&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输入数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; input.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> current = input[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前数字与前一个数字连续</span></span><br><span class="line">        <span class="keyword">if</span> (current === end + <span class="number">1</span>) &#123;</span><br><span class="line">            end = current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，将当前范围添加到结果数组</span></span><br><span class="line">            <span class="title function_">addRangeToResult</span>(start, end);</span><br><span class="line">            <span class="comment">// 开始一个新的范围</span></span><br><span class="line">            start = current;</span><br><span class="line">            end = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后一个范围</span></span><br><span class="line">    <span class="title function_">addRangeToResult</span>(start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例输入</span></span><br><span class="line"><span class="keyword">const</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并输出结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mergeConsecutiveNumbers</span>(input));  <span class="comment">// 输出 [&#x27;1-&gt;4&#x27;, &#x27;6-&gt;7&#x27;, &#x27;9&#x27;, &#x27;13&#x27;, &#x27;15&#x27;]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q18：非递归遍历二叉树"><a href="#Q18：非递归遍历二叉树" class="headerlink" title="Q18：非递归遍历二叉树"></a>Q18：非递归遍历二叉树</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在数据结构和算法中，非递归遍历二叉树是指通过迭代的方式来遍历二叉树，而不是使用递归的方法。二叉树的遍历方式主要有三种：前序遍历、中序遍历和后序遍历。接下来，我将分别介绍这些遍历方式的非递归实现。</p><p><strong>前序遍历（Pre-order Traversal）：</strong></p><p>在前序遍历中，遍历顺序是根节点 -&gt; 左子树 -&gt; 右子树。非递归实现通常使用栈来模拟递归过程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">preOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    stack.<span class="title function_">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentNode = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNode.<span class="property">value</span>); <span class="comment">// 处理当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将右子节点入栈，因为栈是后进先出</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">right</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再将左子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">left</span>) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历（In-order Traversal）：</strong></p><p>在中序遍历中，遍历顺序是左子树 -&gt; 根节点 -&gt; 右子树。非递归实现通常使用栈来辅助遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> currentNode = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (currentNode || stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 向左走到底，将所有左子节点入栈</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(currentNode);</span><br><span class="line">            currentNode = currentNode.<span class="property">left</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 弹出一个节点并处理</span></span><br><span class="line">        currentNode = stack.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentNode.<span class="property">value</span>); <span class="comment">// 处理当前节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续遍历右子树</span></span><br><span class="line">        currentNode = currentNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后序遍历（Post-order Traversal）：</strong></p><p>在后序遍历中，遍历顺序是左子树 -&gt; 右子树 -&gt; 根节点。非递归实现有几种方法，通常使用栈进行辅助。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postOrderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stack1 = [];</span><br><span class="line">    <span class="keyword">const</span> stack2 = [];</span><br><span class="line">    stack1.<span class="title function_">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两个栈来处理</span></span><br><span class="line">    <span class="keyword">while</span> (stack1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> currentNode = stack1.<span class="title function_">pop</span>();</span><br><span class="line">        stack2.<span class="title function_">push</span>(currentNode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将左子树和右子树依次入栈</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">left</span>) &#123;</span><br><span class="line">            stack1.<span class="title function_">push</span>(currentNode.<span class="property">left</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentNode.<span class="property">right</span>) &#123;</span><br><span class="line">            stack1.<span class="title function_">push</span>(currentNode.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 stack2 中弹出所有节点即为后序遍历</span></span><br><span class="line">    <span class="keyword">while</span> (stack2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack2.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>); <span class="comment">// 处理节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的非递归遍历实现，你可以在不使用递归的情况下对二叉树进行前序遍历、中序遍历和后序遍历。这些实现都使用了栈来模拟递归过程，以达到非递归遍历的目的</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q19-：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"><a href="#Q19-：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名" class="headerlink" title="Q19 ：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"></a>Q19 ：写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回数据类型的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTypeOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查参数是否为 null 或 undefined</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;null or undefined&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Object.prototype.toString.call(obj) 获取对象的类型信息</span></span><br><span class="line">    <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理自定义类的类名</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;[object Object]&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="property">constructor</span> &amp;&amp; obj.<span class="property">constructor</span>.<span class="property">name</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.<span class="property">constructor</span>.<span class="property">name</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果无法获取类名，返回 &#x27;Object&#x27; 作为兜底类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型直接返回类型信息</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="keyword">const</span> myObject = <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="string">&#x27;Example&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> myString = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> myNumber = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myObject)); <span class="comment">// 输出: MyClass</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myArray));  <span class="comment">// 输出: [object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myString)); <span class="comment">// 输出: [object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myNumber)); <span class="comment">// 输出: [object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(myFunction)); <span class="comment">// 输出: [object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(<span class="literal">null</span>)); <span class="comment">// 输出: null or undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTypeOf</span>(<span class="literal">undefined</span>)); <span class="comment">// 输出: null or undefined</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>谢谢你提醒我可以详细一些。下面是对比 JavaScript 中几种判断数据类型的方法的表格形式，包括它们的优点和缺点：</p><div class="table-container"><table><thead><tr><th>判断类型方法</th><th>优点</th><th>缺点</th><th>示例代码</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>- 简单易用，代码简洁。<br>- 对于基本数据类型（如字符串、数字、布尔值、函数、未定义）判断准确。</td><td>- 对于对象、数组和 <code>null</code>，返回的结果不准确。<br>- <code>null</code> 的判断结果是 <code>&quot;object&quot;</code>，这可能导致混淆。<br>- 无法区分复杂数据类型（如数组和对象）。</td><td><img src="https://s2.loli.net/2024/04/18/1HAIVxder26quki.png" alt="image-20240418185016079"></td></tr><tr><td><code>instanceof</code></td><td>- 判断对象是否属于某个类（包括内置的类，如 <code>Array</code>、<code>Date</code>）。<br>- 适用于对象的类继承关系判断。</td><td>- 对于原始数据类型（如字符串、数字等）无效。<br>- 无法区分原始数据类型和其包装对象（例如 <code>String</code> 对象和字符串）。</td><td><img src="https://s2.loli.net/2024/04/18/nVsqZrO1i7PTXko.png" alt="image-20240418185032946"></td></tr><tr><td><code>Object.prototype.toString.call()</code></td><td>- 对各种类型（包括 <code>null</code> 和 <code>undefined</code>）返回明确的类型信息。<br>- 可以准确判断复杂数据类型（如数组、日期、正则表达式等）。</td><td>- 代码较长，不如 <code>typeof</code> 简洁。</td><td><img src="https://s2.loli.net/2024/04/18/q1TWJsSnPHO369X.png" alt="image-20240418185041665"></td></tr><tr><td><code>Array.isArray()</code></td><td>- 专门用于判断数组，判断准确。</td><td>- 只能判断数组类型，无法判断其他类型。</td><td><img src="https://s2.loli.net/2024/04/18/ZuJPcS4lAkLzpDq.png" alt="image-20240418185052865"></td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q20：JQuery的链式调用怎么实现的"><a href="#Q20：JQuery的链式调用怎么实现的" class="headerlink" title="Q20：JQuery的链式调用怎么实现的"></a>Q20：JQuery的链式调用怎么实现的</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 jQuery 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jQuery</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟选择器操作</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">elements</span> = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟设置 CSS 样式的方法</span></span><br><span class="line">    <span class="title function_">css</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">style</span>[property] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟添加 CSS 类的方法</span></span><br><span class="line">    <span class="title function_">addClass</span>(<span class="params">className</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">classList</span>.<span class="title function_">add</span>(className);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟设置元素内容的方法</span></span><br><span class="line">    <span class="title function_">html</span>(<span class="params">content</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">elements</span>) &#123;</span><br><span class="line">            element.<span class="property">innerHTML</span> = content;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 this 对象，实现链式调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 jQuery 对象并进行链式调用</span></span><br><span class="line"><span class="keyword">const</span> $div = <span class="keyword">new</span> <span class="title function_">jQuery</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    .<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)    <span class="comment">// 设置字体颜色为红色</span></span><br><span class="line">    .<span class="title function_">addClass</span>(<span class="string">&#x27;highlight&#x27;</span>)   <span class="comment">// 添加 CSS 类名</span></span><br><span class="line">    .<span class="title function_">html</span>(<span class="string">&#x27;Hello, World!&#x27;</span>);  <span class="comment">// 设置元素内容为 &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($div); <span class="comment">// 输出 jQuery 对象，包含了设置后的元素</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>jQuery 的链式调用是通过在每个 jQuery 方法中返回 jQuery 对象的引用来实现的</p><p>当你调用一个 jQuery 方法时，该方法会修改 jQuery 对象的状态，并返回修改后的 jQuery 对象，从而使得可以连续调用其他 jQuery 方法</p><p>这种链式调用的实现方式可以使得 jQuery 代码更加清晰和易于编写，同时也能够提高代码的可读性和可维护性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q21：怎么检测浏览器的版本"><a href="#Q21：怎么检测浏览器的版本" class="headerlink" title="Q21：怎么检测浏览器的版本"></a>Q21：怎么检测浏览器的版本</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>监测浏览器版本是通过获取用户浏览器的 User Agent 字符串，并解析该字符串来获取浏览器的名称和版本信息</p><p>通常情况下，User Agent 字符串会包含浏览器的相关信息，包括名称、版本号和操作系统等</p><p>以下是一种常见的检测浏览器版本的方法：</p><ol><li>使用 <code>navigator.userAgent</code> 获取用户浏览器的 User Agent 字符串</li><li>根据 User Agent 字符串中是否包含特定浏览器的标识来确定浏览器的类型。常见的浏览器标识包括 <code>&quot;Chrome&quot;</code>、<code>&quot;Firefox&quot;</code>、<code>&quot;Safari&quot;</code>、<code>&quot;Edge&quot;</code>、<code>&quot;MSIE&quot;</code> 等</li><li>通过正则表达式匹配来提取出浏览器的版本信息。通常情况下，浏览器的版本号会跟在浏览器名称后面，并且以斜杠 <code>/</code> 分隔，例如 <code>&quot;Chrome/92.0.4515.159&quot;</code></li><li>根据不同的浏览器类型和版本信息，进行相应的处理或输出</li></ol><p>这种方法是一种基于 User Agent 字符串的检测浏览器版本的常用方法。然而，需要注意的是，User Agent 字符串可以被篡改，因此在实际应用中可能会存在一定的不准确性</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取浏览器的 user agent 字符串</span></span><br><span class="line"><span class="keyword">var</span> userAgent = navigator.<span class="property">userAgent</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义浏览器名称与对应版本匹配的正则表达式</span></span><br><span class="line"><span class="keyword">var</span> browserRegex = &#123;</span><br><span class="line">    <span class="string">&quot;Chrome&quot;</span>: <span class="regexp">/Chrome\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Firefox&quot;</span>: <span class="regexp">/Firefox\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Edge&quot;</span>: <span class="regexp">/Edge\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;Safari&quot;</span>: <span class="regexp">/Version\/(\d+)/</span>,</span><br><span class="line">    <span class="string">&quot;IE&quot;</span>: <span class="regexp">/(?:MSIE |rv:)(\d+)/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测浏览器的版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> browser <span class="keyword">in</span> browserRegex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userAgent.<span class="title function_">indexOf</span>(browser) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> version = userAgent.<span class="title function_">match</span>(browserRegex[browser])[<span class="number">1</span>];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(browser + <span class="string">&quot; 版本：&quot;</span> + version);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 找到匹配的浏览器后立即跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有找到匹配的浏览器，输出提示信息</span></span><br><span class="line"><span class="keyword">if</span> (!version) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;无法检测浏览器版本。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>Feature Detection（特性检测）</strong></p><p>通过检测浏览器是否支持某些特定的 JavaScript 特性或 API 来判断浏览器版本</p><p>不同版本的浏览器可能会实现不同的特性或 API，因此可以根据特性的支持情况来推断浏览器版本</p><p>这种方法不依赖于 User Agent 字符串，更加可靠，但需要了解不同浏览器版本对特性的支持情况</p></li><li><p><strong>嗅探技术（Sniffing）</strong></p><p>通过检测浏览器的行为、属性或功能来确定其类型和版本</p><p>例如，可以检测浏览器的渲染引擎、JavaScript 引擎、CSS 属性支持情况等</p><p>嗅探技术相对复杂，需要针对不同浏览器进行详细的测试和分析，但可以提供更准确的浏览器识别结果</p></li><li><p><strong>服务端检测</strong></p><p>在服务器端进行浏览器检测</p><p>当浏览器向服务器发送请求时，服务器可以通过解析请求的 User Agent 字符串来确定浏览器类型和版本，并返回相应的内容或页面</p><p>这种方法相对可靠，但需要在服务器端进行处理，可能会增加服务器的负载和复杂度</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q22：什么是单点登录，以及如何进行实现"><a href="#Q22：什么是单点登录，以及如何进行实现" class="headerlink" title="Q22：什么是单点登录，以及如何进行实现"></a>Q22：什么是单点登录，以及如何进行实现</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>一、单点登录是什么</strong></p><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p><p>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p><p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p><p><img src="https://s2.loli.net/2024/05/10/chsjAqRGB3Vba4X.png" alt="image-20240510155436715"></p><p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p><p><strong>举个例子</strong></p><p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p><p><strong>二、如何实现</strong></p><p><strong>同域名下的单点登录</strong></p><p><code>cookie</code>的<code>domin</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p><p>利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com</code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p><p><strong>不同域名下的单点登录(一)</strong></p><p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p><p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p><p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p><p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p><p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p><p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p><p><strong>不同域名下的单点登录(二)</strong></p><p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p><p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端</p><p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p><p>关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 token </span></span><br><span class="line"><span class="keyword">var</span> hl-= result.<span class="property">data</span>.<span class="property">token</span>; </span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML </span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>)</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe); </span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&quot;http://app1.com&quot;</span>)</span><br><span class="line"> &#125;, <span class="number">4000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    iframe.<span class="title function_">remove</span>()</span><br><span class="line">&#125;, <span class="number">6000</span>); </span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, event.<span class="property">data</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code> 被多个域所共享</p><p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p><p><strong>三、流程</strong></p><p>单点登录的流程图如下所示：</p><p><img src="https://s2.loli.net/2024/05/10/Bpr7kJf6dl9azPQ.png" alt="image-20240510155953411"></p><ul><li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名密码提交登录申请</li><li>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>sso认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统1</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</li><li>用户访问系统2的受保护资源</li><li>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li><li>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去sso认证中心校验令牌是否有效</li><li>sso认证中心校验令牌，返回有效，注册系统2</li><li>系统2使用该令牌创建与用户的局部会话，返回受保护资源</li></ul><p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p><p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p><p>全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><p><a href="https://zhuanlan.zhihu.com/p/334720992">单点登录参考文章</a></p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              
              </div>
            </details>
<p><br/></p>
<h3 id="Q23：如何判断一个元素是否在可视区域中"><a href="#Q23：如何判断一个元素是否在可视区域中" class="headerlink" title="Q23：如何判断一个元素是否在可视区域中"></a>Q23：如何判断一个元素是否在可视区域中</h3><p>难度：⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>element.getBoundingClientRect()</code></p><p>使用<code>element.getBoundingClientRect()</code>方法，它会返回元素的大小及其相对于视口的位置</p><p>这个方法返回一个DOMRect对象，包含了<code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>, <code>width</code>, <code>height</code>这些值，其中<code>top</code>和<code>left</code>表示元素左上角相对于视口的位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewport</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    rect.<span class="property">top</span> &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.<span class="property">left</span> &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.<span class="property">bottom</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>) &amp;&amp;</span><br><span class="line">    rect.<span class="property">right</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会返回一个布尔值，如果元素完全在视口内部则为<code>true</code>，否则为<code>false</code></p></li><li><p><code>Intersection Observer</code> API</p><p><code>Intersection Observer</code> API提供了一种异步检测目标元素与其祖先元素或顶级文档视窗(<code>viewport</code>)交叉状态变化的方式</p><p>这种方法非常适合用来实现懒加载、无限滚动等功能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过IntersectionObserver构造函数创建一个观察者对象</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果entry.isIntersecting为true，表示元素进入可视区</span></span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素已进入可视区域&#x27;</span>);</span><br><span class="line">      <span class="comment">// 做一些操作，比如加载图片等</span></span><br><span class="line">      <span class="comment">// 完成操作后，可以取消观察</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用observe方法来观察一个元素</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#yourElementId&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q24：什么是防抖和节流，以及如何编码实现"><a href="#Q24：什么是防抖和节流，以及如何编码实现" class="headerlink" title="Q24：什么是防抖和节流，以及如何编码实现"></a>Q24：什么是防抖和节流，以及如何编码实现</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>是什么</strong></p><p>本质上是优化高频率执行代码的一种手段</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p><p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用<code>throttle</code>（节流）和<code>debounce</code>（防抖）的方式来减少调用频率</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性/技术</th><th style="text-align:left">防抖 (Debouncing)</th><th style="text-align:left">节流 (Throttling)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义</strong></td><td style="text-align:left">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</td><td style="text-align:left">在固定时间间隔内只执行一次事件回调。</td></tr><tr><td style="text-align:left"><strong>相同点</strong></td><td style="text-align:left">两者都是性能优化的技术，用于减少事件处理器执行的频率。</td><td style="text-align:left">同左。</td></tr><tr><td style="text-align:left"><strong>不同点</strong></td><td style="text-align:left">防抖关注于延迟执行。一段时间内的多次操作只会执行最后一次。</td><td style="text-align:left">节流关注于定时执行。一段时间内的操作，无论触发多少次，只会定期执行一次。</td></tr><tr><td style="text-align:left"><strong>应用场景</strong></td><td style="text-align:left">- 搜索框搜索输入。（减少请求次数）<br/> - 窗口大小调整（resize）。（避免重绘和重流）<br/> - 表单验证。（停止输入一段时间后进行验证）</td><td style="text-align:left">- 滚动加载，滚动事件的无限加载。（比如滚动到页面底部自动加载内容）<br/> - 轮播图用户快速多次点击箭头按钮。（限制用户点击频率）<br/> - 测量滚动位置。（例如固定时间内只计算一次滚动距离）</td></tr></tbody></table></div><p><img src="https://s2.loli.net/2024/05/10/zolVey45Hrcuh96.png" alt="image-20240510161540382"></p><p><strong>举例：</strong></p><p>每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p><p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p><p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p><p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p><p><strong>代码实现</strong></p><ol><li><p>防抖</p><ul><li><p>立即执行</p><p>事件触发后立即执行，然后n秒内不再执行</p><p>这种实现方式的效果是，事件触发后立即执行，然后在等待的n秒内如果事件又被触发则重新等待n秒</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait);</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非立即执行</p><p>事件触发后不立即执行，等待n秒后执行，如果在这n秒内又触发了事件，则重新开始等待</p><p>这种实现方式的效果是，当事件在n秒内没有再次被触发，才会执行回调函数。即当你滚动滚动条时，滚动结束后n秒再执行，如果滚动过程中又滚动了，那么重新等待n秒</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>节流</p><ul><li><p>时间戳方式</p><p>时间戳方式的节流函数会立即执行第一次触发的事件，然后如果在设定的时间间隔内再次触发事件，这次触发的事件不会被执行</p><p>只有当过了设定的时间间隔后，才会再次执行事件处理函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定时器方式</p><p>定时器方式的节流函数会在第一次触发事件时不立即执行事件处理函数，而是设置一个延时，等待指定的时间间隔后执行。如果在这个延时期间内再次触发了事件，这次触发的事件不会被执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两者结合方式</p><p>有时候，为了同时满足立即执行第一次触发的事件和结束触发时还能执行一次事件处理函数的需求，可以将时间戳方式和定时器方式结合起来使用</p><p>这种方式结合了两者的优点，第一次触发事件会立即执行，之后如果在设定的时间间隔内再次触发事件，则会延迟执行，确保在结束触发后还能再执行一次</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout, context, args, previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> later = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        previous = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q25：Javascript中如何实现函数缓存-函数缓存有哪些应用场景"><a href="#Q25：Javascript中如何实现函数缓存-函数缓存有哪些应用场景" class="headerlink" title="Q25：Javascript中如何实现函数缓存?函数缓存有哪些应用场景"></a>Q25：Javascript中如何实现函数缓存?函数缓存有哪些应用场景</h3><p>难度：⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数缓存，也被称为记忆化（Memoization），是一种优化技术，主要用于存储昂贵函数调用的结果，然后在再次调用同样的输入时直接返回缓存的结果</p><ol><li><p><strong>闭包（Closures）</strong></p><p>使用闭包可以缓存函数的计算结果</p><p>闭包可以访问函数外部的变量，因此可以将函数结果存储在一个变量中，并在下次执行时首先检查该变量</p></li><li><p><strong>映射对象（Map Object）</strong></p><p> <code>Map</code>对象可以存储键值对，并且能记住原始插入顺序</p><p>你可以用传递给函数的参数作为键，把函数返回的结果作为值来进行存储</p></li><li><p><strong>高阶函数（Higher Order Functions）</strong></p><p>可以创建一个高阶函数，它接受一个函数并返回一个新的函数</p><p>这个新函数会检查是否已经缓存了传递给原函数的特定参数的结果</p></li></ol><p><strong>实现代码</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用args作为键创建一个唯一的表示，这里简单地将参数连接为字符串</span></span><br><span class="line">    <span class="keyword">const</span> key = args.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    cache.<span class="title function_">set</span>(key, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的加法函数，后面将使用memoize进行缓存</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用memoize创建一个缓存版本的add函数</span></span><br><span class="line"><span class="keyword">const</span> memoizedAdd = <span class="title function_">memoize</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用会执行计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoizedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3，进行计算，并存入缓存</span></span><br><span class="line"><span class="comment">// 第二次调用时，同样的参数会直接从缓存中获取结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoizedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 结果为3，直接从缓存中获取，不再执行计算</span></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ol><li><p><strong>重复计算</strong></p><p>当函数需要多次重复计算相同参数的结果时，函数缓存可以避免重复工作，只需计算一次然后存储结果即可。</p></li><li><p><strong>昂贵的函数调用</strong></p><p>对于计算成本很高的函数，如涉及复杂算法的函数，使用缓存可以减少执行时间。</p></li><li><p><strong>递归函数</strong></p><p>特别是在处理递归函数时，如计算斐波纳契数列等，缓存结果可以大幅度减少计算量。</p></li><li><p><strong>数据库查询</strong></p><p>在需要频繁进行相同查询的数据库操作中，函数缓存可以存储之前的查询结果，减少数据库的压力。</p></li><li><p><strong>API调用</strong></p><p>如果一个API的数据不会频繁更新，通过缓存API调用结果可以节省网络带宽并提高响应速度。</p></li><li><p><strong>DOM操作的优化</strong></p><p>如果有一个函数根据相同参数总是生成相同的DOM结构，可以通过缓存来优化，避免重复的DOM操作。</p></li><li><p><strong>数据转换</strong></p><p>对于数据格式化或转换操作，如日期格式化，如果转换规则复杂且转换对象重复性高，可以用缓存来提高效率。</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">闭包</th><th style="text-align:left">高阶函数</th><th style="text-align:left">函数柯里化</th></tr></thead><tbody><tr><td style="text-align:left"><strong>定义</strong></td><td style="text-align:left">函数嵌套函数，内部函数访问外部变量</td><td style="text-align:left">一个至少满足以下一个条件的函数：接受一个或多个函数作为参数，或者返回一个函数</td><td style="text-align:left">一个将多参数函数转换为一系列使用一个参数的函数的技术</td></tr><tr><td style="text-align:left"><strong>作用</strong></td><td style="text-align:left">使函数可以访问其定义时的作用域中的变量，即使它在其定义环境外执行</td><td style="text-align:left">抽象或封装行为，可以用函数作为参数或返回新的函数来构建更加模块化的代码</td><td style="text-align:left">分解复杂的函数参数，使得函数变得易于处理，易于复用，并且能够逐步应用函数</td></tr><tr><td style="text-align:left"><strong>状态保持</strong></td><td style="text-align:left">可以记住和访问创建它的函数的局部变量，参数和其他闭包</td><td style="text-align:left">不一定保持任何状态，可以是无状态的，仅用于抽象计算步骤或创建新的函数</td><td style="text-align:left">不直接关注状态，而是关注参数的重组和分配</td></tr><tr><td style="text-align:left"><strong>返回值</strong></td><td style="text-align:left">会返回一个函数，这个函数可以访问创建它时的环境</td><td style="text-align:left">可以返回函数，也可以返回其他任何类型的值</td><td style="text-align:left">返回接收下一个参数的新函数，直到所有参数被”消耗”</td></tr><tr><td style="text-align:left"><strong>参数处理</strong></td><td style="text-align:left">参数在闭包创建时确定，并在闭包的上下文中保持不变</td><td style="text-align:left">参数的处理取决于具体的高阶函数实现，并非固定模式</td><td style="text-align:left">每次调用仅接受一个参数，并返回接受下一个参数的新函数</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">用于创建私有变量和方法，保存状态，实现模块化</td><td style="text-align:left">用于函数抽象和复用，函数组合，以及处理不确定数量的参数</td><td style="text-align:left">用于固定某些参数，简化多参数函数的逆复，以及函数的偏应用</td></tr></tbody></table></div>
              </div>
            </details>
<p><br/></p>
<h3 id="Q26：如何有顺序的执行10个异步任务"><a href="#Q26：如何有顺序的执行10个异步任务" class="headerlink" title="Q26：如何有顺序的执行10个异步任务"></a>Q26：如何有顺序的执行10个异步任务</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><code>Async/Await</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">asyncTask</span>(i); <span class="comment">// 等待当前任务完成</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runTasks</span>(); <span class="comment">// 启动任务</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>await</code> 关键字使得 JavaScript 引擎等待每个 <code>asyncTask</code> 完成之后再继续循环</p></li><li><p><code>Promise 链</code></p><p>通过在每个异步操作上调用 <code>.then()</code> 方法，可以确保它们按顺序执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  promise = promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">asyncTask</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，每个任务都将在前一个任务解决后启动</p></li><li><p>使用递归</p><p>通过递归函数顺序执行异步任务</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Task &#x27;</span> + i);</span><br><span class="line">    <span class="title function_">resolve</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runTasks</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">asyncTask</span>(i).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">runTasks</span>(i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runTasks</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当一个任务完成，它会调用<code>runTasks</code>来启动下一个任务</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q27：javascript里面怎么取消请求"><a href="#Q27：javascript里面怎么取消请求" class="headerlink" title="Q27：javascript里面怎么取消请求"></a>Q27：javascript里面怎么取消请求</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>取消 <code>XMLHttpRequest</code> 请求</p><p>对于 <code>XMLHttpRequest</code> 对象，我们可以使用 <code>abort</code> 方法来取消请求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.example.com/api&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求失败的处理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要取消请求的时候调用</span></span><br><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>在这个例子中，调用 <code>xhr.abort()</code> 会立即终止请求，然后触发 <code>onabort</code> 事件</p><p>加上对 <code>onerror</code> 的监听可以确保所有的异常情况都有对应的处理</p></li><li><p>取消 <code>Fetch</code> 请求</p><p>通过使用 <code>AbortController</code> 和它的 <code>signal</code> 属性，可以取消一个 <code>fetch</code> 请求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://www.example.com/api&#x27;</span>, &#123; signal &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Fetch operation was aborted&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其它错误的处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要取消请求的地方调用</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>在此示例中，创建了一个 <code>AbortController</code> ，并将其 <code>signal</code> 属性传递给 <code>fetch</code> </p><p>要取消请求，在合适的时机调用 <code>controller.abort()</code></p></li><li><p>取消 <code>Axios</code> 请求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://www.example.com/api&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求成功的处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误的处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要取消请求时执行</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>我们创建了一个 <code>AbortController</code> 的实例，并将它的 <code>signal</code> 属性作为配置选项传递给 Axios 的请求方法</p><p>当调用 <code>controller.abort()</code> 方法时，如果请求仍在进行中，它将被取消，并且 <code>catch</code> 块将捕获到一个异常，其中 <code>axios.isCancel(error)</code> 可以检测这个异常是否是因为请求被取消造成的</p><p>您应该确保使用的 Axios 版本支持 <code>AbortController</code></p><p>这个特性自 Axios v0.19.0 起被引入</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q28：如何让-var-a-b-a-1-b-2-解构赋值成功"><a href="#Q28：如何让-var-a-b-a-1-b-2-解构赋值成功" class="headerlink" title="Q28：如何让 var [a, b]={a: 1,b: 2}解构赋值成功"></a>Q28：如何让 var [a, b]={a: 1,b: 2}解构赋值成功</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>在浏览器运行的时候，报错如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a,b] = obj</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/11/D4dKLRzSjyrnNio.png" alt="image-20240511174905915"></p><p>它告诉我们obj这个对象是不可迭代的，只要改成可迭代的，就可以解决这个问题</p><p>要想满足迭代协议需要对象身上有一个名为<code>[Symbol.iterator]</code>的方法</p><p>再使用for..of或者解构赋值的时候会隐式的调用这个方法，得到一个迭代对象，通过迭代对象的next方法判断当前是否完成迭代和具体迭代的值</p><p>也就是说我们要在obj上添加<code>[Symbol.iterator]</code>方法并且完成next方法的逻辑</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">value</span>: obj[keys[index++]]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p><strong>可迭代协议的概念（</strong> <strong>MDN</strong> <strong>）</strong></p><p>可迭代协议是JavaScript中规定的一套标准，它允许对象通过特定的方法定义它们的迭代行为，即规定了对象如何被<code>for...of</code>这样的迭代语句遍历。这个协议主要涉及到两个部分：</p><ol><li><p><strong>迭代器方法 (<code>@@iterator</code>)</strong>:</p><p>对象或其原型链中的某个对象必须有一个名为<code>Symbol.iterator</code>的属性，该属性是一个无参数函数，它返回一个迭代器对象。当对象需要被迭代时，例如在<code>for...of</code>循环中，这个方法会被调用</p></li><li><p><strong>迭代器对象</strong>:</p><p>该对象必须遵守<strong>迭代器协议</strong>，具体来说，需要有一个<code>next()</code>方法，该方法在每次迭代时被调用。每次调用<code>next()</code>方法时，迭代器对象返回另一个称为迭代结果的对象。迭代结果对象必须具有两个属性：</p><ul><li><code>value</code>：迭代的当前值</li><li><code>done</code>：布尔值，如果迭代器已经遍历了迭代对象所有值，则为<code>true</code>；如果迭代还未结束，则为<code>false</code></li></ul></li></ol><p>通过实现这个协议，任何对象都可定制它在迭代时产生值的序列，成为可迭代的</p><p>例如，数组和字符串是可迭代的，因为它们的原型链上都有<code>Symbol.iterator</code>属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>在此示例中，数组<code>arr</code>是内建可迭代对象，它的<code>Symbol.iterator</code>方法返回一个迭代器对象<code>it</code>，我们可以手动调用<code>next()</code>方法来迭代数组</p><p>如果需要让一个自定义对象满足可迭代协议，可以定义如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; keys.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="variable language_">this</span>[keys[index++]], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出：1, 然后 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个普通对象，并给它添加了一个<code>[Symbol.iterator]</code>属性，从而使对象变成可迭代的</p><p>通过这种方式，对象就可以用在任何期待可迭代值的JavaScript语言结构中</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q29：前端的页面截图怎么实现"><a href="#Q29：前端的页面截图怎么实现" class="headerlink" title="Q29：前端的页面截图怎么实现"></a>Q29：前端的页面截图怎么实现</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>Canvas</p><p>最常见的方式是将需要截图的内容绘制到一个<code>&lt;canvas&gt;</code>元素上，然后使用<code>canvas.toDataURL()</code>方法获取图像的DataURL，这是一个Base64编码的字符串表示的图片</p><p>基于此字符串，可以显示图片或者转换成Blob进行下载</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">screenshotDOMElement</span>(<span class="params">element, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 将DOM元素渲染到canvas上的函数</span></span><br><span class="line">  <span class="title function_">html2canvas</span>(element).<span class="title function_">then</span>(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 转换canvas为DataURL</span></span><br><span class="line">    <span class="keyword">var</span> dataURL = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">    <span class="title function_">callback</span>(dataURL);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">screenshotDOMElement</span>(<span class="variable language_">document</span>.<span class="property">body</span>, <span class="keyword">function</span>(<span class="params">dataURL</span>)&#123;</span><br><span class="line">  <span class="comment">// 创建一个Image元素</span></span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = dataURL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将Image元素添加到页面中以显示截图</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(img);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者创建下载链接以下载截图</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  a.<span class="property">href</span> = dataURL;</span><br><span class="line">  a.<span class="property">download</span> = <span class="string">&#x27;screenshot.png&#x27;</span>;</span><br><span class="line">  a.<span class="title function_">click</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要提醒的是，上面的代码使用了<code>html2canvas</code>库，它是一个非常流行的库，可以将HTML转换成Canvas图片</p><p>你需要在你的项目中包含这个库才能使用上述功能</p></li><li><p>浏览器拓展API</p><p>如果你正在开发一个浏览器扩展，你可以利用浏览器提供的API来捕捉当前页面或者页面的部分区域</p><p>例如，在Chrome扩展程序中，可以使用<code>chrome.tabs.captureVisibleTab</code>方法实现截屏</p><p>这通常用于浏览器插件开发，对于普通的前端网页开发并不适用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">captureVisibleTab</span>(<span class="literal">null</span>, &#123;&#125;, <span class="keyword">function</span> (<span class="params">image</span>) &#123;</span><br><span class="line">  <span class="comment">// image是一个base64编码的DataURL</span></span><br><span class="line">  <span class="keyword">var</span> screenshotUrl = image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面你可以将截图DataURL用于不同的目的，例如显示或下载</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用这个API，用户的浏览器必须安装相应的扩展，并且在扩展的权限设置中允许这种截图行为</p></li></ol><p><strong>注意</strong></p><ul><li>如果页面中有跨域内容，使用Canvas进行截图可能会遇到安全限制</li><li>上述方法仅适合静态内容的截图。如果页面有复杂的动态效果或者视频等流媒体内容，可能无法准确捕获</li><li>对于特权环境（如浏览器扩展），可能有额外的API用于截图</li><li>用户隐私应予以考虑，不应在用户不知情或未经允许的情况下进行截图</li></ul>
              </div>
            </details>
<p><br/></p>
<h3 id="Q30：怎么实现虚拟列表"><a href="#Q30：怎么实现虚拟列表" class="headerlink" title="Q30：怎么实现虚拟列表"></a>Q30：怎么实现虚拟列表</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>虚拟列表（Virtual List）或虚拟滚动（Virtual Scrolling）是一种极其有效的前端性能优化技术，专门用于优化长列表数据的渲染性能</p><p>当面对需要渲染成千上万条数据项的列表时，虚拟列表技术通过只渲染当前视口（viewport）内以及少量缓冲区内的列表项，而不是整个列表的数据项，来显著提高页面的渲染效率及性能</p><ol><li><p>核心概念</p><ul><li><p><strong>渲染优化</strong></p><p>虚拟列表通过减少实际渲染的DOM节点数量来降低浏览器的负担，使得即使是数据量极大的列表页也能实现流畅的滚动和交互体验</p></li><li><p><strong>动态渲染</strong></p><p>随着用户滚动，应用程序会根据视口的变化动态地添加或移除列表项，确保在任何时候，DOM中的节点数量保持恒定</p></li></ul></li><li><p>优点与缺点</p><ul><li><p><strong>优点</strong></p><ul><li><p><strong>性能提升</strong></p><p>显著减少了待渲染的DOM元素数量，提高页面渲染性能</p></li><li><p><strong>用户体验增强</strong></p><p>页面滚动流畅，减少了内存的占用，提高了页面响应速度</p></li></ul></li><li><p><strong>缺点</strong></p><ul><li><p><strong>实现复杂度</strong></p><p>动态计算可见项、处理滚动事件等，实现相对较为复杂</p></li><li><p><strong>滚动位置误差</strong></p><p>尤其在列表项高度不一致时，可能会导致滚动位置的计算误差</p></li></ul></li></ul></li><li><p>应用场景</p><ul><li><p><strong>电商网站的商品列表</strong></p><p>展示成千上万的商品信息</p></li><li><p><strong>后台系统的数据表格</strong></p><p>处理大量的数据展示</p></li><li><p><strong>社交媒体信息流</strong></p><p>如新闻、文章列表或社交动态的无限滚动加载</p></li></ul></li></ol><p>虽然可以手动实现虚拟列表，但大多数开发者倾向于使用现成的库来简化开发流程，例如<code>react-window</code>和<code>react-virtualized</code>等库，它们提供了开箱即用的虚拟列表实现方案，大大降低了复杂度</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>实现虚拟列表涉及以下关键步骤与技术：</p><ol><li><p><strong>计算可见区域</strong></p><p>根据视口大小和滚动位置来计算当前应该渲染哪些列表项</p></li><li><p><strong>渲染策略</strong></p><p>仅渲染视口内的数据项，对于非可见区域的数据，通过占位符或者估算高度来确保滚动条正常</p></li><li><p><strong>动态调整</strong></p><p>根据滚动位置动态加载新的列表项并回收离开视口的旧数据项</p></li><li><p><strong>优化技术</strong></p><ul><li><p><strong>虚拟DOM</strong></p><p>降低重绘与回流，提升性能</p></li><li><p><strong>懒加载</strong></p><p>延迟渲染非可见区域的数据，减少网络和资源消耗</p></li><li><p><strong>缓存机制</strong></p><p>缓存已渲染的列表项，提高滚动性能</p></li><li><p><strong>预测加载</strong></p><p>根据用户的滚动行为预测接下来的数据需求，提前加载数据</p></li></ul></li></ol><p><strong>具体实现</strong></p><p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/wutiaowu5t5/VirtualList"><img src="https://github-readme-stats.vercel.app/api/pin/?username=wutiaowu5t5&repo=VirtualList&show_owner=true"/></a></p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q31：如何判断某个字符串长度-要求支持表情"><a href="#Q31：如何判断某个字符串长度-要求支持表情" class="headerlink" title="Q31：如何判断某个字符串长度(要求支持表情)"></a>Q31：如何判断某个字符串长度(要求支持表情)</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>JavaScript 的 <code>length</code> 属性在处理包含四字节 Unicode 字符（例如表情符号）的字符串时可能不会返回预期的结果，原因是 <code>length</code> 属性会将四字节的 Unicode 字符计算为 2 个字符</p><p>所以如果需要准确获得包含表情符号的字符串长度，我们要用到“展开”操作符 (<code>...</code>) 和 <code>Array</code> 对象的 <code>length</code> 属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, World! 😊&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStringLength</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查输入是否为字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;getStringLength error: The input must be a string.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 或者根据你的需要，返回其他方案</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [...str].<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getStringLength</span>(str); <span class="comment">// 返回正确的字符数量，包括表情符号</span></span><br></pre></td></tr></table></figure><p>这段代码会将字符串里的每个字符（包括四字节 Unicode 字符）都单独展开成独立的数组元素，然后使用 <code>length</code> 属性统计元素的数量，避免了四字节字符被错误地计为2个字符的问题</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q32：如何判断页面是通过PC端还是移动端访问"><a href="#Q32：如何判断页面是通过PC端还是移动端访问" class="headerlink" title="Q32：如何判断页面是通过PC端还是移动端访问"></a>Q32：如何判断页面是通过PC端还是移动端访问</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong><code>navigator.userAgent</code></strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectDevice</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> userAgent = navigator.<span class="property">userAgent</span>;</span><br><span class="line">  <span class="keyword">if</span> (userAgent.<span class="title function_">match</span>(<span class="regexp">/Android/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/webOS/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPhone/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPad/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/iPod/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/BlackBerry/i</span>)</span><br><span class="line">    || userAgent.<span class="title function_">match</span>(<span class="regexp">/Windows Phone/i</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Mobile Device&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Desktop Device&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">detectDevice</span>());</span><br></pre></td></tr></table></figure><p>这个 <code>detectDevice()</code> 函数在执行时会检查<code>navigator.userAgent</code>是否包含特定的移动设备标识符</p><p>如果匹配到这些设备标识符中的任何一个，该函数将返回 <code>&#39;Mobile Device&#39;</code></p><p>否则，该函数将返回 <code>&#39;Desktop Device&#39;</code></p><p>这个方法并不是<code>100%</code>准确的，因为用户代理字符串可以被浏览器设置项或恶意用户修改</p><p>然而，这仍然是一个大多数情况下有效的方法，用于判断访问者使用的是桌面还是移动设备</p></li><li><p><strong>使用CSS媒体查询</strong></p><p>通过CSS媒体查询判断窗口的大小，从而对移动设备和桌面设备采取不同的样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line"> <span class="comment">/* 在这里放置移动端的CSS */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查屏幕宽度</strong></p><p>移动设备通常支持触摸事件，而桌面则依赖于鼠标事件，所以你可以侦测页面是否可以进行触摸事件来判定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt;= <span class="number">768</span>) &#123;</span><br><span class="line"> <span class="comment">// 移动端执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 桌面端执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>触摸事件检测</strong></p><p>移动设备通常支持触摸事件，而桌面则依赖于鼠标事件，所以可以侦测页面是否可以进行触摸事件来判定</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isTouchDevice</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         (<span class="string">&#x27;ontouchstart&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) </span><br><span class="line">         || (navigator.<span class="property">MaxTouchPoints</span> &gt; <span class="number">0</span>)</span><br><span class="line">         || (navigator.<span class="property">msMaxTouchPoints</span> &gt; <span class="number">0</span>)</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用库或框架</strong></p><p>现成的库，如Modernizr、WURFL.js等，可以帮助你检测设备的类型</p></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q33：实现一个数字转中文的方法"><a href="#Q33：实现一个数字转中文的方法" class="headerlink" title="Q33：实现一个数字转中文的方法"></a>Q33：实现一个数字转中文的方法</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>函数目标与输入检验</p><p>这个函数的主要目标是将数字转换为汉字表示的形式</p><p>它不仅包括正负整数的转换，也支持处理小数部分以及检查输入数字是否在特定的区间内</p><p>最开始的几行代码用于验证输入是否为合法的数字，并确定输入数字是否在函数处理的范围内（本例中为-1亿到1亿）</p><p>javascript</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="string">&#x27;输入不是一个有效的数字&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MIN_NUM</span> = -<span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_NUM</span> = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="variable constant_">MIN_NUM</span> || num &gt; <span class="variable constant_">MAX_NUM</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`数字必须在<span class="subst">$&#123;MIN_NUM&#125;</span>到<span class="subst">$&#123;MAX_NUM&#125;</span>之间`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负数处理</strong></p><p>接下来，函数检查数字是否为负</p><p>如果是负数，它会标记一个负数标志为<code>true</code>并将数字转换为正数以便后续处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> negative = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    negative = <span class="literal">true</span>;</span><br><span class="line">    num = -num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整数部分转换</strong></p><p>函数中的<code>getIntegerChn</code>辅助函数负责将数字的整数部分转换成汉字</p><p>这一过程通过递归地处理数字的每四位（即在中文中的“万”与“亿”单位间的分割点）来完成</p><p>它首先将数字分解成小于10000的块，并为每个块生成对应的中文表示，然后根据其在原数中的位置添加适当的单位（如“万”、“亿”等）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getIntegerChn</span> = (<span class="params">intNum</span>) =&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>小数部分转换</strong></p><p>如果数字有小数点，<code>getDecimalChn</code>函数负责将小数点后的每位数字转换为相应的汉字，并在前面加上“点”字以区分整数和小数部分</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getDecimalChn</span> = (<span class="params">str</span>) =&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p><strong>负数的最终表示</strong></p><p>在整数和小数部分都转换完成后，如果最初标记的负数标志为<code>true</code>，则在最终的中文字符串前加上“负”字</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertToChinese</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) <span class="keyword">return</span> <span class="string">&#x27;输入不是一个有效的数字&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义转换的区间</span></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MIN_NUM</span> = -<span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MAX_NUM</span> = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查数字是否在允许的区间内</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="variable constant_">MIN_NUM</span> || num &gt; <span class="variable constant_">MAX_NUM</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`数字必须在<span class="subst">$&#123;MIN_NUM&#125;</span>到<span class="subst">$&#123;MAX_NUM&#125;</span>之间`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> numMap = [<span class="string">&#x27;零&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;七&#x27;</span>, <span class="string">&#x27;八&#x27;</span>, <span class="string">&#x27;九&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> unitMap = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;万&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;亿&#x27;</span>, <span class="string">&#x27;十&#x27;</span>, <span class="string">&#x27;百&#x27;</span>, <span class="string">&#x27;千&#x27;</span>, <span class="string">&#x27;万亿&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> negative = <span class="literal">false</span>; <span class="comment">// 标记是否为负数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        negative = <span class="literal">true</span>;</span><br><span class="line">        num = -num; <span class="comment">// 将负数转为正数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换整数部分</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getIntegerChn</span> = (<span class="params">intNum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(intNum === <span class="number">0</span>) <span class="keyword">return</span> numMap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> chnStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> zero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (intNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> section = intNum % <span class="number">10000</span>;</span><br><span class="line">            <span class="keyword">if</span> (zero) chnStr = numMap[<span class="number">0</span>] + chnStr;</span><br><span class="line">            <span class="keyword">let</span> strIns = <span class="title function_">sectionToChinese</span>(section);</span><br><span class="line">            strIns += (section !== <span class="number">0</span>) ? unitMap[count] : unitMap[<span class="number">0</span>];</span><br><span class="line">            chnStr = strIns + chnStr;</span><br><span class="line">            zero = section &lt; <span class="number">1000</span> &amp;&amp; section &gt; <span class="number">0</span>;</span><br><span class="line">            intNum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(intNum / <span class="number">10000</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chnStr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换小数部分</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getDecimalChn</span> = (<span class="params">str</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> decimalStr = <span class="string">&#x27;点&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            decimalStr += numMap[+char];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> decimalStr;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> [integerPart, decimalPart] = num.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> chineseStr = <span class="title function_">getIntegerChn</span>(<span class="built_in">parseInt</span>(integerPart));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decimalPart) &#123;</span><br><span class="line">        chineseStr += <span class="title function_">getDecimalChn</span>(decimalPart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">        chineseStr = <span class="string">&#x27;负&#x27;</span> + chineseStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chineseStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convertToChinese</span>(-<span class="number">12345.678</span>)); <span class="comment">// 返回 &quot;负一万二千三百四十五点六七八&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">convertToChinese</span>(<span class="number">1000000000</span>)); <span class="comment">// 返回 &quot;数字必须在-100000000到100000000之间&quot;</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q34：用js实现二叉树的定义和基本操作（待完善）"><a href="#Q34：用js实现二叉树的定义和基本操作（待完善）" class="headerlink" title="Q34：用js实现二叉树的定义和基本操作（待完善）"></a>Q34：用js实现二叉树的定义和基本操作（待完善）</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>二叉树是一种特殊的树形数据结构，其中每个节点最多有两个子节点，通常被称为左子节点和右子节点</p><p>按定义，二叉树是空的（即，没有节点）或者由一个根节点和两棵互不相交的、被分别称为左子树和右子树的二叉树组成</p><p>详细地说，二叉树的每个节点包含以下部分：</p><ul><li>数据元素：包含节点值或者其他相关信息的部分</li><li>左指针：指向左子节点的指针。如果没有左子节点，该指针指向空或者NULL</li><li>右指针：指向右子节点的指针。如果没有右子节点，该指针指向空或者NULL</li></ul><p>二叉树有许多变体，如二叉搜索树、AVL树（自平衡二叉搜索树）、堆（一种特殊的完全二叉树）和红黑树等</p><p>其中，二叉搜索树是最常用的一种，它的特点是任意节点的值都大于或等于其左子树中存储的值，并且小于或等于其右子树中存储的值</p><p>二叉树的优势在于其查找、插入、删除的平均和最佳时间复杂度可以达到O(log n)（其中n代表树中节点的数量），这归功于二叉树数据结构的特性使查找路径大大缩短</p><p>但是，为了保持树的平衡（即保持左右两边节点数量均衡，避免退化为链），可能需要进行一些额外操作</p><p>二叉树可被用来实现二叉搜索树、表达式解析树、堆和B+树（一种用于数据库和文件系统的数据结构）等等</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q35：查找岛屿数量"><a href="#Q35：查找岛屿数量" class="headerlink" title="Q35：查找岛屿数量"></a>Q35：查找岛屿数量</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span></span><br><span class="line"><span class="comment">// 2、岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span></span><br><span class="line"><span class="comment">// 3、此外，你可以假设该网格的四条边均被水包围。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 返回结果 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示</span></span><br><span class="line">m == grid.<span class="property">length</span></span><br><span class="line">n == grid[i].<span class="property">length</span></span><br><span class="line"><span class="number">1</span> &lt;= m, n &lt;= <span class="number">300</span></span><br><span class="line">grid[i][j] 的值为 <span class="string">&#x27;0&#x27;</span> 或 <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在计算二维网格中岛屿的数量问题中，主要有两种搜索方法来遍历岛屿：</p><ol><li><p><strong>深度优先搜索（DFS, Depth-First Search）</strong><br>深度优先搜索是以垂直的方式进行探索。它从一个节点开始，尽可能深地搜索每一个分支，直到到达底部，然后回溯并探索下一条分支</p><p>在岛屿数量的问题中，DFS可以从任一未访问过的陆地出发，尽可能探索与之相连的所有陆地，然后将其标记为已访问</p><p>DFS通过递归或栈实现</p></li><li><p><strong>广度优先搜索（BFS, Breadth-First Search）</strong><br>广度优先搜索是以水平的方式进行探索</p><p>它从一个节点开始，首先访问所有邻近的节点，即先宽后深地探索每一层</p><p>在岛屿数量的问题中，BFS可以从任一未访问过的陆地出发，一层一层地探索所有相邻的陆地，并将其标记为已访问</p><p>BFS通常用队列来实现</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p>使用递归的方式进行<strong>深度优先搜索</strong></p><p>每当我们遇到”1”（即陆地）时，我们将尝试访问它的所有相邻的”1”（即未访问过的陆地），并将它们标记为已访问，以此来识别一个完整的岛屿</p><p>完成对一个岛屿的探索后，我们继续搜索下一个未被访问的”1”</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="comment">// 辅助函数用于执行深度优先搜索</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查越界情况以及是否是水域或已访问过的陆地</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">length</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前位置标记为已访问</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 通过将1修改为0来标记已访问</span></span><br><span class="line">        <span class="comment">// 访问四个方向的相邻陆地</span></span><br><span class="line">        <span class="title function_">dfs</span>(i+<span class="number">1</span>, j); <span class="comment">// 下</span></span><br><span class="line">        <span class="title function_">dfs</span>(i-<span class="number">1</span>, j); <span class="comment">// 上</span></span><br><span class="line">        <span class="title function_">dfs</span>(i, j+<span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="title function_">dfs</span>(i, j-<span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!grid || !grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 计数器，用于统计岛屿数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123; <span class="comment">// 发现未访问的陆地，启动深度优先搜索</span></span><br><span class="line">                <span class="title function_">dfs</span>(i, j);</span><br><span class="line">                count++; <span class="comment">// 完成一个岛屿的搜索，岛屿数量加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid1)); <span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid2)); <span class="comment">// 返回结果 3</span></span><br></pre></td></tr></table></figure><p>这段代码首先定义了一个<code>dfs</code>函数，用于实现深度优先搜索并标记已访问的陆地</p><p>然后，我们遍历整个网格，每次遇到”1”（未访问过的陆地）时，使用<code>dfs</code>函数搜索整个岛屿，并通过将”1”标记为”0”来标记已访问的陆地</p><p>遍历过程中每完成对一个岛屿的探索，就将岛屿数量加一</p></li><li><p>使用<strong>广度优先搜索（BFS）</strong></p><p>我们通常会用队列来追踪需要探索的陆地</p><p>从遇到初始的一个“1”开始，我们将其添加到队列中，然后按层序遍历相邻的格子，将遇到的所有“1”都置为“0”以防重复计数，直到队列为空</p><p>这样，每完成一轮循环，就能识别并计数一个岛屿</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!grid || !grid.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dirs = [[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]; <span class="comment">// 上下左右移动的方向</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++; <span class="comment">// 找到一个岛屿，岛屿数量加1</span></span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">                <span class="keyword">const</span> queue = [[i, j]]; <span class="comment">// 使用数组模拟队列，存储岛屿中的陆地坐标</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> [x, y] = queue.<span class="title function_">shift</span>(); <span class="comment">// 从队列中取出一个陆地坐标</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检查此陆地的所有相邻陆地</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> [dx, dy] <span class="keyword">of</span> dirs) &#123;</span><br><span class="line">                        <span class="keyword">const</span> nx = x + dx, ny = y + dy;</span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; cols &amp;&amp; grid[nx][ny] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            grid[nx][ny] = <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">                            queue.<span class="title function_">push</span>([nx, ny]); <span class="comment">// 相邻的陆地入队</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">const</span> grid1 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid1)); <span class="comment">// 返回结果 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">const</span> grid2 = [</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numIslands</span>(grid2)); <span class="comment">// 返回结果 3</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>dirs</code>数组定义了可以移动的方向，即上下左右</p><p>每次发现一个“1”后，都开始一个新的BFS过程：首先将其标记为“0”，然后将它的坐标加入队列中</p><p>在队列不为空的情况下循环，每次从队列中取出一个坐标，再将其相邻的未标记的陆地坐标入队，同时将这些陆地标记为“0”以表示已访问</p></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>时间复杂度和空间复杂度是用来评估算法效率的两个标准。想象一下，你在厨房做饭：</p><ol><li><p><strong>时间复杂度</strong></p><p>就像是完成菜肴所需要的总时间</p><p>简单的菜，比如煮鸡蛋，可能只需要几分钟</p><p>但如果是做一个复杂的烤鸡大餐，可能需要几个小时</p><p>在计算机的世界里，时间复杂度帮助我们了解一个程序运行完成需要多长时间</p><p><strong>评估标准</strong></p><ul><li><p><strong>确定算法的基本操作</strong></p><p>识别算法中执行最频繁的操作</p><p>比如在排序算法中，基本操作可能是比较或交换元素</p></li><li><p><strong>分析操作的数量</strong></p><p>计算输入数据大小为n时，基本操作执行了多少次</p><p>假设操作数量为<code>f(n)</code></p></li><li><p><strong>考虑最坏情况</strong></p><p>通常我们评估算法的时间复杂度时，考虑的是最坏的情况</p><p>即对于给定大小的输入，算法所需时间的最大值</p></li><li><p><strong>简化表达式</strong></p><p>在<code>f(n)</code>中去掉常数项和低阶项，保留最高阶项，并注意它前面的系数也不重要</p><p>因为时间复杂度关注的是随着输入规模n的增长，算法所需时间的变化趋势</p></li><li><p><strong>使用大O符号</strong></p><p>得到简化后的表达式并采用大O符号来描述算法的时间复杂度</p><p>例如，如果操作数量<code>f(n)</code>可被简化为<code>2n^2 + 3n + 5</code>，则算法的时间复杂度是<code>O(n^2)</code></p></li></ul></li><li><p><strong>空间复杂度</strong></p><p>则像是你在做饭时占用的厨房空间大小</p><p>如果你只是煮个鸡蛋，可能只需要一个小锅</p><p>但如果是准备一个大餐，你可能需要整个厨房的空间</p><p>在计算机中，空间复杂度告诉我们运行一个程序需要多少内存空间</p><p><strong>评估标准</strong></p><ul><li><p><strong>考虑所有内存使用</strong></p><p>算法可能使用内存来存储各种变量、数组、来自外部输入的数据和递归栈</p></li><li><p><strong>区分临时和持久空间使用</strong></p><p>有些内存使用在算法执行完后就不再需要了，这是临时内存使用</p><p>有些可能是算法的输出，或者是算法运行过程中必须长期保留的，这是持久内存使用</p></li><li><p><strong>计算所有部件的总空间</strong></p><p>评估由输入大小n导致的总内存使用情况</p><p>这通常包括输入数据结构的大小，加上算法内部额外创建的数据结构大小</p></li><li><p><strong>简化表达式</strong></p><p>和时间复杂度一样，去掉表达式中的常量项和低阶项，只保留最高阶项</p></li><li><p><strong>使用大O符号</strong></p><p>最后，使用大O符号来描述空间复杂度</p><p>例如，如果一个算法只需要一个大小与输入大小n成比例的数组，那么空间复杂度就是<code>O(n)</code></p></li></ul></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q36：计算背包"><a href="#Q36：计算背包" class="headerlink" title="Q36：计算背包"></a>Q36：计算背包</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有 N 件物品和一个容量是 V 的背包。每件物品有且只有一件。</span></span><br><span class="line"><span class="comment">// 第 i 件物品的体积是 v[i] ，价值是 w[i] 。</span></span><br><span class="line"><span class="comment">// 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1：</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], w = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 输出: 4</span></span><br><span class="line"><span class="comment">// 解释: 只选第一件物品，可使价值最大。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：</span></span><br><span class="line"><span class="comment">// 输入: </span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], w = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 输出: 5</span></span><br><span class="line"><span class="comment">// 解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>解决这类背包问题，有几种不同的方法，通常包括动态规划、回溯、贪心算法等。下面我将概述几种常用的解决方法：</p><ol><li><p><strong>动态规划（DP）</strong></p><p>动态规划是解决背包问题最经典也是最有效的方法之一</p><p>它主要有两种方式：<strong>0-1背包</strong>和<strong>完全背包</strong></p><p>对于你的问题，我们使用0-1背包的思路，因为每件物品只能选择一次</p><ul><li><p><strong>0-1背包问题</strong></p><p>可以用二维数组<code>dp</code>表示，其中<code>dp[i][j]</code>表示从前<code>i</code>个物品中挑选，总体积不超过<code>j</code>的条件下的最大价值</p><p>状态转移方程为：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])</code></p></li></ul><p>这种方法的时间复杂度和空间复杂度均为O(NV)，N是物品数量，V是背包容量</p></li><li><p><strong>动态规划（空间优化）</strong></p><p>基于上面的动态规划方法，可以对其进行空间优化，将二维数组压缩为一维数组。优化后，使用单个数组<code>dp[j]</code>表示总体积不超过<code>j</code>的条件下的最大价值，状态转移方程变为：<code>dp[j] = max(dp[j], dp[j-v[i]] + w[i])</code>。</p><p>空间复杂度降低为O(V)。</p></li><li><p><strong>贪心算法</strong></p><p>贪心算法是另一种思路，它不总能得到最优解，但在某些情况下计算效率较高</p><p>对于物品选择问题，一个简单的贪心策略可能是按价值密度（价值除以体积）降序排列物品，然后尽量选择价值密度高的物品装入背包，直到装不下为止</p></li><li><p><strong>分支限界法</strong></p><p>分支限界法是基于队列的宽度优先搜索，它使用“分支”来探索可行的解空间，并使用“限界”来剪枝，不继续探索那些无法得到最优解的分支</p><p>这种方法适用于更复杂的背包问题或需要精确解的场景</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>0-1背包写法</strong></p><p>实现0-1背包问题的动态规划算法，你需要构建一个二维数组用来保存每个状态下的最大价值</p><p>在实现过程中，我们创建了一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>代表考虑前<code>i</code>个物品，当背包容量限制为<code>j</code>时我们能够装进背包的最大价值</p><p>通过填充这个二维数组，我们可以找到最后的解</p><p>在结束时，<code>dp[N][V]</code>就代表了所有物品在不超过背包容量<code>V</code>的条件下能达到的最大总价值</p><p>注意在真实应用中，为了节省空间，你也可以将这个二维数组压缩到一维数组</p><p>这样的优化需要你在更新<code>dp[j]</code>的时候从后往前更新，这样可以保证状态转移使用的是上个物品的数据</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">knapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">  <span class="comment">// dp是一个二维数组，dp[i][j]表示前i个物品，在不超过j的体积下的最大价值</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: N + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前物品体积大于当前背包容量，不能加入当前物品</span></span><br><span class="line">      <span class="keyword">if</span> (v[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 状态转移方程</span></span><br><span class="line">        dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - v[i - <span class="number">1</span>]] + w[i - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大价值在dp[N][V]中</span></span><br><span class="line">  <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">knapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">knapsack</span>(N, V, v, w)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>完全背包</strong></p><p>完全背包问题的关键区别在于每种物品可以选取无限次</p><p>在JavaScript中，这种问题的动态规划解法与0-1背包问题类似，但是在更新<code>dp</code>数组的时候，内部循环会有所不同，因为你需要考虑重复选择某一物品的情况</p><p>这段代码的处理方式与0-1背包问题的主要差异在于内层循环<code>j</code>的方向</p><p>在完全背包问题中，当你在计算<code>dp[j]</code>时，因为每种类型的物品可以使用多次，所以可以从左到右遍历，并且用自身的先前计算的值来更新后面的值</p><p>这种处理方式意味着在计算<code>dp[j]</code>时，可以重复考虑物品<code>i</code>，而这在0-1背包问题中不被允许</p><p>注意，这里的代码为了简洁明了，省略了物品数量的限制，也就是说，默认情况下每种物品可以无限使用。如果物品有数量限制，解法将不同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeKnapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化dp数组，dp[j]代表容量为j的背包能达到的最大值</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="comment">// 注意：此循环与0-1背包问题相反，我们从小到大遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = v[i]; j &lt;= V; j++) &#123;</span><br><span class="line">      <span class="comment">// 更新dp[j]，选择当前物品i或者不选择，取二者的最大值</span></span><br><span class="line">      dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回容量为V的背包的最大价值</span></span><br><span class="line">  <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="comment">// 解释: 选择第二件物品两次</span></span><br></pre></td></tr></table></figure></li><li><p><strong>空间优化写法</strong></p><p>空间优化版本的完全背包问题可以将二维的dp数组压缩为一维数组</p><p>空间复杂度从O(NV)降为O(V)</p><p>空间优化的关键在于对dp数组定义的更改</p><p>在原始方法中，dp是一个二维数组，表示考虑前i个物品在不超过j的体积上的最大价值</p><p>优化后，我们在更新dp[j]时，不再需要考虑“前i个物品”这个维度，只需要考虑“不超过j的体积上的最大价值”，因为我们已经在内层循环中涵盖了所有的物品</p><p>这种优化极大地节省了空间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">completeKnapsack</span>(<span class="params">N, V, v, w</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化状态数组，dp[v]代表容量为v的背包能装载物品的最大总价值</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(V + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 从小到大遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = v[i]; j &lt;= V; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移方程，取最大值</span></span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大背包价值存储在dp[V]</span></span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1:</span></span><br><span class="line"><span class="keyword">let</span> N = <span class="number">3</span>, V = <span class="number">4</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2:</span></span><br><span class="line">N = <span class="number">3</span>, V = <span class="number">5</span>, v = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], w = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">completeKnapsack</span>(N, V, v, w)); <span class="comment">// 输出: 6，解释：选择第二件物品两次</span></span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>
<p><br/></p>
<h3 id="Q37：全排列"><a href="#Q37：全排列" class="headerlink" title="Q37：全排列"></a>Q37：全排列</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 1：</span></span><br><span class="line"><span class="comment">// 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2：</span></span><br><span class="line"><span class="comment">// 输入：nums = [0,1]</span></span><br><span class="line"><span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3：</span></span><br><span class="line"><span class="comment">// 输入：nums = [1]</span></span><br><span class="line"><span class="comment">// 输出：[[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示：</span></span><br><span class="line"><span class="comment">// 1 &lt;= nums.length &lt;= 6</span></span><br><span class="line"><span class="comment">// -10 &lt;= nums[i] &lt;= 10</span></span><br><span class="line"><span class="comment">// nums 中的所有整数 互不相同</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>解决这个问题的关键是采用回溯法</p><p>回溯法是一个通过探索所有可能的候选解来找出所有解的策略</p><p>如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃它，并且递归地尝试另一个候选解</p><p>对于全排列问题，我们可以将问题视为一个树形结构，每一层选择一个不在当前排列中的数字</p><p>当我们达到树的底部时，就找到了一个排列，并且回退到上一步，尝试下一个数字</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这段代码通过递归函数<code>backtrack</code>遍历所有可能的排列情况</p><p>对于每个位置，它都会尝试数组<code>nums</code>中的每一个数字，如果这个数字还没有被使用过（也就是说，它还没有在<code>path</code>中），就将它添加到当前排列(<code>path</code>)中，并继续递归处理下一个位置</p><p>当达到一个完整排列时（也就是<code>path</code>的长度与<code>nums</code>的长度相等），就将其加入到结果<code>result</code>中</p><p>在处理完一个位置所有可能的数字之后，需要进行回溯（通过<code>path.pop()</code>），也就是撤销上一步的选择，尝试其他选择</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// 结果列表</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="comment">// 路径列表，用来保存当前的排列组合</span></span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">nums, path</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前排列长度等于原始数组长度时，记录当前排列</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(path));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 跳过已经选择的数字</span></span><br><span class="line">      <span class="keyword">if</span> (path.<span class="title function_">includes</span>(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 选择当前数字</span></span><br><span class="line">      path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">      <span class="comment">// 进入下一层决策树</span></span><br><span class="line">      <span class="title function_">backtrack</span>(nums, path);</span><br><span class="line">      <span class="comment">// 取消选择当前数字，回退到之前的状态</span></span><br><span class="line">      path.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从空路径开始进行回溯</span></span><br><span class="line">  <span class="title function_">backtrack</span>(nums, path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">0</span>, <span class="number">1</span>]));    <span class="comment">// 输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">permute</span>([<span class="number">1</span>]));       <span class="comment">// 输出：[[1]]</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q38：写一个LRU缓存函数"><a href="#Q38：写一个LRU缓存函数" class="headerlink" title="Q38：写一个LRU缓存函数"></a>Q38：写一个LRU缓存函数</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>LRU缓存，即最近最少使用（Least Recently Used）缓存算法，是一种常用的页面置换算法，选择最近最久未使用的数据进行淘汰</p><p>这个算法的主要目的是为了保持最常用的数据在缓存中，而不经常使用的数据会被移出缓存</p><p>实现LRU缓存机制的分析过程通常包括以下步骤：</p><ol><li><p><strong>确定数据结构</strong></p><p>一个高效的LRU缓存通常需要使用两种数据结构，一种是用于保持插入顺序的链表（比如双向链表），另一种是用于O(1)时间复杂度查找的哈希表</p></li><li><p><strong>实现插入操作</strong></p><p>插入新元素时，我们需要将元素插入到链表的头部</p><p>如果缓存已经达到最大容量，我们则移除链表尾部的元素，因为尾部元素是最近最少使用的</p><p>同时，需要在哈希表中添加该元素的键和指向链表中元素的指针</p></li><li><p><strong>实现访问操作</strong></p><p>访问元素时，如果元素在缓存中，则需要将其移动到链表的头部，表示它最近被使用过</p><p>这也意味着链表的尾部始终表示最久未使用的元素</p></li><li><p><strong>同步操作</strong></p><p>插入和访问操作都需要及时在哈希表和链表之间进行同步，确保两者的数据是一致的</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    #map;</span><br><span class="line">    #capacity;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#capacity = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.#map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.#map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.#map.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="comment">// 如果key存在，首先删除旧的位置，然后将其重新设置到Map的末尾，代表最近使用过</span></span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">set</span>(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.#map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.#map.<span class="property">size</span> === <span class="variable language_">this</span>.#capacity) &#123;</span><br><span class="line">            <span class="comment">// 当缓存达到上限时，删除最近最少使用的元素</span></span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.#map.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.#map.<span class="title function_">set</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个方法来修改缓存的容量</span></span><br><span class="line">    <span class="title function_">setCapacity</span>(<span class="params">newCapacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.#capacity = newCapacity;</span><br><span class="line">        <span class="comment">// 如果新容量小于当前map的大小，需要删除最久未使用的项直到大小符合新容量</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.#map.<span class="property">size</span> &gt; <span class="variable language_">this</span>.#capacity) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.#map.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>;</span><br><span class="line">            <span class="variable language_">this</span>.#map.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以提供一些其他的方法来满足不同的需求，例如获取当前缓存容量</span></span><br><span class="line">    <span class="title function_">getCapacity</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前缓存中元素的数量</span></span><br><span class="line">    <span class="title function_">getSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#map.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例:</span></span><br><span class="line"><span class="keyword">const</span> lruCache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">1</span>));   <span class="comment">// 返回  1</span></span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 移除 key 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">2</span>));   <span class="comment">// 返回  -1 (未找到)</span></span><br><span class="line">lruCache.<span class="title function_">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 移除 key 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">1</span>));   <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">3</span>));   <span class="comment">// 返回  3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lruCache.<span class="title function_">get</span>(<span class="number">4</span>));   <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q39：大文件怎么实现断点续传"><a href="#Q39：大文件怎么实现断点续传" class="headerlink" title="Q39：大文件怎么实现断点续传"></a>Q39：大文件怎么实现断点续传</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>Step 1: 切割文件</strong></p><p>利用JavaScript中的<code>Blob</code>对象的<code>slice</code>方法来切割大文件成为多个小块（即文件片段或file chunks）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file, chunkSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> chunks = [];</span><br><span class="line">  <span class="keyword">const</span> size = file.<span class="property">size</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> start = <span class="number">0</span>; start &lt; size; start += chunkSize) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(start, <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, size));</span><br><span class="line">    chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 2: 上传文件切片</strong></p><p>上传每个文件切片之前，需要检查服务器上已经上传了哪些切片</p><p>通过<code>fetch</code>或<code>axios</code>等HTTP客户端进行异步上传，并在请求中发送额外信息，如切片序号、文件唯一标识符等</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadChunks</span>(<span class="params">chunks, fileId</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;chunk&#x27;</span>, chunks[i]);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;fileId&#x27;</span>, fileId);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;index&#x27;</span>, i);</span><br><span class="line">    <span class="comment">// 发送请求到后端</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/upload&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: formData &#125;);</span><br><span class="line">    <span class="comment">// 保存上传进度，用于续传</span></span><br><span class="line">    <span class="title function_">saveProgress</span>(fileId, i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 3: 保存上传进度</strong></p><p>利用<code>localStorage</code>或其他持久化方法来记录上传的进度，这样在网络断开后可以从中断点继续上传</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">saveProgress</span>(<span class="params">fileId, chunkIndex</span>) &#123;</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(fileId, chunkIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 4: 断点续传</strong></p><p>在上传之前，先向服务器查询文件上传的进度或已上传的切片，从而决定从哪个切片开始上传</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">continueUploading</span>(<span class="params">file, fileId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="comment">/* 您设置的切片大小 */</span>;</span><br><span class="line">  <span class="keyword">const</span> chunks = <span class="title function_">sliceFile</span>(file, chunkSize);</span><br><span class="line">  <span class="keyword">const</span> uploadedChunks = <span class="keyword">await</span> <span class="title function_">fetchUploadedChunks</span>(fileId);</span><br><span class="line">  <span class="keyword">const</span> remainingChunks = chunks.<span class="title function_">slice</span>(uploadedChunks);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">uploadChunks</span>(remainingChunks, fileId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Step 5: 后端合并切片</strong></p><p>在服务器端，当所有切片上传完成后，需要将这些切片合并成原始的文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js 示例</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeChunks</span>(<span class="params">chunks, dest</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wStream = fs.<span class="title function_">createWriteStream</span>(dest);</span><br><span class="line"></span><br><span class="line">  chunks.<span class="title function_">forEach</span>(<span class="function"><span class="params">chunkPath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(chunkPath);</span><br><span class="line">    wStream.<span class="title function_">write</span>(data);</span><br><span class="line">    fs.<span class="title function_">unlinkSync</span>(chunkPath); <span class="comment">// 删除已合并的切片</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  wStream.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些是客户端实现大文件断点续传的基本步骤</p><p>实际实现时，你还需要处理异常情况，比如网络错误重试、权限校验、加密等安全措施、以及后端接收切片的API设计等</p>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>大文件断点续传是网络传输中的一个术语，指的是在上传或下载大文件时，如果传输中断，则下次可以从中断的地方继续传输，而不是重新开始</p><p>底层实现通常依靠的是HTTP协议的范围请求（Range Requests）</p><p><strong>工作原理简述：</strong></p><ol><li><p><strong>切片</strong></p><p>将整个文件切分成多个小块，每一小块可以单独传输</p></li><li><p><strong>传输记录</strong></p><p>记录每个小块的传输进度，成功或失败</p></li><li><p><strong>中断和恢复</strong></p><p>如果传输中断（比如网络问题、程序关闭等），下次传输可以根据已有的记录，直接从上次中断的小块开始传输</p></li><li><p><strong>文件重组</strong></p><p>当所有的小块都传输完成后，将这些小块重组成原始的大文件</p></li></ol><p><strong>为什么需要断点续传？</strong></p><ul><li><p><strong>节省带宽</strong></p><p>如果网络连接不稳定，避免多次上传下载同一个文件的相同部分</p></li><li><p><strong>提高效率</strong></p><p>对于特别大的文件，重新传输全部内容代价很高</p></li><li><p><strong>用户体验</strong></p><p>提供更为流畅和友好的用户体验，特别是移动设备用户在不稳定网络下</p></li></ul><p>断点续传对于提高大文件传输的可靠性和效率至关重要，特别是在容错、网络条件差、数据传输成本高的情况下</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q40：版本号排序"><a href="#Q40：版本号排序" class="headerlink" title="Q40：版本号排序"></a>Q40：版本号排序</h3><p>难度：⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一组版本号如下</span></span><br><span class="line">[<span class="string">&#x27;0.1.1&#x27;</span>, <span class="string">&#x27;2.3.3&#x27;</span>, <span class="string">&#x27;0.302.1&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>, <span class="string">&#x27;4.3.5&#x27;</span>, <span class="string">&#x27;4.3.4.5&#x27;</span>]。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需要对其进行排序，排序的结果为 [&#x27;4.3.5&#x27;,&#x27;4.3.4.5&#x27;,&#x27;2.3.3&#x27;,&#x27;0.302.1&#x27;,&#x27;0.1.1&#x27;]</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>这是一个关于版本号排序问题的javascript解决办法</p><p>把每一个版本号分解，并使用’.’做成一个数组，这样你具有一个一维数组，其中每个元素是一个数组</p><p>然后根据这个数组，你可以使用数组的<code>sort()</code>方法进行排序</p><p>在排序函数中，你需要进行一些定制，以确保排序行为符合你的期望</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">versionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> aArr = a.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">    <span class="keyword">let</span> bArr = b.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">max</span>(aArr.<span class="property">length</span>, bArr.<span class="property">length</span>); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((aArr[i] || <span class="number">0</span>) &lt; (bArr[i] || <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((aArr[i] || <span class="number">0</span>) &gt; (bArr[i] || <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> versions = [<span class="string">&#x27;0.1.1&#x27;</span>, <span class="string">&#x27;2.3.3&#x27;</span>, <span class="string">&#x27;0.302.1&#x27;</span>, <span class="string">&#x27;4.2&#x27;</span>, <span class="string">&#x27;4.3.5&#x27;</span>, <span class="string">&#x27;4.3.4.5&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">versionSort</span>(versions));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [ &#x27;4.3.5&#x27;, &#x27;4.3.4.5&#x27;, &#x27;4.2&#x27;, &#x27;2.3.3&#x27;, &#x27;0.302.1&#x27;, &#x27;0.1.1&#x27; ]</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们首先定义了一个函数<code>versionSort()</code>，它接收一个版本号数组</p><p>在这个函数中我们使用了数组的<code>sort()</code>方法，定制排序函数来对数组排序</p><p>在排序函数中，我们首先把版本号分解成多个部分，然后我们对版本号的每一部分进行比较，如果发现某一部分的版本号更大，我们就认定此版本号整体更大，并结束循环和比较</p><p>如果所有部分的版本号都相等，我们认定此版本号等于比较的版本号</p>
              </div>
            </details>
<p><br/></p>
<h3 id="排序算法拓展Q41-Q42"><a href="#排序算法拓展Q41-Q42" class="headerlink" title="排序算法拓展Q41-Q42"></a>排序算法拓展Q41-Q42</h3><details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <ol><li><p><strong>冒泡排序（Bubble Sort）</strong></p><p>通过重复遍历要排序的数列，比较每对相邻元素，如果他们的顺序错误就把他们交换过来</p><p>过程类似在水中的气泡逐渐上升</p></li><li><p><strong>选择排序（Selection Sort）</strong></p><p>首先在未排序的数列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾</p></li><li><p><strong>希尔排序（Shell Sort）</strong></p><p>是插入排序的一种更高效的改进版本</p><p>希尔排序会先将数列进行分组，然后对每组数据进行插入排序，逐渐缩小分组的间隔进行排序，最终当整个数列基本有序时，再对全体元素进行一次直接插入排序</p></li><li><p><strong>插入排序（Insertion Sort）</strong></p><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p></li><li><p><strong>归并排序（Merge Sort）</strong></p><p>归并排序是建立在归并操作上的一种有效的排序算法</p><p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p></li><li><p><strong>快速排序（Quick Sort）</strong></p><p>通过选取一个元素作为基准，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面，此时基准元素在其排好序后的正确位置</p></li><li><p><strong>堆排序（Heap Sort）</strong></p><p>利用堆这种数据结构所设计的，视为一种树形选择排序</p></li><li><p><strong>计数排序（Counting Sort）</strong></p><p>是一个非比较排序，利用数组下标来确定元素的正确位置</p></li><li><p><strong>桶排序（Bucket Sort）</strong></p><p>数组分到有限数量的桶里，每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p></li><li><p><strong>基数排序（Radix Sort）</strong></p><p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位</p><p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序</p></li></ol>
              </div>
            </details>
<h3 id="Q41：实现冒泡排序"><a href="#Q41：实现冒泡排序" class="headerlink" title="Q41：实现冒泡排序"></a>Q41：实现冒泡排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历待排序的数组，比较两个相邻的项目，并且在必要时交换它们</p><p>每遍历一次都会确保至少有一个元素被移动到其最终位置</p><p>实现冒泡排序的步骤解析：</p><ol><li><p><strong>检查输入是否为数组 (<code>Array.isArray(arr)</code>)</strong> </p><p>这个条件判定确保了输入的数据类型是数组</p><p>冒泡排序是针对数组设计的，所以这个检查是必要的</p></li><li><p><strong>空数组或单个元素数组的检查 (<code>arr.length &lt;= 1</code>)</strong></p><p> 如果数组为空或者仅包含一个元素，则不需要排序，因为它已经是有序的</p><p>直接返回原数组</p></li><li><p><strong>设置<code>n</code>为数组的长度 (<code>n = arr.length</code>)</strong></p><p> 这个变量后面会被用来确定当前未排序部分的范围</p></li><li><p><strong>定义<code>newN</code>变量</strong> </p><p>这个变量用来记录在某一趟遍历中最后一次发生元素交换的位置，表示数组从<code>newN</code>之后的位置已经是排序好的，下一轮排序时不需要再考虑</p></li><li><p><strong>执行排序的外部循环 (<code>do...while</code>)</strong></p><p> 外部循环确保排序会持续进行直到没有再需要交换的项，这表示数组已经完全排序</p></li><li><p><strong>内部循环 (<code>for</code>循环)</strong></p><p> 在数组的未排序部分进行遍历</p><ul><li><p><strong>类型检查 (<code>typeof arr[i - 1] !== typeof arr[i]</code>)</strong></p><p> 在比较之前确认元素类型相同，以确保排序的有效性和防止JavaScript的强制类型转换可能导致的问题</p></li><li><p><strong>相邻元素比较 (<code>arr[i - 1] &gt; arr[i]</code>)</strong></p><p> 对当前元素和它之前的元素进行比较。如果前面的元素比当前元素大，它们的位置需要交换</p></li><li><p><strong>交换元素</strong></p><p> 使用临时变量<code>temp</code>来交换两个元素的位置</p></li><li><p><strong>更新<code>newN</code></strong></p><p> 设置<code>newN</code>为这次内部循环中最后一次发生交换的索引</p></li></ul></li><li><p><strong>更新<code>n</code></strong></p><p> 将<code>n</code>设置为最后一次发生交换的位置<code>newN</code>，这样下一次外部循环时，只需要检查到<code>newN</code>为止，因为后面的部分已经排序好了</p></li><li><p><strong>循环结束条件 (<code>newN != 0</code>)</strong></p><p> 如果在一轮完整的遍历中没有发生任何交换，<code>newN</code>会保持为0，这表明数组已经完全排序，循环可以结束</p></li></ol><p>通过以上步骤，冒泡排序利用交换元素的方式实现了数组的排序</p><p>冒泡的“名字”来源于较大元素的“冒泡”效应，因为在每轮遍历中，它们会如气泡一般逐渐“浮”到数组的一端</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查输入是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The provided input is not an array.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查数组长度，对于空数组或只有一个元素的数组直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> newN; <span class="comment">// 用于记录一轮遍历中最后一次交换的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      newN = <span class="number">0</span>; <span class="comment">// 每轮开始前将newN重置为0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// 添加了一个检查用以确保元素能够比较</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> arr[i - <span class="number">1</span>] !== <span class="keyword">typeof</span> arr[i]) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Elements are not of the same type for comparison.&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">              <span class="keyword">let</span> temp = arr[i - <span class="number">1</span>];</span><br><span class="line">              arr[i - <span class="number">1</span>] = arr[i];</span><br><span class="line">              arr[i] = temp;</span><br><span class="line">              newN = i; <span class="comment">// 更新为最新的交换位置</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      n = newN; <span class="comment">// 将n更新为最后一次交换的位置，下一轮遍历只到这里为止</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (newN != <span class="number">0</span>); <span class="comment">// 如果一轮中没有任何交换发生，那么数组已经是排序好的，循环结束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试数组</span></span><br><span class="line"><span class="keyword">let</span> testArray = [<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行冒泡排序</span></span><br><span class="line"><span class="title function_">bubbleSort</span>(testArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出排序后的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testArray);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q42：实现选择排序"><a href="#Q42：实现选择排序" class="headerlink" title="Q42：实现选择排序"></a>Q42：实现选择排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是选择排序算法的一个 JavaScript 实现</p><p>以下是每个主要部分的详细解析:</p><ol><li><p><code>if (!Array.isArray(arr))</code> 这个部分检查输入的参数是否为数组</p><p>如果不是，就抛出一个 <code>TypeError</code></p></li><li><p><code>if(arr.length &lt;= 1) return arr;</code> 对于空数组或只有一个元素的数组，它们已经被认为是排序过的，所以直接返回就可以了</p></li><li><p><code>arr.forEach((ele, index) =&gt; {...}</code> 这个循环检查数组的每个元素是否为数字，并且不是 <code>NaN</code></p><p>如果元素不是数字或者是 <code>NaN</code>，那么会抛出一个 <code>TypeError</code></p></li><li><p><code>for (let i = 0; i &lt; n - 1; i++) {...}</code> 这个外层循环遍历数组的每个元素，将当前元素设为最小元素</p></li><li><p><code>for (let j = i + 1; j &lt; n; j++) {...}</code> 内层循环遍历当前元素之后的所有元素，如果找到比当前最小元素还小的元素，就更新最小元素的索引</p></li><li><p><code>if (i !== minIndex) {...}</code> 当一次内层循环结束后，如果最小元素不是当前元素（that is, 索引 <code>i</code> 和 <code>minIndex</code> 不等），就交换这两个元素的位置</p><p>这样，第 <code>i</code> 个位置上的元素就会是前 <code>i+1</code> 个元素中的最小元素</p></li><li><p>最后，返回排序后的数组</p></li></ol><p>这个算法的时间复杂度是 O(n^2)，其中 n 是数组的长度</p><p>尽管选择排序在大多数情况下没有快速排序或归并排序高效，但是它的代码简洁，而且不需要使用额外的内存空间，这使得它在某些情况下仍然是一个很好的选择</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查输入是否为数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The provided input is not an array.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于非常小的数组，排序是不必要的，可以早点返回</span></span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在开始排序之前，检查数组元素是否可比较</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> ele !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(ele)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`The provided input array contains non-comparable elements at index <span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;ele&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> n = arr.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到了一个较小的元素，与当前位置的元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q43：实现希尔排序"><a href="#Q43：实现希尔排序" class="headerlink" title="Q43：实现希尔排序"></a>Q43：实现希尔排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是希尔排序算法的实现，我会详细地逐步解析这个过程。</p><ol><li><p>输入验证</p><p><strong>首先</strong>, 它验证传入的参数是不是一个数组，如果不是数组则抛出错误“<code>Input must be an array</code>”</p><p><strong>然后</strong>, 它通过一个for循环遍历数组中的每一个元素来验证每个元素是否为数字或字符串</p><p>如果数组中存在既不是数字也不是字符串的元素，则抛出错误“<code>Array elements must be numbers or strings</code></p></li><li><p>初始化变量</p><p><strong>接下来</strong>, 定义了数组的长度<code>len</code>和初始间隔<code>gap</code></p><p>间隔的初始值设为1，这个值将用于确定排序时比较元素之间的间隔</p></li><li><p>动态定义间隔序列</p><p>使用一个while循环计算初始的<code>gap</code>值</p><p>这个循环基于希尔排序的增量序列计算方法（<code>gap = gap * 3 + 1</code>），直到<code>gap</code>值不小于数组长度的三分之一</p><p>这样做是为了从较宽的间隔开始排序，并逐步缩短间隔，最终达到1</p></li><li><p>进行希尔排序</p><p><strong>在外层for循环中</strong>, <code>gap</code>值从初始值开始不断地通过<code>Math.floor(gap / 3)</code>缩小，直到<code>gap</code>值为1</p><p>这是希尔排序中减小间隔的过程</p><p><strong>内层for循环</strong>从<code>i = gap</code>开始迭代数组，这确保了每次比较都是在间隔<code>gap</code>之间进行的</p><p><strong>最内层for循环</strong>将当前元素<code>arr[j]</code>与距离<code>gap</code>位置之前的对应元素<code>arr[j - gap]</code>进行比较</p><p>如果<code>arr[j] &lt; arr[j - gap]</code>，则将它们位置互换</p><p>这个比较和交换过程一直进行，直到当前元素正确地“插入”（实际上是交换到正确位置）或是已经比较到数组的开始位置</p></li><li><p>结束和返回</p><p>当所有的间隔遍历完成，数组将完成排序，并通过<code>return arr;</code>返回排序后的数组</p></li></ol><p>这就是希尔排序的整个过程，从较大的间隔开始，逐渐缩小间隔进行比较和交换，直至间隔为1，相当于进行了一次插入排序，这时数组已经是排序好的了</p><p>这种方法相比于直接插入排序，在同样是基于插入的排序算法中，大大提升了效率</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 输入验证</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element !== <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> element !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Array elements must be numbers or strings&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>,</span><br><span class="line">    gap = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="title class_">Math</span>.<span class="title function_">floor</span>(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt;= gap &amp;&amp; arr[j] &lt; arr[j - gap]; j -= gap) &#123;</span><br><span class="line">        <span class="comment">// 交换元素位置</span></span><br><span class="line">        [arr[j], arr[j - gap]] = [arr[j - gap], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shellSort</span>([<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q44：实现插入排序"><a href="#Q44：实现插入排序" class="headerlink" title="Q44：实现插入排序"></a>Q44：实现插入排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是插入排序算法的一个实现，适用于JavaScript数组</p><p>下面我会逐步解析代码的各个部分：</p><ol><li><p><strong>数组输入验证</strong></p><ul><li>函数首先检查传入的参数<code>arr</code>是否为数组类型。如果不是，抛出一个错误</li></ul></li><li><p><strong>元素类型验证与NaN排除</strong></p><ul><li><p>检查数组中的每个元素是否都是数字类型，并且不是<code>NaN</code>（Not a Number）</p><p>如果某个元素不是数字或者是<code>NaN</code>，抛出一个错误</p></li></ul></li><li><p><strong>排序逻辑</strong></p><ul><li><p>函数通过两层循环来实现插入排序</p><ul><li><p>外层循环从<code>arr</code>的第二个元素开始，即索引<code>1</code>，遍历到数组的末尾</p><p>这个外层循环表示我们从未排序部分取出的待插入元素</p></li><li><p>内层循环用于找到这个待插入元素在已排序部分的正确位置，并将其插入</p><p>在这个过程中，我们把当前元素<code>current</code>保存在一个变量中，并逐一将已排序的元素向后移动，直到找到一个比<code>current</code>小的元素</p></li></ul></li><li><p>一旦找到合适的位置，我们退出内层循环，并将<code>current</code>放到正确的位置上</p></li></ul></li><li><p><strong>插入动作</strong></p><ul><li>当内层循环完成后，已找到<code>current</code>元素的插入位置，此时<code>j</code>变量代表<code>current</code>元素应该插入的位置索引</li><li>最后一步是将<code>current</code>变量赋值给<code>arr[j+1]</code>，这样我们就将元素插入到了数组的正确位置</li></ul></li></ol><p>代码执行后会返回已经排序的数组</p><p>插入排序算法利用了事实，即数组的一个子序列（在当前索引之前的元素）已经是排序过的</p><p>它在每次迭代中都会将一个新元素插入到已排序的子序列中，直到整个数组排序完成</p><p>插入排序的时间复杂度通常是O(n^2)，对于较小的或部分排序的数组来说效率是可接受的</p><p>对于较大的数组，可能会需要更高效的算法，如快速排序、堆排序或归并排序</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 验证输入是否为数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 验证数组元素类型并排除 NaN</span></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(item)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;All array elements must be valid numbers&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找插入位置的同时进行元素移动</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; current) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = current; <span class="comment">// 完成插入动作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q45：实现归并排序"><a href="#Q45：实现归并排序" class="headerlink" title="Q45：实现归并排序"></a>Q45：实现归并排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>这段代码是一个实现归并排序的JavaScript函数，它包括两个部分：<code>mergeSort</code>主函数和<code>merge</code>辅助函数</p><p>让我们逐步来解析一下这段代码</p><ol><li><p><strong>mergeSort函数</strong></p><p>这是一个调用归并排序算法的函数，输入参数为一个待排序的数组<code>arr</code></p><ul><li>首先，函数通过<code>Array.isArray(arr)</code>来检查输入是否为数组，然后使用<code>every</code>方法检查数组内的每个元素是否都是有限的数字，对于非数组或者数组中含有无效数字的情况，会抛出一个错误信息</li><li>如果数组长度小于等于1（表示数组为空或只有一个元素），那就没有必要排序，直接返回原数组</li><li>然后，函数将待排序的数组从中间拆分为两个子数组，一个包含前半部分的元素，另一个包含后半部分的元素</li><li>最后，函数递归地对这两个子数组进行排序，然后通过<code>merge</code>函数将排序后的结果合并在一起</li></ul></li><li><p><strong>merge函数</strong></p><p>这是一个辅助函数，使用两个已经排序的数组作为输入参数，在这个例子中就是<code>left</code>和<code>right</code></p><ul><li>函数首先初始化一个空的结果数组<code>resultArray</code>和两个从0开始的索引<code>leftIndex</code>和<code>rightIndex</code></li><li>在接下来的循环中，函数将<code>left</code>数组中索引为<code>leftIndex</code>的元素和<code>right</code>数组中索引为<code>rightIndex</code>的元素进行比较，较小的那一个将被推入<code>resultArray</code>，并将相应的索引加1，用于追踪两个数组中的比较进度</li><li>最后，当<code>left</code>数组和<code>right</code>数组中的元素都被比较过后，剩下的未被比较的元素（其一定会全部在其中一个数组的末尾并且比已经比较过的元素要大）会被加入到结果数组的尾部</li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 验证输入是否为数组, 并确保每个元素都是有效的数字</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) || !arr.<span class="title function_">every</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="keyword">typeof</span> num === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isFinite</span>(num))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Input must be an array of numbers.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(middle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> resultArray = [], leftIndex = <span class="number">0</span>, rightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.<span class="property">length</span> &amp;&amp; rightIndex &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      resultArray.<span class="title function_">push</span>(left[leftIndex]);</span><br><span class="line">      leftIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resultArray.<span class="title function_">push</span>(right[rightIndex]);</span><br><span class="line">      rightIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultArray</span><br><span class="line">    .<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(leftIndex))</span><br><span class="line">    .<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(rightIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q46：实现快速排序"><a href="#Q46：实现快速排序" class="headerlink" title="Q46：实现快速排序"></a>Q46：实现快速排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>isNumeric(value)</code> </p><p> 这是一个辅助函数，接收一个参数并返回一个布尔值表示该参数是否是finite number（即不是NaN, Infinity或-Infinity）</p></li><li><p><code>swap(array, i, j)</code> </p><p>它是用于交换数组两个索引下的元素的位置</p><p>这个函数在排序算法中非常关键</p></li><li><p><code>partition(array, left, right)</code> 在快速排序中也是一个核心的函数</p><p>所谓”partition operation”，就是将数组分成两半，使得左边子数组的所有元素都小于右边子数组的所有元素</p><p>同时，该函数还会返回一个“pivot index”</p><p>这个索引是计算后得到，使得所有比它小的元素都在它的左边，所有比它大的元素都在它的右边</p><p>这个pivot就是我们之后进行递归操作的基础</p></li><li><p><code>quickSort(array, left, right)</code> 是主要的排序函数</p><p>它首先检查传入的参数是否满足所需的要求，例如数组中的元素是否全为数字等</p><p>然后，它使用了划分(partition)操作并得到了一个“pivot index”</p><p>在得到这个pivot index后，quickSort函数进行自我调用，对pivot index的左边和右边的子数组分别进行排序</p><p>这个过程中的自我调用，就是quickSort中的“递归”部分</p></li></ol><p>快速排序算法是一种非常高效的排序算法</p><p>它的基本思想是：通过一次排序将待排序数据分割成独立的两部分，其中一部分数据都比另外一部分的数据小，然后再按此方法对这两部分数据分别进行快速排序，整个过程可以递归进行，以此达到整个数据变成有序序列</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNumeric</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; !<span class="built_in">isNaN</span>(value) &amp;&amp; <span class="built_in">isFinite</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, left = <span class="number">0</span>, right = array.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 参数验证</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(array)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The first argument must be an array&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> right !== <span class="string">&#x27;number&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Left and right must be numbers&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回已经排序好的小数组</span></span><br><span class="line">  <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查元素是否全部为数字</span></span><br><span class="line">  <span class="keyword">if</span> (!array.<span class="title function_">slice</span>(left, right + <span class="number">1</span>).<span class="title function_">every</span>(isNumeric)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array should contain only numbers&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始排序</span></span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="title function_">partition</span>(array, left, right); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; pivotIndex - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="title function_">quickSort</span>(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pivotIndex &lt; right) &#123;</span><br><span class="line">    <span class="title function_">quickSort</span>(array, pivotIndex, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, i, j</span>) &#123;</span><br><span class="line">  [array[i], array[j]] = [array[j], array[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = array[<span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>)];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (array[i] &lt; pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (array[j] &gt; pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(array, i, j);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q47：实现堆排序"><a href="#Q47：实现堆排序" class="headerlink" title="Q47：实现堆排序"></a>Q47：实现堆排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><code>heapSort</code> 函数</p><p>这是排序的主函数，接收一个数组 <code>arr</code> 作为参数</p><ol><li><strong>输入验证</strong>: 首先，进行检查以确保 <code>arr</code> 参数是一个数组</li><li><strong>长度验证</strong>: 如果数组长度 <code>&lt;= 1</code>，那就不需要排序，直接返回原数组</li><li><strong>类型验证</strong>: 接下来检查数组中的每个元素都是有限数值</li><li><strong>构建最大堆</strong>: 使用 <code>buildMaxHeap</code> 函数把输入数组 <code>arr</code> 转换为最大堆</li><li>排序逻辑<ul><li>循环从数组的末尾开始到索引1处结束</li><li>使用 <code>swap</code> 函数将堆顶的最大元素与当前考察位置的元素交换</li><li>调用 <code>maxHeapify</code> 函数将堆顶至考察位置上的部分调整为最大堆</li></ul></li></ol><p>这个函数将按升序排列数组 <code>arr</code></p></li><li><p><code>buildMaxHeap</code> 函数</p><p>这个辅助函数将数组转换成一个最大堆结构</p><ul><li>从最后一个非叶子节点开始向前（这是由 <code>start = Math.floor(length / 2) - 1</code> 决定的），每个节点都进行下沉操作，以保证子节点的值小于这个节点的值</li></ul></li><li><p><code>maxHeapify</code> 函数</p><p><code>maxHeapify</code> 是堆排序核心步骤，它确保堆的属性被维护</p><ul><li>该函数接收一个索引 <code>index</code> 和堆的大小 <code>heapSize</code>，使用左儿子和右儿子的索引与当前节点的值进行比较</li><li>如果子节点的值大于父节点，<code>largest</code> 将记录最大值的索引</li><li>如果发现最大值的索引不是当前考察的父节点，则通过 <code>swap</code> 交换当前节点和最大值的节点</li><li>由于交换后影响了子堆的结构，所以递归调用 <code>maxHeapify</code> 来调整变动后的子堆，确保它仍然是最大堆</li></ul></li><li><p><code>swap</code> 函数</p><p>这个简单的函数通过解构赋值交换数组中两个元素的位置</p><ul><li>实现数组 <code>arr</code> 中索引 <code>i</code> 和 <code>j</code> 上的两个元素的交换。这种写法是ES6语法糖，是交换元素的快捷方式</li></ul></li></ol><p>这整个堆排序的过程：</p><p>首先，通过 <code>buildMaxHeap</code> 将数组重新排序成最大堆</p><p>然后，堆顶（也是整个数组中的最大值）和数组的最后一个元素交换位置，然后缩小考察的数组范围（即 减少 <code>heapSize</code>），由于交换破坏了最大堆的属性，需要重新调用 <code>maxHeapify</code> 来恢复最大堆</p><p>重复这个过程，直到整个数组完全排序</p><p>最终，原数组 <code>arr</code> 变成已排序的数组，并返回</p><p>由于堆排序的方法，我们每次都能确定最大的元素被放置在最终的位置，因此不需要额外的存储空间之外的数组来进行排序</p>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Expected an array&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!arr.<span class="title function_">every</span>(<span class="title class_">Number</span>.<span class="property">isFinite</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Array must contain only numbers&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建最大堆</span></span><br><span class="line">  <span class="title function_">buildMaxHeap</span>(arr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换首尾元素并重新调整最大堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildMaxHeap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 从最后一个非叶子节点开始向前遍历，进行下沉操作</span></span><br><span class="line">  <span class="keyword">const</span> length = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, i, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxHeapify</span>(<span class="params">arr, index, heapSize</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>, largest = index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (largest !== index) &#123;</span><br><span class="line">    <span class="title function_">swap</span>(arr, index, largest);</span><br><span class="line">    <span class="comment">// 继续调整下面的非叶子节点</span></span><br><span class="line">    <span class="title function_">maxHeapify</span>(arr, largest, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>) &#123;</span><br><span class="line">  [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q48：怎么实现一个二维码登录pc网站"><a href="#Q48：怎么实现一个二维码登录pc网站" class="headerlink" title="Q48：怎么实现一个二维码登录pc网站"></a>Q48：怎么实现一个二维码登录pc网站</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p>二维码登录是现代Web开发中常见的一种身份验证方式，尤其在移动设备广泛使用的背景下</p><p>它提供了一个便捷的方法，允许用户通过扫描二维码来登录PC网站，避免了手动输入账号密码的麻烦</p><p>接下来，我将详细解释二维码的本质及如何实现二维码登录PC网站</p><p><strong>二维码的本质</strong></p><p>二维码（Quick Response Code, QR Code）是一种矩阵二维码或二维条码，它由黑白色块组成</p><p>与传统的一维条码相比，二维码可以存储更多信息，包括网址、文本或其他数据</p><p>二维码可以通过相机扫描进行读取，这一点在二维码登录中尤为重要</p><p><strong>实现二维码登录的流程</strong></p><p>实现二维码登录通常涉及后端服务器、PC网站（通常是网站的登录页面）和用户的移动设备</p><p>基本流程大致如下：</p><ol><li><p>生成登录二维码</p><p><strong>在PC网站登录页面生成二维码</strong> </p><p>当用户打开PC网站的登录页面时，网站后台会生成一个唯一标识（通常是一个随机生成的字符串或UUID），并将这个唯一标识与一个登录请求的URL合并</p><p>然后，使用这个URL生成二维码显示在登录页面上</p></li><li><p>移动设备扫描二维码</p><p><strong>用户使用移动设备扫描二维码</strong> </p><p>这一步通常需要用户已经在移动设备上登录了相应的移动应用（比如微信、支付宝等），应用可以识别并处理扫描到的URL</p></li><li><p>移动设备请求登录授权</p><p><strong>移动应用处理二维码中的URL，向服务器发起登录授权请求</strong></p><p>在这一步，移动应用通常会向服务器发送包含用户凭据（如令牌）和二维码中的唯一标识的请求</p></li><li><p>服务器验证并授权登录</p><p><strong>服务器验证请求</strong></p><p>服务器接收到登录授权请求后，验证用户凭据和唯一标识</p><p>如果验证成功，服务器则认为PC端的登录请求是合法的</p></li><li><p>通知PC端登录成功</p><p><strong>服务器通过WebSocket或轮询机制通知PC端</strong></p><p>一旦服务器验证用户成功，并且授权了PC端的登录请求，它需要一个方式来通知PC端</p><p>这通常通过WebSocket连接实现，如果PC端在生成二维码时就建立了WebSocket连接</p><p>或者通过PC端定期轮询服务器来检查登录状态</p></li><li><p>PC端完成登录</p><p><strong>PC端接收到登录成功的通知后，完成登录过程</strong> </p><p>这可能涉及到设置用户的登录状态、储存令牌和跳转到登录后的页面等</p></li></ol><p><strong>关键技术实现</strong></p><ol><li><p><strong>二维码生成</strong> </p><p>可以使用各种前端库来在网页上生成二维码，例如<code>qrcode.js</code></p></li><li><p><strong>WebSocket或轮询</strong> </p><p>WebSocket提供了一个实时双向通信方案，使得服务器可以实时通知PC网站</p><p>如果不使用WebSocket，可以采用定时轮询的方式，让PC端定时向服务器发起请求查询登录状态</p></li><li><p><strong>唯一标识处理</strong> </p><p>在服务器端生成并处理唯一标识（比如UUID），将它与用户的登录状态关联起来</p></li><li><p><strong>安全性</strong> </p><p>确保所有通信都通过HTTPS进行，保护用户数据安全</p><p>另外，二维码的有效期应该设定得短些，避免被滥用</p></li></ol><p>通过上述流程和关键技术实现点，你可以在自己的PC网站上实现二维码登录功能</p><p>这种登录方式为用户提供了便利的同时，也要确保整个过程的安全性</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q49：Javascript里面的倒计时怎么纠正偏差"><a href="#Q49：Javascript里面的倒计时怎么纠正偏差" class="headerlink" title="Q49：Javascript里面的倒计时怎么纠正偏差"></a>Q49：Javascript里面的倒计时怎么纠正偏差</h3><p>难度：⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <ol><li><p><strong>使用服务器时间作为基准</strong></p><p>因为用户的设备时间可能不准确，所以最好在倒计时开始时同步一次服务器时间，并据此进行后续的倒计时计算</p><ul><li><p><strong>AJAX请求</strong></p><p>通过一个异步请求获取服务器时间，并存储这个时间用于后续计算</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getServerTime</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api/server-time&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(data.<span class="property">serverTime</span>); <span class="comment">// 服务器的UNIX时间戳</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>WebSocket连接</strong></p><p>维持一个WebSocket连接，动态同步服务器时间用于精确计时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设已经打开了一个WebSocket连接ws</span></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> serverTime = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>).<span class="property">serverTime</span>;</span><br><span class="line">  <span class="title function_">startCountdown</span>(serverTime);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>校正时间间隔</strong></p><p>使用<code>setTimeout</code>或<code>setInterval</code>的周期性调用可以不断校正时间，避免累计误差</p><p>每次回调时应该重新计算剩余时间，而不是简单依赖固定的间隔</p><ul><li><p><strong>递归<code>setTimeout</code>调用</strong>：使用<code>setTimeout</code>代替<code>setInterval</code>，并在每次回调执行时递归地调用它，实现自调正的特性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">remaining</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(remaining + <span class="string">&#x27; ms remaining&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(remaining - <span class="number">1000</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">countdown</span>(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>动态延迟</strong>：在<code>setTimeout</code>中动态计算下一次回调的延迟时间</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adaptiveCountdown</span>(<span class="params">endTime</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">scheduleNextTick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">var</span> remaining = endTime - now;</span><br><span class="line">    <span class="keyword">var</span> nextTick = remaining % <span class="number">1000</span> || <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(scheduleNextTick, nextTick);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">scheduleNextTick</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>避免长时间间隔</strong></p><p>尽量不要设置很长的单次倒计时（如几分钟以上），因为更长的时间间隔意味着更大的潜在偏差</p><p>如果需要长时间倒计时，应该分成多个较短的间隔</p><ul><li><p><strong>分段计时</strong></p><p>将长时间间隔分成多个短时间间隔，逐段计时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">segmentCountdown</span>(<span class="params">duration, segment</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> segmentsLeft = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(duration / segment);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    segmentsLeft--;</span><br><span class="line">    <span class="keyword">if</span> (segmentsLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(tick, segment);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(tick, segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用性能优化</strong></p><p>确保倒计时函数的执行尽可能快和轻量，减少其他JavaScript任务对倒计时精度的影响</p><ul><li><p><strong>降低页面复杂度</strong></p><p>确保倒计时期间页面尽可能简洁，减少DOM操作和CPU密集型任务</p></li><li><p><strong>使用<code>requestAnimationFrame</code></strong></p><p>这通常用于动画，但可以确保计时器的代码在浏览器绘图前执行，从而保持同步</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">frameCountdown</span>(<span class="params">targetTime</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">frame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (targetTime &gt; now) &#123;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Countdown finished&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用Web Workers</strong></p><p>如果需要高精度计时器，可以使用Web Workers，因为它们运行在后台线程，不受主线程任务的干扰</p><ul><li><p><strong>Dedicated Worker</strong></p><p>创建一个独立的脚本文件，该文件作为Web Worker运行，用于倒计时</p><p>这个Dedicated Worker脚本接收来自主线程的倒计时开始指令，然后每秒通过<code>postMessage</code>方法更新剩余时间，直至倒计时结束</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收主线程消息，开始倒计时</span></span><br><span class="line">onmessage = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> seconds = event.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> countdown = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">postMessage</span>(seconds);</span><br><span class="line">    <span class="keyword">if</span>(seconds-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(countdown, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">countdown</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在主线程处理倒计时逻辑</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Dedicated Worker</span></span><br><span class="line"><span class="keyword">var</span> countdownWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;countdownWorker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收Worker发来的倒计时数据</span></span><br><span class="line">countdownWorker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;剩余时间: &quot;</span> + event.<span class="property">data</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(event.<span class="property">data</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;倒计时结束!&quot;</span>);</span><br><span class="line">    countdownWorker.<span class="title function_">terminate</span>(); <span class="comment">// 停止Worker</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动倒计时，比如60秒</span></span><br><span class="line">countdownWorker.<span class="title function_">postMessage</span>(<span class="number">60</span>);</span><br></pre></td></tr></table></figure></li><li><p>Shared Worker</p><p>如果需要在多个标签页或者iframe中共享同一个倒计时，可以使用Shared Worker来实现</p><p>主线程代码</p><p>只需要一处（例如，用户打开的第一个标签页）通过<code>postMessage</code>启动倒计时，其他所有连接了这个Shared Worker的标签页都会收到倒计时更新的消息</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySharedWorker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;sharedCountdownWorker.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mySharedWorker.<span class="property">port</span>.<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line">mySharedWorker.<span class="property">port</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;剩余时间: &quot;</span> + e.<span class="property">data</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">data</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;倒计时结束！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只在一个标签页中启动倒计时即可</span></span><br><span class="line"><span class="comment">// mySharedWorker.port.postMessage(60);</span></span><br></pre></td></tr></table></figure><p>这个Shared Worker脚本接收来自任一连接它的页面的倒计时开始指令，然后每秒通过<code>postMessage</code>给所有连接的端口更新剩余时间，实现多标签页或iframe间的倒计时共享</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ports = [];</span><br><span class="line">onconnect = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">  ports.<span class="title function_">push</span>(port);</span><br><span class="line"></span><br><span class="line">  port.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> seconds = event.<span class="property">data</span>;</span><br><span class="line">    <span class="title function_">countdown</span>(seconds);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">seconds</span>) &#123;</span><br><span class="line">  ports.<span class="title function_">forEach</span>(<span class="function"><span class="params">port</span> =&gt;</span> &#123;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(seconds);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(seconds-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">countdown</span>(seconds), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>
              </div>
            </details>
<details class="folding-tag" purple><summary> 引申 </summary>
              <div class='content'>
              <p>前端JavaScript获取的时间实际上是来自用户设备的系统时间，这意味着如果用户修改了设备的时间，那么JavaScript获取的时间也会受到影响，倒计时和其他依赖时间的功能会因此而不准确</p>
              </div>
            </details>
<p><br/></p>
<h3 id="Q50：实现合并Promise函数"><a href="#Q50：实现合并Promise函数" class="headerlink" title="Q50：实现合并Promise函数"></a>Q50：实现合并Promise函数</h3><p>实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中</p>
<p>难度：⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">time</span> = (<span class="params">timer</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax1</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">2000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax2</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ajax3</span> = (<span class="params"></span>) =&gt; <span class="title function_">time</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span> () &#123;</span><br><span class="line">  <span class="comment">// 在这里写代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <ol><li><p><strong>promise方式</strong></p><p>为了实现<code>mergePromise</code>函数，我们需要按照传入数组的顺序依次执行这些异步操作，并收集每个异步操作的结果</p><p>这可以通过链式调用Promise的<code>.then()</code>方法来完成</p><p>在这个实现中，<code>mergePromise</code>函数接受一个包含ajax函数的数组<code>ajaxArray</code></p><p>我们定义了<code>data</code>数组来保存每个ajax调用后resolve的结果</p><p>我们开始时有一个“空”的已经resolved的Promise对象，我们把这个Promise对象赋值给<code>sequence</code>变量</p><p>然后我们利用<code>Array.prototype.forEach</code>遍历<code>ajaxArray</code>数组，将数组中的每个函数加到<code>sequence</code>的调用链中，并通过连续调用<code>.then()</code>保证顺序执行</p><p>在每一次迭代中，我们都将上一个Promise通过<code>.then()</code>链接到当前的ajax调用，然后在另一个<code>.then()</code>中将结果<code>res</code>推入<code>data</code>数组，并返回<code>data</code>数组，这样下一个Promise的<code>.then()</code>可以接收到上一个<code>.then()</code>返回的数据数组</p><p>这样遍历之后，<code>data</code>数组就按顺序积累了所有ajax调用的结果</p><p>最后返回的<code>sequence</code> Promise在所有的ajax函数都顺序执行并且它们的结果都被推入<code>data</code>数组之后，就会被resolve</p><p>这个最后的Promise resolve了<code>data</code>数组作为结果，然后我们在<code>.then()</code>回调函数中打印出”data”数组和”done”</p><p>利用这种方式，我们实现了函数依次执行，并按序收集它们resolve的值</p></li><li><p><strong>await方式</strong></p><p>也可以使用<code>async/await</code>来实现</p><p>使用<code>async/await</code>可以让我们的代码看起来更像同步代码，降低了复杂性</p><p>在此实现中，我们使用<code>async</code>关键字声明了一个异步函数<code>mergePromise</code>，此函数接受一个包含ajax函数的数组<code>ajaxArray</code></p><p>在异步函数内部，我们可以使用<code>await</code>关键字来等待每个ajax函数的完成，并将结果push进<code>data</code>数组</p><p>这种方式的优点是，代码更简洁，更易于阅读</p><p>我们没有必要手动创建一个Promise链，可以直接在for循环中循环等待每个Promise的resolve，一旦全部完成，我们便得到了所有值放在<code>data</code>数组中</p><p>然后返回这个数组，当所有ajax调用都结束后，将会resolve整个<code>mergePromise</code>函数的Promise</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <p><strong>promise方式</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">  <span class="comment">// 存储每个ajax的结果</span></span><br><span class="line">  <span class="keyword">const</span> data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始值是一个已解决的Promise</span></span><br><span class="line">  <span class="keyword">let</span> sequence = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  ajaxArray.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 上一个Promise的.then()的结果是新的Promise</span></span><br><span class="line">    sequence = sequence.<span class="title function_">then</span>(item).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 把每次得到的结果放入data</span></span><br><span class="line">      data.<span class="title function_">push</span>(res);</span><br><span class="line">      <span class="keyword">return</span> data; <span class="comment">// 传递data到下一个.then</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sequence的最终值是最后一个被处理的Promise</span></span><br><span class="line">  <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>await方式</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mergePromise</span>(<span class="params">ajaxArray</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> ajaxArray) &#123;</span><br><span class="line">        data.<span class="title function_">push</span>(<span class="keyword">await</span> <span class="title function_">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergePromise</span>([ajax1, ajax2, ajax3]).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q51：使用Promise实现，限制异步并发个数，并尽快完成"><a href="#Q51：使用Promise实现，限制异步并发个数，并尽快完成" class="headerlink" title="Q51：使用Promise实现，限制异步并发个数，并尽快完成"></a>Q51：使用Promise实现，限制异步并发个数，并尽快完成</h3><p>有8个图片资源的url，已经存储在数组urls中</p>
<p>urls类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code> 而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。</p>
<p>但有一个要求，任何时刻同时下载的链接数量不可以超过3个</p>
<p>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成</p>
<p>难度：⭐⭐⭐⭐⭐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png&quot;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImg</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;一张图片加载完成&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at&#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>可以考虑使用”并发控制”的模式，即每次并发请求的数量为3，当有请求完成后再发起新的请求，直到全部图片都加载完成</p><p>这样可以确保任何时刻最多只有3个请求在同时进行</p><p>这段代码实现了一个名为 <code>limitLoad</code> 的函数，其目的是管理对图片资源的异步加载，限制在任何时刻同时进行的加载数量不超过给定的限制值（<code>limit</code>）</p><p>下面是对这个函数如何工作的逐步解析：</p><ol><li><p>输入参数</p><ul><li><p><code>urls</code></p><p>一个包含图片资源URLs的数组</p></li><li><p><code>loadImg</code></p><p>一个接受单个URL为参数并返回一个<code>Promise</code>的函数，该<code>Promise</code>会在相应的图片加载完成时解决，如果加载失败，则拒绝</p></li><li><p><code>limit</code></p><p>同时进行图片加载的最大数量</p></li></ul></li><li><p>函数执行流程</p><ol><li><strong>初始化变量</strong><ul><li><code>sequence</code>: 通过复制<code>urls</code>数组创建，以避免修改原始数组</li><li><code>promises</code>: 存储正在进行的、数量不超过<code>limit</code>的加载操作的<code>Promise</code>对象数组</li></ul></li><li><strong>启动初始的并发请求</strong><ul><li>使用<code>map</code>函数从<code>sequence</code>中提取前<code>limit</code>个URL，并对每个URL调用<code>loadImg</code>函数，开始加载对应的图片</li><li>对<code>loadImg</code>返回的每个<code>Promise</code>，通过<code>then</code>和<code>catch</code>确保无论成功还是失败都将返回resolving的Promise，其中包含了该次加载操作在<code>promises</code>数组中的索引</li></ul></li><li><strong>利用<code>reduce</code>顺序处理剩余的<code>urls</code></strong><ul><li><code>reduce</code>通过一个初始的<code>Promise</code>开始执行，并且为序列中的每个URL顺序安排加载操作</li><li>在每次迭代中，使用<code>Promise.race</code>等待<code>promises</code>数组中任意一个<code>Promise</code>完成（无论是解决还是拒绝）</li><li>一旦有<code>Promise</code>完成，就用新的加载操作的<code>Promise</code>替换<code>promises</code>数组中对应的位置，这样可以确保<code>promises</code>数组始终在维护最多<code>limit</code>个正在进行的加载操作</li></ul></li><li><strong>处理所有加载操作完成后的情况</strong><ul><li>使用<code>promiseChain.then()</code>等待所有通过<code>reduce</code>安排的加载操作完成</li><li>再通过<code>Promise.all(promises)</code>等待当前正在进行的所有加载操作的完成</li><li>之后，通过<code>then()</code>可以执行一些所有图片加载尝试完成（无论成功或失败）后的最终处理</li></ul></li><li><strong>错误处理</strong><ul><li>在最后，通过<code>catch</code>捕获整个加载过程中遇到的任何错误，并打印错误信息</li></ul></li></ol></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">limitLoad</span>(<span class="params">urls, loadImg, limit</span>) &#123;</span><br><span class="line">    <span class="comment">// 拷贝urls</span></span><br><span class="line">    <span class="keyword">let</span> sequence = [].<span class="title function_">concat</span>(urls);</span><br><span class="line">    <span class="comment">// 存储正在加载的图片Promise数组</span></span><br><span class="line">    <span class="keyword">let</span> promises = [];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 启动初始的并发请求</span></span><br><span class="line">    promises = sequence.<span class="title function_">splice</span>(<span class="number">0</span>, limit).<span class="title function_">map</span>(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里加载图片，然后返回图片索引</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">loadImg</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> index).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> index);</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用reduce依次加载剩余的图片</span></span><br><span class="line">    <span class="keyword">let</span> promiseChain = sequence.<span class="title function_">reduce</span>(<span class="function">(<span class="params">lastPromiseChain, url, currentIndex</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastPromiseChain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 等待到promises数组中任何一个Promise被解决（或被拒绝）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(promises);</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">fastestIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 一旦图片加载完成，用新的Promise替换掉promises数组中已完成的Promise</span></span><br><span class="line">            promises[fastestIndex] = <span class="title function_">loadImg</span>(url).<span class="title function_">then</span>(<span class="function">() =&gt;</span> fastestIndex).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> fastestIndex);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当所有图片加载完成（或失败）后，返回一个新的Promise</span></span><br><span class="line">    <span class="keyword">return</span> promiseChain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 最后等待剩余的图片加载完成（或失败）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在所有图片加载（或失败）后，可能需要做一些最终的处理</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片都已尝试加载&#x27;</span>);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理整个图片加载过程中遇到的任何错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;在加载所有图片的过程中发生了一个错误: &quot;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">limitLoad</span>(urls, loadImg, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h2 id="实现API"><a href="#实现API" class="headerlink" title="实现API"></a>实现API</h2><h3 id="Q1：使用-setTimeout-实现-setlnterval"><a href="#Q1：使用-setTimeout-实现-setlnterval" class="headerlink" title="Q1：使用 setTimeout 实现 setlnterval"></a>Q1：使用 setTimeout 实现 setlnterval</h3><p>难度：⭐⭐⭐</p>
<details class="folding-tag" gray><summary> 解析 </summary>
              <div class='content'>
              <p>在使用<code>setTimeout</code>实现<code>setInterval</code>（即模拟周期性执行某个函数的行为）的时候，核心思想是通过递归调用<code>setTimeout</code>来达到<code>setInterval</code>的效果</p><p>这么做有几个关键的注意点和技巧：</p><ol><li><p><strong>精确的时间控制</strong></p><p>使用<code>setTimeout</code>递归调用的方式可以比<code>setInterval</code>提供更精确的时间控制</p><p>因为<code>setInterval</code>在某些情况下可能会受到多个待执行的回调函数堆积的影响，导致实际执行间隔不准确</p><p>在递归调用<code>setTimeout</code>时，每次都是在上一个调用完成后才设置下一个调用，从一定程度上避免了这个问题</p></li><li><p><strong>避免堆积</strong></p><p>在高负载或者执行时间较长的情况下，避免回调函数的堆积。如果回调函数执行时间过长，超过了设置的间隔时间，<code>setTimeout</code>会等待回调函数执行完毕后立即执行，不会像<code>setInterval</code>那样导致回调函数堆积。</p></li><li><p><strong>错误处理</strong></p><p>递归调用时，可以在每一次的回调函数中添加错误处理逻辑</p><p>这是利用<code>setTimeout</code>模拟<code>setInterval</code>可以做到而直接使用<code>setInterval</code>较难实现的</p></li><li><p><strong>提供停止机制</strong></p><p>在直接使用<code>setInterval</code>时，可以通过<code>clearInterval</code>停止执行</p><p>在用<code>setTimeout</code>模拟时，需要手动提供一个机制来停止循环（比如，通过一个标志变量控制）</p></li><li><p><strong>性能考虑</strong></p><p>虽然使用<code>setTimeout</code>递归可以提供更灵活的控制，但在某些极端情况下（比如，非常短的时间间隔和复杂的业务逻辑），它可能会导致性能问题</p><p>因此，设计时应考虑到具体的业务需求和环境</p></li></ol>
              </div>
            </details>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">fn, timeout</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于停止定时器的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerId) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerId);</span><br><span class="line">      timerId = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归函数用来模拟 setInterval 的行为</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">intervalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerId !== <span class="literal">null</span>) &#123; <span class="comment">// 检查定时器是否已经被停止</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>(); <span class="comment">// 尝试执行用户提供的回调函数</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error during interval execution:&quot;</span>, error);</span><br><span class="line">        <span class="title function_">stop</span>(); <span class="comment">// 出错时停止定时器</span></span><br><span class="line">        <span class="keyword">throw</span> error; <span class="comment">// 可选，根据需要决定是否需要重新抛出错误</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 安排下一次执行</span></span><br><span class="line">      timerId = <span class="built_in">setTimeout</span>(intervalFunction, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  timerId = <span class="built_in">setTimeout</span>(intervalFunction, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个对象，包含 stop 方法，以便外部可以停止定时器</span></span><br><span class="line">  <span class="keyword">return</span> &#123; stop &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="title function_">mySetInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在需要停止定时器时，可以调用 stop 方法</span></span><br><span class="line"><span class="comment">// 例如，5秒后停止</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  interval.<span class="title function_">stop</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Interval stopped&quot;</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
<h3 id="Q5：实现js里面的sort排序"><a href="#Q5：实现js里面的sort排序" class="headerlink" title="Q5：实现js里面的sort排序"></a>Q5：实现js里面的sort排序</h3><p>难度：⭐⭐⭐⭐⭐</p>
<details class="folding-tag" green><summary> 答案 </summary>
              <div class='content'>
              <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr, compareFn = defaultCompare</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> pivot = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> lesser = [];</span><br><span class="line">    <span class="keyword">const</span> greater = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compareFn</span>(arr[i], pivot) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            lesser.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            greater.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...<span class="title function_">quickSort</span>(lesser, compareFn), pivot, ...<span class="title function_">quickSort</span>(greater, compareFn)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defaultCompare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<p><br/></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《直达底部按钮》</title>
    <url>/posts/350b33d1/</url>
    <content><![CDATA[<h2 id="修改rightside-pug"><a href="#修改rightside-pug" class="headerlink" title="修改rightside.pug"></a>修改rightside.pug</h2><p>路径： <code>[BlogRoot]\themes\butterfly\layout\includes\</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">button#go-up(type=&quot;button&quot; title=_p(&quot;rightside.back_to_top&quot;))</span><br><span class="line">  i.fas.fa-arrow-up</span><br><span class="line"></span><br><span class="line"><span class="addition">+button#go-down(type=&quot;button&quot; title=&quot;直达底部&quot; onclick=&quot;btf.scrollToDest(document.body.scrollHeight, 500)&quot;)</span></span><br><span class="line"><span class="addition">+  i.fas.fa-arrow-down</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《移动端侧边栏收起》</title>
    <url>/posts/6f0ca27e/</url>
    <content><![CDATA[<h2 id="新建hideAsideOnMobile-js"><a href="#新建hideAsideOnMobile-js" class="headerlink" title="新建hideAsideOnMobile.js"></a>新建hideAsideOnMobile.js</h2><p>路径：<code>[Blogroot]\source\js\</code></p>
<p>这个文件用来控制显示隐藏的逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 固定卡片点击动作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FixedCardWidget</span>(<span class="params">type,name,index</span>)&#123;</span><br><span class="line">  <span class="comment">// 根据id或class选择元素</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&quot;id&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> tempcard = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempcard = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(name)[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 若元素存在</span></span><br><span class="line">  <span class="keyword">if</span> (tempcard) &#123;</span><br><span class="line">    <span class="comment">// 首先判断是否存在fixed-card-widget类</span></span><br><span class="line">    <span class="keyword">if</span> (tempcard.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;fixed-card-widget&#x27;</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// 存在则移除</span></span><br><span class="line">      <span class="title class_">RemoveFixedCardWidget</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 不存在则先初始化防止卡片叠加</span></span><br><span class="line">      <span class="title class_">RemoveFixedCardWidget</span>();</span><br><span class="line">      <span class="comment">//新建退出蒙版</span></span><br><span class="line">      <span class="title class_">CreateQuitBox</span>();</span><br><span class="line">      <span class="comment">// 再添加固定卡片样式</span></span><br><span class="line">      tempcard.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;fixed-card-widget&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个蒙版，作为退出键使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateQuitBox</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> quitBox = <span class="string">`&lt;div id=&quot;quit-box&quot; onclick=&quot;RemoveFixedCardWidget()&quot;&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">var</span> asideContent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;aside-content&#x27;</span>);</span><br><span class="line">  asideContent.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>,quitBox)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除卡片方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RemoveFixedCardWidget</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> activedItems = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.fixed-card-widget&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (activedItems) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; activedItems.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      activedItems[i].<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;fixed-card-widget&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//移除退出蒙版</span></span><br><span class="line">  <span class="keyword">var</span> quitBox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;quit-box&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (quitBox) quitBox.<span class="title function_">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常规先初始化，确保切换页面后不会有固定卡片留存</span></span><br><span class="line"><span class="title class_">RemoveFixedCardWidget</span>()</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建mobileReadingModeHideSidebar-js"><a href="#新建mobileReadingModeHideSidebar-js" class="headerlink" title="新建mobileReadingModeHideSidebar.js"></a>新建mobileReadingModeHideSidebar.js</h2><p>路径：<code>[Blogroot]\source\js\</code></p>
<p>这个文件用来控制阅读模式下的侧边栏按钮</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取要观察的目标元素</span></span><br><span class="line"><span class="keyword">const</span> targetNode = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Mutation Observer 实例并指定回调函数</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> mutation <span class="keyword">of</span> mutationsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;attributes&#x27;</span> &amp;&amp; mutation.<span class="property">attributeName</span> === <span class="string">&#x27;class&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> updatedBodyClassNames = mutation.<span class="property">target</span>.<span class="property">className</span>;</span><br><span class="line">      <span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#fixedcard-dashboard&#x27;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果找不到目标元素，直接返回</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> isMobileDevice = <span class="regexp">/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i</span>.<span class="title function_">test</span>(navigator.<span class="property">userAgent</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (isMobileDevice) &#123;</span><br><span class="line">        <span class="keyword">const</span> shouldHide = updatedBodyClassNames.<span class="title function_">includes</span>(<span class="string">&#x27;read-mode&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        target.<span class="property">style</span>.<span class="property">display</span> = shouldHide ? <span class="string">&#x27;none&#x27;</span> : <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shouldHide) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">          target.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;display&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设备不在移动端&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 在这里执行你希望进行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置观察选项（监视属性变化）</span></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察目标节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, config);</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建fixed-card-widget-styl"><a href="#新建fixed-card-widget-styl" class="headerlink" title="新建fixed_card_widget.styl"></a>新建<code>fixed_card_widget.styl</code></h2><p>路径：<code>[Blogroot]\themes\butterfly\source\css\_layout\</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垂直居中卡片样式（排除toc目录卡片）</span></span><br><span class="line"><span class="selector-class">.fixed-card-widget</span></span><br><span class="line">  <span class="selector-pseudo">&amp;:not</span>(#card-toc)</span><br><span class="line">    <span class="attribute">visibility</span> visible<span class="meta">!important</span></span><br><span class="line">    <span class="attribute">display</span> block<span class="meta">!important</span></span><br><span class="line">    <span class="attribute">position</span> fixed<span class="meta">!important</span></span><br><span class="line">    <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">    <span class="attribute">margin</span> auto</span><br><span class="line">    <span class="attribute">margin-bottom</span> auto<span class="meta">!important</span></span><br><span class="line">    <span class="attribute">margin-top</span> auto<span class="meta">!important</span></span><br><span class="line">    <span class="attribute">max-width</span> <span class="number">300px</span></span><br><span class="line">    <span class="attribute">max-height</span> <span class="number">500px</span></span><br><span class="line">    <span class="attribute">width</span> auto</span><br><span class="line">    <span class="attribute">height</span> auto</span><br><span class="line">    <span class="attribute">overflow-y</span>: scroll</span><br><span class="line">    <span class="attribute">z-index</span> <span class="number">999</span></span><br><span class="line">    <span class="attribute">animation</span> rotateX <span class="number">0.5s</span> ease</span><br><span class="line">    <span class="attribute">animation-fill-mode</span> forwards</span><br><span class="line">    &amp;::-webkit-scrollbar</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">0</span></span><br><span class="line"><span class="comment">// 针对说说卡片做样式兼容适配</span></span><br><span class="line"><span class="selector-class">.card-shuo</span></span><br><span class="line">  &amp;<span class="selector-class">.fixed-card-widget</span></span><br><span class="line">    <span class="selector-id">#artitalk_main</span></span><br><span class="line">      <span class="attribute">max-height</span> <span class="number">460px</span></span><br><span class="line">      <span class="attribute">overflow</span> scroll</span><br><span class="line">      &amp;::-webkit-scrollbar</span><br><span class="line">        <span class="attribute">display</span>: none</span><br><span class="line">    <span class="selector-id">#operare_artitalk</span></span><br><span class="line">      <span class="selector-class">.c2</span></span><br><span class="line">        <span class="attribute">z-index</span> <span class="number">1000</span></span><br><span class="line"><span class="comment">// 针对标签卡片做样式兼容适配</span></span><br><span class="line"><span class="selector-class">.card-tags</span></span><br><span class="line">  &amp;<span class="selector-class">.fixed-card-widget</span></span><br><span class="line">    <span class="selector-class">.card-tag-cloud</span></span><br><span class="line">      <span class="attribute">max-height</span> <span class="number">460px</span></span><br><span class="line">      <span class="attribute">overflow</span> scroll</span><br><span class="line">      &amp;::-webkit-scrollbar</span><br><span class="line">        <span class="attribute">display</span>: none</span><br><span class="line"><span class="comment">// 控制手机端可见</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)</span><br><span class="line">  div#fixedcard-dashboard</span><br><span class="line">    display flex!important</span><br><span class="line">// 侧栏悬浮按钮样式</span><br><span class="line">div#fixedcard-dashboard</span><br><span class="line">  position fixed</span><br><span class="line">  top <span class="number">150px</span></span><br><span class="line">  <span class="attribute">width</span> fit-content</span><br><span class="line">  <span class="attribute">height</span> <span class="number">40px</span></span><br><span class="line">  opacity <span class="number">0.3</span></span><br><span class="line">  transition all <span class="number">0.5s</span></span><br><span class="line">  display none</span><br><span class="line">  background rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>)</span><br><span class="line">  padding <span class="number">5px</span> <span class="number">10px</span></span><br><span class="line">  border-top-right-radius <span class="number">20px</span></span><br><span class="line">  border-bottom-right-radius <span class="number">20px</span></span><br><span class="line">  z-index <span class="number">1000</span></span><br><span class="line">  &amp;:<span class="attribute">hover</span></span><br><span class="line">    opacity <span class="number">1</span></span><br><span class="line">    button</span><br><span class="line">      &amp;.fixedcard-activebtn</span><br><span class="line">        <span class="attribute">width</span> <span class="number">30px</span></span><br><span class="line">        opacity <span class="number">1</span></span><br><span class="line">        pointer-events all</span><br><span class="line">// 按钮样式</span><br><span class="line">button</span><br><span class="line">  &amp;.fixedcard-activebtn</span><br><span class="line">    <span class="attribute">width</span> <span class="number">0px</span></span><br><span class="line">    <span class="attribute">height</span> <span class="number">30px</span></span><br><span class="line">    transition all .<span class="number">5s</span></span><br><span class="line">    display flex</span><br><span class="line">    opacity <span class="number">0</span></span><br><span class="line">    align-items center</span><br><span class="line">    justify-content space-around</span><br><span class="line">    pointer-events none</span><br><span class="line">    <span class="attribute">color</span> #<span class="number">757273</span></span><br><span class="line">// 悬浮按钮头像</span><br><span class="line">.fixedcard-user-avatar</span><br><span class="line">  display inline-block</span><br><span class="line">  img</span><br><span class="line">    &amp;.fixedcard-user-avatar-img</span><br><span class="line">      <span class="attribute">width</span> <span class="number">30px</span></span><br><span class="line">      <span class="attribute">height</span> <span class="number">30px</span></span><br><span class="line">      border-radius <span class="number">50%</span></span><br><span class="line">// 悬浮按钮夜间模式适配</span><br><span class="line">[data-theme=&quot;dark&quot;]</span><br><span class="line">  div#fixedcard-dashboard</span><br><span class="line">    background rgba(<span class="number">55</span>,<span class="number">55</span>,<span class="number">55</span>,<span class="number">0.9</span>)</span><br><span class="line">  button</span><br><span class="line">    &amp;.fixedcard-activebtn</span><br><span class="line">      <span class="attribute">color</span> #bcbdbd</span><br><span class="line"></span><br><span class="line">// 卡片开启动画效果</span><br><span class="line">@keyframes rotateX</span><br><span class="line">  from</span><br><span class="line">    transform rotateX(<span class="number">90deg</span>)</span><br><span class="line">  to</span><br><span class="line">    transform rotateX(<span class="number">0deg</span>)</span><br><span class="line">// 退出蒙版效果</span><br><span class="line">div#quit-box</span><br><span class="line">  position fixed</span><br><span class="line">  display block</span><br><span class="line">  left <span class="number">0</span></span><br><span class="line">  top <span class="number">0</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">100vh</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">100vh</span></span><br><span class="line">  z-index <span class="number">99</span></span><br><span class="line">  background rgba(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[data-theme=&quot;dark&quot;]</span><br><span class="line">  div#quit-box</span><br><span class="line">    background rgba(<span class="number">147</span>, <span class="number">146</span>, <span class="number">128</span>, <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建fixed-card-widget-pug"><a href="#新建fixed-card-widget-pug" class="headerlink" title="新建fixed_card_widget.pug"></a>新建<code>fixed_card_widget.pug</code></h2><p>路径：<code>[Blogroot]\themes\butterfly\layout\includes\custom\</code></p>
<p>以后的源码魔改教程都会尽量将改动文件归纳到带custom字样的文件夹里，便于管理魔改文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#fixedcard-dashboard</span><br><span class="line">  if is_post()</span><br><span class="line">    each poitem in theme.fixed_card_widget.post</span><br><span class="line">      button.fixedcard-activebtn(type=&quot;button&quot; title=poitem.title onclick=`FixedCardWidget(&quot;` + poitem.type + `&quot;,&quot;` + poitem.name + `&quot;,&quot;` + poitem.index + `&quot;)`)</span><br><span class="line">        i(class=poitem.icon)</span><br><span class="line">  else</span><br><span class="line">    each paitem in theme.fixed_card_widget.page</span><br><span class="line">      button.fixedcard-activebtn(type=&quot;button&quot; title=paitem.title onclick=`FixedCardWidget(&quot;` + paitem.type + `&quot;,&quot;` + paitem.name + `&quot;,&quot;` + paitem.index + `&quot;)`)</span><br><span class="line">        i(class=paitem.icon)</span><br><span class="line">  .fixedcard-user-avatar.fixedcard-activebtn(onclick=&quot;RemoveFixedCardWidget()&quot;)</span><br><span class="line">    img.fixedcard-user-avatar-img(src=url_for(theme.avatar.img) title=config.author)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改additional-js-pug"><a href="#修改additional-js-pug" class="headerlink" title="修改additional-js.pug"></a>修改<code>additional-js.pug</code></h2><p>路径：<code>[Blogroot]\themes\butterfly\layout\includes\</code></p>
<p>直接加在文件末尾即可，但是注意缩进！</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  if theme.busuanzi.site_uv || theme.busuanzi.site_pv || theme.busuanzi.page_pv</span><br><span class="line">    script(async data-pjax src=url_for(theme.CDN.busuanzi))</span><br><span class="line"><span class="addition">+ if !theme.aside.mobile &amp;&amp; theme.fixed_card_widget.enable</span></span><br><span class="line"><span class="addition">+   include ./custom/fixed_card_widget.pug</span></span><br></pre></td></tr></table></figure>
<p>因为还做了page和post页面不同悬浮按钮的配置，为了让它能够自动切换而不是惰性加载，需要修改<code>[Blogroot]\themes\butterfly\layout\includes\third-party\pjax.pug</code>大约第十四行的位置，在pjax选择器中加入悬浮按钮的id。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  script.</span><br><span class="line">    let pjaxSelectors = [</span><br><span class="line">      &#x27;title&#x27;,</span><br><span class="line">      &#x27;#config-diff&#x27;,</span><br><span class="line">      &#x27;#body-wrap&#x27;,</span><br><span class="line">      &#x27;#rightside-config-hide&#x27;,</span><br><span class="line">      &#x27;#rightside-config-show&#x27;,</span><br><span class="line"><span class="addition">+     &quot;#fixedcard-dashboard&quot;,</span></span><br><span class="line">      &#x27;.js-pjax&#x27;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改<code>_config.butterfly.yml</code></h2><p>新增配置项，此处的选择器其实就是提取了<code>document.getElementsByClassName(&quot;name&quot;)[index]</code>和<code>document.getElementById(&quot;name&quot;)</code>这两个方法中的参数来确保能够找到侧栏卡片。原本其实是可以做成自动根据侧栏生成的，但是考虑到还有插件挂载和自定义卡片，以及还有部分用户会刻意隐藏一些侧栏卡片，所以干脆还是让用户自己去配置想要加到菜单的卡片好了。<br>找id或者class的办法很简单，用F12开启控制台，用左上角的元素选择器点选想要的侧栏卡片，在源码栏找到对应的class或者id。因为class是可以重名的，所以还存在一个序列问题，从0开始计数。此处为了避免语意混乱，建议还是用特征明显的class或者id来选择对应卡片。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#侧栏悬浮卡片控制按钮</span></span><br><span class="line"><span class="comment">#https://akilar.top/posts/451ac5f8/</span></span><br><span class="line"><span class="attr">fixed_card_widget:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span>  <span class="comment">#页面显示按钮</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span> <span class="comment">#侧栏卡片选择器类型</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-info</span> <span class="comment">#侧栏卡片选择器名称</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span> <span class="comment">#侧栏卡片选择器序列</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-address-book</span> <span class="comment">#图标</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">用户信息</span> <span class="comment">#悬停显示提示</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-clock</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-cloud-sun</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">电子钟</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-history</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-calendar</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">那年今日</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-visitor</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-earth-americas</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">来访者</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-recent-post</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-history</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">最新文章</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-newest-comments</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-comment-dots</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">最新评论</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-tags</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-categories</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-table-list</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">post:</span> <span class="comment">#文章页显示按钮</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-info</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-address-book</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">用户信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-recent-post</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-history</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">最新文章</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">class</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">card-visitor</span></span><br><span class="line">      <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-earth-americas</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">来访者</span></span><br></pre></td></tr></table></figure>
<p>inject配置项</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  inject:</span><br><span class="line">    head:</span><br><span class="line"></span><br><span class="line">    bottom:</span><br><span class="line"><span class="addition">+     - &lt;script data-pjax defer src=&quot;/js/hideAsideOnMobile.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+     - &lt;script src=&quot;/js/mobileReadingModeHideSidebar.js&quot; async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>关闭手机端显示侧栏卡片才能启用fixed卡片样式</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  aside:</span><br><span class="line">    enable: true</span><br><span class="line">    hide: false</span><br><span class="line">    button: true</span><br><span class="line"><span class="deletion">-   mobile: true # display on mobile</span></span><br><span class="line"><span class="addition">+   mobile: false # display on mobile</span></span><br><span class="line">    position: right # left or right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《文章标签外挂》</title>
    <url>/posts/79175f37/</url>
    <content><![CDATA[<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在博客根目录下打开终端，运行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-tag-plugins-plus --save</span><br></pre></td></tr></table></figure>
<p>考虑到hexo自带的markdown渲染插件<code>hexo-renderer-marked</code>与外挂标签语法的兼容性较差，建议您将其替换成<code>hexo-renderer-kramed</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><p>在站点配置文件<code>_config.yml</code>中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tag-plugins-plus</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/615e2dec/</span></span><br><span class="line"><span class="attr">tag_plugins:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">issues:</span> <span class="literal">false</span> <span class="comment">#issues标签依赖注入开关</span></span><br><span class="line">  <span class="attr">link:</span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">/img/link.png</span> <span class="comment">#link_card标签默认的图标图片</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br><span class="line">    <span class="attr">anima:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css</span> <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">    <span class="attr">jquery:</span> <span class="string">https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">issues:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/issues.js</span> <span class="comment">#issues标签依赖</span></span><br><span class="line">    <span class="attr">iconfont:</span> <span class="string">//at.alicdn.com/t/font_2032782_8d5kxvn09md.js</span> <span class="comment">#参看https://akilar.top/posts/d2ebecef/</span></span><br><span class="line">    <span class="attr">carousel:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js</span></span><br><span class="line">    <span class="attr">tag_plugins_css:</span> <span class="string">https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="参数释义"><a href="#参数释义" class="headerlink" title="参数释义"></a>参数释义</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">备选值/类型</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">enable</td>
<td style="text-align:left">true/false</td>
<td style="text-align:left">【必选】控制开关</td>
</tr>
<tr>
<td style="text-align:left">priority</td>
<td style="text-align:left">number</td>
<td style="text-align:left">【可选】过滤器优先级，数值越小，执行越早，默认为10，选填</td>
</tr>
<tr>
<td style="text-align:left">issues</td>
<td style="text-align:left">true/false</td>
<td style="text-align:left">【可选】issues标签控制开关，默认为false</td>
</tr>
<tr>
<td style="text-align:left">link.placeholder</td>
<td style="text-align:left">【必选】link卡片外挂标签的默认图标</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">CDN.anima</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】动画标签anima的依赖</td>
</tr>
<tr>
<td style="text-align:left">CDN.jquery</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】issues标签依赖</td>
</tr>
<tr>
<td style="text-align:left">CDN.issues</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】issues标签依赖</td>
</tr>
<tr>
<td style="text-align:left">CDN.iconfont</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】iconfont标签symbol样式引入，如果不想引入，则设为false</td>
</tr>
<tr>
<td style="text-align:left">CDN.carousel</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】carousel旋转相册标签鼠标拖动依赖，如果不想引入则设为false</td>
</tr>
<tr>
<td style="text-align:left">CDN.tag_plugins_css</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">【可选】外挂标签样式的CSS依赖，为避免CDN缓存延迟，建议将@latest改为具体版本号</td>
</tr>
</tbody>
</table>
</div>
<p><br/></p>
<h2 id="所有的示例"><a href="#所有的示例" class="headerlink" title="所有的示例"></a>所有的示例</h2><h3 id="行内文本样式TEXT"><a href="#行内文本样式TEXT" class="headerlink" title="行内文本样式TEXT"></a>行内文本样式TEXT</h3><div class="tabs" id="行内文本样式text"><ul class="nav-tabs"><button type="button" class="tab " data-href="行内文本样式text-1">标签语法</button><button type="button" class="tab " data-href="行内文本样式text-2">参数配置</button><button type="button" class="tab  active" data-href="行内文本样式text-3">样式预览</button><button type="button" class="tab " data-href="行内文本样式text-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="行内文本样式text-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="行内文本样式text-2"></div><div class="tab-item-content active" id="行内文本样式text-3"><ol>
<li>带 <u>下划线</u> 的文本</li>
<li>带 <emp>着重号</emp> 的文本</li>
<li>带 <wavy>波浪线</wavy> 的文本</li>
<li>带 <del>删除线</del> 的文本</li>
<li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li>
<li>密码样式的文本：<psw>这里没有验证码</psw></li>
</ol></div><div class="tab-item-content" id="行内文本样式text-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="段落文本P"><a href="#段落文本P" class="headerlink" title="段落文本P"></a>段落文本P</h3><div class="tabs" id="段落文本p"><ul class="nav-tabs"><button type="button" class="tab " data-href="段落文本p-1">标签语法</button><button type="button" class="tab " data-href="段落文本p-2">参数配置</button><button type="button" class="tab  active" data-href="段落文本p-3">样式预览</button><button type="button" class="tab " data-href="段落文本p-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="段落文本p-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="段落文本p-2"><ol>
<li>字体: logo, code</li>
<li>颜色: red,yellow,green,cyan,blue,gray</li>
<li>大小: small, h4, h3, h2, h1, large, huge, ultra</li>
<li>对齐方向: left, center, right</li>
</ol></div><div class="tab-item-content active" id="段落文本p-3"><ul>
<li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li>
<li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p>
<p class='p center small'>A Wonderful Theme for Hexo</p>

</li>
</ul></div><div class="tab-item-content" id="段落文本p-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="引用-note"><a href="#引用-note" class="headerlink" title="引用 note"></a>引用 note</h3><div class="tabs" id="引用-note"><ul class="nav-tabs"><button type="button" class="tab " data-href="引用-note-1">通用配置</button><button type="button" class="tab " data-href="引用-note-2">语法格式</button><button type="button" class="tab " data-href="引用-note-3">参数配置</button><button type="button" class="tab  active" data-href="引用-note-4">样式预览</button><button type="button" class="tab " data-href="引用-note-5">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="引用-note-1"><p>修改主题配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>Note</code>标签外挂有两种用法。<code>icons</code>和<code>light_bg_offset</code>只对方法一生效</p></div><div class="tab-item-content" id="引用-note-2"><details class="folding-tag" open><summary> 方法一 </summary>
              <div class='content'>
              <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>



<details class="folding-tag" ><summary> 方法二 </summary>
              <div class='content'>
              <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details></div><div class="tab-item-content" id="引用-note-3"><details class="folding-tag" open><summary> 方法一 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td style="text-align:left">no-icon</td><td style="text-align:left">【可选】不显示 icon</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div>
              </div>
            </details>



<details class="folding-tag" ><summary> 方法二 </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td style="text-align:left">no-icon</td><td style="text-align:left">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table></div>
              </div>
            </details></div><div class="tab-item-content active" id="引用-note-4"><details class="folding-tag" open><summary> 方法一 </summary>
              <div class='content'>
              <ol><li><p><code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div></li><li><p><code>modern</code>样式</p><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div></li><li><p><code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div></li><li><p><code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div></li><li><p><code>no-icon</code>样式</p><div class="note no-icon simple"><p>默认 提示块标签</p></div><div class="note default no-icon simple"><p>default 提示块标签</p></div><div class="note primary no-icon simple"><p>primary 提示块标签</p></div><div class="note success no-icon simple"><p>success 提示块标签</p></div><div class="note info no-icon simple"><p>info 提示块标签</p></div><div class="note warning no-icon simple"><p>warning 提示块标签</p></div><div class="note danger no-icon simple"><p>danger 提示块标签</p></div></li></ol>
              </div>
            </details>



<details class="folding-tag" ><summary> 方法二 </summary>
              <div class='content'>
              <ol><li><p><code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div></li><li><p><code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div></li><li><p><code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div></li><li><p><code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div></li><li><p><code>no-icon</code>样式</p><div class="note no-icon simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon simple"><p>2021年快到了….</p></div><div class="note pink no-icon simple"><p>小心开车 安全至上</p></div><div class="note red no-icon simple"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon simple"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon simple"><p>剪刀石头布</p></div><div class="note green no-icon simple"><p>前端最讨厌的浏览器</p></div></li></ol>
              </div>
            </details></div><div class="tab-item-content" id="引用-note-5"><details class="folding-tag" open><summary> 方法一 </summary>
              <div class='content'>
              <ol><li><p><code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details>



<details class="folding-tag" ><summary> 方法二 </summary>
              <div class='content'>
              <ol><li><p><code>simple</code>样式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p><code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="上标标签Tip"><a href="#上标标签Tip" class="headerlink" title="上标标签Tip"></a>上标标签Tip</h3><div class="tabs" id="上标标签tip"><ul class="nav-tabs"><button type="button" class="tab " data-href="上标标签tip-1">标签语法</button><button type="button" class="tab " data-href="上标标签tip-2">参数配置</button><button type="button" class="tab  active" data-href="上标标签tip-3">样式预览</button><button type="button" class="tab " data-href="上标标签tip-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="上标标签tip-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="上标标签tip-2"><ol>
<li>样式: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li>
<li>自定义图标: 支持fontawesome。</li>
</ol></div><div class="tab-item-content active" id="上标标签tip-3"><div class="tip "><p>default</p>
</div>
<div class="tip info"><p>info</p>
</div>
<div class="tip success"><p>success</p>
</div>
<div class="tip error"><p>error</p>
</div>
<div class="tip warning"><p>warning</p>
</div>
<div class="tip bolt"><p>bolt</p>
</div>
<div class="tip ban"><p>ban</p>
</div>
<div class="tip home"><p>home</p>
</div>
<div class="tip sync"><p>sync</p>
</div>
<div class="tip cogs"><p>cogs</p>
</div>
<div class="tip key"><p>key</p>
</div>
<div class="tip bell"><p>bell</p>
</div>
<div class="tip fa-atom"><p>自定义font awesome图标</p>
</div></div><div class="tab-item-content" id="上标标签tip-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="动态标签Anima"><a href="#动态标签Anima" class="headerlink" title="动态标签Anima"></a>动态标签Anima</h3><div class="tabs" id="动态标签anima"><ul class="nav-tabs"><button type="button" class="tab " data-href="动态标签anima-1">标签语法</button><button type="button" class="tab " data-href="动态标签anima-2">参数配置</button><button type="button" class="tab  active" data-href="动态标签anima-3">样式预览</button><button type="button" class="tab " data-href="动态标签anima-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="动态标签anima-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="动态标签anima-2"><p>更多详情请参看<a href="http://l-lin.github.io/font-awesome-animation/">font-awesome-animation文档</a></p>
<ol>
<li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li>
<li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li>
<li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">On DOM load 当页面加载时 显示动画</th>
<th style="text-align:left">On hover 当鼠标悬停时 显示动画</th>
<th style="text-align:left">On parent hover 当鼠标悬停 在父级元素时 显示动画</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">faa-wrench animated</td>
<td style="text-align:left">faa-wrench animated-hover</td>
<td style="text-align:left">faa-wrench</td>
</tr>
<tr>
<td style="text-align:left">faa-ring animated</td>
<td style="text-align:left">faa-ring animated-hover</td>
<td style="text-align:left">faa-ring</td>
</tr>
<tr>
<td style="text-align:left">faa-horizontal animated</td>
<td style="text-align:left">faa-horizontal animated-hover</td>
<td style="text-align:left">faa-horizontal</td>
</tr>
<tr>
<td style="text-align:left">faa-vertical animated</td>
<td style="text-align:left">faa-vertical animated-hover</td>
<td style="text-align:left">faa-vertical</td>
</tr>
<tr>
<td style="text-align:left">faa-flash animated</td>
<td style="text-align:left">faa-flash animated-hover</td>
<td style="text-align:left">faa-flash</td>
</tr>
<tr>
<td style="text-align:left">faa-bounce animated</td>
<td style="text-align:left">faa-bounce animated-hover</td>
<td style="text-align:left">faa-bounce</td>
</tr>
<tr>
<td style="text-align:left">faa-spin animated</td>
<td style="text-align:left">faa-spin animated-hover</td>
<td style="text-align:left">faa-spin</td>
</tr>
<tr>
<td style="text-align:left">faa-tada animated</td>
<td style="text-align:left">faa-tada animated-hover</td>
<td style="text-align:left">faa-tada</td>
</tr>
<tr>
<td style="text-align:left">faa-pulse animated</td>
<td style="text-align:left">faa-pulse animated-hover</td>
<td style="text-align:left">faa-pulse</td>
</tr>
<tr>
<td style="text-align:left">faa-shake animated</td>
<td style="text-align:left">faa-shake animated-hover</td>
<td style="text-align:left">faa-shake</td>
</tr>
<tr>
<td style="text-align:left">faa-tada animated</td>
<td style="text-align:left">faa-tada animated-hover</td>
<td style="text-align:left">faa-tada</td>
</tr>
<tr>
<td style="text-align:left">faa-passing animated</td>
<td style="text-align:left">faa-passing animated-hover</td>
<td style="text-align:left">faa-passing</td>
</tr>
<tr>
<td style="text-align:left">faa-passing-reverse animated</td>
<td style="text-align:left">faa-passing-reverse animated-hover</td>
<td style="text-align:left">faa-passing-reverse</td>
</tr>
<tr>
<td style="text-align:left">faa-burst animated</td>
<td style="text-align:left">faa-burst animated-hover</td>
<td style="text-align:left">faa-burst</td>
</tr>
<tr>
<td style="text-align:left">faa-falling animated</td>
<td style="text-align:left">faa-falling animated-hover</td>
<td style="text-align:left">faa-falling</td>
</tr>
<tr>
<td style="text-align:left">faa-rising animated</td>
<td style="text-align:left">faa-rising animated-hover</td>
<td style="text-align:left">faa-rising</td>
</tr>
</tbody>
</table>
</div></div><div class="tab-item-content active" id="动态标签anima-3"><ol>
<li><p>On DOM load（当页面加载时显示动画）</p>
<div class="tip warning faa-horizontal animated"><p>warning</p>
</div>
<div class="tip ban faa-flash animated"><p>ban</p>
</div>
</li>
<li><p>调整动画速度</p>
<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p>
</div>
<div class="tip ban faa-flash animated faa-slow"><p>ban</p>
</div>
</li>
<li><p>On hover（当鼠标悬停时显示动画）</p>
<div class="tip warning faa-horizontal animated-hover"><p>warning</p>
</div>
<div class="tip ban faa-flash animated-hover"><p>ban</p>
</div>
</li>
<li><p>On parent hover（当鼠标悬停在父级元素时显示动画）</p>
<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div>
<div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div>

</li>
</ol></div><div class="tab-item-content" id="动态标签anima-4"><ol>
<li><p>On DOM load（当页面加载时显示动画）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>调整动画速度</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>On hover（当鼠标悬停时显示动画）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>On parent hover（当鼠标悬停在父级元素时显示动画）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="复选列表-checkbox"><a href="#复选列表-checkbox" class="headerlink" title="复选列表 checkbox"></a>复选列表 checkbox</h3><div class="tabs" id="复选列表-checkbox"><ul class="nav-tabs"><button type="button" class="tab " data-href="复选列表-checkbox-1">标签语法</button><button type="button" class="tab " data-href="复选列表-checkbox-2">参数配置</button><button type="button" class="tab  active" data-href="复选列表-checkbox-3">样式预览</button><button type="button" class="tab " data-href="复选列表-checkbox-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="复选列表-checkbox-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="复选列表-checkbox-2"><ol>
<li>样式: plus, minus, times</li>
<li>颜色: red,yellow,green,cyan,blue,gray</li>
<li>选中状态: checked</li>
</ol></div><div class="tab-item-content active" id="复选列表-checkbox-3"><div class='checkbox'><input type="checkbox" />
            <p>纯文本测试</p>
            </div>
<div class='checkbox checked'><input type="checkbox" checked="checked"/>
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class='checkbox red'><input type="checkbox" />
            <p>支持自定义颜色</p>
            </div>
<div class='checkbox green checked'><input type="checkbox" checked="checked"/>
            <p>绿色 + 默认选中</p>
            </div>
<div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>
            <p>黄色 + 默认选中</p>
            </div>
<div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>
            <p>青色 + 默认选中</p>
            </div>
<div class='checkbox blue checked'><input type="checkbox" checked="checked"/>
            <p>蓝色 + 默认选中</p>
            </div>
<div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>
            <p>增加</p>
            </div>
<div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>
            <p>减少</p>
            </div>
<div class='checkbox times red checked'><input type="checkbox" checked="checked"/>
            <p>叉</p>
            </div></div><div class="tab-item-content" id="复选列表-checkbox-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="单选列表-radio"><a href="#单选列表-radio" class="headerlink" title="单选列表 radio"></a>单选列表 radio</h3><div class="tabs" id="单选列表-radio"><ul class="nav-tabs"><button type="button" class="tab " data-href="单选列表-radio-1">标签语法</button><button type="button" class="tab " data-href="单选列表-radio-2">参数配置</button><button type="button" class="tab  active" data-href="单选列表-radio-3">样式预览</button><button type="button" class="tab " data-href="单选列表-radio-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="单选列表-radio-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="单选列表-radio-2"><ol>
<li>颜色: red,yellow,green,cyan,blue,gray</li>
<li>选中状态: checked</li>
</ol></div><div class="tab-item-content active" id="单选列表-radio-3"><div class='checkbox'><input type="radio" />
            <p>纯文本测试</p>
            </div>
<div class='checkbox checked'><input type="radio" checked="checked"/>
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class='checkbox red'><input type="radio" />
            <p>支持自定义颜色</p>
            </div>
<div class='checkbox green'><input type="radio" />
            <p>绿色</p>
            </div>
<div class='checkbox yellow'><input type="radio" />
            <p>黄色</p>
            </div>
<div class='checkbox cyan'><input type="radio" />
            <p>青色</p>
            </div>
<div class='checkbox blue'><input type="radio" />
            <p>蓝色</p>
            </div></div><div class="tab-item-content" id="单选列表-radio-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="时间轴-timeline"><a href="#时间轴-timeline" class="headerlink" title="时间轴 timeline"></a>时间轴 timeline</h3><div class="tabs" id="时间轴-timeline"><ul class="nav-tabs"><button type="button" class="tab " data-href="时间轴-timeline-1">标签语法</button><button type="button" class="tab " data-href="时间轴-timeline-2">参数配置</button><button type="button" class="tab  active" data-href="时间轴-timeline-3">样式预览</button><button type="button" class="tab " data-href="时间轴-timeline-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="时间轴-timeline-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="时间轴-timeline-2"><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left">标题/时间线</td>
</tr>
<tr>
<td style="text-align:left">color</td>
<td style="text-align:left"><code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</td>
</tr>
</tbody>
</table>
</div></div><div class="tab-item-content active" id="时间轴-timeline-3"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p>
</div></div><div class='timeline-item-content'><ol>
<li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li>
<li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li>
<li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li>
<li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li>
<li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li>
</ol>
</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p>
</div></div><div class='timeline-item-content'><p>不需要额外处理。</p>
</div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p>
</div></div><div class='timeline-item-content'><ol>
<li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li>
<li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li>
<li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li>
</ol>
</div></div></div></div><div class="tab-item-content" id="时间轴-timeline-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="链接卡片-link"><a href="#链接卡片-link" class="headerlink" title="链接卡片 link"></a>链接卡片 link</h3><div class="tabs" id="链接卡片-link"><ul class="nav-tabs"><button type="button" class="tab " data-href="链接卡片-link-1">标签语法</button><button type="button" class="tab  active" data-href="链接卡片-link-2">样式预览</button><button type="button" class="tab " data-href="链接卡片-link-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="链接卡片-link-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="链接卡片-link-2"><div class="tag link"><a class="link-card" title="Nanami" href="https://wutiaowu5t5.github.io/"><div class="left"><img src="https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg"/></div><div class="right"><p class="text">Nanami</p><p class="url">https://wutiaowu5t5.github.io/</p></div></a></div></div><div class="tab-item-content" id="链接卡片-link-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% link Nanami, https://wutiaowu5t5.github.io/, https://s2.loli.net/2023/12/29/7htnI1LMOY4WCTF.jpg %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="按钮-btns"><a href="#按钮-btns" class="headerlink" title="按钮 btns"></a>按钮 btns</h3><div class="tabs" id="按钮-btns"><ul class="nav-tabs"><button type="button" class="tab " data-href="按钮-btns-1">标签语法</button><button type="button" class="tab " data-href="按钮-btns-2">参数配置</button><button type="button" class="tab  active" data-href="按钮-btns-3">样式预览</button><button type="button" class="tab " data-href="按钮-btns-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="按钮-btns-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="按钮-btns-2"><ol>
<li>圆角样式：rounded, circle</li>
<li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;标题&lt;/b&gt;</code>和<code>&lt;p&gt;描述文字&lt;/p&gt;</code></li>
<li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">wide</td>
<td style="text-align:left">宽一点的按钮</td>
</tr>
<tr>
<td style="text-align:left">fill</td>
<td style="text-align:left">填充布局，自动铺满至少一行，多了会换行</td>
</tr>
<tr>
<td style="text-align:left">center</td>
<td style="text-align:left">居中，按钮之间是固定间距</td>
</tr>
<tr>
<td style="text-align:left">around</td>
<td style="text-align:left">居中分散</td>
</tr>
<tr>
<td style="text-align:left">grid2</td>
<td style="text-align:left">等宽最多2列，屏幕变窄会适当减少列数</td>
</tr>
<tr>
<td style="text-align:left">grid3</td>
<td style="text-align:left">等宽最多3列，屏幕变窄会适当减少列数</td>
</tr>
<tr>
<td style="text-align:left">grid4</td>
<td style="text-align:left">等宽最多4列，屏幕变窄会适当减少列数</td>
</tr>
<tr>
<td style="text-align:left">grid5</td>
<td style="text-align:left">等宽最多5列，屏幕变窄会适当减少列数</td>
</tr>
</tbody>
</table>
</div></div><div class="tab-item-content active" id="按钮-btns-3"><ol>
<li>如果需要显示类似「团队成员」之类的一组含有头像的链接：<div class="btns circle grid5">
         <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>
<a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>
<a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>
<a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>
<a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>
       </div></li>
<li>或者含有图标的按钮：<div class="btns rounded grid5">
         <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a>
<a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>
       </div></li>
<li>圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">
         <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>
<i class='fab fa-apple'></i>
<b>心率管家</b>
<p class='p red'>专业版</p>
<img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png'>
</a>
<a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>
<i class='fab fa-apple'></i>
<b>心率管家</b>
<p class='p green'>免费版</p>
<img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png'>
</a>
       </div>

</li>
</ol></div><div class="tab-item-content" id="按钮-btns-4"><ol>
<li><p>如果需要显示类似「团队成员」之类的一组含有头像的链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者含有图标的按钮：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="github卡片-ghcard"><a href="#github卡片-ghcard" class="headerlink" title="github卡片 ghcard"></a>github卡片 ghcard</h3><div class="tabs" id="github卡片-ghcard"><ul class="nav-tabs"><button type="button" class="tab " data-href="github卡片-ghcard-1">标签语法</button><button type="button" class="tab " data-href="github卡片-ghcard-2">参数配置</button><button type="button" class="tab  active" data-href="github卡片-ghcard-3">样式预览</button><button type="button" class="tab " data-href="github卡片-ghcard-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="github卡片-ghcard-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="github卡片-ghcard-2"><p>更多参数可以参考：<br><a href="https://github.com/anuraghazra/github-readme-stats"><img src="https://github-readme-stats.vercel.app/api/pin/?username=anuraghazra&amp;repo=github-readme-stats&amp;show_owner=true" alt="img"></a><br>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code>，以下只写几个常用参数值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">取值</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hide</td>
<td style="text-align:left">stars,commits,prs,issues,contribs</td>
<td style="text-align:left">隐藏指定统计</td>
</tr>
<tr>
<td style="text-align:left">count_private</td>
<td style="text-align:left">true</td>
<td style="text-align:left">将私人项目贡献添加到总提交计数中</td>
</tr>
<tr>
<td style="text-align:left">show_icons</td>
<td style="text-align:left">true</td>
<td style="text-align:left">显示图标</td>
</tr>
<tr>
<td style="text-align:left">theme</td>
<td style="text-align:left">请查阅<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td>
<td style="text-align:left">主题</td>
</tr>
</tbody>
</table>
</div></div><div class="tab-item-content active" id="github卡片-ghcard-3"><ol>
<li><p>用户信息卡片</p>
<p> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=vue&show_owner=true"/></a><br> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=buefy&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-light&show_owner=true"/></a><br> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=onedark&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=solarized-dark&show_owner=true"/></a><br> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=algolia&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu"><img src="https://github-readme-stats.vercel.app/api/?username=xaoxuu&theme=calm&show_owner=true"/></a> </p>
</li>
<li><p>仓库信息卡片</p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a> </p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a> </p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a> </p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a> </p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></p>
<p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a> <a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a> </p>
<div class="btns rounded grid5">
         <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>
       </div>

</li>
</ol></div><div class="tab-item-content" id="github卡片-ghcard-4"><ol>
<li><p>用户信息卡片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% ghcard xaoxuu %&#125; &#123;% ghcard xaoxuu, theme=vue %&#125;</span><br><span class="line">&#123;% ghcard xaoxuu, theme=buefy %&#125; &#123;% ghcard xaoxuu, theme=solarized-light %&#125;</span><br><span class="line">&#123;% ghcard xaoxuu, theme=onedark %&#125; &#123;% ghcard xaoxuu, theme=solarized-dark %&#125;</span><br><span class="line">&#123;% ghcard xaoxuu, theme=algolia %&#125; &#123;% ghcard xaoxuu, theme=calm %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>仓库信息卡片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; </span><br><span class="line"></span><br><span class="line">&#123;% btns rounded grid5 %&#125;&#123;% cell 下载源码, /, fas fa-download %&#125;&#123;% cell 查看文档, /, fas fa-book-open %&#125;&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="github徽标-ghbdage"><a href="#github徽标-ghbdage" class="headerlink" title="github徽标 ghbdage"></a>github徽标 ghbdage</h3><div class="tabs" id="github徽标-ghbdage"><ul class="nav-tabs"><button type="button" class="tab " data-href="github徽标-ghbdage-1">标签语法</button><button type="button" class="tab " data-href="github徽标-ghbdage-2">参数配置</button><button type="button" class="tab  active" data-href="github徽标-ghbdage-3">样式预览</button><button type="button" class="tab " data-href="github徽标-ghbdage-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="github徽标-ghbdage-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="github徽标-ghbdage-2"><ol>
<li><code>left</code>：徽标左边的信息，必选参数。</li>
<li><code>right</code>: 徽标右边的信息，必选参数，</li>
<li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li>
<li><code>color</code>：徽标右边的颜色，可选参数。</li>
<li><code>link</code>：指向的链接，可选参数。</li>
<li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li>
<li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li>
</ol></div><div class="tab-item-content active" id="github徽标-ghbdage-3"><ol>
<li><p>基本参数,定义徽标左右文字和图标</p>
<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object>
<object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object>
</li>
<li><p>信息参数，定义徽标右侧内容背景色，指向链接</p>
<object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object>
</li>
<li><p>拓展参数，支持shields的API的全部参数内容</p>
<object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object>

</li>
</ol></div><div class="tab-item-content" id="github徽标-ghbdage-4"><ol>
<li><p>基本参数,定义徽标左右文字和图标</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息参数，定义徽标右侧内容背景色，指向链接</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拓展参数，支持shields的API的全部参数内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="网站卡片-sites"><a href="#网站卡片-sites" class="headerlink" title="网站卡片 sites"></a>网站卡片 sites</h3><div class="tabs" id="网站卡片-sites"><ul class="nav-tabs"><button type="button" class="tab " data-href="网站卡片-sites-1">标签语法</button><button type="button" class="tab  active" data-href="网站卡片-sites-2">样式预览</button><button type="button" class="tab " data-href="网站卡片-sites-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="网站卡片-sites-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="网站卡片-sites-2"><div class="site-card-group"><a class="site-card" href="https://xaoxuu.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png"/><span class="title">xaoxuu</span><span class="desc">简约风格</span></div></a>
<a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a>
<a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a>
<a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a>
<a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div></div><div class="tab-item-content" id="网站卡片-sites-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="行内图片-inlineimage"><a href="#行内图片-inlineimage" class="headerlink" title="行内图片 inlineimage"></a>行内图片 inlineimage</h3><div class="tabs" id="行内图片-inlineimage"><ul class="nav-tabs"><button type="button" class="tab " data-href="行内图片-inlineimage-1">标签语法</button><button type="button" class="tab " data-href="行内图片-inlineimage-2">参数配置</button><button type="button" class="tab  active" data-href="行内图片-inlineimage-3">样式预览</button><button type="button" class="tab " data-href="行内图片-inlineimage-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="行内图片-inlineimage-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="行内图片-inlineimage-2"><ol>
<li>高度：height=20px</li>
</ol></div><div class="tab-item-content active" id="行内图片-inlineimage-3"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p>
<p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p></div><div class="tab-item-content" id="行内图片-inlineimage-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="单张图片-image"><a href="#单张图片-image" class="headerlink" title="单张图片 image"></a>单张图片 image</h3><div class="tabs" id="单张图片-image"><ul class="nav-tabs"><button type="button" class="tab " data-href="单张图片-image-1">标签语法</button><button type="button" class="tab " data-href="单张图片-image-2">参数配置</button><button type="button" class="tab  active" data-href="单张图片-image-3">样式预览</button><button type="button" class="tab " data-href="单张图片-image-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="单张图片-image-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="单张图片-image-2"><ol>
<li>图片宽度高度：width=300px, height=32px</li>
<li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li>
<li>占位背景色：bg=#f2f2f2</li>
</ol></div><div class="tab-item-content active" id="单张图片-image-3"><ol>
<li><p>添加描述：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>
</li>
<li><p>指定宽度：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>
</li>
<li><p>指定宽度并添加描述：</p>
<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>
</li>
<li><p>设置占位背景色：</p>
<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div>

</li>
</ol></div><div class="tab-item-content" id="单张图片-image-4"><ol>
<li><p>添加描述：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定宽度：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定宽度并添加描述：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置占位背景色：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h3><div class="tabs" id="音频-audio"><ul class="nav-tabs"><button type="button" class="tab " data-href="音频-audio-1">标签语法</button><button type="button" class="tab  active" data-href="音频-audio-2">样式预览</button><button type="button" class="tab " data-href="音频-audio-3">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="音频-audio-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content active" id="音频-audio-2"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div></div><div class="tab-item-content" id="音频-audio-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="视频-video"><a href="#视频-video" class="headerlink" title="视频 video"></a>视频 video</h3><div class="tabs" id="视频-video"><ul class="nav-tabs"><button type="button" class="tab " data-href="视频-video-1">标签语法</button><button type="button" class="tab " data-href="视频-video-2">参数配置</button><button type="button" class="tab  active" data-href="视频-video-3">样式预览</button><button type="button" class="tab " data-href="视频-video-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="视频-video-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="视频-video-2"><ol>
<li>对其方向：left, center, right</li>
<li>列数：逗号后面直接写列数，支持 1 ～ 4 列。</li>
</ol></div><div class="tab-item-content active" id="视频-video-3"><ol>
<li><p>100%宽度</p>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
</li>
<li><p>50%宽度</p>
<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>
</li>
<li><p>25%宽度</p>
<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>
<div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>

</li>
</ol></div><div class="tab-item-content" id="视频-video-4"><ol>
<li><p>100%宽度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>50%宽度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>25%宽度</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="折叠框-folding"><a href="#折叠框-folding" class="headerlink" title="折叠框 folding"></a>折叠框 folding</h3><div class="tabs" id="折叠框-folding"><ul class="nav-tabs"><button type="button" class="tab " data-href="折叠框-folding-1">标签语法</button><button type="button" class="tab " data-href="折叠框-folding-2">参数配置</button><button type="button" class="tab  active" data-href="折叠框-folding-3">样式预览</button><button type="button" class="tab " data-href="折叠框-folding-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="折叠框-folding-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="折叠框-folding-2"><ol>
<li>颜色：blue, cyan, green, yellow, red</li>
<li>状态：状态填写 open 代表默认打开。</li>
</ol></div><div class="tab-item-content active" id="折叠框-folding-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>
              <div class='content'>
              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>
              </div>
            </details>

<details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>
              <div class='content'>
              <p>这是一个默认打开的折叠框。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>假装这里有代码块（代码块没法嵌套代码块）</p>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 查看列表测试 </summary>
              <div class='content'>
              <ul><li>haha</li><li>hehe</li></ul>
              </div>
            </details>

<details class="folding-tag" red><summary> 查看嵌套测试 </summary>
              <div class='content'>
              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>
              </div>
            </details></div><div class="tab-item-content" id="折叠框-folding-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="分栏-tab"><a href="#分栏-tab" class="headerlink" title="分栏 tab"></a>分栏 tab</h3><div class="tabs" id="分栏-tab"><ul class="nav-tabs"><button type="button" class="tab " data-href="分栏-tab-1">标签语法</button><button type="button" class="tab " data-href="分栏-tab-2">参数配置</button><button type="button" class="tab  active" data-href="分栏-tab-3">样式预览</button><button type="button" class="tab " data-href="分栏-tab-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="分栏-tab-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-tab-2"><ol>
<li>Unique name :<ul>
<li>选项卡块标签的唯一名称，不带逗号。</li>
<li>将在#id中用作每个标签及其索引号的前缀。</li>
<li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li>
<li>仅当前帖子/页面的URL必须是唯一的！</li>
</ul>
</li>
<li>[index]:<ul>
<li>活动选项卡的索引号。</li>
<li>如果未指定，将选择第一个标签（1）。</li>
<li>如果index为-1，则不会选择任何选项卡。</li>
<li>可选参数。</li>
</ul>
</li>
<li>[Tab caption]:<ul>
<li>当前选项卡的标题。</li>
<li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li>
<li>如果未指定标题，但指定了图标，则标题将为空。</li>
<li>可选参数。</li>
</ul>
</li>
<li>[@icon]:<ul>
<li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li>
<li>可以指定带空格或不带空格；</li>
<li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li>
<li>可选参数。</li>
</ul>
</li>
</ol></div><div class="tab-item-content active" id="分栏-tab-3"><div class="tip "><p>Demo 1 - 预设选择第一个【默认】</p>
</div>

<div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<div class="tip "><p>Demo 2 - 预设选择tabs</p>
</div>
<div class="tabs" id="test2"><ul class="nav-tabs"><button type="button" class="tab " data-href="test2-1">test2 1</button><button type="button" class="tab " data-href="test2-2">test2 2</button><button type="button" class="tab  active" data-href="test2-3">test2 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<div class="tip "><p>Demo 3 - 没有预设值</p>
</div>
<div class="tabs" id="test3"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test3-1">test3 1</button><button type="button" class="tab " data-href="test3-2">test3 2</button><button type="button" class="tab " data-href="test3-3">test3 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<div class="tip "><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p>
</div>
<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">第一个Tab</button><button type="button" class="tab " data-href="test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4-3"><i class="fas fa-bomb"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tab-item-content" id="分栏-tab-4"><ol>
<li><p>Demo 1 - 预设选择第一个【默认】</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Demo 2 - 预设选择tabs</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Demo 3 - 没有预设值</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="诗词标签-poem"><a href="#诗词标签-poem" class="headerlink" title="诗词标签 poem"></a>诗词标签 poem</h3><div class="tabs" id="诗词标签-poem"><ul class="nav-tabs"><button type="button" class="tab " data-href="诗词标签-poem-1">标签语法</button><button type="button" class="tab " data-href="诗词标签-poem-2">参数配置</button><button type="button" class="tab  active" data-href="诗词标签-poem-3">样式预览</button><button type="button" class="tab " data-href="诗词标签-poem-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="诗词标签-poem-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% poem [title],[author] %&#125;</span><br><span class="line">诗词内容</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="诗词标签-poem-2"><ol>
<li>title：诗词标题</li>
<li>author：作者，可以不写</li>
</ol></div><div class="tab-item-content active" id="诗词标签-poem-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p>
<p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p>
</div></div><div class="tab-item-content" id="诗词标签-poem-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="阿里图标-icon"><a href="#阿里图标-icon" class="headerlink" title="阿里图标 icon"></a>阿里图标 icon</h3><div class="tabs" id="阿里图标-icon"><ul class="nav-tabs"><button type="button" class="tab " data-href="阿里图标-icon-1">标签语法</button><button type="button" class="tab " data-href="阿里图标-icon-2">参数配置</button><button type="button" class="tab  active" data-href="阿里图标-icon-3">样式预览</button><button type="button" class="tab " data-href="阿里图标-icon-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="阿里图标-icon-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="阿里图标-icon-2"><ol>
<li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li>
<li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li>
</ol></div><div class="tab-item-content active" id="阿里图标-icon-3"><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg>

<svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg>

<svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg>

<svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg>

<svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg>

<svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg>

<svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg>

<svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg>

<svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg>

<svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg>

<svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg>

<svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></div><div class="tab-item-content" id="阿里图标-icon-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><br/></p>
<h3 id="进度条-progress"><a href="#进度条-progress" class="headerlink" title="进度条 progress"></a>进度条 progress</h3><div class="tabs" id="进度条-progress"><ul class="nav-tabs"><button type="button" class="tab " data-href="进度条-progress-1">标签语法</button><button type="button" class="tab " data-href="进度条-progress-2">参数配置</button><button type="button" class="tab  active" data-href="进度条-progress-3">样式预览</button><button type="button" class="tab " data-href="进度条-progress-4">示例源码</button></ul><div class="tab-contents"><div class="tab-item-content" id="进度条-progress-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="进度条-progress-2"><p><code>width</code>: 0到100的阿拉伯数字<br><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray<br><code>text</code>:进度条上的文字内容</p></div><div class="tab-item-content active" id="进度条-progress-3"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div></div><div class="tab-item-content" id="进度条-progress-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《网站加载动画》</title>
    <url>/posts/99871f76/</url>
    <content><![CDATA[<h2 id="头部插入css"><a href="#头部插入css" class="headerlink" title="头部插入css"></a>头部插入<code>css</code></h2><p>在主题配置文件里找到<code>inject</code>的<code>head</code>，添加一行<code>link</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://use.fontawesome.com/releases/v5.6.1/css/all.css&quot;&gt;</span> <span class="comment"># loading用的fontawesome图标</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建pug文件"><a href="#新建pug文件" class="headerlink" title="新建pug文件"></a>新建<code>pug</code>文件</h2><p>在<code>themes\butterfly\layout\includes\loading\</code>里，新建文件<code>clickenter.pug</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#loading-box(onclick=&#x27;document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)&#x27;)</span><br><span class="line">  #loading-box-me</span><br><span class="line">    #wrapper</span><br><span class="line">      #mouse</span><br><span class="line">      .loader</span><br><span class="line">      .loading-bar-me</span><br><span class="line">        .progress-bar</span><br><span class="line">      .status</span><br><span class="line">        .state</span><br><span class="line">        .percentage</span><br><span class="line">script.</span><br><span class="line">  const preloader = &#123;</span><br><span class="line">    endLoading: () =&gt; &#123;</span><br><span class="line">      var loadingBox = document.getElementById(&#x27;loading-box&#x27;);</span><br><span class="line">      var loadingBoxme = document.getElementById(&#x27;loading-box-me&#x27;);</span><br><span class="line">      loadingBoxme.addEventListener(&#x27;animationend&#x27;, () =&gt; &#123;setTimeout(function() &#123;loadingBox.classList.add(&quot;loaded&quot;);&#125;, 2000) &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    initLoading: () =&gt; &#123;</span><br><span class="line">      document.getElementById(&#x27;loading-box&#x27;).classList.remove(&quot;loaded&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">    otherendLoading: () =&gt; &#123;</span><br><span class="line">      document.getElementById(&#x27;loading-box&#x27;).classList.add(&quot;loaded&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  window.addEventListener(&#x27;load&#x27;,()=&gt; &#123; preloader.endLoading() &#125;)</span><br><span class="line">  setTimeout(function()&#123;preloader.otherendLoading();&#125;,10000)</span><br><span class="line"></span><br><span class="line">  if (!&#123;theme.pjax &amp;&amp; theme.pjax.enable&#125;) &#123;</span><br><span class="line">    document.addEventListener(&#x27;pjax:send&#x27;, () =&gt; &#123; preloader.initLoading() &#125;)</span><br><span class="line">    document.addEventListener(&#x27;pjax:complete&#x27;, () =&gt; &#123; preloader.otherendLoading() &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改index-pug"><a href="#修改index-pug" class="headerlink" title="修改index.pug"></a>修改<code>index.pug</code></h2><p><code>themes\butterfly\layout\includes\loading\</code>的<code>index.pug</code>文件，整个替换为下面内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if theme.preloader.source === 1</span><br><span class="line">  include ./fullpage-loading.pug</span><br><span class="line">else if theme.preloader.source === 2</span><br><span class="line">  include ./pace.pug</span><br><span class="line">else if theme.preloader.source === 3</span><br><span class="line">  include ./fullpage-loading.pug</span><br><span class="line">  include ./pace.pug</span><br><span class="line">else if theme.preloader.source === 4</span><br><span class="line">  include ./clickenter.pug</span><br><span class="line">else if theme.preloader.source === 5</span><br><span class="line">  include ./clickenter.pug</span><br><span class="line">  include ./pace.pug</span><br><span class="line">else</span><br><span class="line">  include ./fullpage-loading.pug</span><br><span class="line">  include ./pace.pug</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="备份默认styl"><a href="#备份默认styl" class="headerlink" title="备份默认styl"></a>备份默认<code>styl</code></h2><p><code>themes\butterfly\source\css\</code>里，<code>loading.styl</code>复制一份改名为<code>default.styl</code><br>建个<code>load_style</code>文件夹，把<code>default.styl</code>放到这个<code>load_style</code>文件夹里<br>然后修改<code>loading.styl</code>，整个替换为下面内容</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.enable&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.source&#x27;</span>) == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/default&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.source&#x27;</span>) == <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/default&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.source&#x27;</span>) == <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/default&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.source&#x27;</span>) == <span class="string">&#x27;4&#x27;</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/clickenter&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader.source&#x27;</span>) == <span class="string">&#x27;5&#x27;</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/clickenter&#x27;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">@import</span> <span class="string">&#x27;./load_style/default&#x27;</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="新建styl"><a href="#新建styl" class="headerlink" title="新建styl"></a>新建<code>styl</code></h2><p><code>themes\butterfly\source\css\_global\load_style\</code>里新建一个<code>clickenter.styl</code></p>
<p>注意<code>loading-box-me</code>里面的<code>background</code>要替换成你们自己的顶层跟随深色模式的那个颜色变量</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">hexo-config</span>(<span class="string">&#x27;preloader&#x27;</span>)</span><br><span class="line">  <span class="selector-id">#loading-box</span></span><br><span class="line">    user-select <span class="attribute">none</span></span><br><span class="line">    &amp;<span class="selector-class">.loaded</span></span><br><span class="line">      <span class="selector-id">#loading-box-me</span></span><br><span class="line">        <span class="attribute">animation</span> fadeOut <span class="number">0.15s</span> ease-in-out</span><br><span class="line">        <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">z-index</span> -<span class="number">1000</span></span><br><span class="line">  <span class="selector-id">#loading-box-me</span></span><br><span class="line">    <span class="attribute">position</span> fixed</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">z-index</span> <span class="number">1001</span></span><br><span class="line">    <span class="attribute">background</span> <span class="built_in">var</span>(--anzhiyu-card-bg)</span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="attribute">display</span> flex</span><br><span class="line">    <span class="attribute">justify-content</span> center</span><br><span class="line">    <span class="attribute">align-items</span> center</span><br><span class="line">    <span class="attribute">overflow</span> hidden</span><br><span class="line">    &amp;::-webkit-scrollbar </span><br><span class="line">      <span class="attribute">display</span>: none</span><br><span class="line">    *</span><br><span class="line">      <span class="attribute">margin</span> <span class="number">0</span></span><br><span class="line">      <span class="attribute">padding</span> <span class="number">0</span></span><br><span class="line">      <span class="attribute">font-family</span> sans-serif</span><br><span class="line">      <span class="attribute">box-sizing</span> border-box</span><br><span class="line">      <span class="attribute">animation-timing-function</span> ease</span><br><span class="line">  <span class="selector-id">#wrapper</span></span><br><span class="line">    <span class="attribute">position</span> relative</span><br><span class="line">    <span class="attribute">width</span> <span class="number">350px</span></span><br><span class="line">    <span class="attribute">animation</span> out <span class="number">0.3s</span> forwards ease</span><br><span class="line">    <span class="attribute">animation-delay</span> <span class="number">5s</span></span><br><span class="line">    <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="attribute">transform-origin</span> center -<span class="number">80%</span></span><br><span class="line">    <span class="selector-class">.loader</span></span><br><span class="line">      <span class="attribute">animation</span> rotation <span class="number">3.5s</span> forwards linear</span><br><span class="line">      <span class="attribute">position</span> absolute</span><br><span class="line">      <span class="attribute">top</span> -<span class="number">120px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">35px</span>)</span><br><span class="line">      <span class="attribute">border</span> <span class="number">5px</span> solid <span class="number">#fff</span></span><br><span class="line">      <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">      <span class="attribute">border-top-color</span> <span class="number">#a29bfe</span></span><br><span class="line">      <span class="attribute">height</span> <span class="number">70px</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">70px</span></span><br><span class="line">      <span class="attribute">display</span> flex</span><br><span class="line">      <span class="attribute">justify-content</span> center</span><br><span class="line">      <span class="attribute">align-items</span> center</span><br><span class="line">      <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">        <span class="attribute">content</span> <span class="string">&quot;\f00c&quot;</span></span><br><span class="line">        <span class="attribute">font-family</span> <span class="string">&quot;Font Awesome 5 Free&quot;</span></span><br><span class="line">        <span class="attribute">font-weight</span> <span class="number">900</span></span><br><span class="line">        <span class="attribute">font-size</span> <span class="number">2em</span></span><br><span class="line">        <span class="attribute">color</span> <span class="number">#2ed573</span></span><br><span class="line">        <span class="attribute">animation</span> overspin <span class="number">0.5s</span> forwards <span class="built_in">cubic-bezier</span>(<span class="number">0.175</span>, <span class="number">0.885</span>, <span class="number">0.32</span>, <span class="number">1.275</span>)</span><br><span class="line">        <span class="attribute">animation-delay</span> <span class="number">3.4s</span></span><br><span class="line">        <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">180deg</span>)</span><br><span class="line">        <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="selector-id">#mouse</span></span><br><span class="line">      <span class="attribute">position</span> absolute</span><br><span class="line">      <span class="attribute">top</span> <span class="number">100px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">80%</span></span><br><span class="line">      <span class="attribute">animation</span> mouse-pos <span class="number">3.5s</span> forwards, mouse-pos2 <span class="number">1s</span> forwards</span><br><span class="line">      <span class="attribute">animation-delay</span> <span class="number">0s</span>, <span class="number">4s</span></span><br><span class="line">      <span class="attribute">z-index</span> <span class="number">20</span></span><br><span class="line">      <span class="selector-pseudo">&amp;:after</span></span><br><span class="line">        <span class="attribute">content</span> <span class="string">&quot;\f245&quot;</span></span><br><span class="line">        <span class="attribute">position</span> absolute</span><br><span class="line">        <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">font-family</span> <span class="string">&quot;Font Awesome 5 Free&quot;</span></span><br><span class="line">        <span class="attribute">font-weight</span> <span class="number">900</span></span><br><span class="line">        <span class="attribute">font-size</span> <span class="number">20px</span></span><br><span class="line">        <span class="attribute">animation</span> mouse-cont <span class="number">2s</span> forwards</span><br><span class="line">        <span class="attribute">animation-delay</span> <span class="number">1.7s</span></span><br><span class="line">        <span class="attribute">color</span> <span class="number">#341f97</span></span><br><span class="line">        <span class="attribute">text-shadow</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>)</span><br><span class="line">      <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">        <span class="attribute">content</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="attribute">position</span> absolute</span><br><span class="line">        <span class="attribute">top</span> -<span class="number">22px</span></span><br><span class="line">        <span class="attribute">left</span> -<span class="number">24px</span></span><br><span class="line">        <span class="attribute">width</span> <span class="number">50px</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">50px</span></span><br><span class="line">        <span class="attribute">border-radius</span> <span class="number">50%</span></span><br><span class="line">        <span class="attribute">border</span> <span class="number">2px</span> solid <span class="number">#222f3e</span></span><br><span class="line">        <span class="attribute">animation</span> circle <span class="number">3.5s</span> forwards</span><br><span class="line">        <span class="attribute">animation-delay</span> <span class="number">1.7s</span></span><br><span class="line">        <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="selector-class">.loading-bar-me</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">      <span class="attribute">height</span> <span class="number">30px</span></span><br><span class="line">      <span class="attribute">background</span> <span class="number">#dfe6e9</span></span><br><span class="line">      <span class="attribute">border-radius</span> <span class="number">5px</span></span><br><span class="line">      <span class="selector-class">.progress-bar</span></span><br><span class="line">        <span class="attribute">animation</span> progress <span class="number">3.5s</span> forwards</span><br><span class="line">        <span class="attribute">width</span> <span class="number">6%</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">100%</span></span><br><span class="line">        <span class="attribute">background</span> <span class="built_in">var</span>(--anzhiyu-logo-color)</span><br><span class="line">        <span class="attribute">border-radius</span> <span class="number">5px</span></span><br><span class="line">        <span class="attribute">border</span> <span class="number">0</span> solid <span class="number">#0abde3</span></span><br><span class="line">    <span class="selector-class">.status</span></span><br><span class="line">      <span class="attribute">margin-top</span> <span class="number">10px</span></span><br><span class="line">      <span class="selector-class">.state</span></span><br><span class="line">        <span class="attribute">float</span> left</span><br><span class="line">        <span class="attribute">font-size</span> <span class="number">0.9em</span></span><br><span class="line">        <span class="attribute">letter-spacing</span> <span class="number">1pt</span></span><br><span class="line">        <span class="attribute">text-transform</span> uppercase</span><br><span class="line">        <span class="attribute">width</span> <span class="number">100px</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">20px</span></span><br><span class="line">        <span class="attribute">position</span> relative</span><br><span class="line">        <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">          <span class="attribute">content</span> <span class="string">&quot;Loading&quot;</span></span><br><span class="line">          <span class="attribute">position</span> absolute</span><br><span class="line">          <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">          <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">          <span class="attribute">animation</span> fadeLeft <span class="number">0.5s</span> forwards ease</span><br><span class="line">          <span class="attribute">animation-delay</span> <span class="number">3.2s</span></span><br><span class="line">        <span class="selector-pseudo">&amp;:after</span></span><br><span class="line">          <span class="attribute">content</span> <span class="string">&quot;Complete&quot;</span></span><br><span class="line">          <span class="attribute">position</span> absolute</span><br><span class="line">          <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">          <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">          <span class="attribute">text-indent</span> <span class="number">100px</span></span><br><span class="line">          <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">          <span class="attribute">animation</span> fadeLeft2 <span class="number">0.5s</span> forwards ease</span><br><span class="line">          <span class="attribute">animation-delay</span> <span class="number">3.2s</span></span><br><span class="line">      <span class="selector-class">.percentage</span></span><br><span class="line">        <span class="attribute">float</span> right</span><br><span class="line">        <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">          -webkit-<span class="attribute">animation</span> percentage-slow <span class="number">3s</span> forwards, percentage-fast <span class="number">0.4s</span> forwards</span><br><span class="line">          -webkit-<span class="attribute">animation-delay</span> <span class="number">0s</span>, <span class="number">3s</span></span><br><span class="line">          <span class="attribute">content</span> <span class="string">&quot;10%&quot;</span></span><br><span class="line">          <span class="attribute">font-size</span> <span class="number">0.9em</span></span><br><span class="line">          <span class="attribute">letter-spacing</span> <span class="number">1pt</span></span><br><span class="line">  <span class="keyword">@keyframes</span> out</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">0</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">@keyframes</span> rotation</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="number">84%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">500deg</span>)</span><br><span class="line">    <span class="number">95%</span></span><br><span class="line">      <span class="attribute">border</span> <span class="number">5px</span> solid <span class="number">#fff</span></span><br><span class="line">      <span class="attribute">border-top-color</span> <span class="number">#a29bfe</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">1800deg</span>)</span><br><span class="line">      <span class="attribute">border</span> <span class="number">5px</span> solid <span class="number">#2ed573</span></span><br><span class="line">  <span class="keyword">@keyframes</span> overspin</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">180deg</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">rotate</span>(<span class="number">0</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">@keyframes</span> mouse-pos</span><br><span class="line">    <span class="number">30%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">100px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">80%</span></span><br><span class="line">    <span class="number">50%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">15px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">4%</span></span><br><span class="line">    <span class="number">60%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">15px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">4%</span></span><br><span class="line">    <span class="number">75%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">5px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">7.3%</span></span><br><span class="line">    <span class="number">85%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">5px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">7.3%</span></span><br><span class="line">    <span class="number">95%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">15px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">105%</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">15px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">105%</span></span><br><span class="line">  <span class="keyword">@keyframes</span> mouse-pos2</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">top</span> <span class="number">15px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">105%</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">top</span> -<span class="number">85px</span></span><br><span class="line">      <span class="attribute">left</span> <span class="number">53%</span></span><br><span class="line">  <span class="keyword">@keyframes</span> mouse-cont</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">font-size</span> <span class="number">20px</span></span><br><span class="line">    <span class="number">2%</span></span><br><span class="line">      <span class="attribute">font-size</span> <span class="number">15px</span></span><br><span class="line">    <span class="number">4%</span></span><br><span class="line">      <span class="attribute">font-size</span> <span class="number">20px</span></span><br><span class="line">    <span class="number">33%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;\f245&quot;</span></span><br><span class="line">    <span class="number">34%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;\f337&quot;</span></span><br><span class="line">    <span class="number">80%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;\f337&quot;</span></span><br><span class="line">    <span class="number">81%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;\f245&quot;</span></span><br><span class="line">  <span class="keyword">@keyframes</span> circle</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="number">4%</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="number">8%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="number">92%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">0</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="number">95%</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">transform</span> <span class="built_in">scale</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">@keyframes</span> progress</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">6%</span></span><br><span class="line">    <span class="number">50%</span></span><br><span class="line">      <span class="attribute">border</span> <span class="number">0</span> solid <span class="number">#0abde3</span></span><br><span class="line">    <span class="number">51%</span></span><br><span class="line">      <span class="attribute">border</span> <span class="number">4px</span> solid <span class="number">#0abde3</span></span><br><span class="line">    <span class="number">85%</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">11%</span></span><br><span class="line">    <span class="number">95%</span></span><br><span class="line">      <span class="attribute">border</span> <span class="number">4px</span> solid <span class="number">#0abde3</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">  <span class="keyword">@keyframes</span> fadeLeft</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">text-indent</span> <span class="number">0</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">text-indent</span> -<span class="number">100px</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">@keyframes</span> fadeLeft2</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">text-indent</span> <span class="number">100px</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">text-indent</span> <span class="number">0</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">@keyframes</span> percentage-slow</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;6%&quot;</span></span><br><span class="line">    <span class="number">25%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;7%&quot;</span></span><br><span class="line">    <span class="number">50%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;8%&quot;</span></span><br><span class="line">    <span class="number">75%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;9%&quot;</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;10%&quot;</span></span><br><span class="line">  <span class="keyword">@keyframes</span> percentage-fast</span><br><span class="line">    <span class="number">11%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;11%&quot;</span></span><br><span class="line">    <span class="number">12%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;12%&quot;</span></span><br><span class="line">    <span class="number">13%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;13%&quot;</span></span><br><span class="line">    <span class="number">14%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;14%&quot;</span></span><br><span class="line">    <span class="number">15%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;15%&quot;</span></span><br><span class="line">    <span class="number">16%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;16%&quot;</span></span><br><span class="line">    <span class="number">17%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;17%&quot;</span></span><br><span class="line">    <span class="number">18%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;18%&quot;</span></span><br><span class="line">    <span class="number">19%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;19%&quot;</span></span><br><span class="line">    <span class="number">20%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;20%&quot;</span></span><br><span class="line">    <span class="number">21%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;21%&quot;</span></span><br><span class="line">    <span class="number">22%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;22%&quot;</span></span><br><span class="line">    <span class="number">23%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;23%&quot;</span></span><br><span class="line">    <span class="number">24%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;24%&quot;</span></span><br><span class="line">    <span class="number">25%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;25%&quot;</span></span><br><span class="line">    <span class="number">26%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;26%&quot;</span></span><br><span class="line">    <span class="number">27%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;27%&quot;</span></span><br><span class="line">    <span class="number">28%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;28%&quot;</span></span><br><span class="line">    <span class="number">29%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;29%&quot;</span></span><br><span class="line">    <span class="number">30%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;30%&quot;</span></span><br><span class="line">    <span class="number">31%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;31%&quot;</span></span><br><span class="line">    <span class="number">32%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;32%&quot;</span></span><br><span class="line">    <span class="number">33%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;33%&quot;</span></span><br><span class="line">    <span class="number">34%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;34%&quot;</span></span><br><span class="line">    <span class="number">35%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;35%&quot;</span></span><br><span class="line">    <span class="number">36%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;36%&quot;</span></span><br><span class="line">    <span class="number">37%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;37%&quot;</span></span><br><span class="line">    <span class="number">38%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;38%&quot;</span></span><br><span class="line">    <span class="number">39%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;39%&quot;</span></span><br><span class="line">    <span class="number">40%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;40%&quot;</span></span><br><span class="line">    <span class="number">41%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;41%&quot;</span></span><br><span class="line">    <span class="number">42%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;42%&quot;</span></span><br><span class="line">    <span class="number">43%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;43%&quot;</span></span><br><span class="line">    <span class="number">44%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;55%&quot;</span></span><br><span class="line">    <span class="number">45%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;45%&quot;</span></span><br><span class="line">    <span class="number">46%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;46%&quot;</span></span><br><span class="line">    <span class="number">47%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;47%&quot;</span></span><br><span class="line">    <span class="number">48%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;48%&quot;</span></span><br><span class="line">    <span class="number">49%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;49%&quot;</span></span><br><span class="line">    <span class="number">50%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;50%&quot;</span></span><br><span class="line">    <span class="number">51%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;51%&quot;</span></span><br><span class="line">    <span class="number">52%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;52%&quot;</span></span><br><span class="line">    <span class="number">53%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;53%&quot;</span></span><br><span class="line">    <span class="number">54%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;54%&quot;</span></span><br><span class="line">    <span class="number">55%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;55%&quot;</span></span><br><span class="line">    <span class="number">56%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;56%&quot;</span></span><br><span class="line">    <span class="number">57%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;57%&quot;</span></span><br><span class="line">    <span class="number">58%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;58%&quot;</span></span><br><span class="line">    <span class="number">59%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;59%&quot;</span></span><br><span class="line">    <span class="number">60%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;60%&quot;</span></span><br><span class="line">    <span class="number">61%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;61%&quot;</span></span><br><span class="line">    <span class="number">62%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;62%&quot;</span></span><br><span class="line">    <span class="number">63%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;63%&quot;</span></span><br><span class="line">    <span class="number">64%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;64%&quot;</span></span><br><span class="line">    <span class="number">65%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;65%&quot;</span></span><br><span class="line">    <span class="number">66%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;66%&quot;</span></span><br><span class="line">    <span class="number">67%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;67%&quot;</span></span><br><span class="line">    <span class="number">68%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;68%&quot;</span></span><br><span class="line">    <span class="number">69%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;69%&quot;</span></span><br><span class="line">    <span class="number">70%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;70%&quot;</span></span><br><span class="line">    <span class="number">71%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;71%&quot;</span></span><br><span class="line">    <span class="number">72%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;72%&quot;</span></span><br><span class="line">    <span class="number">73%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;73%&quot;</span></span><br><span class="line">    <span class="number">74%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;74%&quot;</span></span><br><span class="line">    <span class="number">75%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;75%&quot;</span></span><br><span class="line">    <span class="number">76%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;76%&quot;</span></span><br><span class="line">    <span class="number">77%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;77%&quot;</span></span><br><span class="line">    <span class="number">78%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;78%&quot;</span></span><br><span class="line">    <span class="number">79%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;79%&quot;</span></span><br><span class="line">    <span class="number">80%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;80%&quot;</span></span><br><span class="line">    <span class="number">81%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;81%&quot;</span></span><br><span class="line">    <span class="number">82%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;82%&quot;</span></span><br><span class="line">    <span class="number">83%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;83%&quot;</span></span><br><span class="line">    <span class="number">84%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;84%&quot;</span></span><br><span class="line">    <span class="number">85%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;85%&quot;</span></span><br><span class="line">    <span class="number">86%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;86%&quot;</span></span><br><span class="line">    <span class="number">87%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;87%&quot;</span></span><br><span class="line">    <span class="number">88%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;88%&quot;</span></span><br><span class="line">    <span class="number">89%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;89%&quot;</span></span><br><span class="line">    <span class="number">90%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;90%&quot;</span></span><br><span class="line">    <span class="number">91%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;91%&quot;</span></span><br><span class="line">    <span class="number">92%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;92%&quot;</span></span><br><span class="line">    <span class="number">93%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;93%&quot;</span></span><br><span class="line">    <span class="number">94%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;94%&quot;</span></span><br><span class="line">    <span class="number">95%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;95%&quot;</span></span><br><span class="line">    <span class="number">96%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;96%&quot;</span></span><br><span class="line">    <span class="number">97%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;97%&quot;</span></span><br><span class="line">    <span class="number">98%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;98%&quot;</span></span><br><span class="line">    <span class="number">99%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;99%&quot;</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">content</span> <span class="string">&quot;100%&quot;</span></span><br><span class="line">  <span class="keyword">@keyframes</span> fadeOut</span><br><span class="line">    <span class="number">0%</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span></span><br><span class="line">      <span class="attribute">z-index</span> <span class="number">1001</span></span><br><span class="line">    <span class="number">100%</span></span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">0</span></span><br><span class="line">      <span class="attribute">z-index</span> -<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改<code>_config.yml</code></h2><p>在主题配置文件里找到<code>preloader</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Loading Animation (加载动画)</span></span><br><span class="line"><span class="attr">preloader:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source</span></span><br><span class="line">  <span class="comment"># 1. fullpage-loading(default)</span></span><br><span class="line">  <span class="comment"># 2. pace (progress bar)</span></span><br><span class="line">  <span class="comment"># 3. fullpage-loading + pace</span></span><br><span class="line">  <span class="comment"># 4. fullpage-loading(clickenter)</span></span><br><span class="line">  <span class="comment"># 5. fullpage-loading(clickenter) + pace</span></span><br><span class="line">  <span class="comment"># else fullpage-loading + pace</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># pace theme (see https://codebyzach.github.io/pace/)</span></span><br><span class="line">  <span class="attr">pace_css_url:</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg</span> <span class="comment"># 自定义头像</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《网站特殊日子置灰》</title>
    <url>/posts/facfc145/</url>
    <content><![CDATA[<h2 id="在js文件夹下面新建grayscale-js文件"><a href="#在js文件夹下面新建grayscale-js文件" class="headerlink" title="在js文件夹下面新建grayscale.js文件"></a>在js文件夹下面新建<code>grayscale.js</code>文件</h2><p><img src="https://s2.loli.net/2023/12/07/khKptiDuTXSHG3c.png" alt="image-20231207154811805"></p>
<p><br/></p>
<h2 id="inject到hexo里面（该步骤后续不再赘述）"><a href="#inject到hexo里面（该步骤后续不再赘述）" class="headerlink" title="inject到hexo里面（该步骤后续不再赘述）"></a><code>inject</code>到<code>hexo</code>里面（该步骤后续不再赘述）</h2><p><img src="https://s2.loli.net/2023/12/07/TEicaKPB2R81qAs.png" alt="image-20231207154633197"></p>
<p><br/></p>
<h2 id="编写grayscale-js代码"><a href="#编写grayscale-js代码" class="headerlink" title="编写grayscale.js代码"></a>编写<code>grayscale.js</code>代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Description: 网站置灰</span></span><br><span class="line"><span class="comment"> * @Author: 5t5</span></span><br><span class="line"><span class="comment"> * @Time: 2023/12/7 15:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PublicSacrificeDay</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 你想要置灰的特殊日子的日期</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">PSFarr</span> = [<span class="string">&quot;0403&quot;</span>, <span class="string">&quot;0512&quot;</span>, <span class="string">&quot;0707&quot;</span>, <span class="string">&quot;0918&quot;</span>, <span class="string">&quot;0930&quot;</span>, <span class="string">&quot;1213&quot;</span>];</span><br><span class="line">  <span class="keyword">let</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> mm = currentDate.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> dd = currentDate.<span class="title function_">getDate</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">`<span class="subst">$&#123;mm &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span><span class="subst">$&#123;mm&#125;</span><span class="subst">$&#123;dd &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span><span class="subst">$&#123;dd&#125;</span>`</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">PSFarr</span>.<span class="title function_">includes</span>(str) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setGrayStyle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;html&quot;</span>)[<span class="number">0</span>].<span class="title function_">setAttribute</span>(</span><br><span class="line">    <span class="string">&quot;style&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filter: gray !important; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&quot;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">PublicSacrificeDay</span>()) &#123;</span><br><span class="line">  <span class="title function_">setGrayStyle</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《随机跳转一篇文章》</title>
    <url>/posts/9c8bb964/</url>
    <content><![CDATA[<h2 id="安装NPM插件"><a href="#安装NPM插件" class="headerlink" title="安装NPM插件"></a>安装NPM插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="添加自定义js"><a href="#添加自定义js" class="headerlink" title="添加自定义js"></a>添加自定义js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomPost</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/baidusitemap.xml&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">str</span> =&gt;</span> (<span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">DOMParser</span>()).<span class="title function_">parseFromString</span>(str, <span class="string">&quot;text/xml&quot;</span>)).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ls = data.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;url loc&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> url = ls[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * ls.<span class="property">length</span>)].<span class="property">innerHTML</span>;</span><br><span class="line">            <span class="keyword">if</span> (location.<span class="property">href</span> == url) <span class="keyword">continue</span>;</span><br><span class="line">            location.<span class="property">href</span> = url;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="在-config-butterfly-yml菜单内添加按钮"><a href="#在-config-butterfly-yml菜单内添加按钮" class="headerlink" title="在_config.butterfly.yml菜单内添加按钮"></a>在_config.butterfly.yml菜单内添加按钮</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">随机访问:</span> <span class="string">javascript:randomPost();</span> <span class="string">||</span> <span class="string">fa-solid</span> <span class="string">fa-shuffle</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="在-config-yml内修改你的url"><a href="#在-config-yml内修改你的url" class="headerlink" title="在_config.yml内修改你的url"></a>在_config.yml内修改你的url</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your station url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/post&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://username.github.io/post</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《页面透明度》</title>
    <url>/posts/d6d4e12e/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<ul>
<li><code>--trans-light</code>：白天模式带透明度的背景色，如<code>rgba(255, 255, 255, 0.88)</code>底色是纯白色，其中0.88就透明度，在0-1之间调节，值越大越不透明；</li>
<li><code>--trans-dark</code>: 夜间模式带透明度的背景色，如<code>rgba(25, 25, 25, 0.88)</code>底色是柔和黑色，其中0.88就透明度，在0-1之间调节，值越大越不透明;</li>
<li><code>--border-style</code>: 边框样式，<code>1px solid rgb(169, 169, 169)</code>指宽度为1px的灰色实体边框;</li>
<li><code>--backdrop-filter</code>: 背景过滤器，如<code>blur(5px) saturate(150%)</code>表示饱和度为150%的、高斯模糊半径为5px的过滤器，这是亚克力效果的一种实现方法;</li>
<li>大家可以根据自己喜好进行调节，不用拘泥于我的样式！</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--trans-light</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.88</span>);</span><br><span class="line">    <span class="attr">--trans-dark</span>: <span class="built_in">rgba</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">0.88</span>);</span><br><span class="line">    <span class="attr">--border-style</span>: <span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">169</span>, <span class="number">169</span>, <span class="number">169</span>);</span><br><span class="line">    <span class="attr">--backdrop-filter</span>: <span class="built_in">blur</span>(<span class="number">5px</span>) <span class="built_in">saturate</span>(<span class="number">150%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首页文章卡片 */</span></span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--trans-light);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="built_in">var</span>(--border-style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 排除github日历 */</span></span><br><span class="line"><span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:first</span>-child) &#123;</span><br><span class="line">    backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--global-bg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首页侧栏卡片 */</span></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--trans-light);</span><br><span class="line">    backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="built_in">var</span>(--border-style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文章页、归档页、普通页面 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#post</span>,</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#page</span>,</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#archive</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--trans-light);</span><br><span class="line">    backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">    <span class="attribute">border</span>: <span class="built_in">var</span>(--border-style);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏 */</span></span><br><span class="line"><span class="selector-id">#page-header</span><span class="selector-class">.nav-fixed</span> <span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.75</span>);</span><br><span class="line">    backdrop-<span class="attribute">filter</span>: <span class="built_in">var</span>(--backdrop-filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#page-header</span><span class="selector-class">.nav-fixed</span> <span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.7</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 夜间模式遮罩 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#recent-posts</span> &gt; <span class="selector-class">.recent-post-item</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#post</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#archive</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-tag">div</span><span class="selector-id">#page</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--trans-dark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 夜间模式页脚页头遮罩透明 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#footer</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#page-header</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阅读模式 */</span></span><br><span class="line"><span class="selector-class">.read-mode</span> <span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">158</span>, <span class="number">204</span>, <span class="number">171</span>, <span class="number">0.5</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.read-mode</span> <span class="selector-tag">div</span><span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">158</span>, <span class="number">204</span>, <span class="number">171</span>, <span class="number">0.5</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 夜间模式下的阅读模式 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.read-mode</span> <span class="selector-id">#aside-content</span> <span class="selector-class">.card-widget</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">0.9</span>) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.read-mode</span> <span class="selector-tag">div</span><span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">0.9</span>) <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Beautify (美化頁面顯示)</span></span><br><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># station/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f863&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《网站缓存刷新》</title>
    <url>/posts/f4a5c12b/</url>
    <content><![CDATA[<div class="tip warning faa-horizontal animated"><p>此功能用于刷新浏览器网站的缓存，用以查看最新的文章或者解决缓存问题</p>
</div>
<h2 id="新建Javascript文件"><a href="#新建Javascript文件" class="headerlink" title="新建Javascript文件"></a>新建Javascript文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refreshCache</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">confirm</span>(<span class="string">&#x27;是否确定刷新博文缓存&#x27;</span>)) location.<span class="title function_">reload</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改rightside-pug"><a href="#修改rightside-pug" class="headerlink" title="修改rightside.pug"></a>修改rightside.pug</h2><p>路径： <code>[butterfly]\layout\includes\</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      when &#x27;comment&#x27;</span><br><span class="line">        if commentsJsLoad</span><br><span class="line">          a#to_comment(href=&quot;#post-comment&quot; title=_p(&quot;rightside.scroll_to_comment&quot;))</span><br><span class="line">            i.fas.fa-comments</span><br><span class="line">+      when &#x27;refresh&#x27;</span><br><span class="line">+        button#refresh-cache(type=&quot;button&quot; title=&#x27;刷新缓存&#x27; onclick=&quot;refreshCache()&quot;)</span><br><span class="line">+          i.fas.fa-refresh.fa-spin</span><br><span class="line"></span><br><span class="line">#rightside</span><br><span class="line">  - const &#123; enable, hide, show &#125; = theme.rightside_item_order</span><br><span class="line">+  - const hideArray = enable ? hide &amp;&amp; hide.split(&#x27;,&#x27;) : [&#x27;readmode&#x27;,&#x27;translate&#x27;,&#x27;darkmode&#x27;,&#x27;hideAside&#x27;, &#x27;refresh&#x27;]</span><br><span class="line">  - const showArray = enable ? show &amp;&amp; show.split(&#x27;,&#x27;) : [&#x27;toc&#x27;,&#x27;chat&#x27;,&#x27;comment&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #rightside-config-hide</span><br><span class="line">    if hideArray</span><br><span class="line">      +rightsideItem(hideArray)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-butterfly-yml"><a href="#修改-config-butterfly-yml" class="headerlink" title="修改_config.butterfly.yml"></a>修改_config.butterfly.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 缓存刷新按钮</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/新建的.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《黑夜霓虹灯》</title>
    <url>/posts/cc5846f3/</url>
    <content><![CDATA[<h2 id="新建Css文件"><a href="#新建Css文件" class="headerlink" title="新建Css文件"></a>新建Css文件</h2><p>写入以下代码，并<code>inject</code>到头部</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 日间模式不生效 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#site-name</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#site-title</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#site-subtitle</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-id">#post-info</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 夜间模式生效 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#site-name</span>,</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#site-title</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: light_15px <span class="number">10s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#site-subtitle</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: light_10px <span class="number">10s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-id">#post-info</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: light_5px <span class="number">10s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 关键帧描述 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> light_15px &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">12.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#11ee5e</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">25%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f14747</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">37.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1a247</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1ee47</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#b347f1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">62.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#002afa</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">75%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#ed709b</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">87.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#39c5bb</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> light_10px &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">12.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#11ee5e</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">25%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f14747</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">37.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1a247</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1ee47</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#b347f1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">62.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#002afa</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">75%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#ed709b</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">87.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#39c5bb</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> light_5px &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">12.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#11ee5e</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">25%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f14747</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">37.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1a247</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#f1ee47</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#b347f1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">62.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#002afa</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">75%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#ed709b</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">87.5%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#39c5bb</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">#5636ed</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《首页双栏布局》</title>
    <url>/posts/6d7d1eb8/</url>
    <content><![CDATA[<h2 id="安装NPM插件"><a href="#安装NPM插件" class="headerlink" title="安装NPM插件"></a>安装NPM插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-butterfly-article-double-row --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">butterfly_article_double_row:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="重新运行"><a href="#重新运行" class="headerlink" title="重新运行"></a>重新运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>魔改-《适配PDF》</title>
    <url>/posts/d7d0074/</url>
    <content><![CDATA[<h2 id="安装hexo-pdf插件"><a href="#安装hexo-pdf插件" class="headerlink" title="安装hexo-pdf插件"></a>安装hexo-pdf插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-pdf --save</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="引用格式"><a href="#引用格式" class="headerlink" title="引用格式"></a>引用格式</h2><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="type">#</span> <span class="number">1.</span>本地文件<span class="operator">:</span>在<span class="variable">md</span>文件路径下创建一个同名文件夹，其内放<span class="variable">pdf</span>文件名为<span class="variable">xxx</span><span class="operator">.</span><span class="variable">pdf</span>的文件</span><br><span class="line"><span class="punctuation">&#123;</span><span class="operator">%</span> <span class="variable">pdf</span> <span class="variable">xxx</span><span class="operator">.</span><span class="variable">pdf</span> <span class="operator">%</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="type">#</span> <span class="number">2.</span>在线链接</span><br><span class="line"><span class="punctuation">&#123;</span><span class="operator">%</span> <span class="variable">pdf</span> <span class="variable">https</span><span class="operator">://</span><span class="variable">cdn</span><span class="operator">.</span><span class="variable">jsdelivr</span><span class="operator">.</span><span class="variable">net</span><span class="operator">/</span><span class="variable">gh</span><span class="operator">/</span><span class="variable">Justlovesmile</span><span class="operator">/</span><span class="variable">CDN</span><span class="operator">/</span><span class="variable">pdf</span><span class="operator">/</span>小作文讲义<span class="operator">.</span><span class="variable">pdf</span> <span class="operator">%</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>魔改</category>
      </categories>
      <tags>
        <tag>Butterfly</tag>
      </tags>
  </entry>
</search>
